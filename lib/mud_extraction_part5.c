
// --- MUD Extraction File: mud_extraction_part1.c ---
// Generated: 2025-03-07 07:27:40 UTC
// Source Directory: /mnt/home2/grok/lib
// Purpose: Consolidated LPC .c files for analysis and recreation with FluffOS v2019+
//          and Forgotten Realms theming, replicating discworld.starturtle.net:4242
//          with optimizations (UTF-8, JSON, strict typing).
// Note: Each file break is marked with // --- END [file_path] ---
//
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/idle.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/idle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627112   Available: 13574466
Inodes: Total: 5242880    Free: 4960132
364 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/idle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627112   Available: 13574466
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

int cmd(object who) {
  if (!interactive(who))
    write(who->query_cap_name() + " is net-dead.\n");
  else
    write(who->query_cap_name() + " has been idle for " +
          "/secure/finger"->time_elapsed_string(query_idle(who)) + ".\n");
  return 1;
  
}

mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/idle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/ex_amine.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/ex_amine.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627112   Available: 13574466
Inodes: Total: 5242880    Free: 4960132
211 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/ex_amine.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627112   Available: 13574466
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/living/l_ook";

mixed *query_patterns() {
    return ({ "<string'direction'>", (: cmd_string($4[0]) :),
              "<indirect:object>", (: cmd_object($1, $4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/ex_amine.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/ea_lias.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/ea_lias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627112   Available: 13574466
Inodes: Total: 5242880    Free: 4960132
3471 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/ea_lias.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627112   Available: 13574466
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <alias.h>
inherit "/cmds/base";

mapping editing_alias;

void create() {
   editing_alias = ([ ]);
} /* create() */

/**
 * The method used by the 'ealias' command.  
 * @param str the alias name to edit
 * @return 1 on success, 0 on failure
 * @see cmd::ealias
 * @see finish_alias_edit()
 */
protected int edit_alias(string str, int new_flag) {
   string al;

   if (editing_alias[this_player()]) {
      add_failed_mess("You are already editing the '" + 
                  editing_alias[this_player()] + "' alias.\n");
      return 0;
   }
   if (!this_player()->is_alias(str))  {
      if (!new_flag)  {
         add_failed_mess("No alias '"+str+"' defined.\n");
         return 0;
      }
   } else if (new_flag)  {
      add_failed_mess("You already have an alias called \"" + str + "\".");
      return 0;
   }
   editing_alias[this_player()] = str;
   if (new_flag)  al = "";
   else al = replace(ALIAS_CMD->alias_string(this_player()->
      query_player_alias(str)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
} /* edit_alias() */

/**
 * This method used to copy an alias to another one and then edit the
 * result.
 * @param alias the alias to copy
 * @param new_alias the alias to copy to
 * @return 1 on success, 0 on failure
 * @see cmd::ealias
 * @see finish_alias_edit()
 */
protected int edit_alias_copy(string alias, string new_alias) {
   string al;

   if (!this_player()->is_alias(alias)) {
      add_failed_mess("No alias '"+alias+"' defined.\n");
      return 0;
   }
   if (this_player()->is_alias(new_alias)) {
      add_failed_mess("The alias '"+new_alias+"' already exists.\n");
      return 0;
   }
   new_alias = replace_string(new_alias, "END_ALIAS", "NO YOU DONT");
   editing_alias[this_player()] = new_alias;
   al = replace(ALIAS_CMD->alias_string(this_player()->query_player_alias(alias)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
} /* edit_alias_copy() */

/**
 * The method called when the editing of the alias has been completed.
 * @param str the new alias value
 * @return 1 on success, 0 on failure
 */
void finish_alias_edit(string str) {
   string alias;

   if (!editing_alias[this_player()]) {
      write("Oh dear.  We got terribly confused and forgot "
            "what you were trying to do.  Terribly sorry.\n");
      return ;
   }
   if (!str  ||  str == "") {
      write("Can't save an empty alias, sorry.\n");
      editing_alias[this_player()] = 0;
      return ;
   }
   str = replace(str, "\n", ";");
   /*
     str = replace(str, "@@", "@ @ ");
   */
   alias = editing_alias[this_player()];
   if (!this_player()->is_alias(alias))
      printf("Added alias '%s'.\n", alias);
   else
      printf("Changed alias '%s'\n", alias);
   this_player()->add_player_alias(alias, ALIAS_CMD->compile_alias(str));
   map_delete(editing_alias, this_player());
   return ;
} /* finish_alias_edit() */

mixed *query_patterns() {
  return ({
    "<word'alias'>", (: edit_alias($4[0], 0) :),
    "new <word'alias'>", (: edit_alias($4[0], 1) :),
    "copy <word'alias'> to <word'new alias'>", (: edit_alias_copy($4[0], $4[1]) :),
      });
} /* query_patterns() */


/* These functions are here so the command object isn't destructed
 * while someone is still editing. */
int clean_up()  {
   if (sizeof(editing_alias) == 0)
      ::clean_up();
   return 1;
}


void reset()  {
   if (sizeof(editing_alias) == 0)
      ::reset();
   return;
}
// --- END [/mnt/home2/grok/lib/cmds/player/ea_lias.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/unkeep.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/unkeep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627111   Available: 13574465
Inodes: Total: 5242880    Free: 4960132
1174 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/unkeep.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627111   Available: 13574465
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unkeep.c,v 1.4 2001/10/02 01:53:23 presto Exp $
 * $Log: unkeep.c,v $
 * Revision 1.4  2001/10/02 01:53:23  presto
 * Fixed runtime when unkeeping
 *
 * Revision 1.3  2000/01/19 01:54:22  presto
 * Was only allowing you to unkeep one thing at a time.
 * Fixed up a bunch of other ugliness as well.
 *
 * Revision 1.2  1999/10/27 01:48:31  pinkfish
 * Fix them up to use a nice new effect instead of a horrible shadow.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
 */
#define EFFECT "/std/effects/object/identity_hold"

inherit "/cmds/base";

int cmd( object *obs ) {
   object thing, *success;

   success = ({ });
   foreach (thing in obs)  {
      if (thing->query_keep())  {
         thing->reset_keep();
         success += ({ thing });
      }
   }
   if (!sizeof(success))  {
      write("You are not attempting to keep anything.\n");
   }
   else  {
      write("You will no longer attempt to keep " +
            query_multiple_short(success) + ".\n");
   }
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/unkeep.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/maptemp.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/maptemp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627110   Available: 13574464
Inodes: Total: 5242880    Free: 4960132
1282 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/maptemp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627110   Available: 13574464
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Print out a cute little map if one exists.
 * @author Pinkfish
 * @started Wed Jul 17 23:51:41 PDT 2002
 */
inherit "/cmds/base";

int do_map() {
   string map;
   int* coords;
   object env;
   string handler;

   env = environment(this_player());
   if (!env)  {
      add_failed_mess("You are somewhere not on any map.\n");
      return 0;
   }

   if (this_player()->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }

   switch(this_player()->check_dark(environment(this_player())->query_light()))
   {
   case -2:
   case -1:
     return add_failed_mess("It is too dark to see anything.\n");
   case 2:
   case 1:
     return add_failed_mess("It is too bright to see anything.\n");
   }
   
   coords = env->query_terrain_coords();
   handler = env->query_terrain_handler();
   if (!coords  ||  !handler) {
      add_failed_mess("You can only do this in a terrain.\n");
      return 0;
   }

   map = handler->query_player_map_template(coords[0], coords[1], coords[2],
                                   env->query_visibility(env));
   if (!map) {
      add_failed_mess("There is no map available here.\n");
      return 0;
   }
   write(map);
   return 1;
}

mixed* query_patterns() {
   return ({ "", (: do_map :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/maptemp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/hi_story.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/hi_story.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627110   Available: 13574464
Inodes: Total: 5242880    Free: 4960132
221 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/hi_story.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627110   Available: 13574464
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int cmd(string arg){
   return this_player()->print_history(arg);
}

mixed query_patterns() {
   return ({ "", (: cmd("") :),
               "<string'number|number,number'>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/hi_story.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/bury.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/bury.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627110   Available: 13574464
Inodes: Total: 5242880    Free: 4960132
5209 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/bury.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627110   Available: 13574464
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: bury.c,v 1.21 2003/07/08 07:20:31 pinkfish Exp $
 * 
 */
#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>

inherit "/cmds/base";

#define TP this_player()
#define GP_INCREMENT 10

#define MAX_BURY_NUMBER 20

mixed cmd(object *obs) {
   string person;
   mixed effs, *xp;
   string* messages;
   object ob, tmp;
   object *sobs;
   object *fobs;
   object *too_many;
   int gp;

#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif

   sobs = ({ });
   fobs = ({ });
   too_many = ({ });
   if (TP->query_property("dead")) {
      add_failed_mess("You are a disembodied spirit, how do you expect to bury "
                      "anything at all?\n");
      return 0;
   }
   if(sizeof(filter_array(TP->query_attacker_list(),
                          (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot bury items while in combat.\n");
      return 0;
   }

   if(environment(TP)->query_property("no burial")) {
      add_failed_mess("You cannot bury things here.\n");
      return 0;
   }

   fobs = filter(obs, (: !is_in_me_or_environment($1, this_player()) :));
   obs -= fobs;
     
   foreach (ob in obs) {
      if (sizeof(sobs) >= MAX_BURY_NUMBER) {
         too_many += ({ ob });
      } else if ((ob->query_owner() == this_player()->query_cap_name()) ||
                 ((ob->get() == MOVE_OK) ||
                  (ob->get() == MOVE_TOO_HEAVY)) &&
                 (ob->query_property("no burial") != 1) &&
                 !ob->ok_to_bury(this_player())) {

        if (ob->query_property("player") != 1 ||
            ob->query_owner() == this_player()->query_name()) {
            // If the weapon is owned, record its burial.
            effs = ob->effects_matching("mudlib.owned.weapon");
            if(sizeof(effs)) {
               person = ob->arg_of(effs[0]);
               log_file("BURIAL", "%s: %s's %s buried by %s\n", ctime(time()),
                        person, ob->query_short(), TP->query_name());
            }
                                    
            environment(this_player())->add_effect(BURY_EFFECT, ob);
            //ob->move("/room/rubbish");
            sobs += ({ ob });
            if (ob->query_property("corpse bit") || 
                ob->query_property("money")) {
               gp--;
            } else if(base_name(ob) == "/obj/corpse" &&
                      !ob->query_property("already buried")) {
               gp += GP_INCREMENT;
               ob->add_property("already buried", 1);
               
               // This hands out the rest of the death Xp when the object
               // is buried.
               xp = ob->query_property("XP");
               if(xp && sizeof(xp) == 2) {
                 foreach(tmp in xp[0]) {
                   if(tmp)
                     tmp->adjust_xp(xp[1], 1);
                 }
               }
               ob->remove_property("XP");
            }
         } else {
            fobs += ({ ob });
         }
      } else {
         fobs += ({ ob });
      }
   }
  
   if (!sizeof(sobs)) {
      if (sizeof(fobs)) {
         if (member_array(TP, fobs) == -1) {
            add_failed_mess("You cannot bury " + 
                            query_multiple_short(fobs)+".\n");
            return 0;
         } else {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs - ({TP}) + 
                                                 ({"yourself"}))+
                            ".\n");
            return 0;
         }
      } else {
         add_failed_mess("You cannot find anything here to bury!\n");
         return 0;
      }
   }

   if (sizeof(too_many)) {
      write("You can only bury up to " + MAX_BURY_NUMBER + 
            " items at a time, not burying " + 
            query_multiple_short(too_many) + ".\n");
   }
 
   messages = environment(TP)->query_burial_message(); 
   if (messages) {
      write(replace_string(messages[0], "$objs$", query_multiple_short(sobs)));
      say(replace(messages[1], ({ "$N", TP->the_short(), "$objs$", query_multiple_short(sobs) })));
   } else if (environment(TP)->query_property("location") != "outside") {
      write("You tidy up the place, clearing away "+
            query_multiple_short(sobs)+".\n");
      say( (string)this_player()->one_short() +
           " tidies up the place, clearing away "+
           query_multiple_short( sobs ) +".\n" );
   } else {
      write("You bury "+query_multiple_short(sobs)+" deep within the earth.\n");
      say( (string)this_player()->one_short() +
           " buries "+ query_multiple_short( sobs ) +
           " deep within the ground.\n" );
   }
   
   TP->adjust_gp(gp);
   
   return 1;
} /* cmd() */

/**
 * The default bury is to bury corpses.
 */
mixed *query_patterns() {
  return ({ "<indirect:object:here>", (: cmd($1) :),
            "",
            (: cmd(match_objects_for_existence("corpse", environment(TP))) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/player/bury.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/countries.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/countries.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627108   Available: 13574462
Inodes: Total: 5242880    Free: 4960132
13058 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/countries.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627108   Available: 13574462
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/***
 * Five minute hack of a command to display where people
 * are logged on from.
 *    --Tape
 ***/
 
#define COUNTRIES_NO_SHOW_PROP "don't show on countries list"

// the common countries mapping is used as a sort of cache
mapping common_countries = ([
   "N/A" : ({ 0, "An unresolved address" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "net" : ({ 0, "Network" }),
   "uk" : ({ 0, "United Kingdom" }),
   "au" : ({ 0, "Australia" })
   ]);

mapping all_countries = ([
   "ad" : ({ 0, "Andorra", }),
   "ae" : ({ 0, "United Arab Emirates" }),
   "af" : ({ 0, "Afghanistan" }),
   "ag" : ({ 0, "Antigua and Barbuda" }),
   "ai" : ({ 0, "Anguila" }),
   "al" : ({ 0, "Albania" }),
   "am" : ({ 0, "Armenia" }),
   "an" : ({ 0, "Netherlands Antilles" }),
   "ao" : ({ 0, "Angola" }),
   "aq" : ({ 0, "Antarctica" }),
   "ar" : ({ 0, "Argentina" }),
   "as" : ({ 0, "American Samoa" }),
   "at" : ({ 0, "Austria" }),
   "au" : ({ 0, "Australia" }),
   "aw" : ({ 0, "Aruba" }),
   "az" : ({ 0, "Azerbaijan" }),
   "ba" : ({ 0, "Bosnia and Herzegovina" }),
   "bb" : ({ 0, "Barbados" }),
   "bd" : ({ 0, "Bangladesh" }),
   "be" : ({ 0, "Belgium" }),
   "bf" : ({ 0, "Burkina Faso" }),
   "bg" : ({ 0, "Bulgaria" }),
   "bh" : ({ 0, "Bahrain" }),
   "bi" : ({ 0, "Burundi" }),
   "bj" : ({ 0, "Benin" }),
   "bm" : ({ 0, "Bermuda" }),
   "bn" : ({ 0, "Brunei Darussalam" }),
   "bo" : ({ 0, "Bolivia" }),
   "br" : ({ 0, "Brazil" }),
   "bs" : ({ 0, "Bahamas" }),
   "bt" : ({ 0, "Bhutan" }),
   "bv" : ({ 0, "Bouvet Island" }),
   "bw" : ({ 0, "Botswana" }),
   "by" : ({ 0, "Belarus" }),
   "bz" : ({ 0, "Belize" }),
   "ca" : ({ 0, "Canada" }),
   "cc" : ({ 0, "Cocos (Keeling) Islands" }),
   "cf" : ({ 0, "Central African Republic" }),
   "cg" : ({ 0, "Congo" }),
   "ch" : ({ 0, "Switzerland" }),
   "ci" : ({ 0, "Cote D'Ivoire (Ivory Coast)" }),
   "ck" : ({ 0, "Cook Island" }),
   "cl" : ({ 0, "Chile" }),
   "cm" : ({ 0, "Cameroon" }),
   "cn" : ({ 0, "China" }),
   "co" : ({ 0, "Colombia" }),
   "cr" : ({ 0, "Costa Rica" }),
   "cs" : ({ 0, "Czechoslovakia (former)" }),
   "cu" : ({ 0, "Cuba" }),
   "cv" : ({ 0, "Cape Verde" }),
   "cx" : ({ 0, "Christmas Island" }),
   "cy" : ({ 0, "Cyprus" }),
   "cz" : ({ 0, "Czech Republic" }),
   "de" : ({ 0, "Germany" }),
   "dk" : ({ 0, "Denmark" }),
   "dm" : ({ 0, "Dominica" }),
   "do" : ({ 0, "Dominican Republic" }),
   "dz" : ({ 0, "Algeria" }),
   "ec" : ({ 0, "Ecuador" }),
   "ee" : ({ 0, "Estonia" }),
   "eg" : ({ 0, "Egypt" }),
   "eh" : ({ 0, "Western Sahara" }),
   "er" : ({ 0, "Eritrea" }),
   "es" : ({ 0, "Spain" }),
   "et" : ({ 0, "Ethiopia" }),
   "fi" : ({ 0, "Finland" }),
   "fj" : ({ 0, "Fiji" }),
   "fk" : ({ 0, "Falkland Islands (Malvinas)" }),
   "fm" : ({ 0, "Micronesia" }),
   "fo" : ({ 0, "Faroe Islands" }),
   "fr" : ({ 0, "France" }),
   "fx" : ({ 0, "France, Metropolitan" }),
   "ga" : ({ 0, "Gabon" }),
   "gd" : ({ 0, "Grenada" }),
   "ge" : ({ 0, "Georgia" }),
   "gf" : ({ 0, "French Guiana" }),
   "gh" : ({ 0, "Ghana" }),
   "gi" : ({ 0, "Gibraltar" }),
   "gl" : ({ 0, "Greenland" }),
   "gm" : ({ 0, "Gambia" }),
   "gn" : ({ 0, "Guinea" }),
   "gp" : ({ 0, "Guadeloupe" }),
   "gq" : ({ 0, "Equatorial Guinea" }),
   "gr" : ({ 0, "Greece" }),
   "gs" : ({ 0, "S. Georgia and S. Sandwich Isls." }),
   "gt" : ({ 0, "Guatemala" }),
   "gu" : ({ 0, "Guam" }),
   "gw" : ({ 0, "Guinea-Bissau" }),
   "gy" : ({ 0, "Guyana" }),
   "hk" : ({ 0, "Hong Kong" }),
   "hm" : ({ 0, "Heard and McDonald Islands" }),
   "hn" : ({ 0, "Honduras" }),
   "hr" : ({ 0, "Croatia (Hrvatska)" }),
   "ht" : ({ 0, "Haiti" }),
   "hu" : ({ 0, "Hungary" }),
   "id" : ({ 0, "Indonesia" }),
   "ie" : ({ 0, "Ireland" }),
   "il" : ({ 0, "Israel" }),
   "in" : ({ 0, "India" }),
   "io" : ({ 0, "British Indian Ocean Territory" }),
   "iq" : ({ 0, "Iraq" }),
   "ir" : ({ 0, "Iran" }),
   "is" : ({ 0, "Iceland" }),
   "it" : ({ 0, "Italy" }),
   "jm" : ({ 0, "Jamaica" }),
   "jo" : ({ 0, "Jordan" }),
   "jp" : ({ 0, "Japan" }),
   "ke" : ({ 0, "Kenya" }),
   "kg" : ({ 0, "Kyrgyzstan" }),
   "kh" : ({ 0, "Cambodia" }),
   "ki" : ({ 0, "Kiribati" }),
   "km" : ({ 0, "Comoros" }),
   "kn" : ({ 0, "Saint Kitts and Nevis" }),
   "kp" : ({ 0, "Korea (North)" }),
   "kr" : ({ 0, "Korea (South)" }),
   "kw" : ({ 0, "Kuwait" }),
   "ky" : ({ 0, "Cayman Islands" }),
   "kz" : ({ 0, "Kazakhstan" }),   
   "la" : ({ 0, "Laos" }),
   "lb" : ({ 0, "Lebanon" }),
   "lc" : ({ 0, "Saint Lucia" }),
   "li" : ({ 0, "Liechtenstein" }),
   "lk" : ({ 0, "Sri Lanka" }),
   "lr" : ({ 0, "Liberia" }),
   "ls" : ({ 0, "Lesotho" }),
   "lt" : ({ 0, "Lithuania" }),
   "lu" : ({ 0, "Luxembourg" }),
   "lv" : ({ 0, "Latvia" }),
   "ly" : ({ 0, "Libya" }),
   "ma" : ({ 0, "Morocco" }),
   "mc" : ({ 0, "Monaco" }),
   "md" : ({ 0, "Moldovia" }),
   "mg" : ({ 0, "Madagascar" }),
   "mh" : ({ 0, "Marshall Islands" }),
   "mk" : ({ 0, "Macedonia" }),
   "ml" : ({ 0, "Mali" }),
   "mm" : ({ 0, "Myanmar" }),
   "mn" : ({ 0, "Mongolia" }),
   "mo" : ({ 0, "Macau" }),
   "mp" : ({ 0, "Northern Mariana Islands" }),
   "mq" : ({ 0, "Martinique" }),
   "mr" : ({ 0, "Mauritania" }),
   "ms" : ({ 0, "Montserrat" }),
   "mt" : ({ 0, "Malta" }),
   "mu" : ({ 0, "Mauritius" }),
   "mv" : ({ 0, "Maldives" }),
   "mw" : ({ 0, "Malawi" }),
   "mx" : ({ 0, "Mexico" }),
   "my" : ({ 0, "Malaysia" }),
   "mz" : ({ 0, "Mozambique" }),
   "na" : ({ 0, "Namibia" }),
   "nc" : ({ 0, "New Caledonia" }),
   "ne" : ({ 0, "Niger" }),
   "nf" : ({ 0, "Norfolk Islands" }),
   "ng" : ({ 0, "Nigeria" }),
   "ni" : ({ 0, "Nicaragua" }),
   "nl" : ({ 0, "Netherlands" }),
   "no" : ({ 0, "Norway" }),
   "np" : ({ 0, "Nepal" }),
   "nr" : ({ 0, "Nauru" }),
   "nt" : ({ 0, "Neutral Zone" }),
   "nu" : ({ 0, "Niue" }),
   "nz" : ({ 0, "New Zealand (Aotearoa)" }),
   "om" : ({ 0, "Oman" }),
   "pa" : ({ 0, "Panama" }),
   "pe" : ({ 0, "Peru" }),
   "pf" : ({ 0, "French Polynesia" }),
   "pg" : ({ 0, "Papua New Guinea" }),
   "ph" : ({ 0, "Philippines" }),
   "pk" : ({ 0, "Pakistan" }),
   "pl" : ({ 0, "Poland" }),
   "pm" : ({ 0, "St. Pierre and Miquelon" }),
   "pn" : ({ 0, "Pitcairn" }),
   "pr" : ({ 0, "Puerto Rico" }),
   "pt" : ({ 0, "Portugal" }),
   "pw" : ({ 0, "Palau" }),
   "py" : ({ 0, "Paraguay" }),
   "qa" : ({ 0, "Qatar" }),
   "re" : ({ 0, "Reunion" }),
   "ro" : ({ 0, "Romania" }),
   "ru" : ({ 0, "Russian Federation" }),
   "rw" : ({ 0, "Rwanda" }),
   "sa" : ({ 0, "Saudi Arabia" }),
   "sb" : ({ 0, "Solomon Islands" }),
   "sc" : ({ 0, "Seychelles" }),
   "sd" : ({ 0, "Sudan" }),
   "se" : ({ 0, "Sweden" }),
   "sg" : ({ 0, "Singapore" }),
   "sh" : ({ 0, "St. Helena" }),
   "si" : ({ 0, "Slovenia" }),
   "sj" : ({ 0, "Svalbard and Jan Mayen Islands" }),
   "sk" : ({ 0, "Slovak Republic" }),
   "sl" : ({ 0, "Sierra Leone" }),
   "sm" : ({ 0, "San Marino" }),
   "sn" : ({ 0, "Senegal" }),
   "so" : ({ 0, "Somalia" }),
   "sr" : ({ 0, "Suriname" }),
   "st" : ({ 0, "Sao Tome and Principe" }),
   "su" : ({ 0, "USSR (former)" }),
   "sv" : ({ 0, "El Salvador" }),
   "sy" : ({ 0, "Syria" }),
   "sz" : ({ 0, "Swaziland" }),
   "tc" : ({ 0, "Turks and Caicos Islands" }),
   "td" : ({ 0, "Chad" }),
   "tf" : ({ 0, "French Southern Territories" }),
   "tg" : ({ 0, "Togo" }),
   "th" : ({ 0, "Thailand" }),
   "tj" : ({ 0, "Tajikistan" }),
   "tk" : ({ 0, "Tokelau" }),
   "tm" : ({ 0, "Turkmenistan" }),
   "tn" : ({ 0, "Tunisia" }),
   "to" : ({ 0, "Tonga" }),
   "tp" : ({ 0, "East Timor" }),
   "tr" : ({ 0, "Turkey" }),
   "tt" : ({ 0, "Trinidad and Tobago" }),
   "tv" : ({ 0, "Tuvalu" }),
   "tw" : ({ 0, "Taiwan" }),
   "tz" : ({ 0, "Tanzania" }),
   "ua" : ({ 0, "Ukraine" }),
   "ug" : ({ 0, "Uganda" }),
   "uk" : ({ 0, "United Kingdom" }),
   "um" : ({ 0, "US Minor Outlying Islands" }),
   "us" : ({ 0, "United States" }),
   "uy" : ({ 0, "Uruguay" }),
   "uz" : ({ 0, "Uzbekistan" }),
   "va" : ({ 0, "Vatican City State (Holy See)" }),
   "vc" : ({ 0, "Saint Vincent and the Grenadines" }),
   "ve" : ({ 0, "Venezuela" }),
   "vg" : ({ 0, "Virgin Islands (British)" }),
   "vi" : ({ 0, "Virgin Islands (U.S.)" }),
   "vn" : ({ 0, "Viet Nam" }),
   "vu" : ({ 0, "Vanuatu" }),
   "wf" : ({ 0, "Wallis and Futuna Islands" }),
   "ws" : ({ 0, "Samoa" }),
   "ye" : ({ 0, "Yemen" }),
   "yt" : ({ 0, "Mayotte" }),
   "yu" : ({ 0, "Yugoslavia" }),
   "za" : ({ 0, "South Africa" }),
   "zm" : ({ 0, "Zambia" }),
   "zr" : ({ 0, "Zaire" }),
   "zw" : ({ 0, "Zimbabwe" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "gov" : ({ 0, "US Government" }),
   "int" : ({ 0, "International" }),
   "mil" : ({ 0, "US Military" }),
   "net" : ({ 0, "Network" }),
   "org" : ({ 0, "Non-Profit Organization" }),
   "arpa" : ({ 0, "Old Style Arpanet" }),
   "nato" : ({ 0, "NATO Field" })
   ]);

int cmd();
int handle_no_show( int hide );
string resolve_domain_suffix( object player );

int cmd() {

   int left, right, size;
   float percentage;
   object person, *users;
   string suffix, message, country;
   mixed *unsorted, *sorted, *data;
   mapping countries;
   
   // get a copy of the common countries
   countries = copy( common_countries );
   
   // filter only those users who want to be displayed and are visible
   users = filter( users(), (: $1->query_visible( this_player() ) &&
      !$1->query_property( COUNTRIES_NO_SHOW_PROP ) :) );
   
   if( !size = sizeof( users ) ) {
      return notify_fail( "No visible players.\n" );
   }
   
   // go through them
   foreach( person in users ) {
   
      // figure out what their domain suffix is
      suffix = resolve_domain_suffix( person );
      
      // if it's not on the list of common countries
      if( undefinedp( countries[ suffix ] ) ) {
         // if it's not on the list of all countries
         if( undefinedp( all_countries[ suffix ] ) ) {
            countries[ "N/A" ][ 0 ] ++;
            continue;
         } else {
            // add it to the common countries for next time
            common_countries += ([ suffix : all_countries[ suffix ] ]);
            countries += ([ suffix : copy( all_countries[ suffix ] ) ]);
         }
      }

      countries[ suffix ][ 0 ] ++;
   }
   
   unsorted = ({ });

   size -= countries[ "N/A" ][ 0 ];
   map_delete( countries, "N/A" );
      
   // go through the countries and sort them in descending order
   foreach( country, data in countries ) {
      // if this country had zero entries (no one logging on from there)
      if( !data[ 0 ] ) {
         // remove it from the common countries list for next time
         map_delete( common_countries, country );
         // go to the next country
         continue;
      } else {
         data[ 1 ] += " (%^BOLD%^" + upper_case( country ) + "%^RESET%^)";
         unsorted += ({ data });
      }
   }

   sorted = sort_array( unsorted, -1 );
   
   message = "\nA total of %^BOLD%^" + query_num( size ) +
      "%^RESET%^ visible " + ( size != 1 ? "users" : "user" ) +
      " with resolvable addresses logged on:\n";

   left = this_player()->query_cols() / 3 * 2;
   left -= 3;
   right = this_player()->query_cols() - left;

   // make it look pretty
   foreach( data in sorted ) {
      percentage = data[ 0 ] * 100.0 / size;
      message += sprintf( "   %-=*'.'s%*-=s\n",
      left, data[ 1 ],
      right, "  " + to_int( percentage + 0.5 ) + "%" );
   }

   // stuff it through the user's more prompt
   this_player()->more_string( message );
   
   return 1;
   
} /* cmd() */


string resolve_domain_suffix( object player ) {
   
   string addy, *host;
   
   addy = query_ip_name( player );
   
   if( !addy ) {
      return 0;
   }
   
   host = explode( lower_case( addy ), "." );
   
   // tell_creator( this_player(), "%O\n", host );   

   return host[ sizeof( host ) - 1 ];
   
} /* resolve_domain_suffix() */


int handle_no_show( int hide ) {
   switch( hide ) {
      case 1:
         if( this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already hidden on the "
               "countries list.\n" );
            return 1;
         }
         this_player()->add_property( COUNTRIES_NO_SHOW_PROP, 1 );
         tell_object( this_player(), "You will no longer be included in "
            "the countries list.\n" );
         return 1;
      case 0:
         if( !this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already visible on "
               "the countries list.\n" );
            return 1;
         }
         this_player()->remove_property( COUNTRIES_NO_SHOW_PROP );
         tell_object( this_player(), "You will now be shown on the "
            "countries list.\n" );
         return 1;
      default: 
         return notify_fail( "This shouldn't happen.\n" );
   }
} /* handle_no_show() */


mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "hide", (: handle_no_show( 1 ) :),
             "show", (: handle_no_show( 0 ) :)
          });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/player/countries.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/nickname.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/nickname.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627105   Available: 13574459
Inodes: Total: 5242880    Free: 4960132
3576 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/nickname.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627105   Available: 13574459
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: nickname.c,v 1.7 2002/02/10 19:07:37 tannah Exp $
 * $Log: nickname.c,v $
 * Revision 1.7  2002/02/10 19:07:37  tannah
 * Blocked nicknaming a, an and the.
 *
 * Revision 1.6  2001/11/08 01:46:18  pinkfish
 * Change the message a little.
 *
 * Revision 1.5  2001/07/16 23:52:12  ceres
 * Added lower_case for adding nicknames
 *
 * Revision 1.4  2000/07/13 00:54:53  pinkfish
 * Make it preint somethign when there are no nicknaes.
 *
 * Revision 1.3  2000/04/23 03:39:51  presto
 * Corrected mistake with doing 'nickname <foo>'
 *
 * Revision 1.2  2000/03/03 02:45:59  pinkfish
 * Do sorting and a few other things.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 *
*/
/* command, trial out by Turrican for a commands daemon. */

inherit "cmds/base";

int print_nicknames(mapping map_nicknames);
int add_nickname(string str, mapping map_nicknames);

int print_single_nickname(string str) {
  mapping map_nicknames;

  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }

  str = lower_case(str);
  if(!map_nicknames[str]) {
    add_failed_mess("That nickname does not exist.\n");
    return 0;
  }
  write("Setting for nickname "+str+" is "+map_nicknames[str]+".\n");
  return 1;
} /* print_single_nickname() */

int print_nicknames(int sorted) {
  int i;
  int cols;
  string str;
  string str_long;
  string str_middle;
  string str_small;
  string bit;
  string *tmp;
  mapping map_nicknames;

  map_nicknames = previous_object()->query_nicknames();
  bit = "";
  str_long = "";
  str_middle = "";
  str_small = "";
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }

  if (!sizeof(map_nicknames)) {
     write("You do not have any nicknames.\n");
     return 1;
  }

  tmp = sort_array(keys(map_nicknames), 1);
  cols = (int)this_player()->query_cols();
  for (i=0;i<sizeof(tmp);i++) {
    str = tmp[i]+": "+map_nicknames[tmp[i]]+"  ";
    if (strlen(str) > 39 || sorted) {
      str_long += sprintf(tmp[i]+": %-=*s\n", cols - strlen(tmp[i]), map_nicknames[tmp[i]]);
    } else if (strlen(str) > 19) {
      str_middle += str+"\n";
    } else {
      str_small += str+"\n";
    }
  }
  if (strlen(str_middle)) {
    str_long += sprintf("%-#*s\n", cols, str_middle);
  }
  if (strlen(str_small)) {
    str_long += sprintf("%-#*s\n", cols, str_small);
  }
  this_player()->more_string(str_long, "Nicknames");
  return 1;
} /* print_nicknames() */

int add_nickname(string s1, string s2) {
  mapping map_nicknames;

  s1 = lower_case(s1);
  s2 = lower_case(s2);

  // nicknaming these things buggers up the parser
  if( member_array( s1, ({ "a", "an", "the" }) ) != -1 ) {
    add_failed_mess( "Using articles as nicknames confuses the parser.  "
                     "Choose another.\n" );
    return 0;
  }

  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!map_nicknames[s1]) {
    map_nicknames[s1] = s2;
    write("Added nickname "+s1+" for "+s2+".\n");
    return 1;
  }
  write("Changed nickname "+s1+" from "+map_nicknames[s1]+" to "+s2+".\n");
  map_nicknames[s1] = s2;

  this_player()->set_nicknames(map_nicknames);
  return 1;
} /* add_nickname() */

mixed* query_patterns() {
   return ({ "", (: print_nicknames(0) :),
             "sorted", (: print_nicknames(1) :),
             "<string'nickname'>", (: print_single_nickname($4[0]) :),
             "<string'nickname'> <string'realname'>", (: add_nickname($4[0], $4[1]) :)
           });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/nickname.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/perm_it.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/perm_it.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627104   Available: 13574458
Inodes: Total: 5242880    Free: 4960132
1979 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/perm_it.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627104   Available: 13574458
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
* $Id: perm_it.c,v 1.3 2001/06/01 20:58:43 ceres Exp $
*/

/* Thanks to Turrican, Gruper, and Mansarde, without whom I would have
 * given up on this project.
 * - Aragorn
 */

inherit "/cmds/base";

int cmd( object player ) {
  
  object *corpses, corpse;
  int i;
  
  /* Obviously we'll only want to search player corpses */
  corpses = filter( children( "/obj/corpse" ),
                    (: $1 && $1->query_property("player" ) :) );
  
  /* Now we look for corpses they own */
  corpses = filter( corpses,
                    (: $1 && $1->query_ownership() ==
                     $(this_player()->query_name()) :) );
  
  if( sizeof( corpses ) ) { 
    foreach( corpse in corpses ){
       /*Let's see if any of these corpses have already been permitted*/
      if(member_array(player->query_name(), corpse->query_permitted()) != -1) {
        i++;
      } else {
        /*
         * The heart of the command, this adds the name to the corpses
         * array of permitted players
         */
        corpse->give_permission( player->query_name() );
      }
    }
    
  } else { 
    /* Whoops, we don't have any corpses loaded */
    add_failed_mess("You don't seem to have a corpse!  Why not die and try "
                    "again?%^RESET%^\n");
    return 0;
  }           
  
  /* Let them know if we were successful or if we just wasted our time */
  if( i == sizeof( corpses ) ){
    write(capitalize(player->query_name()) + " is already permitted to "
          "remove items from your corpse.%^RESET%^\n" );
  } else { 
    write(capitalize(player->query_name()) + " is now permitted to "
          "remove items from your corpse.%^RESET%^\n" );
    tell_object(player, "%^BOLD%^%^GREEN%^You now have permission to get "
                "items from " + this_player()->query_cap_name() +
                "'s corpse.%^RESET%^\n");
  }
  return 1;
} 

mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/perm_it.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/ear_muffs.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/ear_muffs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627103   Available: 13574457
Inodes: Total: 5242880    Free: 4960132
5162 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/ear_muffs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627103   Available: 13574457
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ear_muffs.c,v 1.17 2003/06/05 00:37:41 pinkfish Exp $
 *
 * Command to allow the earmuffing of channels that a person doesn't wish to
 * hear.
 *
 */
#define TP this_player()
#include <player.h>
#include <newbiehelpers.h>
inherit "/cmds/base";

private string *_normal_types;
private string *_cre_types;
private string _player_format;

void create() {
   ::create();
   _normal_types = ({ "shout", "newbie", "cryer", "remote-soul",
         "multiple-soul", "multiple-tell",  "teach",
         "tell", "remote", "multiple-remote" });
   _cre_types = ({ "cre", "lord", "code", "liaison",
         "intermud-all", "intercre", "intergossip",
         "dwcre", "dwchat", "remote-spam", "newbiehelpers",
                     "verbose-logon"});
   _player_format = "{" + implode(_normal_types, "|") + "}";
} /* create() */

int check_earmuffs() {
  string *on;
  string *types;

  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }

  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }

  if (TP->query_earmuffs()) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      printf("Your earmuffs are set to allow friends through.\n");
    } else {
      printf("Your earmuffs are on.\n");
    }
  } else { 
    printf("Your earmuffs are off.\n");
  }
  if (!sizeof(on)) {
    printf("You have nothing set to be earmuffed.\n");
    write("$I$5=Earmuffable events are "+ query_multiple_short(types)+
          ".\n");
  } else {
    write("$I$5=You have "+ query_multiple_short(on)+ " earmuffed.\n");
    types -= on;
    if (sizeof(types)) {
      write("$I$5=You are not currently earmuffing "+
            query_multiple_short(types)+ " events.\n");
    }
  }
  return 1;
} /* check_earmuffs() */

int do_earmuff_control(string str) {
  string *types;
  string *on;

  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }

  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }

  switch (str) {
    case "on" :
      if (!TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      } else if (TP->query_allow_friends_earmuffs()) {
        TP->toggle_earmuffs();
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned on.\n");
      break;
    case "off" :
      if (TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned off.\n");
      break;
    case "allowfriends" :
      TP->set_allow_friends_earmuffs();
      write("Earmuffs set to allow friends through.\n");
      break;
    case "all" :
      on = types;
      if (sizeof(on)) {
        write("$I$5=Your "+ query_multiple_short(on)+
              " events will now be earmuffed.\n");
      }
      break;
    case "none" :
      write("Nothing will be earmuffed any more.  (No news is good news?)\n");
      on = ({ });
      break;
  }

  TP->add_property(PLAYER_EARMUFF_PROP, on);

  return 1;
} /* do_earmuff_control() */

int do_earmuff(string str, string onOff) {
  string *types, *on, *off;

  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types;
  }

  on = (string *)TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }

  off = ({ });
  switch (onOff) {
    case "on" :
      if (member_array(str, on) == -1) {
        on += ({ str });
      }
      write("You are now earmuffing " + str + " events.\n");
      break;
    case "off" :
      off += ({ str });
      write("You are not earmuffing " + str + " events anymore.\n");
      break;
    default :
      if (member_array(str, on) == -1) {
        on += ({ str });
        write("You are now earmuffing " + str + " events.\n");
      } else {
        off += ({ str });
        write("You are not earmuffing " + str + " events anymore.\n");
      }
      break;
  }
  on -= off;
  TP->add_property(PLAYER_EARMUFF_PROP, on);
  return 1;
} /* do_earmuff() */

mixed *query_patterns() {
  string cre_format;
  
  if (this_player()->query_creator()) {
    cre_format = "{" + implode(_normal_types +
                     _cre_types + this_player()->channel_list(), "|") + "}";
    
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                cre_format, (: do_earmuff($4[0], "") :),
                cre_format + " {on|off}", (: do_earmuff($4[0], $4[1]) :) });
  } else {
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      _player_format = "{" +
                       implode(_normal_types + ({"newbiehelpers"}), "|") + "}";
    }
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                _player_format, (: do_earmuff($4[0], "") :) ,
                _player_format + " {on|off}",
                (: do_earmuff($4[0], $4[1]) :) });
  }
}
// --- END [/mnt/home2/grok/lib/cmds/player/ear_muffs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/register.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/register.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627102   Available: 13574456
Inodes: Total: 5242880    Free: 4960132
2921 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/register.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627102   Available: 13574456
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Addalt - adds a record about a player's alt character.
 * @author Fiona
 */
#include <player_handler.h>
#include <playerinfo.h>

inherit "/cmds/base";

int cmd(string alt) {
  string p1;
  string p2;

  alt = lower_case(alt);
  if (!PLAYER_HANDLER->test_user(alt))
    return notify_fail(alt + " is not a player.\n");

   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if(!p1 || p1 == "") {
     p1 = this_player()->query_name();
   }
   
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   
   if(p1 == p2) {
     add_failed_mess("You and " + alt + " are already registered.\n");
     return 0;
   }

   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2)) &&
      sizeof(PLAYERINFO_HANDLER->query_alts(p1))) {
     add_failed_mess("Sorry, there is a clash of alts here, you'll need to "
                     "ask a creator for assistance.\n");
     return 0;
   }
  write("Enter your password (this character): ");
  input_to("get_pw", 1, this_player(), alt);
  return 1;
}

void get_pw(string pass, object player, string alt) {
  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  write("\nEnter the password for " + alt + ": ");
  input_to("get_alt_pw", 1, player, alt);
}

void get_alt_pw(string pass, object player, string alt) {
  string result;
  string p1, p2;
  write("\n");

  if(this_player() != player) {
    write("Something has gone wrong, player objects don't match.\n");
    return;
  }

  if (!PLAYER_HANDLER->test_password(alt, pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }

  //Do we need a p1 variable? -- Terano.
  p1 = PLAYERINFO_HANDLER->query_alt_of(player->query_name());
  if(!p1 || p1 == "") {
    p1 = player->query_name();
  }

   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }

   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2))) {
     write("Registering " + p1 + " as an alt of " + p2 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p2, p1);
   } else {
     write("Registering " + p2 + " as an alt of " + p1 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p1, p2);
   }

   write(result);
}

int cmd_list() {
   string* alts;
   string p1;

   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!p1) {
      p1 = this_player()->query_name();
   }
   alts = (string*)PLAYERINFO_HANDLER->query_alts(p1) |
          (string*)PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!sizeof(alts)) {
      write("No alts registered.\n");
      return 1;
   }
   write("Your registered alts are " + query_multiple_short(alts) + ".\n");
   return 1;
}

// Answer the command patterns
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "list", (: cmd_list :),
             "<word'alt-name'>", (: cmd($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/register.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/news.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/news.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627101   Available: 13574455
Inodes: Total: 5242880    Free: 4960132
4236 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/news.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627101   Available: 13574455
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: news.c,v 1.6 2001/03/09 22:46:08 pinkfish Exp $
 * $Log: news.c,v $
 * Revision 1.6  2001/03/09 22:46:08  pinkfish
 * Add in a post time.
 *
 * Revision 1.5  2000/04/04 06:06:20  ceres
 * Modified to use board handler newsrc functions
 *
 * Revision 1.4  1998/02/21 19:49:01  pinkfish
 * Changed it again to fix yp the login only showing 10 lines...
 *
 * Revision 1.3  1998/02/21 19:40:57  pinkfish
 * cd /global
 *
 * Revision 1.2  1998/02/21 19:38:55  pinkfish
 * Make it handle shorter login lists when players logon.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* command, trial out by Turrican for a commands daemon. */
/*
 * A news system for player announcements. It uses a bulletin board called:
 * "announcements". Players will be able to read the news at anytime which
 * should be an improvement over the current NEWS file which is shown
 * on login only.
 */
#include <board.h>

inherit "/cmds/base";

object board;
string board_name = "announcements";

void do_list(int all);
int do_read(int num);

#define LOGON_LIMIT 10
#define MOST 1
#define ALL 2
#define SOME 0

mixed cmd(string str) {
  int msg;
  
  switch(str) {
  case "help":
  case "?":
  case "h":
    tell_object( this_player(),
                "Usage:\n"
                "To read next news item type: \"news\".\n"
                "To read a specific news item type: \"news <num>\".\n"
                "To list new news items type: \"news list\".\n"
                "To list all news items type: \"news review\".\n");
    break;
  case "l":
  case "list":
    do_list(MOST);
    break;
  case "r":
  case "review":
    do_list(ALL);
    break;
  default:
    if(str) sscanf(str, "%d", msg);
    do_read(msg);
  }
  return 1;
}

int do_read(int num) {
  mapping news_rc;
  mixed *stuff;
  
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if ( !news_rc ) {
    news_rc = ([ ]);
  }
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  
  if(!num) {
    num = sizeof(stuff);
    while((num > 0) && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
    }
    if(num == sizeof(stuff)) {
      write("No news is good news.\n");
      return 1;
    }
    num++;
  }
  
  if(num < 0) {
    num = sizeof(stuff) + num + 1;
  }
  if(( num < 1) || (num > sizeof(stuff))) {
    write("No news item of that number.\n");
    return 1;
  }
  num--;
  
  if(news_rc[ board_name ] < stuff[ num ][ B_TIME ]) {
    news_rc[ board_name ] = stuff[ num ][ B_TIME ];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  this_player()->more_string( "Note #"+ ( num + 1 ) +" posted at " +
        ctime(stuff[num][B_TIME])[0..9] + " Title: \""+
        stuff[ num ][ B_SUBJECT ][ 0 .. (int)this_player()->query_cols() -
       10 ] +"\"\n\n"+ (string)BOARD_HAND->get_message( board_name, num ),
       "[Note "+ ( num + 1 ) +"]" );
  return 1;
}

string the_date(int i) {
  return ctime(i)[4..9];
}

void do_list(int all) {
  int i, newones;
  mixed *stuff;
  string ret;
  mapping news_rc;

  ret = "";
  
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (!sizeof(stuff)) {
    tell_object(this_player(), "No news is good news.\n");
    return;
  }
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc) {
    news_rc = ([ ]);
  }
  newones = 0;
  for (i = 0; i < sizeof(stuff); i++) {
    if (news_rc[board_name] < stuff[i][B_TIME]) {
      ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
      newones += 1;
      if (all == SOME) {
        if (newones > LOGON_LIMIT) {
          write("Plus more....\n");
          break;
        }
      }
    } else if(all == ALL) {
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
    }
  }
  if(!newones && all != ALL) {
    ret += "\nNo news is good news.\n";
  }
  if (all == SOME) {
    ret += "\nUse 'news list' for all new news items and 'news review' for all news times.\n";
  }
  this_player()->more_string( ret, "News" );
}
// --- END [/mnt/home2/grok/lib/cmds/player/news.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/gather.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/gather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627099   Available: 13574453
Inodes: Total: 5242880    Free: 4960132
1876 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/gather.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627099   Available: 13574453
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gather.c,v 1.6 2003/07/14 22:28:50 pinkfish Exp $
 * $Log: gather.c,v $
 * Revision 1.6  2003/07/14 22:28:50  pinkfish
 * Fixed up the error message.
 *
 * Revision 1.5  2000/09/02 22:19:38  ceres
 * Fixed faulty error message
 *
 * Revision 1.4  2000/06/27 16:43:05  wodan
 * New version, Tannah changed something.
 *
 * Revision 1.3  2000/06/27 14:42:27  sojan
 * Tannah changed to use add_failed_mess
 *
 * Revision 1.2  2000/04/03 13:39:51  taffyd
 * Made it so that gathering does not cause items to be insta-pickeld
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <move_failures.h>

inherit "/cmds/base";

// #define NO_DECAY 1
#define TP this_player()

int cmd( string str ) {
  object *items, *moved = ({ }), *left = ({ });
  int i;

  if( !stringp(str) || (str == "" )) {
    add_failed_mess("Syntax: gather <plant>\n");
    return 0;
  }
    
  items = "/obj/handlers/gathering"->gather_item(str, TP);
  if (!sizeof(items)) {
    if (str[<1] != 's') {
       str = pluralize(str);
    }
    add_failed_mess( "You couldn't find any " + str + ".\n");
    return 0;
  }
    
  for (i = 0; i < sizeof(items); i++) {
    if (items[i]->move(TP) == MOVE_OK) {
    moved += ({ items[i] });
  }  else 
    if(items[i]->move(environment(TP)) == MOVE_OK) {
      left += ({ items[i] });
    } else {
      items[i]->move("/room/rubbish");
    }
  }
  if (sizeof(moved)) {
#ifdef NO_DECAY
    moved->set_decay_speed(0);
#endif
    add_succeeded_mess( "$N gather$s $I.\n", moved );
    event( environment( this_player() ), "gather", this_player(), str, 
        moved );
  }

  left -= ({ this_player() });
  
  if (sizeof(left))
    write("You found but couldn't get " + query_multiple_short(left) + ".\n");
  return 1;
}

mixed query_patterns() {
  return ({ "<string>", (: cmd( $4[0] ) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/gather.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/coverage.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/coverage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627099   Available: 13574453
Inodes: Total: 5242880    Free: 4960132
5040 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/coverage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627099   Available: 13574453
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: coverage.c,v 1.5 2003/02/21 01:28:10 pinkfish Exp $
 *
 *
 */

inherit "/cmds/base.c";

#define CLOTHING_HANDLER "/obj/handlers/clothing_handler"

private string _zone_patterns;

int cmd(object *items, int inverse, string bits)  {
   object   armor;
   object  *wearing;
   object  *fail = ({ });
   object  *armors;
   object  *covering;
   string  *types;
   string   equiv_type;
   string   type;
   string  *zones;
   string  *all_zones;
   string  *parts;
   string   zone;
   string   verb;
   string   mess;
   mapping  covered;
   mapping  pot_covered;

   all_zones = keys(CLOTHING_HANDLER->query_all_clothing_zones());
   covered = allocate_mapping(sizeof(all_zones));
   pot_covered = allocate_mapping(sizeof(all_zones));
   foreach (zone in all_zones)  {
      covered[zone] = ({ });
      pot_covered[zone] = ({ });
   }

   if (sizeof(items) == 0)
      armors = this_player()->query_armours();
   else
      armors = items;

   fail = filter(armors,
                 (: !$1->query_armour()  &&  !$1->query_clothing() :));
   armors -= fail;
   wearing = this_player()->query_wearing();

   if (bits)  {
      bits = replace(bits, " ", ",");
      bits = replace(bits, ",and,", ",");
      zones = explode(bits, ",") - ({ "" });
      parts = filter(zones, (: member_array($1, $(all_zones)) != -1 :));
      if (sizeof(parts) == 0)  {
         write("Please choose some combination of " +
               query_multiple_short(all_zones) + ".\n");
         return 1;
      }
   }

   foreach (armor in armors)  {
      if (!arrayp(armor->query_type()))
         types = ({ armor->query_type() });
      else
         types = armor->query_type();

      zones = ({ });
      foreach (type in types)  {
         equiv_type = CLOTHING_HANDLER->query_equivilant_type(type);
         if (equiv_type)
            zones += CLOTHING_HANDLER->query_zone_names(equiv_type);
         else
            zones += CLOTHING_HANDLER->query_zone_names(type);
      }

      if (sizeof(zones))  {
         if (member_array(armor, wearing) > -1)
            foreach (zone in zones)
               covered[zone] += ({ armor });
         else
            foreach (zone in zones)
               pot_covered[zone] += ({ armor });
      }
      else fail += ({ armor });
   }

   if (bits)  {
      covered = filter(covered, (: member_array($1, $(parts)) != -1 :));
      pot_covered = filter(pot_covered,
                           (: member_array($1, $(parts)) != -1 :));
   }

   if (inverse)  {
      zones = filter(all_zones, (: sizeof($(covered)[$1]) == 0 :));
      if (sizeof(zones) > 0)  {
         if (sizeof(zones) > 1  ||
             zones[0] == "arms"  ||  zones[0] == "hands"  ||
             zones[0] == "legs"  || zones[0] == "feet")
            verb = " are";
         else
            verb = " is";
         write("Your " + query_multiple_short(zones) + verb +
               " unprotected.\n");
      }
      else write("You are covered from head to foot.\n");
      return 1;
   }

   zones = sort_array(keys(covered) | keys(pot_covered), 1);
   foreach (zone in zones)  {
      if (zone == "arms"  ||  zone == "hands"  ||
          zone == "legs"  ||  zone == "feet")
         verb = " are";
      else
         verb = " is";
      if (sizeof(covering = covered[zone]) > 0)  {
         if (sizeof(covering) == 1)
            mess = "Your " + zone + verb + " protected by " +
                   covering[0]->one_short();
         else
            mess = "Your " + zone + verb + " protected by " +
                   query_num(sizeof(covering)) + " things, " +
                   query_multiple_short(covering, "one");
         if (sizeof(pot_covered[zone]) > 0)  {
            mess += " and could be protected by " +
                    query_multiple_short(pot_covered[zone], "one") + ".\n";
            pot_covered[zone] = ({ });
         }
         else mess += ".\n";
         write(mess);
      }
      else if (sizeof(covering = pot_covered[zone]) > 0)  {
         write("Your " + zone + " could be protected by " +
               query_multiple_short(covering, "one") + ".\n");
      }
      else if (bits) write("Your " + zone + verb + " unprotected.\n");
   }

   if (sizeof(fail) != 0  &&  sizeof(items) != 0)  {
      if (sizeof(fail) == 1  &&  fail[0] == this_player())
         write("You don't offer any protection.  Perhaps you should invest "
               "in some sonkies?\n");
      else
         write(query_multiple_short(fail, "the") +
               (sizeof(fail) == 1 ? " doesn't" : " don't") +
               " offer any protection.\n");
   }
   else if (sizeof(armors - fail) == 0) /* Everything failed! */
      write("You are completely unprotected.  Good luck!\n");

   return 1;
}


mixed *query_patterns()  {
   return ({ "", (: cmd(({ }), 0, 0) :),
             "[by] <indirect:object'armour/clothing'>", (: cmd($1, 0, 0) :),
             "unprotected", (: cmd(({ }), 1, 0) :),
             "of <string'body part(s)'>", (: cmd(({ }), 0, $4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/coverage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/bugcheck.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/bugcheck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627097   Available: 13574451
Inodes: Total: 5242880    Free: 4960132
3978 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/bugcheck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627097   Available: 13574451
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Bugcheck command migrated from the badge
 *  @author Arienne
 *  @started 18/07/2002 01:56
 *
 */

#define WEIRD_OBJECT_LOG "/log/secure/playtesters/bugcheck-weird-objects"

inherit "/cmds/base";

varargs int cmd(object *obs) {
    string* s;
    string txt;

    foreach ( object ob in obs ) {
        if ( stringp( ob->query_property( "virtual name" ) ) )
            s = explode( ob->query_property( "virtual name" ), "/" );
        else
            s = explode( base_name( ob ), "/" );

        switch ( s[ 0 ] ) {
        case "d":
            write(capitalize( ob->the_short() ) +
                         " is a domain thing.  It's probably safe to "
                         "bugrep it directly.\n" );
            break;
            
        case "w":
            write(capitalize( ob->the_short() ) +
                         "... why do you have a creator item?\n" );
            log_file ("ILLEGAL_OBJECT", "%s: %s tried to bugcheck %s.\n\n",
              ctime(time()), this_player()->query_name(), base_name (ob));                         
            break;
            
        case "std":
            write(capitalize( ob->the_short() ) +
                         " is a weird MUD library thing.  If you bugrep "
                         "it, the response might be slow.  It may be a "
                         "better idea to bugrep the room that the object "
                         "was found in.\n" );
            break;
            
        case "obj":
          switch (s[1]) {
            case "weapons":
            case "armours":
            case "clothes":
            case "food":
            case "jewellery":
              write(capitalize( ob->the_short() ) +
                         " is a Disc-wide item, but belongs to a directory "
                         "that is checked regularly.  Best to make the "
                         "bugrep directly on the item.\n" );

            break;
            default:              
              write(capitalize( ob->the_short() ) +
                         " is a fairly general Disc-wide object.  If you "
                         "bugrep it, the response might be slow.  It would "
                         "most likely be a better idea to bugrep the room "
                         "in which the object was found.\n" );
            break;
          }
        break;
        case "global":
          switch (s[1]) {
            case "player":
            case "lord":
            case "playtester":
              if ( ob == this_player() ) {
                  txt = "are";
              }
              else {
                  txt = "is";
              }

              write(capitalize( ob->the_short() ) +
                         " " + txt + " the general " + s[1] + " object... if your "
                         "bugrep is on this, then bugrep this object.  If "
                         "your bugrep is along the frivolous lines of '" 
                         + ob->the_short() +" " + txt + " overpowered!', "
                         "then don't "
                         "bugreport it... be sure and raise the issue on the "
                         "nearest bulletin board.\n" );
            break;
          }            
        break;
        default:
            write("I've got no idea about " +
                         ob->the_short() + ".  Sorry it didn't work out.\n" );
            log_file( WEIRD_OBJECT_LOG, implode( s, "/" ) + "\n" );
            break;
        }
    }
    
    return 1;
} /* cmd() */

int cmd_room() {
   write("Bug report the room for anything that seems to be odd in the room, "
         "descriptions being wrong, items you look at being wrong.  Anything "
         "odd you see that does not seem to fit anywhere else should also be "
         "reported to the room.\n");
   return 1;
}

mixed *query_patterns() {
   return ({ "<indirect:object:'thing'>", (: cmd($1) :),
             "here", (: cmd_room :)
    });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/player/bugcheck.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/recover.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/recover.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627096   Available: 13574450
Inodes: Total: 5242880    Free: 4960132
3263 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/recover.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627096   Available: 13574450
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This method allows you to recover items from the room.
 * @author Pinkfish
 * @started Mon Feb  7 01:04:04 PST 2000
 * @changed Sun Jul 16 23:43:49 PST 2000 Taffyd 
 * Added MAX_RECOVER.
 */
#include <obj_parser.h>

inherit "/cmds/base";

#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
#include <player.h>

/**
 * This is the maximum number of items that can be
 * recovered.
 */
#define MAX_RECOVER 20

int cmd_recover(string name) {
   object* obs;
   object* fail;
   object* ok_me;
   object* ok_here;
   object cont;
   object ob;
   class obj_match omatch;

#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif

   if (this_player()->query_property("dead")) {
      add_failed_mess("You're a disembodied spirit, how do you expect to "
                      "recover anything at all?\n");
      return 0;
   }

   cont = BURY_EFFECT->query_buried_container(environment(this_player()));
   if (!cont) {
      add_failed_mess("There is nothing buried here.\n");
      return 0;
   }
   omatch = (class obj_match)match_objects_in_environments(name, cont);
   if (omatch->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(omatch));
      return 0;
   }
   obs = omatch->objects;
   
   if ( sizeof( obs ) > MAX_RECOVER ) {
      add_failed_mess( "You can only recover " + 
        query_num( MAX_RECOVER ) + " items at a time.\n" );
      return 0;
   }

   fail = ({ });
   ok_me = ({ });
   ok_here = ({ });
   if (sizeof(obs)) {
      //
      // Recover them...
      //
      foreach (ob in obs) {
#ifndef __DISTRIBUTION_LIB__
        if(interactive(this_player()) &&
           PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("recover",
                                                           this_player(),
                                                           ob)) {
          fail += ({ ob });
        } else 
#endif
         if (ob->move(this_player()) == MOVE_OK) {
            ok_me += ({ ob });
         } else if (ob->move(environment(this_player())) == MOVE_OK) {
            ok_here += ({ ob });
         } else {
            fail += ({ ob });
         }
      }
      if (!sizeof(ok_me) && !sizeof(ok_here)) {
         add_failed_mess("Unable to recover $I.\n", fail);
         return 0;
      }
      if (sizeof(ok_me)) {
         add_succeeded_mess("$N $V $I.\n", ok_me);
      }
      if (sizeof(ok_here)) {
         add_succeeded_mess("$N $V $I and leave$s " +
                            (sizeof(ok_here) > 1?"them":"it") +
                            " here.\n", ok_here);
      }
      return 1;
   } else {
      ok_me = all_inventory(cont);
      if (sizeof(ok_me)) {
         add_failed_mess("Unable to recover " + name + ", available objects "
                       "are " + query_multiple_short(ok_me) +
                      ".\n");
      } else {
         add_failed_mess("Unable to recover " + name + ".\n");
      }
      return 0;
   }
} /* cmd_recover() */

mixed* query_patterns() {
   return ({ "<string'buried object'>", (: cmd_recover($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/recover.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/email.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/email.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627095   Available: 13574449
Inodes: Total: 5242880    Free: 4960132
831 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/email.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627095   Available: 13574449
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: email.c,v 1.1 1998/01/06 05:29:43 ceres Exp $
 * $Log: email.c,v $
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <player.h>
inherit "/cmds/base";

#define TP this_player()

int cmd(string str) {
   string email;

  email = TP->query_email();
   
   if (!str) {
      write("Your current email address is "+email+"\n");
      write("To clear use \"email CLEAR\"\n");
      write("For the email address to be only visible by lords prepend a :\n");
      write("eg email :frog@frogcentral.froguni.swamp\n");
      return 1;
   }
   if (str == "CLEAR")
      email = "";
   else
      email = str;
   if (email != "")
      write("Email address set to "+str+".\n");
   else
      write("Email address is null.\n");
   TP->set_email(email);
   return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/player/email.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/rituals.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/rituals.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627095   Available: 13574449
Inodes: Total: 5242880    Free: 4960132
1447 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/rituals.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627095   Available: 13574449
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rituals.c,v 1.1 1998/01/06 05:29:43 ceres Exp $
 * $Log: rituals.c,v $
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <spells.h>

inherit "/cmds/base";

int cmd( string words ) {
   string spell, *religious;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   religious = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( sscanf( spells[ spell ][ 0 ], "%*spriest%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*srituals%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*swizard%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*switch%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*sspell%*s" ) == 2 )
         continue;
   }
   if ( !sizeof( religious ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   if ( sizeof( religious ) ) {
      write( "You know the following religious ritual"+
            ( sizeof( religious ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( religious, 1 ), "\n" ) );
   }
   return 1;
} /* cmd() */
// --- END [/mnt/home2/grok/lib/cmds/player/rituals.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/make.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/make.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627094   Available: 13574448
Inodes: Total: 5242880    Free: 4960132
4824 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/make.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627094   Available: 13574448
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: make.c,v 1.14 2003/03/01 01:35:41 pinkfish Exp $
 * $Log: make.c,v $
 * Revision 1.14  2003/03/01 01:35:41  pinkfish
 * Add in snow player killer.
 *
 * Revision 1.13  2002/08/29 18:45:54  taffyd
 * Fixed space error
 *
 * Revision 1.12  2001/11/08 08:41:07  pinkfish
 * Add in a few extra thingies.
 *
 * Revision 1.11  2001/11/08 08:04:31  pinkfish
 * Add in a snowcabbage.
 *
 * Revision 1.10  2001/07/16 23:03:22  ceres
 * Added snowangel
 *
 * Revision 1.8  2001/03/13 02:50:33  pinkfish
 * Fix a typo.
 *
 * Revision 1.7  2000/09/03 05:38:40  ceres
 * Added some more options.
 *
 * Revision 1.6  2000/06/16 02:02:24  pinkfish
 * Fix it up to work on the distribution lib.
 *
 * Revision 1.5  1999/05/08 01:15:04  pinkfish
 * Fixed some bugs.
 *
 * Revision 1.4  1999/01/13 01:35:26  pinkfish
 * Fix up the make stuff.
 * *8
 *
 * Revision 1.3  1999/01/11 06:28:37  pinkfish
 * Add in the cream pie stuff.
 *
 * Revision 1.2  1998/04/14 02:35:44  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* make command for making snowballs and snowmen. Moved from /global/pweath.c
 * by Ceres 24/3/96
 */

#include <config.h>
#include <weather.h>
#include <move_failures.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif

inherit  "/cmds/base";

#define TP this_player()

private string *_snow_creatures = ({ 
    "snowman",
    "snowwoman", 
    "snowboy",
    "snowgirl",
    "snowbunny",
    "snowfrog",
    "snowball",
    "snowwomble",
    "snowangel",
    "snowcabbage",
    "snowwitch",
    "snowwizard",
    "snowwarrior",
    "snowthief",
    "snowpriest",
    "snowassassin",
    "snowfamily",
    "snowfox",
    "snowdwarf",
    "snowplayerkiller",
    "snowtroll"
}); 

private string _make_pattern_cache; 

void create() {
    ::create();

    _snow_creatures = sort_array( _snow_creatures, 1 );
} /* create() */ 

int is_snowing(object player, string str) {
  object env;
  int *co_ords;

  env = environment(player);
  if ((string)env->query_property("location") == "inside") {
    add_failed_mess("You must be outside to make a " + str + ".\n");
    return 0;
  }

  co_ords = (mixed *)env->query_co_ord();

  if (!WEATHER->query_snowing(env)) {
     add_failed_mess("You need snow to make a " + str + ".\n");
     return 0;
  }

  return 1;
} /* is_snowing() */

mixed cmd(string str) {
  object ob;
  object env;
 
  env = environment(TP);
  switch (str) {
  case "snowball" :
    if (is_snowing(TP, str)) {
      ob = clone_object("/std/environ/snowball");
      if (ob->move(TP) != MOVE_OK) {
        add_succeeded_mess(({ "$N try to make a snowball, but you cannot "
                              "pick it up so it disintergrates in "
                              "disinterest.\n",
                              "$N tries to make a snowball, but they cannot "
                                "pick it up.\n" }));
      } else {
        add_succeeded_mess(({
          "$N $V a lovely big snowball.  Have fun with it ;)\n",
            "$N $V a lovely big snowball.\n" }));
      }
      return 1;
    }
    break;
#ifndef __DISTRIBUTION_LIB__
  case "cream pie":
    if (SPECIAL_DAY_HANDLER->query_special_day() == CREAM_PIE_DAY) {
      if (TP->query_property("made cream pie")) {
        add_failed_mess("You made a cream pie less than 30 seconds ago.  "
                        "Don't be greedy now.\n");
      } else {
        ob = clone_object("/obj/misc/cream_pie");
        if (ob->move(TP) != MOVE_OK) {
          add_succeeded_mess(({ "You try to magicaly conjure a cream pie up "
                                  "out of nowhere, but you cannot pick it up.\n",
                                  "$N tries to conjure up a cream pie, but "
                                  "just looks silly.\n" }));
          ob->dest_me();
          return 1;
        } else {
          /* One pie every 30 seconds... */
          TP->add_property("made cream pie", 1, 30);
          add_succeeded_mess("$N conjure$s up $I.\n", ({ ob }));
          return 1;
        }
      }
    } else {
       add_failed_mess("You can only create cream pies on cream pie day!\n");
    }
    break;

  default:
    if ( member_array( str, _snow_creatures ) > -1 ) { 
        if (is_snowing(TP, str)) {
          ob = clone_object("/std/environ/snowman");
          ob->set_type(str);
          ob->move(env);
          add_succeeded_mess("$N $V a beautiful " + str + ".\n");
          return 1;
        }
    }
    break;

#endif
  }
  return 0;
} /* cmd() */

mixed *query_patterns() {
    if ( !_make_pattern_cache ) { 
        _make_pattern_cache = "{" + implode( _snow_creatures + 
            ({ "cream pie" }), "|" ) + "}";
    }

   return ({ _make_pattern_cache, (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/make.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/killers.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/killers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627093   Available: 13574447
Inodes: Total: 5242880    Free: 4960132
6479 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/killers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627093   Available: 13574447
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: killers.c,v 1.21 2003/03/02 22:30:36 pinkfish Exp $
 */
// Killers command by Ceres
#include <player_handler.h>
#include <clubs.h>

inherit "/cmds/base";

string second_name( string str );

/** @ignore yes */
mixed cmd( string mode ) {
   object *killers;
   object player = this_player();
   string *names, *tmp, name;
   int i, brief, number, guild;
   mixed *unique_names;
   
   if ( mode == "verbose" ) brief = 0;
   else brief = 1;
   

   // OK, OK.  This is awful, but it looks so cool...  :)    --Presto
   killers = filter_array( users(),
                         (: !($1->query_creator())  &&
                            !($1->query_login_ob())  &&
                            !($1->query_property("test character")) &&
                            $1->query_player_killer() :) );
   if (mode) mode = lower_case(mode);
   if (mode &&
       mode != "verbose" &&
       mode != "brief") {
      guild = 1;
      mode = replace(mode, ({  "assassins",   "assassin", 
                               "priests",     "priest",
                               "thieves",     "thief",    
                               "warriors",    "warrior",
                               "witches",     "witch",    
                               "wizards",     "wizard",
                               "adventurers", "adventurer",
                               "fighters",    "warrior", 
                               "fighter",     "warrior",
                               "monks",       "monk",
                              }));
      killers = filter_array( killers, 
                      (: $1->query_guild_ob() == "/std/guilds/" + $(mode) :) );
   }
       
   if (brief) {
      names = killers->query_cap_name();
   } else {
      names = killers->short();
   }
   for (i = 0; i < sizeof(killers); i++) {
      if (names[i] && this_player()->is_friend(killers[i]->query_name())) {
         names[i] += "(%^GREEN%^F%^RESET%^)";
      }
   }

   names -= ({ 0 });

   if (!sizeof(names)) {
      write("There are no " + (guild?mode + " ":"") + "player killers logged"
            " in.\n");
   } else {
      if(sizeof(names) == 1)  {
         if ( names[0] == (brief? player->query_cap_name(): player->short()) ) {
            write( "You are the only player killer on " + mud_name() + ".\n" );
         } else {
            write("The only " + (guild?mode:"") + " player killer currently "
                  "logged in is "+ names[0]+".\n");
         }
      } else {
         i = 0;
         if ( member_array( 
              (brief? player->query_cap_name(): player->short()),
              names ) > -1 )  {
            names -= ({ (brief? player->query_cap_name(): player->short()) });
            i = 1;
         }
         names = sort_array( names,
                             (: strcmp( lower_case( $1 ),
                                        lower_case( $2 ) ) :) );
         if ( i ) {
             name = this_player()->query_cap_name();
             if (this_player()->query_family_name() &&
                 !brief) {
                name += " " + this_player()->query_family_name();
             }
             names += ({ name });
         }
         
         // This is a fairly silly thing, but quite cool, in its own little way :)
         if (!brief) {
           unique_names = unique_array( names, (: second_name($1) :) );
           names = ({ });
           foreach ( tmp in unique_names ) {
                names += tmp;
           }
         }

         
         number = sizeof(names);
         write("There are " + sizeof(names) + (guild?" " + mode:"") + 
               " player killers logged in:\n" +
               query_multiple_short(names) + "\n");
               //sprintf("%-#*s", player->query_cols(), 
               //implode( names, "\n" ) ) + "\n");
      }
   }
   return 1;
} /* cmd() */

int cmd_here() {
   string *killers;

   killers = filter_array( all_inventory(environment(this_player())),
                         (: !($1->query_creator())  &&
                            !($1->query_property("test character")) &&
                            $1->query_player_killer() &&
                            $1->query_visible( this_player() ) &&
                            $1 != this_player() :) );
   if (!sizeof(killers)) {
      add_failed_mess("There are no killers here.\n");
      return 0;
   }
   if (sizeof(killers) > 1) {
      write("The killers here are " +
            query_multiple_short(killers) + ".\n");
   } else {
      write("The killer here is " +
            query_multiple_short(killers) + ".\n");
   }
   return 1;
} /* cmd_here() */

/** @ignore yes */
string second_name( string str ) {
  int pos;

  pos = strsrch( str, " " );
  if (pos == -1) {
     return "";
  }
  return str[pos+1..];
} /* second_name */

/** @ignore yes */
int cmd_club( string club ) {
    int number;
    string *names;

    if( CLUB_HANDLER->query_club_secret( club ) &&
        !CLUB_HANDLER->is_member_of( club, this_player()->query_name() ) ) {
        add_failed_mess( "That is a secret club! Killers information about "
            "secret clubs is only shown to club members.\n" );
        return -1;
    }
    names = map( filter( CLUB_HANDLER->query_members( club ), 
       (: find_player( $1 ) && !PLAYER_HANDLER->test_creator( $1 ) && 
        pk_check( $1, this_player(), 1 ) != 1 :) ), 
        (: capitalize( $1 ) :) );


    if ( number = sizeof( names ) ) {
        if ( number > 1 ) {
            write("There are " + number + " player killers logged on "
                "who are members of " + capitalize( club ) + ":\n" +
                sprintf("%-#*s", this_player()->query_cols(), implode( names, 
                "\n" ) ) + "\n");
        }
        else {
            write("There is " + number + " player killer logged on "
                "who is a member of " + capitalize( club ) + ":\n" +
                sprintf("%-#*s", this_player()->query_cols(), implode( names, 
                "\n" ) ) + "\n");
        }
    }
    else {
        add_failed_mess( "There are no player killers in that club.\n" );
        return -1;
    }

     return 1;
}


/** @ignore yes */
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
            "{verbose|brief}", (: cmd( $4[0] ) :),
            "here", (: cmd_here() :),
            "club <string'club name'>", (: cmd_club( $4[0] ) :),
            "guild <string'guild name'>", (: cmd( $4[0] ) :) });
} /* query_patterns */
// --- END [/mnt/home2/grok/lib/cmds/player/killers.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/splash.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/splash.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627091   Available: 13574445
Inodes: Total: 5242880    Free: 4960132
1802 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/splash.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627091   Available: 13574445
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: splash.c,v 1.7 2001/09/24 01:43:51 presto Exp $
 * $Log: splash.c,v $
 * Revision 1.7  2001/09/24 01:43:51  presto
 * Oopd, should only be able to splash on the surface
 *
 * Revision 1.6  2001/09/24 01:31:53  presto
 * Can splash in water rooms too
 *
 * Revision 1.5  1999/07/23 10:33:39  taffyd
 * Made it so that you could splash people if they were in a bath house. :)
 *
 * Revision 1.4  1998/09/27 21:44:17  ceres
 * Fixed splashing yourself.
 *
 * Revision 1.2  1998/04/14 02:38:07  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
/* make command for making snowballs and snowmen. Moved from /global/pweath.c
 * by Ceres 24/3/96
 */
inherit "/cmds/base";
#include <weather.h>

#define TP this_player()

mixed cmd(object *obs) {
    object env, ob;
    string str;

    env = environment(TP);

    if ( !env->query_baths()  &&  (!env->query_water()  ||  !env->query_surface()) ) {
        if ((string)env->query_property("location") == "inside")
            return notify_fail("You must be outside to do that.\n");

        if (!WEATHER->query_raining(env))
            return notify_fail("It must be raining to splash someone.\n");
    }

    foreach(ob in obs) {
        ob->add_effect("/std/effects/other/wetness", 2 + random(4));
        if(ob == this_player())
            continue;

        tell_object(ob, (string)TP->a_short()+" splashes "+
          query_multiple_short(obs - ({ ob }) + ({ "you" }))+".\n");
    }


    str = query_multiple_short(obs);
    write("You splash "+str+".\n");
    say(TP->a_short()+" splashes "+str+".\n", obs);
    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "<indirect:living>",(: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/splash.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/mccp.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/mccp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627090   Available: 13574444
Inodes: Total: 5242880    Free: 4960132
1137 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/mccp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627090   Available: 13574444
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

int cmd() { 
    object *players; 
    int compressed; 

    if ( compressedp( this_player() ) ) {
        tell_object( this_player(), "You are currently using MCCP to "
          "connect to " + mud_name() + ".\n" );
    }
    else {
        tell_object( this_player(), "You are not currently using MCCP to "
          "connect to " + mud_name() + ".  Please read 'help compression' for "
          "more information about MCCP.\n" );
    }

    players = filter( users(), (: !$1->query_login_ob() &&
        reference_allowed( $1, $(this_player()) ) :) ); 

    compressed = sizeof( filter( players, (: compressedp :) ) );
    
    tell_object( this_player(), "%^BOLD%^$C$" + query_num( compressed, 1000 ) +
                 " users (" + ((compressed * 100) / sizeof(players)) + "%) are "
                 "currently using MCCP and " + query_num(sizeof(players) - compressed, 1000) + " users (" + (((sizeof(players) - compressed) * 100) / sizeof(players)) + "%) are uncompressed.%^RESET%^\n" );

    return 1;
} /* cmd() */

mixed *query_patterns() { 
    return ({ "", (: cmd :) });
} /* query_patterns() */ 


// --- END [/mnt/home2/grok/lib/cmds/player/mccp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/stop.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/stop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627090   Available: 13574444
Inodes: Total: 5242880    Free: 4960132
2894 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/stop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627090   Available: 13574444
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: stop.c,v 1.9 2003/07/16 20:28:33 pinkfish Exp $
 * $Log: stop.c,v $
 * Revision 1.9  2003/07/16 20:28:33  pinkfish
 * Increas eht random delay.
 *
 * Revision 1.8  2002/09/08 20:57:09  ceres
 * Modified to make stopping combat slightly variable
 *
 * Revision 1.7  2002/08/03 19:28:58  ceres
 * New combat system version
 *
 * Revision 1.5  1999/02/01 01:14:58  presto
 * Removed checks for things on attacker list being living.  It was stuffing
 * up for things like training dummys.  This is a test to see if anything else
 * gets broken.
 *
 * Revision 1.4  1999/01/14 23:20:32  ceres
 * Mods to support delayed searching.
 *
 * Revision 1.3  1998/04/14 02:28:16  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.2  1998/03/26 06:13:04  ceres
 * Made it so when you stop fighting you don't stop fighting things in
 * your environment.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

int no_okay;
object tmp;

mixed cmd( string word ) {
   object *atts;

   switch( word ) {
      case "debate" :
      case "debating" :
         this_player()->interrupt_debate();
         break;
      case "spell" :
         this_player()->interrupt_spell();
         break;
      case "ritual" :
         this_player()->interrupt_ritual();
         break;
      case "fight" :
      case "fighting" :
         atts = this_player()->query_attacker_list();
         if ( !sizeof( atts ) ) {
            write( "You are not fighting anyone.\n" );
            return 1;
         }
         if ( (int)this_player()->query_hp() < 0 ) {
            write( "You have already died; stopping now is pointless.\n" );
            return 1;
         }
         write( "Stopping fight.  Please wait.\n" );
         call_out( "stop_fight", 5+random(10), this_player() );
         return 1;
      default:
         no_okay = 1;
         cmd( "debate" );
         cmd( "spell" );
         cmd( "ritual" );
         cmd( "fight" );
         no_okay = 0;
/*
 * This gets called anyway, on its way through.
         this_player()->drunk_check( "stop" );
*/
   }

   "/cmds/player/sea_rch"->interrupt_search(this_player());
   if ( !no_okay )
      write( "Okay.\n" );
   return 1;
} /* cmd() */

void stop_fight( object who ) {
  object *atts, ob;
  
  if ( !who )
    return;

  atts = who->query_attacker_list();
  atts -= ({ 0 });
  tmp = who;
  if(atts == ({ }))
    return;
  
  tell_object( who, "You stop fighting "+
               query_multiple_short( map_array( atts,
         (: $1->query_property( "dead" ) ? (string)$1->a_short() + " (dead anyway)" : $1 :) ) ) +".\n" );

  foreach(ob in atts)
    who->stop_fight(ob);
  
} /* stop_fight() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{debate|debating|spell|ritual|fight|fighting}", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/stop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/t_ell.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/t_ell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627089   Available: 13574443
Inodes: Total: 5242880    Free: 4960132
15315 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/t_ell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627089   Available: 13574443
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: t_ell.c,v 1.64 2003/02/15 20:09:03 pinkfish Exp ceres $
 * 
*/
#include <drinks.h>
#include <player.h>
#include <language.h>

#define TP this_player()

#define TELL_REPLY_LOCK_ID "lock fluff"

/* Behaviour when we encounter ear muffs in player */
#define CUT_THOUGH_PROPERTY "cut earmuffed tells"
#define FAIL_DONT_ASK 0
#define ASK 1
#define CUT_DONT_ASK 2

inherit "/cmds/base";
inherit "/cmds/speech";


/* This function handles tells from cres to players who
 * have tells ear muffed. */
void delayed_tell(string yesno,
                  object * recicipients,
                  string message);


#ifdef USE_SMILEYS
string *two_smileys = ({ ":)", ":(", ":P", ":p", ":b", ";)",
                           ";(", ";P", ";p", ";b", "=)", "=("
                           });

string *three_smileys = ({ ":-)", ":-(", ":-P", ":-p", ":-b",
                             ";-)", ";-(", ";-P", ";-p", ";-b", ":o)", ":o(",
                             ":oP", ":op", ":ob", ";o)", ";o(", ";oP", ";op",
                             ";ob", "=-)", "=-(", "=o)", "=o("
                             });
#endif

int cmd(string arg, mixed thing, int silent) {
  class message mess;
  string words,
    word;
  string them_mess,
    extra;
  string *ok_string;
  string *prop;
  object *obs;
  object *net_dead;
  object *multiple_earmuffed;
  object *cannot_see;
  object *ok;
  object *fail;
  object *earmuffed;           /* These people have ear muffed tells */
  object *roleplaying;
  mixed busy;
  
  if (pointerp(thing)) {
    words = arg;
    thing -= ({ 0 });
    if (TP && environment(TP) &&
        function_exists("trap_tell", environment(TP)) &&
        member_array(this_object(), previous_object(-1)) == -1) {
      return (int) environment(TP)->trap_tell(words, thing, 0);
    }
  } else if (!objectp(thing)) {
    if (!arg || sscanf(arg, "%s %s", word, words) != 2) {
      return 0;
    }
    word = lower_case(word);
    word = (string) TP->expand_nickname(word);

    if (sizeof(thing = explode(word, ",")) == 1)
      thing = ({ find_player(word) });
    else {
      thing = map(thing, (: find_player :));
    }

    thing -= ({ 0 });
    if (sizeof(thing) == 0) {
      if (TP->query_creator() && sscanf(word, "%*s@%*s") == 2) {
        "/net/daemon/out_tell"->do_tell(word + " " + words);
        return 1;
      }
      add_failed_mess(capitalize(word) + " is not logged in.\n");
      return 0;
    }
    if (environment(TP)) {
      if (function_exists("trap_tell", environment(TP)) &&
          member_array(this_object(), previous_object(-1)) == -1) {
        return environment(TP)->trap_tell(words, thing, 0);
      }
    }
  } else {
    thing = ({ thing }) - ({ 0 });
    words = arg;
  }

  /* Don't allow someone with tells ear muffed to use tell. */
  if (TP->check_earmuffs("tell")) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      fail = filter(thing, (: !TP->is_friend($1->query_name()) &&
                            $1 != this_player() :));
      if (sizeof(fail)) {
        add_failed_mess("One of the people ($I) you "
                        "are trying to tell is not a "
                        "friend (and you have tells earmuffed).\n",
                        fail );
        return -1;
      }
    } else {
      add_failed_mess("You have tells ear muffed.\n");
      /* return 0 gave us two messages to player. */
      return -1;
    }
  }

  if(TP->query_role_playing()) {
    add_failed_mess("You cannot send tells as you are currently "
        "role playing.\n");
    return -1;
  }
  
  mess = build_message(words, thing, "tell");
  switch(mess->status) {
  case NOT_DISTANCE:
    return add_failed_mess("The language " + capitalize(mess->language) +
                           " is not able to used over a distance.\n");
  case NOT_SPOKEN:
    return add_failed_mess(capitalize(mess->language) +
                           " is not a spoken language.\n");
  case NO_MESSAGE:
    return add_failed_mess("No message given.\n");
  }
  obs = thing - ({ this_player() });

  if (!sizeof(obs)) {
    add_failed_mess("Talking to yourself again.  I don't know.\n");
    return 0;
  }

  if (sizeof(obs) > 20) {
    add_failed_mess("You can only tell up to 20 people a message.\n");
    return 0;
  }

  fail = this_player()->query_ignoring(obs);
  if (sizeof(fail)) {
    write("You are currently ignoring " +
          query_multiple_short(fail, 0, 1, 0, 0) + ", so " +
          (sizeof(fail) > 1 ? " they" : fail[0]->query_pronoun()) +
          " couldn't reply anyway.\n");
    obs -= fail;
    if (!sizeof(obs)) {
      return 1;
    }
  }

  fail = this_player()->query_ignored_by(obs);
  if (sizeof(fail)) {
    if (!this_player()->query_creator()) {
      write("You are currently being ignored by " +
            query_multiple_short(fail, 0, 1, 0, 0) + ", so "
            "you cannot tell them anything.\n");
      obs -= fail;
      if (!sizeof(obs)) {
        return 1;
      }
    } else {
      write("Warning!  " + query_multiple_short(fail, 0, 1, 0, 0) +
            " have you on ignore.\n");
    }
  }

  if (!TP->query_creator() && (TP->adjust_sp(-TELL_COST) < 0)) {
    return notify_fail(NO_POWER);
  }

  net_dead = ({ });
  multiple_earmuffed = ({ });
  earmuffed = ({ });
  ok = ({ });
  roleplaying = ({ });
  cannot_see = ({ });

  if (sizeof(obs) > 1 && this_player()->check_earmuffs("multiple-tell")) {
    add_failed_mess("You cannot do a multiple-tell if you have them "
                    "earmuffed yourself.\n");
    return 0;
  }

  foreach(thing in obs) {
    if (sizeof(obs) > 1 && thing->check_earmuffs("multiple-tell")) {
      multiple_earmuffed += ({ thing });
    } else if (thing->check_earmuffs("tell")) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        /* A cre that doesn't care about ear muffs, so we warn the
         * cre and player, but don't add to the ear muffed array. */
        write("You cut through the ear muffs of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your ear muffs.\n");
        /* Add to array of people who get the message. */
        ok += ({ thing });
      } else {
        /* Ok, someone cares, so we add to earmuffed array. */
        earmuffed += ({ thing });
      }
    } else if(thing->query_role_playing()) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        /* A cre that doesn't care about ear muffs, so we warn the
         * cre and player, but don't add to the ear muffed array. */
        write("You cut through the roleplaying mode of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your roleplaying mode.\n");
        /* Add to array of people who get the message. */
        ok += ({ thing });
      } else {
        /* Ok, someone cares, so we add to earmuffed array. */
        roleplaying += ({ thing });
      }
    } else if (!this_player()->query_invis() ||
               reference_allowed(this_player(), thing)) {
      /* All is hoopy. */
      ok += ({ thing });
    } else {
      cannot_see += ({ thing });
      ok += ({ thing });
    }
  }

  ok_string = map(ok, (: $1->query_name() :)) +
    ({ this_player()->query_name() });

  switch (mess->type) {
  case "exclaim":
    extra = " to";
    break;
  default:
    extra = "";
    break;
  }

  foreach(thing in ok) {
    them_mess = query_multiple_short(map(ok- ({ thing }),
                                         (: $1->short(0, 0) :)) +
                                     ({ "you"  }), 0, 1, 0, 0);
    if ( interactive( this_player() ) ) {
      thing->event_person_tell(TP, capitalize((string) TP->short(0, 0)) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    else {
      thing->event_person_tell(TP, capitalize( TP->the_short()) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    // Lasts for 15 minutes.
    prop = thing->query_tell_reply_list();
    if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
      // Refresh if one of the locked people tells us.
      if (member_array(TP->query_name(), prop) != -1) {
        thing->set_tell_reply_list(prop);
      }
    } else {
      thing->set_tell_reply_list(ok_string);
    }
    if (!interactive(thing) && userp(thing)) {
      net_dead += ({ thing });
    }
  }

  if (!silent) {
    if (sizeof(net_dead)) {
      write("Warning: " +
            query_multiple_short(map(net_dead, (: $1->query_cap_name() :)), 0,
                                 1, 0, 0) + " " +
            (sizeof(net_dead) > 1 ? "are" : "is") + " net dead.\n");
    }
    if (sizeof(multiple_earmuffed)) {
      write(capitalize(query_multiple_short(multiple_earmuffed, 0, 1, 0, 0)) +
            (sizeof(multiple_earmuffed) > 1 ? " have " : " has ") +
            "multiple tells ear muffed.\n");
    }
    if (sizeof(earmuffed)) {
      write(capitalize(query_multiple_short(earmuffed, 0, 1, 0, 0)) +
            (sizeof(earmuffed) > 1 ? " have " : " has ") +
            "tells ear muffed.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    if (sizeof(roleplaying)) {
      write(capitalize(query_multiple_short(roleplaying, 0, 1, 0, 0)) +
            (sizeof(roleplaying) > 1 ? " are " : " is ") +
            "role playing.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    busy = this_player()->query_busy();
    if (busy == 1) {
      write("Warning! You have your busy flag on.\n");
    } else if (pointerp(busy) && sizeof(ok - busy)) {
      write("Warning! You are currently set as busy with " +
            query_multiple_short(busy, 0, 1, 0, 0) + ".\n");
    }

    if (sizeof(cannot_see)) {
      write("Warning! " + query_multiple_short(cannot_see, 0, 1, 0, 0) +
            " cannot see you and will not be able to respond.\n");
    }

    if (sizeof(ok)) {
      them_mess =
        TP->convert_message(query_multiple_short(map(ok, (:
$1->short(0,0) :)), 0, 1, 1, 0));
      my_mess("You " + mess->emote + mess->type + extra + " " +
              them_mess + ": ", mess->text);
      TP->add_tell_history("You " + mess->emote + mess->type + extra +
                           " " + them_mess + ": ", mess->text);
    } else if (TP->query_creator() && !sizeof(earmuffed)) {
      /* We don't want this message *and* the one about cutting
       * * through ear muffs, so if the player is a cre and has
       * * already gotten the (y/n) stuff, we skip this. */
      add_failed_mess("It seems no one was listening.\n");
      /* return 0 gave two messages. */
      return -1;
    }
  }
  TP->adjust_time_left(-5);
  return 1;
}

int reply_cmd(string mess) {
  string *rep;
  object *obs;

  rep = this_player()->query_tell_reply_list();
  if (!rep) {
    add_failed_mess
      ("No one has told you anything in the last 15 minutes.\n");
    return 0;
  }

  obs = map(rep, (: find_living($1) :)) - ({ 0 });
  if (!sizeof(obs)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are currenttly online.\n");
    return 0;
  }

  this_player()->set_tell_reply_list(rep);
  return cmd(mess, obs, 0);
}

int replylock_cmd(string names) {
  string *rest;
  string *rep;
  rep = uniq_array(explode(names, ","));
  rep = map(rep, (: this_player()->expand_nickname($1) :));
  rest = filter(rep, (: $1 && find_player($1) && interactive(find_player($1)) :));

  if(!sizeof(rest)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are logged in.  You cannot lock onto someone who is "
                    "not here.\n");
    return 0;
  }

  this_player()->set_tell_reply_list(({ TELL_REPLY_LOCK_ID }) + rest);
  add_succeeded_mess(({ "You lock in " +
                          query_multiple_short(rest, 0, 1, 0, 0) +
                          " in your reply list.\n", "" }));
  return 1;
}

int replylockremove_cmd() {
  this_player()->set_tell_reply_list(0);
  add_succeeded_mess(({ "You remove any possible reply locks.\n", "" }));
  return 1;
}

mixed *query_patterns() {
  return ({ "<indirect:player> <string'message'>",
              (: cmd($4[1], $1, 0) :),
              "reply <string'message'>", (: reply_cmd($4[0]) :),
              "replylock <string'names'>", (: replylock_cmd($4[0]) :),
              "replylock remove", (: replylockremove_cmd() :),
              "<string>", (: cmd($4[0], 0, 0) :) });
}


/*
 * Tells from cres to ear muffed players.
 * All emoticon and "asks you" or "exclaims" stuff removed.
 */
void delayed_tell(string yesno,
                  object * recicipients,
                  string message) {
  object ob,
    *netdead;
  int disappeared;

  /*
   * Tried to keep us out
   * But nothing stops creators
   * Except alter.net
   */

  /* Did they really want to break through? */
  if (!(yesno == "yes" || yesno == "y")) {
    write("Ok, tell aborted.\n");
    return;
  }

  netdead = ({ });

  foreach(ob in recicipients) {
    if (!ob) {
      disappeared++;
      recicipients -= ({ ob });
    } else {
      if (!interactive(ob))
        netdead += ({ ob });
      /* Tell them even if they are net dead - it'll end up
       * in their tell history..? */
      message = replace(message, "%^", " ");
      ob->event_person_tell(TP, capitalize(TP->query_name()) +
                            " cuts through your ear muffs and tells "
                            + query_multiple_short(recicipients -
                                                   ({ ob }) + ({ "you" }), 0,
                                                   1, 0, 0) + ": ", message);
    }
  }

  if (sizeof(netdead))
    write("Warning: " + query_multiple_short(netdead, 0, 1, 0, 0) +
          (sizeof(netdead) > 1 ? " is" : " are") + " net dead.\n");


  /* There's no way to get their names now, so we just tell the cre
   * how many recicipients disappeared. */
  if (disappeared)
    write("It seems " + disappeared + " person" +
          (disappeared > 1 ? "s have" : " has")
          + " disappeared.\n");

  /* Ooops - no one left to talk to! */
  if (!sizeof(recicipients)) {
    write("No one wanted to stay around long enough "
          "to hear what you had to say.\n");
    return;
  }

  my_mess("You tell " +
          TP->convert_message(query_multiple_short(recicipients, 0, 1, 0, 0))
          + ": ", message);

  TP->add_tell_history("You cut through earmuffs and tell " +
                       TP->convert_message(capitalize(
                       query_multiple_short(recicipients, 0, 1, 0, 0))) +
                       ": ", message);
  return;
}
// --- END [/mnt/home2/grok/lib/cmds/player/t_ell.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/chfn.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/chfn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627085   Available: 13574439
Inodes: Total: 5242880    Free: 4960132
7357 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/chfn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627085   Available: 13574439
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chfn.c,v 1.8 2003/07/10 07:10:12 pinkfish Exp $
 * $Log: chfn.c,v $
 * Revision 1.8  2003/07/10 07:10:12  pinkfish
 * Fix up the numvers.
 *
 * Revision 1.7  2001/03/12 04:23:16  pinkfish
 * Change lord only to creator only in the message.
 *
 * Revision 1.6  2001/03/12 00:19:45  ceres
 * Fixed 'creators' to 'lords'.
 *
 * Revision 1.5  1999/04/30 01:11:04  pinkfish
 * Fix this up to strip colours.
 *
 * Revision 1.4  1999/02/09 00:23:41  ceres
 * Increased the max email address length to 50.
 *
 * Revision 1.2  1999/02/03 00:52:50  pinkfish
 * Fix it up so you can only enter certain sized bits of data into the fields.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

#define MAX_EMAIL_LEN 50

int cmd(string str) {
  write("Change finger information.\n");
  write("Pressing return at the prompts will take the default.  The default "
        "is the option in []'s.\n");
  write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
  input_to("real_name");
  return 1;
} /* chfn() */

int real_name(string str) {
  string real_name;

  str = strip_colours(str);
  
  real_name = TP->query_real_name();
  if (str && str != "") {
    if (str == "none") {
      real_name = 0;
    } else {
      real_name = str;
    }
  }

  if (real_name && strlen(real_name) > MAX_EMAIL_LEN) {
    write("Real name is too long, a maximum of " + MAX_EMAIL_LEN + " characters is allowed.\n");
    write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
    input_to("real_name");
    return 1;
  }

  if (real_name && real_name != "") {
    write("Ok real name set to "+real_name+".\n");
  } else {
    write("Real name cleared.\n");
  }
  TP->set_real_name(real_name);
  
  write("Enter your location (ie Perth, oz, whatever) ["+
        TP->query_where()+"]\n(none for none) : ");
  input_to("get_where");
  return 1;
} /* real_name() */

int get_where(string str) {
  string where;

  str = strip_colours(str);

  where = TP->query_where();
  
  if (str && str != "") {
    if (str == "none") {
      where = 0;
    } else {
      where = str;
    }
  }
  if (where && where != "") {
    write("Ok location set to "+where+".\n");
  } else {
    write("Location cleared.\n");
  }

  if (where && strlen(where) > MAX_EMAIL_LEN) {
     write("Your location is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
     write("Enter your location (ie Perth, oz, whatever) ["+
           TP->query_where()+"]\n(none for none) : ");
     input_to("get_where");
     return 1;
  }
  TP->set_where(where);

  if(TP->query_birthday() == "Unknown") {
    write("Enter your birthday (ddmm) ["+TP->query_birthday()+
          "] (none for none) : ");
    input_to("birthday");
  } else {
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
  }   
  return 1;
} /* get_where() */

string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  /* we assume it is 4 characters long */

  int day, month, tot;
  string retval;

  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
} /* convert_birthday() */

int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })

  int tot, month, day;

  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
} /* valid_birthday() */

void birthday(string str) {
  string birth_day;

  birth_day = TP->query_birthday();
  if (str == "") {
    if (birth_day)
      write("Birthday unchanged from "+birth_day+".\n");
    else
      write("Birthday left as blank.\n");
  } else {
    if(birth_day != "Unknown") {
      write("You can't change when you were born! Please ask a Creator or " 
        "a Lord to change it if you made an error.\n");
    } else if(!valid_birthday(str)) {
        write("Invalid Birthday.  Birthday cleared.\n");
        birth_day = 0;
    } else {
      birth_day = convert_birthday(str);
      write("Birthday set to " + birth_day + ".\n");
      TP->birthday_gifts();
    }
  }
  TP->set_birthday(birth_day);

  write("What email address do you wish to use.  Set to none to clear.\n");
  write("Putting a : in front of it means that only the creators and lords "
        "can read it.\n");
  write("["+TP->query_email()+"] : ");
  input_to("get_email");
} /* birthday() */

void get_email(string str) {
  string email;
  
  email = TP->query_email();
  
  str = strip_colours(str);

  if (str == "") {
    if (!email || email == "") {
      write("Email address left blank.\n");
    } else {
      write("Email address left as "+email+".\n");
    }
  } else if (str == "none") {
    email = 0;
    write("Email address cleared.\n");
  } else {
    email = str;
    write("Email address set to "+email+".\n");
  }


  if (email && strlen(email) > MAX_EMAIL_LEN) {
    write("Your email address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators and lords "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
    return ;
  }

  TP->set_email(email);

  write("Please enter your home page (World Wide Web page address), "
        "type 'none' to clear it.\n");
  if (!TP->query_homepage()) {
    write("[none] : ");
  } else {
    write("["+TP->query_homepage()+"] : ");
  }
  input_to("get_home_page");
} /* get_email() */

void get_home_page(string str) {

  str = strip_colours(str);

  if (str == "") {
    if (!TP->query_homepage()) {
      write("Home page left as blank.\n");
    } else {
      write("Home page left as "+TP->query_homepage()+"\n");
    }
  } else if (str == "none") {
    TP->set_homepage("");
    write("Home page cleared.\n");
  } else if (strlen(str) <= MAX_EMAIL_LEN) {
    TP->set_homepage(str);
    write("Home page set to "+str+"\n");
  } else {
    write("Your home page address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("Please enter your home page (World Wide Web page address), "
          "type 'none' to clear it.\n");
    if (!TP->query_homepage()) {
      write("[none] : ");
    } else {
      write("["+TP->query_homepage()+"] : ");
    }
    input_to("get_home_page");
    return ;
  }
  TP->save_me();
} /* get_home_page() */
// --- END [/mnt/home2/grok/lib/cmds/player/chfn.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/birthdays.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/birthdays.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627083   Available: 13574437
Inodes: Total: 5242880    Free: 4960132
632 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/birthdays.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627083   Available: 13574437
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: birthdays.c,v 1.3 2003/03/29 03:12:01 presto Exp $
 *
 *
 */

inherit "/cmds/base";

int cmd()  {
   object *peeps;

   peeps = filter(users(), (: $1->query_visible(this_player())  &&
                              $1->query_is_birthday_today() :));
   if (sizeof(peeps) == 0)
      return notify_fail("No one has a birthday today.\n");
   if (sizeof(peeps) == 1)
      printf("%s has a birthday today.\n", peeps[0]->short());
   else
      write(query_multiple_short(peeps) + " have a birthday today.\n"); 
   return 1;
}


mixed *query_patterns()  {
   return ({ "", (: cmd() :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/birthdays.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/verbose.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/verbose.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627083   Available: 13574437
Inodes: Total: 5242880    Free: 4960132
1551 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/verbose.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627083   Available: 13574437
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: verbose.c,v 1.4 2000/09/02 22:29:19 ceres Exp $
 * $Log: verbose.c,v $
 * Revision 1.4  2000/09/02 22:29:19  ceres
 * Added error message
 *
 * Revision 1.3  2000/04/27 01:20:26  pinkfish
 * Add some brackets in.
 *
 * Revision 1.2  1999/02/13 20:57:00  ceres
 * Newbie error = instead of ==
 *
 * Revision 1.1  1999/02/09 01:30:25  ceres
 * Initial revision
 *
 * Revision 1.4  1999/02/09 00:23:41  ceres
 * Increased the max email address length to 50.
 *
 * Revision 1.2  1999/02/03 00:52:50  pinkfish
 * Fix it up so you can only enter certain sized bits of data into the fields.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

int cmd(string which, string type) {
  string t, disp;

  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types()) {
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    }
    write(disp + "\n");
    return 1;
  }

  if(type == "all") {
    foreach(t in TP->query_verbose_types()) {
      TP->set_verbose(t, which == "verbose");
    }
    write("Ok\n");
    return 1;
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
    return 1;
  } else {
    write("No such option.\n");
    return 1;
  }
}


mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("verbose", $4[0]) :),
            "", (: cmd("verbose", 0) :),
         });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/verbose.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/money.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627082   Available: 13574436
Inodes: Total: 5242880    Free: 4960132
5935 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627082   Available: 13574436
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#include <money.h>

inherit "/cmds/base";

private mapping _money_types;

void create()
{
   string zone;
   string *zones;

   zones = MONEY_HAND->query_all_places();
   _money_types = allocate_mapping(sizeof(zones));
   foreach(zone in zones) {
      _money_types[lower_case(zone)] = zone;
   }
   ::create();
   return;
}                               /* create() */


int cmd(string str,
        int brief,
        object * containers)
{
   object *monies;
   object new_money;
   object *divided_money;
   object money;
   object tmp_money;
   object *inv;
// mixed *tmp_arr;
   mixed *total;
// object env;
   int success;
// string tmp;
// int i;
// int j;

   if (this_player()->
          check_dark(environment(this_player())->query_light()) < 0)
   {
      add_failed_mess("It's too dark to count your money.\n");
      return 0;
   }

   if (str) {
      if (str == "here") {
         if (environment(this_player())->query_bank_name())
            str = environment(this_player())->query_money_place();
         else
            str = environment(this_player())->query_property("place");
         if (!str) {
            add_failed_mess("No idea what type of currency is used here.\n");
            return 0;
         }
      }
      str = lower_case(str);
      if (!_money_types[str]) {
         add_failed_mess("This is not a valid type of money, try one of " +
            query_multiple_short(keys(_money_types) + ({ "here" })) + ".\n");
         return 0;
      }
   }

// if (!containers) {
//    inv = deep_inventory(this_player());
// } else {
//    inv = filter(containers,
//                 (: $1->query_closed()  &&  !$1->query_transparent() :));
//    if (sizeof(inv))  {
//       write(query_multiple_short(inv, "one") +
//             (sizeof(inv) > 1 ? " are " : " is ") + "closed.\n");
//       containers -= inv;
//    }
//    if (sizeof(containers))  {
//       inv = ({ });
//       foreach(env in containers) {
//          inv += deep_inventory(env);
//       }
//    }
//    else return 1;
// }
   inv = all_inventory(this_player());
   monies = filter_array(inv, (: this_object()->find_the_dough($1) :));
   total = ({ });
   if (sizeof(monies)) {
      success = 0;
      divided_money = ({ 0, 0 });
      foreach(money in monies) {
         tmp_money = 0;
         if (!str) {
            tmp_money = money;
         } else if (str && _money_types[str]) {
            new_money = MONEY_VAULT->get_money_ob();
            new_money->set_money_array(money->query_money_array());
            divided_money = MONEY_HAND->
               filter_legal_tender(new_money, _money_types[lower_case(str)]);
            tmp_money = divided_money[0];
            if (divided_money[1]) {
               divided_money[1]->dest_me();
            }
         }
         if (tmp_money) {
//          if (environment(money) == this_player()) {
               if (!brief) {
                  write("Your purse contains " +
                        query_multiple_short(tmp_money->half_short(1)) +
                        ".\n");
               }
               else  {
                  write("Your purse contains " +
                     query_multiple_short(tmp_money->half_symbol_short()) +
                     ".\n");
               }
//            }
//          else if (!brief) {
//             env = environment(money);
//             tmp = env->poss_short();
//             env = environment(env);
//             while (env != this_player()) {
//                tmp += " in " + env->poss_short();
//                env = environment(env);
//             }
//             write(tmp + " contains " +
//                   query_multiple_short(tmp_money->half_short(1)) + ".\n");
//          }
            success++;
//          tmp_arr = tmp_money->query_money_array();
//          for (i = 0; i < sizeof(tmp_arr); i += 2) {
//             j = member_array(tmp_arr[i], total);
//             if (j != -1) {
//                total[j + 1] += tmp_arr[i + 1];
//             } else {
//                total += tmp_arr[i..i + 1];
//             }
//          }
            if (divided_money[0]) {
               divided_money[0]->dest_me();
            }
         }
      }
      if (!success) {
         write("You have no money from the Land of " + capitalize(str) +
               ".\n");
      }
//    else if (success > 1 || brief) {
//       write("You have a total of " +
//             MONEY_HAND->money_string(total) + ".\n");
//    }
// } else if (!containers) {
//    write("You have no money that you can see.\n");
// } else {
//    if (!str) {
//       write("You find no money in " +
//             query_multiple_short(containers, "poss") + ".\n");
//    } else {
//       write("You find no money from " + _money_types[str] +
//             "in " + query_multiple_short(containers, "poss") + ".\n");
//    }
   }
   else write("You are flat broke.\n");
   return 1;

} /* cmd() */


int find_the_dough(object env)
{
   if (member_array(MONEY_ALIAS, env->query_alias()) > -1) {
      while ((env = environment(env)) != this_player()) {
         if (env->query_closed() && !env->query_transparent()) {
            return 0;
         }
      }
      return 1;
   } else
      return 0;

} /* find_the_dough() */


mixed *query_patterns()
{
   return ({ "", (: cmd(0, 0, 0) :),
             "brief", (: cmd(0, 1, 0) :),
             "<string'area name'>", (: cmd($4[0], 0, 0) :),
             "<string'area name'> brief", (: cmd($4[0], 1, 0) :),
//             "<string'area name'> in <indirect:object:me'container'>",
//             (: cmd($4[0], 0, $1) :),
//             "<string'area name'> in <indirect:object:me'container'> brief",
//             (: cmd($4[0], 1, $1) :),
//             "in <indirect:object:me'container'>", (: cmd(0, 0, $1) :),
//             "in <indirect:object:me'container'> brief",
//             (: cmd(0, 1, $1) :
          });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/money.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/spells.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/spells.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627081   Available: 13574435
Inodes: Total: 5242880    Free: 4960132
1824 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/spells.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627081   Available: 13574435
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: spells.c,v 1.3 2001/11/08 07:05:25 pinkfish Exp $
 * $Log: spells.c,v $
 * Revision 1.3  2001/11/08 07:05:25  pinkfish
 * Spells!
 *
 * Revision 1.2  1998/04/14 02:33:32  pinkfish
 * Changed to use add_command and the defines from spells.h.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <spells.h>

inherit "/cmds/base";

int cmd() {
   string spell, *magic;
   mapping spells;

   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   magic = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( !stringp( spells[ spell ][ S_OBJECT ] ) ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*spriest%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*srituals%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*swizard%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*switch%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*sspell%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
   }
   if ( !sizeof( magic ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   if ( sizeof( magic ) ) {
      write( "You know the following magic spell"+
            ( sizeof( magic ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( magic, 1 ), "\n" ) );
   }
   return 1;
} /* cmds() */

mixed *query_patterns() {
   return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/spells.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/rpskills.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/rpskills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627080   Available: 13574434
Inodes: Total: 5242880    Free: 4960132
4680 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/rpskills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627080   Available: 13574434
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rpskills.c,v 1.1 2003/07/15 08:01:01 pinkfish Exp $
 * $Log: rpskills.c,v $
 * Revision 1.1  2003/07/15 08:01:01  pinkfish
 * Initial revision
 *
 * Revision 1.5  2000/11/21 02:39:55  ceres
 * Added syntax
 *
 * Revision 1.4  1998/08/19 10:19:00  pinkfish
 * Add in stuff to put in the command name.
 *
 * Revision 1.3  1998/02/25 19:33:25  gototh
 * Little fix on previous query_stupid_skills().
 *
 * Revision 1.1  1998/01/06 05:27:04  ceres
 * Initial revision
 * 
*/
#include <skills.h>

inherit "/cmds/base"; 

string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }

    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}


string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus;
   string str, tp, tmp;

   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      /* Get the level of the skill at this point */
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      /* Is this part of the tree only a leaf heirachy? */
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      /*
       * If it is not a leaf heirachy, we show the levels and bonuses.
       * Or, if it is a leaf the show the bonuses is the level is
       *    above 0 and the we are not force showing all.
       */
      if (!(only_leaf || o_l) ||
              (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero))))
        str += sprintf( "%*'| 's%*'.'-s " + (no_bonus?"\n":"%4s\n"),
              ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], 
              bonus_to_string( (int)this_player()->query_skill_bonus( tp ) ) );
      /* It is a leaf heirachy!  No bonuses, no level if this is not a leaf. */
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all 
                                                || ( sk > 5 * lvl ) ) ) {
         /* Generate the lower bits... */
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         /* Only put ourselves in if the list thingy generated something */
         /* Don't generate the list if it is the language heirachy... */
         if ((only_leaf || o_l) && (tmp != ""))
// || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
} /* rec_list() */

int cmd( string word ) {
   int i;
   string result, *bits;
   mixed *args;
   result = "";

   if ( !"/obj/handlers/playtesters"->query_tester( this_player() ) )
       return 0;


   // This is used to give ratty skills etc. during reincarnation.
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }
   
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Proficiency" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Proficiency");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/rpskills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/unignore.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/unignore.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627079   Available: 13574433
Inodes: Total: 5242880    Free: 4960132
1034 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/unignore.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627079   Available: 13574433
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unignore.c,v 1.2 2002/09/21 05:21:40 presto Exp $
 * $Log: unignore.c,v $
 * Revision 1.2  2002/09/21 05:21:40  presto
 * Made case-insensitive
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <drinks.h>
#include <language.h>
#include <player.h>

#define TP this_player()

inherit "/cmds/base";

int cmd(string str) {
  string *ignoring;
  
  ignoring = TP->query_property("ignoring");
  if(!ignoring)
    ignoring = ({ });

  if(!str)
    return notify_fail("unignore who?\n");

  str = lower_case(TP->expand_nickname(str));

  if(str == "all") {
    TP->remove_property("ignoring");
    write("You are no longer ignoring anyone.\n");
    return 1;
  }
  
  if(member_array(str, ignoring) == -1) {
    write("You are not ignoring "+str+".\n");
    return 1;
  }

  ignoring = delete(ignoring, member_array(str, ignoring), 1);
  TP->add_property("ignoring", ignoring);
  write(str+" has been removed from your list of ignored players.\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/player/unignore.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/groups.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/groups.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627078   Available: 13574432
Inodes: Total: 5242880    Free: 4960132
884 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/groups.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627078   Available: 13574432
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: groups.c,v 1.4 2001/02/01 17:30:43 pinkfish Exp $
 *
 * $Log: groups.c,v $
 * Revision 1.4  2001/02/01 17:30:43  pinkfish
 * Fix up some bugs.
 *
 * Revision 1.3  1999/06/21 09:15:11  tape
 * Made it patch directly into "group list".
 *
 * Revision 1.2  1999/06/20 09:34:54  taffyd
 * Temporarily patched for new groups system.
 *
 * Revision 1.1  1998/07/13 03:42:54  pinkfish
 * Initial revision
 *
*/

#include <group_handler.h>

inherit "/cmds/base";

mixed cmd(string str, string pattern) {
   return GROUP_CMD->group_command_control( "list", "", "", "",
                                            ({ str }), pattern );
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd("", "list") :),
             "[with] <string'player'>",
             (: cmd($4[0], "list [with] <string'player'>") :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/groups.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627078   Available: 13574432
Inodes: Total: 5242880    Free: 4960132
2132 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627078   Available: 13574432
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: finger.c,v 1.12 2001/04/05 03:57:58 ceres Exp $
 */
/* finger command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <clubs.h>

mixed cmd() {
  string ret;
  object ob, *obs;
  string type;
  string str;

    obs = users();
    obs = sort_array(obs, (: strcmp($1->query_cap_name(), 
    $2->query_cap_name()) :));
    str = sprintf("%-12.12s    %-20.20s %-20.20s %-20.20s\n",
                  "Name", "Real name", "Where", "Birthday");
    foreach (ob in obs) {
      string euid;
      type = (ob->query_earmuffs() ? "e" : " ");
      euid = geteuid(ob);
      type += ob->query_object_type();
      /*
       * above changed to use query_object_type by ember 16-feb-93 ... does
       * query_object_type get the 'X' as well?
       */
      str += sprintf("%-12.12s %2.2s %-20.20s %-20.20s %-20.20s\n",
      (ob->query_invis()?"("+ob->query_cap_name()+")":(string)ob->query_cap_name()),
                    type,
                    ((ret = (string)ob->query_real_name())?ret:"-"),
                    ((ret = (string)ob->query_where())?ret:"-"),
                    ((ret = (string)ob->query_birthday())?ret:"-"));
    }
    write("$P$Finger$P$" + str);
    return 1;
} /* cmd() */

int finger_player(string str) {
  string ret;
  string mud;

  if (str) {
    str = lower_case(str);
    str = (string)this_player()->expand_nickname(str);
  }
  ret = (string)"/secure/finger"->finger_info(str);
  if (ret) {
    write("$P$finger: " + str + "$P$" + ret);
    return 1;
  } else if (this_player()->query_creator() &&
             sscanf(str, "%s@%s", mud, mud) == 2) {
    "/net/daemon/out_finger"->do_finger(str);
/* Commented out by Turrican, since the daemon gives a message already.
    write("Intermud finger on its way.\n");
*/
    return 1;
  } else {
    add_failed_mess("No one going by the name of " + str + " has ever visited " 
      "" + mud_name() + ".\n");
    return 0;
  }
}

mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "<string'name|domain|club'>", (: finger_player($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/unidentify.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/unidentify.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627077   Available: 13574431
Inodes: Total: 5242880    Free: 4960132
831 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/unidentify.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627077   Available: 13574431
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unidentify.c,v 1.1 2001/09/26 01:45:09 presto Exp $
 *
 *
 */

#define EFFECT "/std/effects/object/identity_hold"

inherit "/cmds/base";

mixed cmd(object *indirect_obs)
{
   object *things;

   things = filter(indirect_obs, (: $1->query_identifier() :));
   if (!sizeof(things))  {
      if (sizeof(indirect_obs) > 1)
         write("You do not have any of those things identified.\n");
      else
         write("You do not have " + indirect_obs[0]->the_short() +
               " identified.\n");
   }
   else  {
      things->set_identifier(0);
      write("You stop identifying " + query_multiple_short(things, "one") +
            ".\n");
   }

   return 1;
}


mixed *query_patterns() {
   return ({ "<indirect:object:me'object(s)'>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/unidentify.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/refer.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/refer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627077   Available: 13574431
Inodes: Total: 5242880    Free: 4960132
733 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/refer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627077   Available: 13574431
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: refer.c,v 1.5 2002/08/05 18:12:14 presto Exp $
 * 
*/
#include <login.h>
#include <clubs.h>

inherit "/cmds/base";

int cmd(string str) {
   string ret;

   str = lower_case(str);
   str = (string)this_player()->expand_nickname(str);
   ret = (string)"/secure/finger"->refer_info(str);
   if (ret) {
      this_player()->more_string( this_player()->fit_message(ret),
                                  "refer: "+str );
      return 1;
   }
   add_failed_mess("No one by the name of " + str + " has "
                   "ever visited " + mud_name() + ".\n");
   return 0;
} /* cmd() */

mixed *query_patterns() {
   return ({"<string'name'>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/refer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/count.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/count.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627076   Available: 13574430
Inodes: Total: 5242880    Free: 4960132
6867 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/count.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627076   Available: 13574430
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <money.h>

inherit "/cmds/base";

#define MAX_COUNT_SIZE 50

int is_not_in_other_player(object thing);

int cmd(object *things, int brief)  {
   string  list;
   string *aliases;
   string  message;
   mixed  *stuff;
   object  thing;
   object  money;
   object  sack;
   object *continuous, *collective;
   object *room_items;
   object *tmp;
   object tmp_ob;
   int     i;
   int     total;

   if (this_player()->
       check_dark(environment(this_player())->query_light()) < 0) {
      add_failed_mess("It's too dark to count anything.\n");
      return 0;
   }
   if(sizeof(things) > MAX_COUNT_SIZE)
     return add_failed_mess("You cannot count that many things!\n");

   things = filter(things, (: !is_not_in_other_player($1) :));
   if (!sizeof(things))  {
      write("You can't count things carried by other people.\n");
      return 1;
   }

   money = 0;
   total = 0;
   list = "";

   foreach (thing in things)  {
      aliases = thing->query_alias();
      if (aliases  &&  member_array(MONEY_ALIAS, aliases) > -1)  {
         if (!money) {
            money = clone_object(MONEY_OBJECT);
         }
         money->adjust_money(thing->query_money_array());
         things -= ({ thing });
      }
   }
   if (money)  {
      total += money->query_number_coins();
      if (sizeof(things))  {
         list = implode(money->half_short(1), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list = query_multiple_short(money->half_short(1));
      }
      money->dest_me();
   }

   continuous = filter(things, (: $1->query_continuous() :));
   if (sizeof(continuous))  {
      sack = clone_object("/std/container");
      foreach (thing in continuous) {
         thing->make_medium_clone(thing->query_amount())->move(sack);
      }
      things -= continuous;
      continuous = all_inventory(sack);
      foreach (thing in continuous)  {
         total += thing->query_how_many();
      }
      if (sizeof(things))  {
         list += implode(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list += query_multiple_short(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)));
      }
      sack->dest_me();
   }
   collective = filter(things, (: $1->query_collective() :));
   if (sizeof(collective))  {
     sack = clone_object("/std/container");
     foreach (thing in collective) {
       if (thing) {
          tmp_ob = thing->make_medium_clone(thing->query_amount());
          if (tmp_ob) {
             tmp_ob->move(sack);
          }
       }
     }
     things -= collective;
     collective = all_inventory(sack);
     foreach (thing in collective) {
       total += thing->query_amount();
     }
      
     if(sizeof(things)) {
       list += implode(map(collective,
                           (: $1->query_amount() + " " +
                            ($1->query_amount() == 1 ? $1->short() :
                             $1->query_plural()) :)),
                       ", ");
       if (sizeof(things) == 1) {
         list += " and ";
       } else {
         list += ", ";
       }
     } else {
       list += query_multiple_short(map(collective,
                                        (: $1->query_amount() + " " +
                                         ($1->query_amount() == 1 ?
                                          $1->short() :
                                          $1->query_plural()) :)));
     }
     sack->dest_me();
   }

   room_items = filter(things, (: strsrch(file_name($1),
                                          "/std/room/basic/item") > -1 :));
   if (sizeof(room_items))  {
      things -= room_items;
      tmp = filter(room_items, (: $1->query_count() :));
      room_items -= tmp;
      if (sizeof(things))  {
         if (sizeof(tmp)) {
            list += implode(map(tmp, (: query_num($1->query_count()) +
                    " " + ($1->query_count() > 1 ? $1->pretty_plural()
                                                 : $1->pretty_short()) :)),
                    ", ");
            foreach (thing in tmp)  {
               total += thing->query_count();
            }
         }
         if (sizeof(room_items)) {
            list += implode(map(room_items, (: "at least one " +
                                               $1->pretty_short() :)), ", ");
            total += sizeof(room_items);
         }
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else  {
         if (sizeof(tmp)) {
            list += query_multiple_short(map(tmp,
                    (: query_num($1->query_count()) + " " +
                    ($1->query_count() > 1 ? $1->pretty_plural()
                                           : $1->pretty_short()) :)), ", ");
            total += sizeof(tmp);
         }
         if (sizeof(room_items)) {
            list += query_multiple_short(map(room_items,
                    (: "at least one " + $1->pretty_short() :)));
            total += sizeof(room_items);
         }
      }
   }
   if (sizeof(things))  {
      list += query_multiple_short(things, "one");

if (this_player() == find_player("presto"))
tell_creator("presto", "list == %s\n", list);
      stuff = this_player()->reform_message(list, ({}));
if (this_player() == find_player("presto"))
printf("test message: %O\n", this_player()->evaluate_message(stuff));
      message = stuff[0];
      for (i = 0; i < sizeof(stuff[1]); i++)  {
         message = replace_string(message, "$" + i + "$",
            this_player()->calc_shorts(stuff[1][i], 1));
      }
      total += sizeof(things);
   } else {
      message = list;
   }

   if (brief) {
      write("You count " + total + " items.\n");
   } else {
      write("You count " + message + " with a total of " +
            query_num(total) + (total > 1 ? " items.\n" : " item.\n"));
   }
   return 1;
}

int is_not_in_other_player(object env)  {
   while ((env = environment(env))  &&  !living(env))
      ;

   if (env  &&  env != this_player())
      return 1;
   else
      return 0;
}


mixed *query_patterns()  {
   return ({ "<indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 0) :),
             "<indirect:object:me'things'> in inventory", (: cmd($1, 0) :),
             "<indirect:object:here'things'> in room", (: cmd($1, 0) :),
             "brief <indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 1) :),
             "brief <indirect:object:me'things'> in inventory", (: cmd($1, 1) :),
             "brief <indirect:object:here'things'> in room", (: cmd($1, 1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/count.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/su.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/su.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627074   Available: 13574428
Inodes: Total: 5242880    Free: 4960132
1460 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/su.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627074   Available: 13574428
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: su.c,v 1.7 2003/01/24 02:00:47 ceres Exp $
 * 
*/
inherit "/cmds/base";

#include <login_handler.h>;
#define TEAM_HANDLER "/obj/handlers/team"

#define TP this_player()

mixed cmd(string str) {
  string from;
  
  if (!str || str == "")
    return notify_fail("Usage: su <name>\n");
  if ( TP->query_auto_loading() ) {
    printf("You cannot quit yet: your inventory is still being generated.\n" );
    return 1;
  }

  if ( find_object( "/obj/shut" )) {
    write("You cannot su during a reboot.\n");
    return 1;
  }
  
  if(sizeof(TP->query_attacker_list())) {
    write("You cannot quit while in combat.\n");
    return 1;
  }

  if (TEAM_HANDLER->query_group(this_player()))  {
    "/cmds/player/leaveg_roup"->cmd(0);
//    catch(command("leavegroup"));  This doesn't work.  "command" assumes this_object() is the issuer
  }

  if (environment(this_player()) == find_object("/room/departures"))  {
    write("You can't use su in the departure lounge.\n");
    return 1;
  }

  from = TP->query_name();
  clone_object("/secure/login")->do_su(str);

  seteuid( "Root" );
  if(str == from)
    LOGIN_HANDLER->write_log("Su", TP->query_name(),
                             TP->query_property("guest"), "(to self)");
  else
    LOGIN_HANDLER->write_log("Su", from, TP->query_property("guest"), str);
  return 1;
} /* do_su() */

mixed* query_patterns() {
   return ({ "<string'new name'>", (: cmd($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/player/su.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/describe.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/describe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627074   Available: 13574428
Inodes: Total: 5242880    Free: 4960132
4945 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/describe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627074   Available: 13574428
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: describe.c,v 1.10 2003/07/16 18:26:24 pinkfish Exp $
 * $Log: describe.c,v $
 * Revision 1.10  2003/07/16 18:26:24  pinkfish
 * Fix up the message.
 *
 * Revision 1.9  2003/07/16 18:19:52  pinkfish
 * Fix up some describe things.
 *
 * Revision 1.8  2003/03/03 05:35:09  pinkfish
 * Fix up the sentances.
 *
 * Revision 1.7  2003/03/02 20:15:59  pinkfish
 * Make it so you have to put in 'main' to set the main description.
 *
 * Revision 1.6  2003/03/01 21:17:32  pinkfish
 * Fix up the spelling of sentence.
 *
 * Revision 1.5  2003/02/21 02:21:16  pinkfish
 * Allow people to set zone based descriptions.
 *
 * Revision 1.4  2003/02/19 08:43:05  ceres
 * Fixed runtime caused by colour codes
 *
 * Revision 1.3  2000/10/30 02:13:50  presto
 * Added some code to prevent the command object from being destructed
 * while someone is still editing their description.
 *
 * Revision 1.2  2000/05/31 01:27:41  presto
 * Added a query_patterns function so that 'syntax describe' works.  Took out
 * the "Usage" notify_fails
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
#include <player.h>
#include <clothing.h>
inherit "/cmds/base";

#define TP this_player()

int use_count = 0;

private string _zone_str;

void create() {
   string zone;

   _zone_str = "face|hair";
   foreach (zone in keys(CLOTHING_HANDLER->query_all_clothing_zones())) {
      _zone_str += "|" + zone;
   }
}

int cmd(string str) {
   string desc;
   string zone;

   desc = TP->query_desc();
   if (!str) {
      if (desc) {
         write("Description reads:\n" + TP->query_cap_name() + " " +
               desc + "\n");
      } else {
         write("No description set.\n");
      }
      if (sizeof(TP->query_zone_desc_names())) {
         foreach (zone in TP->query_zone_desc_names()) {
            write("$I$5=$C$" + zone + ": " + TP->query_zone_desc(zone) + "\n");
         }
         if (!desc) {
            write("%^YELLOW%^Warning! Your zone descriptions will not be "
                  "displayed unless you also have a main description.%^RESET%^\n");
         } else {
            write("Each zone description is a sentence, or multiple "
                  "sentences.  If you do not do this then the descriptions "
                  "will look wrong.\n");
         }
      } else {
         write("No zone descriptions setup.\n");
      }
      return 1;
   }
   else if (str == "clear") {
      write("Description cleared.\n");
      TP->set_desc(0);
      return 1;
   }
   else if (str == "edit") {
      /*
       * The cap name is stuck on so they can see what their desc will look
       * like.
       */
     if (desc) {
         this_player()->do_edit(sprintf("%-=*s", this_player()->query_cols(),
                                        this_player()->query_cap_name() + " " +
                                        replace(strip_colours(desc), "\n",
                                                "\n\n") + "\n"),
                                "finish_desc_edit");
     } else
       this_player()->do_edit("", "finish_desc_edit");
     ++use_count;
     return 1;
   }
   else if (strlen(str) > MAX_DESC) {
      notify_fail("Description unchanged.  Given description was too long.  "
                  "Maximum allowed length is " + MAX_DESC+ ".\n");
      return 0;
   }
   TP->set_desc(strip_colours(str));
   write("Description set.\n");
   return 1;
}

void finish_desc_edit(string str) {
   string cname;
   
   --use_count;
   if (!str) {
      write("Description unchanged.\n");
     return;
   }
   /* Save them some trouble if they started off with their name... */
   cname = this_player()->query_cap_name();
   if (str[0 .. strlen(cname)] == cname + " ")
      str = str[strlen(cname) + 1 .. 10000];
   str = strip_colours(str);
   str = replace(str, ({ "\n\n", "$NEW_LINE$", "\n", " " }));
   str = replace(str, "$NEW_LINE$", "\n");
   if (strlen(str) > MAX_DESC) {
      write("Description unchanged.  Given description was too long.  "
            "Maximum allowed length is " + MAX_DESC+ ".\n");
      return;
   }
   TP->set_desc(str);
   write("Description set.\n");
   return;
}

int cmd_zone(string zone, string desc) {
   this_player()->set_zone_desc(zone, desc);
   write("Set the description for the zone " + zone + " as \"" + desc + "\".\n");
   return 1;
}

int cmd_zone_clear(string zone) {
   this_player()->set_zone_desc(zone, 0);
   write("Cleared the description for the zone " + zone + ".\n");
   return 1;
}

mixed *query_patterns()  {
   return ({ "", (: cmd(0) :),
             "main <string'description'>", (: cmd($4[0]) :),
             "edit", (: cmd("edit") :),
             "clear", (: cmd("clear") :),
             "zone {" + _zone_str + "} <string'description'>",
                  (: cmd_zone($4[0], $4[1]) :),
             "zone {" + _zone_str + "} clear", 
                  (: cmd_zone_clear($4[0]) :),
               });
}

// --- END [/mnt/home2/grok/lib/cmds/player/describe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/create.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/create.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627072   Available: 13574426
Inodes: Total: 5242880    Free: 4960132
1868 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/create.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627072   Available: 13574426
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>
#include <player_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_create( string name );

void create() {
   ::create();
   add_group_sub_command( "create", "<string'name'>", (: do_create( $4[ 0 ] ) :) );
} /* create() */


int do_create( string name ) {
   
   string short;

   // Remove any colour codes.
   name = strip_colours(name);

   if( this_player()->query_group() ) {
      return notify_fail( "You are already a member of " +
         this_player()->query_group() + ".\n" );
   }
   
   if( GROUP->is_group( name ) ) {
      return notify_fail( "Such a group already exists.\n" );
   }

   short = name;
   name = GROUP->short_to_name( short );
   
   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }
   
   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }

   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   
   if( !GROUP->create_group( name, this_player() ) ) {
      return notify_fail( "You failed to create the group.\n" );
   }
   
   GROUP->set_group_short( name, short );
   
   this_player()->add_succeeded_mess( this_object(), "$N begin$s "
      "an adventuring group.\n" );
         
   GROUP->add_member( name, this_player() );
   GROUP->set_leader( name, this_player() );

   return 1;
   
} /* do_create() */

string query_help_string_for( string sub_command ) {
   if( sub_command != "create" ) {
      return 0;
   }
   return "This sub-command creates a new group and sets you as the "
      "leader of it.  You create it by typing \"group create <name>\" "
      "with <name> being the name of your group.";
} /* query_help_string() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/create.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/history.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/history.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627072   Available: 13574426
Inodes: Total: 5242880    Free: 4960132
551 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/history.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627072   Available: 13574426
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_channel_history();

void create() {
   ::create();
   add_group_sub_command( "history", "", (: do_channel_history() :) );
   set_membership_required( "history", 0, 1 );
} /* create() */


int do_channel_history() {

   this_player()->display_group_history();

   return 1;

} /* do_channel_history() */


string query_help_string_for( string sub ) {
   return "This command lets you recap what has been said on your "
      "group's channel.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/history.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/kick.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/kick.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627071   Available: 13574425
Inodes: Total: 5242880    Free: 4960132
1208 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/kick.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627071   Available: 13574425
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_kick_member( object member, string group );

void create() {
   ::create();
   add_group_sub_command( "kick", "<indirect:any-living'member'>",
      (: do_kick_member( $1[ 0 ], $6 ) :) );
   set_membership_required( "kick", 0, 1 );
   set_leadership_required( "kick", 0, 1 );
} /* create() */


int do_kick_member( object member, string group ) {

   if( this_player() == member ) {
      this_player()->new_parser(
         "skick " + this_player()->query_name() );
      return 1;
   }
      
   if( !GROUP->is_member( group, member ) ) {
      return notify_fail( member->the_short() + " is not a member "
         "of your group.\n" );
   }
   
   GROUP->notify_group( group, this_player(), ({
      "You kick " + member->query_cap_name() + " from your ranks.",
      this_player()->query_cap_name() + " has kicked " +
      member->the_short() + " from the group." }) );
      
   GROUP->remove_member( group, member );
   
   return 1;

} /* do_kick_member() */


string query_help_string_for( string sub ) {
   return "This command lets you boot out offending members in "
      "your group.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/kick.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/leave.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/leave.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627071   Available: 13574425
Inodes: Total: 5242880    Free: 4960132
769 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/leave.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627071   Available: 13574425
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_leave( string group );

void create() {
   ::create();
   add_group_sub_command( "leave", "", (: do_leave( $6 ) :) );
   set_membership_required( "leave", 0, 1 );
} /* create() */


int do_leave( string group ) {
   
   if( !GROUP->remove_member( this_player()->query_group(),
      this_player() ) ) {
      return notify_fail( "You failed to leave the group "
         "for some odd-ball reason.\n" );
   }
   
   return 1;
} /* do_leave() */


string query_help_string_for( string sub ) {
   return "This command allows you to leave your current "
      "group.  If you're the leader, a new one will be "
      "chosen at random from the remaining members.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/leave.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/rename.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/rename.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627071   Available: 13574425
Inodes: Total: 5242880    Free: 4960132
1416 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/rename.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627071   Available: 13574425
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>
#include <player_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_rename_group( object member, string group );

void create() {
   ::create();
   add_group_sub_command( "rename", "<string'new name'>",
      (: do_rename_group( $4[ 0 ], $6 ) :) );
   set_membership_required( "rename", 0, 1 );
   set_leadership_required( "rename", 0, 1 );
} /* create() */


int do_rename_group( string new_group, string group ) {
   string short;
   string name;

   if( GROUP->is_group( new_group ) ) {
      return notify_fail( new_group + " already exists.\n");
   }

   short = new_group;
   name = GROUP->short_to_name( short );

   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }

   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }

   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   
   if (!GROUP->rename_group( group, name)) {
      add_failed_mess("Not allowed to rename the group.\n");
      return 0;
   }
   
   return 1;

} /* do_kick_member() */


string query_help_string_for( string sub ) {
   return "This command lets you rename a group to something more "
          "exciting.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/rename.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/leader.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/leader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627070   Available: 13574424
Inodes: Total: 5242880    Free: 4960132
1063 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/leader.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627070   Available: 13574424
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_leader( object member, string group );

void create() {
   ::create();
   add_group_sub_command( "leader", "<indirect:any-living'member'>",
      (: do_leader( $1[ 0 ], $6 ) :) );
   set_membership_required( "leader", 0, 1 );
   set_leadership_required( "leader", 0, 1 );
} /* create() */


int do_leader( object member, string group ) {

   if( member == this_player() ) {
      return notify_fail( "Oh, good thinking, sparky.\n" );
   }
   
   if( member->query_group() != group ) {
      return notify_fail( member->the_short(1) + " is not in your "
         "group.\n" );
   }
   
   GROUP->set_leader( group, member, this_player() );
   
   return 1;

} /* do_leader() */


string query_help_string_for( string sub ) {
   return "This command allows you to relinquish command and "
      "appoint a new leader for the group.  It does not remove "
      "your membership of the group, but you lose all special "
      "privileges granted to leaders.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/leader.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/list.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/list.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627070   Available: 13574424
Inodes: Total: 5242880    Free: 4960132
4077 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/list.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627070   Available: 13574424
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

string *leader_adjectives =
   ({
      "daring",
      "heroic",
      "brave",
      "bold",
      "courageous",
      "dauntless",
      "fearless",
      "intrepid",
      "valiant",
      "awesome",
      "stalwart"
   });

string *follower_messages =
   ({
      " and also includes",
      " and features such prominent figures as",
      ", whose supporters consist of",
      " and features such renowned names as",
   });


int do_list_groups(string person);

void create() {
   ::create();
   add_group_sub_command( "list", "", (: do_list_groups(0) :) );
   add_group_sub_command( "list", "[with] <string'player'>",
                           (: do_list_groups($4[0]) :) );
} /* create() */


int do_list_groups(string person) {

   string group, *groups, prefix, suffix, message, adjective, colour, stats;
   object *members, leader;
   int num_groups, num_members;
   object person_ob;
   
   groups = sort_array( GROUP->query_groups(), 
       (: strcmp( lower_case(GROUP->query_group_short( $1 )), 
            lower_case(GROUP->query_group_short( $2 )) ) :) );

   num_groups = sizeof( groups );

   if (person) {
      person = this_player()->expand_nickname(person);
      person_ob = find_player(person);
      if (!person_ob) {
         add_failed_mess("Sorry, " + person + " is not logged on.\n");
         return 0;
      }
   }
   
   if( !num_groups )
   {
      return notify_fail( "There are currently no active groups.\n" );
   }
         
   prefix = "$I$+8,+0=  + ";
   suffix = "$I$-8,-0=\n";
   
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );

   message = "";
   num_members = 0;
   num_groups = 0;
   
   foreach( group in groups )
   {
      leader = GROUP->leader_of( group );
      members = GROUP->members_of( group );
      
      if( !leader || !sizeof( members ) )
      {
         continue;
      }
      

      if (!person_ob || person_ob == leader ||
          member_array(person_ob, members) != -1) {

         num_members += sizeof( members );
         message += prefix;
      
         message += colour + GROUP->query_group_short( group ) +
            "%^RESET%^ is led by ";
      
         members -= ({ leader });
      
         adjective = leader_adjectives[ random( sizeof(
                                                       leader_adjectives ) ) ];
      
         message += "the " + adjective + " %^BOLD%^" +
            leader->query_short(1) + "%^RESET%^";
      
               
         if( sizeof( members ) )
         {
//            message += follower_messages[ random( sizeof( follower_messages )
//               ) ] + " %^BOLD%^" + query_multiple_short( members, "the", 1, 1, 1 ) +
//               "%^RESET%^.";
            message += follower_messages[ random( sizeof( follower_messages )
               ) ] + " %^BOLD%^" + query_multiple_short( members->short(1) ) +
               "%^RESET%^.";

         }
         else
         {
            message += " and has no other members.";
         }

         message += suffix;
         num_groups++;
      }
   }

   switch( num_groups )
   {
      case 0:
         if (!person) {
            stats = "There are currently no groups, ";
         } else {
            add_failed_mess("There are no groups with " + person +
                            " in them.\n");
            return 0;
         }
         break;
      case 1:
         stats = "There is currently %^BOLD%^one%^RESET%^ active group, ";
         break;
      default:
         stats = "There are currently %^BOLD%^" + query_num( num_groups ) +
            "%^RESET%^ active groups, ";
         break;
   }
   
   stats += "with a total number of %^BOLD%^" +
      query_num( num_members ) + "%^RESET%^ persons:\n";

   tell_object( this_player(), stats + message );
   
   return 1;

} /* do_list_groups() */


string query_help_string_for( string sub ) {
   return "This command lets you list all currently active "
      "groups and their members and leaders.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/list.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/shields.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/shields.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627068   Available: 13574422
Inodes: Total: 5242880    Free: 4960132
2311 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/shields.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627068   Available: 13574422
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <command.h>
#include <group_handler.h>

#define CMD_SHIELDS ( DIR_PLAYER_CMDS "/shields" )

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_shields( object *members, string group );

void create()
{
   ::create();
   add_group_sub_command( "shields", "", (: do_shields( 0, $6 ) :) );
   add_group_sub_command( "shields", "<indirect:any-living'member'>",
      (: do_shields( $1, $6 ) :) );
   set_membership_required( "shields", 0, 1 );
} /* create() */


int do_shields( object *suggested_members, string group )
{
   object cmd_shields, member, *members, *check_for;
   string shields, mess, colour;

   cmd_shields = load_object( CMD_SHIELDS );
   
   if( !cmd_shields )
   {
      return notify_fail( "Cannot find the \"shield\" command.  "
         "Please bug report this group command.\n" );
   }
   
   check_for = members = GROUP->members_of( group );
   
   if( sizeof( suggested_members ) )
   {
      check_for = ( suggested_members & members );
   }
   
   if( !sizeof( check_for ) )
   {
      return notify_fail( "$C$" + query_multiple_short( suggested_members ) +
         ( sizeof( suggested_members ) > 1 ? " are not members " : " is not "
         "a member " ) + "of your group.\n" );
   }
   
   mess = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   
   foreach( member in check_for )
   {
		 if(!member)
			 continue;
		 
		 shields = cmd_shields->construct_shield_message( member, 1 );
		 
		 if( sizeof( shields ) ) {
         mess += "Arcane protection for " + colour +
					 member->query_cap_name() + "%^RESET%^:-\n";
         mess += shields + "\n";
		 } else {
			 mess += colour + member->query_cap_name() +
				 "%^RESET%^ has no arcane protection.\n\n";
		 }
   }
   
   if( sizeof( mess ) > 2 && mess[ sizeof( mess ) - 1 ] == '\n' )
   {
      mess = mess[ 0..( sizeof( mess ) - 2 ) ];
   }
   
   tell_object( this_player(), mess );
   
   return 1;
   
} /* do_shields() */


string query_help_string_for( string what )
{
   return "The \"group shields\" command allows you to view "
      "the arcane protection of all or some of your group's "
      "members.  You can either specify no arguments, or "
      "you can include the names of only those members "
      "whose protection you wish to check.\n";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/shields.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/assist.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/assist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627068   Available: 13574422
Inodes: Total: 5242880    Free: 4960132
2986 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/assist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627068   Available: 13574422
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_assist( object member, string group );
int do_unassist( object member, string group );
int do_assist_list(string group);

void create() {

   ::create();

   add_group_sub_command( "assist", "<indirect:living'member'>",
      (: do_assist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "unassist", "<indirect:distant-living'member'>",
      (: do_unassist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "assist", "list",
      (: do_assist_list( $6 ) :) );

   set_membership_required( "assist", 0, 1 );

} /* create() */


int do_assist_list( string group ) {
   object *assisting;
   
   assisting = this_player()->query_assisting();

   if( sizeof( assisting ) )
   {
      tell_object( this_player(), "You are currently "
         "assisting " + query_multiple_short( assisting ) +
         ".\n" );
      return 1;
   }
   add_failed_mess("You are not assisting anyone.\n");
   return 0;
} /* do_assist_list() */

int do_assist( object member, string group ) {
   object *assisting;
   
   assisting = this_player()->query_assisting();

   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   
   if( !GROUP->is_member( group, member ) ) {
      add_failed_mess( member->the_short() + " is not a "
         "member of your group.\n" );
      return 0;
   }
   
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      add_failed_mess( "You are already assisting " + member->the_short() +
         ".\n" );
      return 0;
   }
   
   if( sizeof( assisting ) >= MAX_PEOPLE_YOU_CAN_ASSIST ) {
      add_failed_mess( "You can not assist any more people.\n" );
      return 0;
   }

   add_succeeded_mess( "$N begin$s keeping a close eye on $I.\n",
                       ({ member }) );
   
   member->add_assister( this_player() );
   
   return 1;
   
} /* do_assist() */

int do_unassist( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      member->remove_assister( this_player() );
      add_succeeded_mess( ({ "You stop assisting " + member->the_short() +
         ".\n", "" }) );
      return 1;
   }

   add_failed_mess("You are not assisting $I.\n", ({ member }));
   
   return 0;
} /* do_unassist() */


string query_help_string_for( string sub ) {
   return "With this command you can guard a group member.  If the "
      "person you're guarding gets attacked, you will automatically "
      "join the fight after a delay.  The length of the delay depends "
      "on how many people you're guarding at the moment.  Use "
      "\"list\" to see who you are currently assisting.  To stop "
      "assisting someone, use \"group assist <someone>\" again "
      "on that person.\n";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/assist.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/report.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/report.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627067   Available: 13574421
Inodes: Total: 5242880    Free: 4960132
891 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/report.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627067   Available: 13574421
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

#define GROUP_CMD_STATUS  ( GROUP_SUB_CMDS_DIR+"status" )

int do_report( string group );

void create() {
   ::create();
   add_group_sub_command( "report", "", (: do_report( $6 ) :) );
   set_membership_required( "report", 0, 1 );
} /* create() */


int do_report( string group ) {
   string message;
   
   message = this_player()->query_cap_name() + " reports that " +
      this_player()->query_pronoun() + " is ";
   message += GROUP_CMD_STATUS->generate_status_message( this_player() );

   GROUP->notify_group( group, this_player(), ({
      "You report:  " + message,
      message
      }) );

   return 1;

} /* do_report() */


string query_help_string_for( string sub_command ) {
   return "This command lets you report your current "
      "condition on the group's channel.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/report.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/follow.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/follow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627066   Available: 13574420
Inodes: Total: 5242880    Free: 4960132
2928 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/follow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627066   Available: 13574420
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_group_follow( object *who, string group, int unfollow );

void create() {
   ::create();
   add_group_sub_command( "follow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 0 ) :) );
   add_group_sub_command( "unfollow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 1 ) :) );      
   set_membership_required( "follow", 0, 1 );
   set_membership_required( "unfollow", 0, 1 );
} /* create() */


int do_group_follow( object *who, string group, int unfollow ) {
   
   int size;
   string fault_message;
   object *what_not, *follow, *already_following;

   fault_message = "";   
   who -= ({ 0 });
   
   if( member_array( this_player(), who ) != -1 ) {
      who -= ({ this_player() });
      fault_message += "You cannot follow yourself.  ";
   }
   
   follow = ( who & GROUP->members_of( group ) );
   
   what_not = who - follow;
   
   switch( unfollow ) {
      case 1:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) == -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are not following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      case 0:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) != -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are already following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      default:
         printf( "Barf.\n" );
   }
   
   size = sizeof( what_not );
   
   if( size ) {
      fault_message += "$C$" + query_multiple_short( what_not, "the" ) +
         ( size > 1 ? " are not members of your group" :
         " is not a member of your group" ) + ".  ";
   }
   
   fault_message += "\n";
   
   if( sizeof( follow ) ) {
      GROUP->handle_group_follow( group, this_player(), follow,
         unfollow, 0 );
      return 1;
   } else {
      tell_object( this_player(), fault_message );
      return 1;
   }
   
} /* do_group_follow() */


string query_help_string_for( string sub ) {
   switch( sub ) {
      case "follow":
         return "This command lets you follow your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
      case "unfollow":
         return "This command lets you stop following your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
   }

   return 0;
   
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/follow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/join.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/join.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627065   Available: 13574419
Inodes: Total: 5242880    Free: 4960132
2222 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/join.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627065   Available: 13574419
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;


int do_join( object member );


void create() {
   ::create();
   add_group_sub_command( "join", "<indirect:living'existing member'>",
      (: do_join( $1[ 0 ] ) :) );
} /* create() */


int do_join( object member ) {

   string his_group, my_group;
   
   his_group = member->query_group();
   
   if( this_player() == member ) {
      return notify_fail( "I could come up with something witty, "
         "but I'm not going to bother.\n" );
   }
   
   if( !his_group ) {
      return notify_fail( member->the_short() + " is not a member "
         "of any group.\n" );
   }
   
   if( !GROUP->is_invited( his_group, this_player() ) ) {
      return notify_fail( "You have not been invited to that "
         "group.\n" );
   }
   
   if( sizeof( GROUP->members_of( his_group ) ) >= MAX_PEOPLE_PER_PARTY ) {
      return notify_fail( "The group you are trying to join is "
         "full.\n" );
   }

   my_group = this_player()->query_group();
   
   if( my_group && ( my_group == his_group ) ) {
      return notify_fail( "You are already a member of "
         "that group.\n" );
   }
   
   if( my_group ) {
      if( !GROUP->remove_member( my_group, this_player() ) ) {
         return notify_fail( "You fail to leave your previous "
            "group.. for some reason.\n" );
      }
      tell_object( this_player(), "%^BOLD%^You leave your current "
         "group behind to join a new one.%^RESET%^\n" );
   }

   if( !GROUP->add_member( his_group, this_player() ) ) {
      return notify_fail( "You failed to join the group "
         "for some weird reason.\n" );
   }

   return 1;
} /* do_join() */


string query_help_string_for( string sub_command ) {
   switch( sub_command ) {
      case "join":
         return "This command lets you join an existing group.  To join, "
            "type \"group join <existing member>\" where "
            "<existing member> is someone who is already a member of the "
            "group you wish to be a part of.  You must be invited to a "
            "group by its leader before you can join.";
      default:
         return 0;
   }
} /* query_help_string_for() */

            
            
// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/join.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/status.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/status.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627065   Available: 13574419
Inodes: Total: 5242880    Free: 4960132
9603 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/status.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627065   Available: 13574419
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_group_status( string verbose, string group );
int display_verbose_group_status( string group );
int display_brief_group_status( string group );
string calc_idle_string( object player );
string generate_status_message( object player );
string convert_percentage_to_colour( int percentage );
string convert_percentage_to_hp_message( int percentage );
string convert_percentage_to_gp_message( int percentage );


void create() {
   ::create();
   add_group_sub_command( "status", "<word'brief|verbose'>",
      (: do_group_status( $4[ 0 ], $6 ) :) );
   add_group_sub_command( "status", "",
      (: do_group_status( "default", $6 ) :) );
   set_membership_required( "status", 0, 1 );
} /* create() */


int do_group_status( string verbose, string group ) {

   int use_verbose;
   
   switch( verbose ) {
      case "default":
         use_verbose = this_player()->query_verbose( "score" );
         break;
      case "verbose":
         use_verbose = 1;
         break;
      case "brief":
         use_verbose = 0;
         break;
      default:
         return notify_fail( "[ERROR]: Unknown return value from verbose information.\n" );
   }
   
   switch( use_verbose ) {
      case 1:
         return display_verbose_group_status( group );
      case 0:
         return display_brief_group_status( group );
      default:
         return notify_fail( "[ERROR]: This shouldn't happen.\n" );
   }

} /* do_group_status() */


int display_verbose_group_status( string group ) {

   int size, cols;   
   object member, *members, *assisting;
   string pronoun, message, status, short, colour, idle;
   
   cols = this_player()->query_cols();
   short = GROUP->query_group_short( group );
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   
   message = "\n";
   message += sprintf( "   %'+'*|s\n", cols - 3, "|" + short + "|" );
      
   size = sizeof( message ) - 3;

   message = replace( message, ({ short, ( colour + short +  
      "%^RESET%^" ) }) );

   message += "\n";
   
   message += sprintf( "%' '*|s\n",
      cols - 3,
      "The group was started on " +
         ctime( GROUP->query_start_time( group ) ) + "." );

   message += "\n";

   members = GROUP->members_of( group );
      
   message += sprintf( "   %-=*s\n\n",
      size, "The group has %^BOLD%^" + query_num( sizeof( members ) ) +
      "%^RESET%^ " + ( sizeof( members ) > 1 ? "members" : "member" ) +
      ":" );

   if (!members) {
      message += "Very unhappy group.\n";
   } else {

      foreach( member in members ) {
          if(!member)
             continue;
          status = "$I$+8,+0=   " + colour;
          status += capitalize( member->query_cap_name() ) + "%^RESET%^" + 
             " is " + generate_status_message( member ) + "  ";
          
          pronoun = member->query_pronoun();
   
          idle = calc_idle_string( member );
          if( idle ) {
             status += "  %^BOLD%^" + idle + ".%^RESET%^";
          }
          
          if( member == GROUP->leader_of( group ) ) {
             status += "  " + capitalize( pronoun ) + " is the " +
                colour + "current leader%^RESET%^ of the group.";
          }
          
         
          assisting = member->query_assisting();
          
          if( sizeof( assisting ) ) {
             status += "  " + capitalize( pronoun ) + " is assisting " +
                query_multiple_short( assisting, "one", 0, 1 ) + ".";
          }
          
          status += "$I$-8,-0=\n";
       
          message += status;
      }
   }
   
   tell_object( this_player(), message );
   
   return 1;

} /* display_verbose_group_status() */


int display_brief_group_status( string group ) {

   object member, *others;
   string message, colour, idle;
   int my_gp, my_hp, my_max_hp, my_max_gp;
   
   message = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );

   others = GROUP->members_of( group ) - ({ this_player() });
   
   my_hp = this_player()->query_hp();
   my_gp = this_player()->query_gp();
   my_max_hp = this_player()->query_max_hp();
   my_max_gp = this_player()->query_max_gp();
   
   message += colour;
   message += capitalize( this_player()->query_cap_name() );

   message += "%^RESET%^; Hp: " + convert_percentage_to_colour( my_hp * 100 / my_max_hp ) +
      my_hp + "/" + my_max_hp + "%^RESET%^ Gp: " +
      convert_percentage_to_colour( my_gp * 100 / my_max_gp ) +
      my_gp + "/" + my_max_gp + "%^RESET%^.\n";
      
   foreach( member in others ) {
     if(!member)
       continue;

      message += colour;
      message += capitalize( member->query_cap_name() );
      message += "%^RESET%^ is " + generate_status_message( member );
      
      idle = calc_idle_string( member );
      if( idle ) {
         message += "  (" + idle + ")";
      }
      
      if( member == GROUP->leader_of( group ) ) {
         message += " (" + colour + "L%^RESET%^)";
      }
      
      if( member->query_property( "dead" ) ) {
         message += " (%^BOLD%^%^RED%^D%^RESET%^)";
      }  
      
      message += "\n";
   }

   tell_object( this_player(), message );
   
   return 1;

} /* display_brief_group_status() */


string calc_idle_string( object player ) {
   int idle;

   if( !interactive( player ) ) {
      return "Net Dead";
   }
   
   idle = query_idle( player );

   if( idle < 15 ) {
      return 0;
   }
   
   return "Idle: " + ( idle / 60 ) + ":" + sprintf("%'0'2d", ( idle % 60 ));
} /* calc_idle_string() */


string generate_status_message( object player ) {
   
   int hp_percentage, gp_percentage;

   hp_percentage = player->query_hp() * 100 / player->query_max_hp();
   gp_percentage = player->query_gp() * 100 / player->query_max_gp();

   return (
      convert_percentage_to_colour( hp_percentage ) +
      convert_percentage_to_hp_message( hp_percentage ) +
      "%^RESET%^ and " +      
      convert_percentage_to_colour( gp_percentage ) +
      convert_percentage_to_gp_message( gp_percentage ) +
      "%^RESET%^." );
   
} /* generate_status_message() */


string query_help_string_for( string sub_command ) {
   return "The status sub-command displays vital statistics "
      "of your group's members.  Depending on your brief "
      "settings for \"score\", the command will either "
      "show the verbose statistics or prompt a brief "
      "display.  You can also force either version by "
      "adding the argument \"verbose\" or \"brief\".";
} /* query_help_string_for() */


string convert_percentage_to_colour( int percentage ) {
   switch( percentage ) {
      case -1000..10: return "%^BOLD%^%^RED%^";
      case 11..20:    return "%^RED%^";
      case 21..30:    return "%^ORANGE%^";
      case 31..40:    return "%^YELLOW%^";
      case 41..50:    return "%^MAGENTA%^";
      case 51..60:    return "%^CYAN%^";
      case 61..70:    return "%^BOLD%^%^CYAN%^";
      case 71..80:    return "%^GREEN%^";
      case 81..90:    return "%^BOLD%^%^GREEN%^";
      case 91..100:   return "%^BOLD%^%^WHITE%^";
      default:        return "";
   }
} /* convert_percentage_to_colour() */


string convert_percentage_to_hp_message( int percentage ) {
   switch( percentage ) {
      case -1000..0: return "perfectly healthy, for a ghost";
      case 1..5:     return "near death";
      case 6..10:    return "critically wounded";
      case 11..20:   return "seriously wounded";
      case 21..30:   return "heavily wounded";
      case 31..40:   return "badly wounded";
      case 41..50:   return "wounded";
      case 51..60:   return "slightly wounded";
      case 61..70:   return "injured";
      case 71..80:   return "slightly injured";
      case 81..89:   return "slightly hurt";
      case 90..94:   return "scratched";
      case 95..99:   return "almost unhurt";
      case 100:      return "unhurt";
      default:       return "ERROR";
   }
} /* convert_percentage_to_hp_message() */


string convert_percentage_to_gp_message( int percentage ) {   
   switch( percentage ) {
      case 0..10:    return "near unconscious";
      case 11..20:   return "severely fatigued";
      case 21..30:   return "highly fatigued";
      case 31..40:   return "very fatigued";
      case 41..50:   return "fatigued";
      case 51..60:   return "slightly fatigued";
      case 61..70:   return "confused";
      case 71..80:   return "slightly confused";
      case 81..90:   return "concentrated";
      case 91..99:   return "clear of mind";
      case 100:      return "refreshed";
      default:       return "ERROR";
   }
} /* convert_percentage_to_gp_message() */


string convert_percentage_to_share_message( int percentage ) {
   switch( percentage ) {
      case 100:       return "all";
      case 95..99:    return "almost all";
      case 90..94:    return "a very large portion";
      case 80..89:    return "a large portion";
      case 70..79:    return "a major portion";
      case 60..69:    return "an above average portion";
      case 52..59:    return "a slightly above average portion";
      case 49..51:    return "an average portion";
      case 41..48:    return "a slightly below average portion";
      case 31..40:    return "a below average portion";
      case 21..30:    return "a minor portion";
      case 11..20:    return "a small portion";
      case 6..10:     return "a very small portion";
      case 1..5:      return "a miniscule portion";
      case 0:         return "next to none";
      default:        return "an ERRONEOUS portion ";
   }
} /* convert_percentage_to_share_message() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/status.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/invite.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/invite.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627062   Available: 13574416
Inodes: Total: 5242880    Free: 4960132
2571 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/invite.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627062   Available: 13574416
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_invite( object person, string group );

void create() {
   ::create();
   add_group_sub_command( "invite", "<indirect:living'person'>", (:
      do_invite( $1, $6 ) :) );
   set_membership_required( "invite", 0, 1 );
   set_leadership_required( "invite", 0, 1 );
} /* create() */


int do_invite( object *persons, string group ) {
   
   object person;
   
   persons -= ({ this_player() });
   
   if( !sizeof( persons ) ) {
      return notify_fail( "I would come up with "
         "something witty, but I'm not going to "
         "bother.\n" );
   }
   
   if( sizeof( persons ) > 1 ) {
      return notify_fail( "You can only invite one person "
         "at a time.\n" );
   }
   
   person = persons[ 0 ];
   
   if( sizeof( GROUP->invitations_of( group ) ) >=
      MAX_INVITATIONS_PER_PARTY_AT_ONCE ) {
      return notify_fail( "You can only have a total of " +
         MAX_INVITATIONS_PER_PARTY_AT_ONCE + " invitations pending "
         "at one time.\n" );
   }

   if( GROUP->is_invited( group, person ) ) {
      return notify_fail( person->the_short() + " has "
         "already been invited to your group.\n" );
   }
   
   if( GROUP->is_member( group, person ) ) {
      return notify_fail( person->the_short() + " is "
         "already a member of your group.\n" );
   }
   
   if( !userp( person ) ) {
      return notify_fail( "You cannot invite " + person->the_short() +
         " to your group.\n" );
   }
   
   GROUP->add_invite( group, person );
   
   GROUP->notify_group( group, this_player(), person->query_cap_name() +
      " has been invited by " + this_player()->query_cap_name() + ".  " );
      
   tell_object( person, "You have been invited by " +
      this_player()->a_short() + " to join " +
      this_player()->query_possessive() + " group.  "
      "You have " + INVITE_TIMEOUT + " seconds to join "
      "the group before the invitation is withdrawn.  Use "
      "\"group join " + this_player()->query_name() + "\" "
      "to join.\n" );
   
   if( person->query_group() ) {
      tell_object( person, "%^BOLD%^Note that accepting the invitation "
         "will force you to leave your current group.%^RESET%^\n" );
   }
   
   return 1;
   
} /* do_invite() */


string query_help_string_for( string sub ) {
   return "With this command the leader of a group can invite new "
      "members to the group.  A person who has been invited must then "
      "use the \"join\" command to actually become a member.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/invite.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/base_group.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/base_group.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627061   Available: 13574415
Inodes: Total: 5242880    Free: 4960132
8244 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/base_group.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627061   Available: 13574415
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

#define GROUP_ARRAY_SIZE      3
#define GROUP_ARRAY_FUNCTION  0
#define GROUP_ARRAY_MEM_REQ   1
#define GROUP_ARRAY_LDR_REQ   2

/**
 * This is the base file for a group sub command.  All group sub commands
 * inherit this file.
 * <p>
 * To create a new sub command that plugs in to the master "group"
 * command, create a new file in the directory where sub commands
 * are stored and have it inherit this file.
 * <p>
 * One file can support several verbs, however it is strongly discouraged
 * unless they are *very* closely tied together.  The file also supports
 * different patterns for the same verb, which is no problem, and in no
 * way discouraged.
 * <p>
 * It is suggested you name the file the same name as the verb(s) it
 * declares.
 *
 * @author Tape
 */

mapping _commands;

/** @ignore */
void create() {
   _commands = ([ ]);
} /* create() */


/**
 * This is the signature function for a group sub command.
 * @return number of sub-commands
 */
int query_group_sub_command_amount() {
   return sizeof( _commands );
} /* query_group_sub_command() */


/**
 * This function declares a new sub command.  If the verb provided already
 * exists, it assumes it is a version of the command that uses a different
 * pattern.  If the verb *and* the pattern already exist, the function
 * will fail.  The cmd_function variable should point to the function
 * which contains the command code.  This function will return 1 or 0
 * depending if the command succeeds and is passed the same arguments
 * as normal commands get.  An additional argument ($6) can be
 * included which returns the group this_player() is a member of
 * (if any).
 *
 * @example add_group_sub_command( "join", "<indirect:object'member of a
 group'>", (: do_join( $1, $6 ) :)
 *
 * @param verb the verb for the command
 * @param pattern the command pattern
 * @param cmd_function the command function
 *
 * @return 1 on success, 0 on failure
 * @see add_command()
 */
int add_group_sub_command( string verb, string pattern,
   function cmd_function ) {

   if( !_commands[ verb ] ) {
      _commands += ([ verb : ([ pattern : ({ cmd_function, 0, 0 }) ]) ]);
      return 1;
   }

   if( _commands[ verb ][ pattern ] ) {
      return 0;
   }
   
   _commands[ verb ] += ([ pattern : ({ cmd_function, 0, 0 }) ]);
   
   return 1;
   
} /* add_group_sub_command() */


/**
 * This function will remove a command from the list of declared sub
 * commands.  If a pattern is provided, it will try to only remove
 * that specific pattern.
 *
 * @param verb the verb to be removed
 * @param pattern the specific pattern to be removed (optional)
 * @return 1 on success, 0 on failure
 */
varargs int remove_group_sub_command( string verb, string pattern ) {
   if( undefinedp( pattern ) ) {      
      if( !_commands[ verb ] ) {
         return 0;
      }
      map_delete( _commands, verb );
      return 1;
   }
   if( !_commands[ verb ] || !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   map_delete( _commands[ verb ], pattern );
   return 1;
} /* remove_group_command() */


/**
 * This function returns all the verbs that have been declared by
 * this object.
 * @return a string array of the verbs
 */
string *query_group_sub_command_verbs() {
   return keys( _commands );
} /* query_group_sub_command_verbs() */


/**
 * This function returns all patterns for a specific verb.
 * @param verb the verb you want patterns for
 * @return a string array of the patterns, 0 if verb doesn't exist
 */
string *query_group_sub_command_patterns( string verb ) {

   if( !_commands[ verb ] ) {
      return 0;
   }
   
   return keys( _commands[ verb ] );

} /* query_group_sub_command_patterns() */


/**
 * This function returns the command function for a specific verb and
 * pattern.  If only the verb is provided, all functions for that
 * verb are returned (in no particular order).
 * @param verb the command verb
 * @param pattern the command pattern (optional)
 * @return array of pointer(s) to the function, 0 if verb/pattern doesn't exist
 */
varargs function *query_group_sub_command_function( string verb, string
   pattern ) {
   
   if( !_commands[ verb ] ) {
      return 0;
   }
   
   if( undefinedp( pattern ) ) {
      return values( _commands[ verb ] );
   }

   if( !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_FUNCTION ];

} /* query_group_sub_command_function() */


/**
 * This function sets a flag which requires the player accessing
 * the command to be a member of a group.  This is automatically
 * handled by the master command before the actual command function
 * is called.  If no pattern is specified, then the flag is set
 * for all patterns of that verb.
 *
 * @param verb the command verb
 * @param pattern the command pattern, or 0
 * @return 1 on success, 0 if verb/pattern not found
 */
int set_membership_required( string verb, string pattern, int flag ) {
   
   mixed *dummy;
   string key;
   
   if( !_commands[ verb ] ) {
      return 0;
   }
   
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ] = flag;
      return 1;
   }
   
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_MEM_REQ ] = flag;
   }

   return 1;
} /* set_membership_required() */


/**
 * This function sets a flag which requires the player accessing
 * the command to be the leader of a group.  This is automatically
 * handled by the master command before the actual command function
 * is called.  If no pattern is specified, then the flag is set
 * for all patterns of that verb.
 *
 * @param verb the command verb
 * @param pattern the command pattern, or 0
 * @return 1 on success, 0 if verb/pattern not found
 */
int set_leadership_required( string verb, string pattern, int flag ) {

   mixed *dummy;
   string key;

   if( !_commands[ verb ] ) {
      return 0;
   }
   
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ] = flag;
      return 1;
   }
   
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_LDR_REQ ] = flag;
   }

   return 1;
} /* set_leadership_required() */


/**
 * This function returns whether a command user has to be a member
 * of a group in order to use that command.  If no pattern is
 * provided, a flag for a random pattern for that verb is returned.  This
 * is not suggested unless it is certain that all patterns use
 * the same settings, and/or there is only one pattern for that
 * verb.
 *
 * @param verb the command verb
 * @param pattern the pattern for the verb (optional)
 * @return 1 if membership is required, 0 if not, -1 if verb/pattern not found
 */
varargs int query_membership_required( string verb, string pattern ) {
   
   if( !_commands[ verb ] ) {
      return -1;
   }
   
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_MEM_REQ ];
   }
   
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ];

} /* query_membership_required() */


/**
 * This function returns whether a command user has to be the leader
 * of a group in order to use that command.  If no pattern is
 * provided, a flag for a random pattern for that verb is returned.  This
 * is not suggested unless it is certain that all patterns use
 * the same settings, and/or there is only one pattern for that
 * verb.
 *
 * @param verb the command verb
 * @param pattern the pattern for the verb (optional)
 * @return 1 if membership is required, 0 if not, -1 if verb/pattern not found
 */
varargs int query_leadership_required( string verb, string pattern ) {
   
   if( !_commands[ verb ] ) {
      return -1;
   }
   
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_LDR_REQ ];
   }
   
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ];

} /* query_leadership_required() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/base_group.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/say.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/say.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627059   Available: 13574413
Inodes: Total: 5242880    Free: 4960132
732 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/say.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627059   Available: 13574413
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_group_say( string message, string group );


void create() {
   ::create();
   add_group_sub_command( "say", "<string'message'>",
      (: do_group_say( $4[ 0 ], $6 ) :) );
   set_membership_required( "say", 0, 1 );
} /* create() */


int do_group_say( string message, string group ) {

   message = replace( message, ({ "%^", "" }) );
   
   GROUP->notify_group( group, this_player(),
      this_player()->query_cap_name() + ": " + message );
      
   return 1;
   
} /* say_to_group() */


string query_help_string_for( string sub ) {
   return "This command allows you to say something on "
      "the group's channel.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/say.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/group_cmds/emote.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/emote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627059   Available: 13574413
Inodes: Total: 5242880    Free: 4960132
815 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/group_cmds/emote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627059   Available: 13574413
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <group_handler.h>

inherit GROUP_SUBCOMMAND_INHERITABLE;

int do_group_emote( string message, string group );

void create() {
   ::create();
   add_group_sub_command( "emote", "<string'message'>",
      (: do_group_emote( $4[ 0 ], $6 ) :) );
   set_membership_required( "emote", 0, 1 );
} /* create() */

int do_group_emote( string message, string group ) {

   message = replace( message, ({ "%^", "", }) );
      
   GROUP->notify_group( group, this_player(), ({
      "You emote: " + this_player()->query_cap_name() + " " + message,
      this_player()->query_cap_name() + " " + message
      }) );
   
   return 1;
   
} /* emote_to_group() */


string query_help_string_for( string sub ) {
   return "This command allows you to emote on the group "
      "channel.";
} /* query_help_string_for() */

// --- END [/mnt/home2/grok/lib/cmds/player/group_cmds/emote.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/date.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/date.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627058   Available: 13574412
Inodes: Total: 5242880    Free: 4960132
32 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/date.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627058   Available: 13574412
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include "/cmds/player/time.c";
// --- END [/mnt/home2/grok/lib/cmds/player/date.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/monitor.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/monitor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627058   Available: 13574412
Inodes: Total: 5242880    Free: 4960132
1131 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/monitor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627058   Available: 13574412
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: monitor.c,v 1.5 2002/08/04 08:09:43 ceres Exp $
 * $Log: monitor.c,v $
 * Revision 1.5  2002/08/04 08:09:43  ceres
 * Modified to use options.h for monitor options.
 *
 * Revision 1.4  2002/08/03 19:29:15  ceres
 * New combat system version
 *
 * Revision 1.3  2001/06/01 20:58:35  ceres
 * Can't remember
 *
 * Revision 1.2  1998/04/14 02:24:30  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
 */
#include <cmds/options.h>

inherit "/cmds/base";

#define TP this_player()

mixed cmd(string str) {
  int monitor;

  monitor = TP->query_monitor();
  
  if(!str) {
    write("Your hit point monitor is set to " + MONITOR_OPTIONS[monitor] +
          ".\n");
    return 1;
  }

  if(member_array(str, MONITOR_OPTIONS) != -1) {
    write("Your hit point monitor is set to " + str + ".\n");
    TP->set_monitor(member_array(str, MONITOR_OPTIONS));
  }
  return 1;
}

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{" + implode(MONITOR_OPTIONS, "|") + "}", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/monitor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/player/start.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/player/start.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627058   Available: 13574412
Inodes: Total: 5242880    Free: 4960132
2536 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/player/start.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627058   Available: 13574412
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: start.c,v 1.4 2002/07/16 23:20:53 pinkfish Exp $
 * $Log: start.c,v $
 * Revision 1.4  2002/07/16 23:20:53  pinkfish
 * Make it work with extra start locations.
 *
 * Revision 1.3  2001/03/04 05:07:55  presto
 * Fixed typo chose --> choose
 *
 * Revision 1.2  1999/05/17 21:47:04  pinkfish
 * Fix up an error.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

int clear_starts() {
  write( "Clearing your list of starting positions...\n" );
  this_player()->reset_starts();
  return 1;
} /* clear_starts() */

int list_starts() {
   int z, i;
   string *starts;

   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;
   if ( z == -1 ) {
      /* No starting positions... */
      write( "Your starting position is " +
             this_player()->query_start_pos()->the_short() + ".\n");
      return 1;
   }
   if ( !z ) {
      /* Only one starting position */
      write( "Your starting position is "+ starts[ 1 ] +".\n" );
      return 1;
   }
   /* Tell us our current starting positions! */
   write( "Your current starting position is "+ starts[ 1 ] +".\n"+
         "You can also choose your starting position from:\n" );
   for ( i = 1; i <= z; i++ )
      write( sprintf( "% 5d: $I$7=%s\n", i, starts[ 2 * i + 1 ] ) );
   write( "Choose a new starting position using: start <number>\n"+
         "To clear your list of starting positions, use: start clear\n" );
   return 1;
} /* list_starts() */

int set_start( int num ) {
   string *starts;
   int z;

   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;

   if (sizeof(starts) < 2) {
      add_failed_mess("You only have one starting location.\n");
      return 0;
   }

   if (z == 0) {
      add_failed_mess("You have no starting locations to choose from at all.\n");
      return 0;
   }

   if ( ( num < 1 ) || ( num > z ) ) {
      add_failed_mess( "You must choose a number from 1 to "+ z +".\n" );
      return 0;
   }
   num *= 2;
   write( "Your new starting position is "+ starts[ num + 1 ]  +".\n" );
   this_player()->set_start_location(starts[num]);
   return 1;
} /* start_stuff() */

/*
 * Not really sure they should be able to clear them...  Anyway...
 *
 * Yes, they should: file names change, and creators make mistakes.
*/

mixed *query_patterns() {
  return ({ "<number>", (: set_start($4[0]) :),
            "clear", (: clear_starts() :),
            "", (: list_starts() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/player/start.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/report_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/report_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627057   Available: 13574411
Inodes: Total: 5242880    Free: 4960132
17654 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/report_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627057   Available: 13574411
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: report_base.c,v 1.44 2003/07/08 07:12:18 pinkfish Exp $ 
 */
/**
 * This is the base object for creating typo, bug, idea etc reporting
 * commands from.  You should set the error type of the
 * object in its create function.  The use_last_error flag should
 * be set for those error report types which will need to use the last
 * runtime error on the player object.
 * @example
 * inherit "/cmds/report_base";
 * 
 * void create() {
 *    ::create();
 *    set_error_type("TYPO");
 * } /\* create() *\/
 */

#include <creator.h>
#include <log.h>
#include <command.h>
#include <spells.h>
#include <user_parser.h>
#include <soul.h>
#include <error_handler.h>

inherit "/cmds/base";
inherit "/cmds/bug_replies";

class errors {
   int type;
   string file;
   string error;
   string extra;
}
#define ROOM_BUG    1
#define OBJECT_BUG  2
#define RITUAL_BUG  3
#define SPELL_BUG   4
#define HELP_BUG    5
#define COMMAND_BUG 6
#define GENERAL_BUG 7
#define WEB_BUG     8
#define SYNONYMS "/doc/SYNONYMS"
int bug_command(string str);
int bug_spell(string str);
int bug_ritual(string str);
int bug_object(object * obj,
               string str);
int bug_help(string str);
int bug_man(string str);
int bug_room();
int bug_general();
int bug_soul(string str);

private nosave mapping _globals;
private nosave string _error_type;
private nosave int _use_last_error;

void create()
{
   bug_replies::create();
   _globals = ([ ]);
}                               /* create() */

/**
 * This sets the error type name.  The error type should be one
 * of "TYPO", "BUG", "IDEA".
 * @param type the type to set
 * @see query_verb()
 */
void set_error_type(string type)
{
   _error_type = type;
}                               /* set_error_type() */

/**
 * This sets the use_last_error flag.  If this flag is set to a non-zero
 * value then the last runtime error stored on the player object will
 * be attached to the error report.
 * @param error the new value of the last error flag
 */
void set_use_last_error(int error)
{
   _use_last_error = error;
}                               /* set_use_last_error() */

/**
 * This method returns the currently set value of the last error flag.
 * @return the current value of the last error flag
 */
int query_use_last_error()
{
   return _use_last_error;
}                               /* query_use_last_error() */

/** @ignore yes */
int bug_room()
{
   if (environment(this_player())) {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:file_name(environment
             (this_player
              ())));
  } else {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:"/d/mudlib/void");
   }
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_room() */

int bug_special(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/d/special/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}

int bug_misc(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/obj/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}

/** @ignore yes */
int bug_general()
{
   string dir;
   string *bits;
   string file;

   //
   // For a general bug put it in the domains base directory.
   //
   if (!environment(this_player())) {
      dir = "/d/am/fluff";
   } else {
      dir = file_name(environment(this_player()));
   }
   bits = explode(dir, "/");
   if (bits[0] == "d") {
      file = implode(bits[0..1], "/") + "/general";
   } else {
      file = file_name(environment(this_player()));
   }
 _globals[this_player()] = new (class errors, type: GENERAL_BUG, error: "GENERAL " + _error_type, file:file);
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_general() */

/** @ignore yes */
int bug_command(string str)
{
   int i;
   string dir;
   string file;
   string *bits;
   mixed *junk,
    *coms;
   class command cmd;
   class errors bing;
   class command_data cmd_data;
   class command_class cmd_class;
   mapping temp;


   bing = new (class errors);
   coms = ({ });
   junk = actions_defined(this_player(), 0, 12);
   for (i = 0; i < sizeof(junk); i += 2) {
      if (junk[i] == str) {
         coms += ({ junk[i], junk[i + 1][0], junk[i + 1][1] });
      }
   }
   if (sizeof(coms) > 3) {
      return notify_fail("More than one commands with the name \"" + str +
                         "\" found.  Please be more specific.\n");
   }
   if (sizeof(coms)) {
      bing->file = function_exists((string) coms[2], (object) coms[1]);
      if (!(bing->file)) {
         bing->file = base_name((object) coms[1]);
         str += " (protected method, so it might not be in this file)";
      }
   } else {
    cmd = new (class command, verb:str);
      if (CMD_D->HandleStars(cmd) &&
          sizeof((coms = (mixed *) CMD_D->GetPaths(cmd->verb) &
                  (mixed *) this_player()->GetSearchPath()))) {
         bing->file = coms[0] + "/" + cmd->verb;
      } else {
         if ((cmd_class = this_player()->query_parse_command(str))) {
//tell_creator("presto", "%O\n", coms);
            temp = cmd_class->patterns;
            cmd_data = temp[keys(temp)[0]];
//tell_creator("presto", "%O\n", cmd_data->calls[0]);
//tell_creator("presto", "%O\n", values(coms->patterns));
            bing->file = base_name(cmd_data->calls[0]);
//            bing->file = base_name((values(coms->patterns))[0]->calls[0]);
//            bing->file = base_name(coms[0][OBJS]);
         } else {
            if ((coms = SOUL_OBJECT->query_soul_command(str))) {
               bing->file = "/soul/" + str[0..0] + "/" + str;
            } else if (_error_type == "IDEA") {
               //bing->file = "/soul/" + str[0..0] + "/" + str;
               dir = file_name(environment(this_player()));
               bits = explode(dir, "/");
               if (bits[0] == "d") {
                  file = implode(bits[0..1], "/") + "/general";
               } else {
                  file = file_name(environment(this_player()));
               }
               bing->file = file;
            } else {
               return notify_fail("Command " + str + " not found.\n");
            }
         }
      }
   }
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_command() */

/** @ignore yes */
int bug_help(string str)
{
   mixed *stuff;
   class errors bing;
   string tmp;

   bing = new (class errors);
   tmp = "/cmds/player/help"->query_synonym(str);
   if (strlen(tmp))
      str = tmp;

   if (str && str != "") {
      stuff = "/cmds/player/help"->query_help_on(str);
      if (!sizeof(stuff)) {
         // See if it is a soul command.
         if (!SOUL_OBJECT->query_soul_command(str)) {
            notify_fail("Could not find the help file '" + str +
                        "'.  If you wish "
                        "to suggest a new command use 'idea help'\n");
            return 0;
         } else {
            bing->file = "/soul/" + str;
         }
      } else {
         sscanf(stuff[0][0], "%*s (%s)", bing->file);
      }
   } else {
     bing->file = "/cmds/player/help";
   }

   bing->error = "HELP " + _error_type + " " + str;
   bing->type = HELP_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_help() */

/** @ignore yes */
int bug_soul(string str)
{
   class errors bing;
   string tmp;

   bing = new (class errors);
   if (str)  {
      tmp = sprintf("/soul/%c/%s.s", str[0], str);
      if (file_size(tmp) < 1)  {
         notify_fail("No such soul command \"" + str + "\".\n");
         return 0;
      }
      else return bug_command(str);
   }
   bing->file = "/soul/ideas";
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_help() */


/** @ignore yes */
int bug_ritual(string str)
{
   mapping junk;
   class errors bing;
   string sname;
   mixed* data;
   string file;

   str = this_player()->expand_nickname(str);
   bing = new (class errors);
   junk = this_player()->query_spells();
   // Do a case insensative search.
   foreach (sname, data in junk) {
      if (lower_case(sname) == lower_case(str)) {
         if (sizeof(data) <= S_OBJECT) {
            // If it has a bad file name, ignore it
            file = file_name(environment(this_player()));
         } else {
            file = data[S_OBJECT];
         }
      }
   }
   if (!file) {
      notify_fail("Ritual " + str + " not found.\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = file;
   bing->error = "RITUAL " + _error_type + " " + str;
   bing->type = RITUAL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_ritual() */

/**
 * This entry point is used to erroring spells without specifically saying
 * which one.
 * @param file the file path to use
 * @param name the name to use
 */
int bug_web(string url)
{
   class errors bing;

   bing = new (class errors);
   bing->file = "/www/fluff";
   bing->error = "OBJECT " + _error_type + " " + url;
   bing->type = WEB_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit("Url: " + url + "\n\n", "end_of_edit");
   return 1;
}                               /* bug_spell() */

/**
 * This entry point is used to erroring spells without specifically saying
 * which one.
 * @param file the file path to use
 * @param name the name to use
 */
int bug_spell_file(string file, string name)
{
   class errors bing;

   bing = new (class errors);
   bing->file = file;
   bing->error = "SPELL " + _error_type + " " + name;
   bing->type = SPELL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_spell() */

/** @ignore yes */
int bug_spell(string str)
{
   mapping junk;
   string file;
   string sname;
   mixed data;

   if (str == "wizards" || str == "witches") {
      file = "/obj/spells/" + str;
   } else {
      // Expand the nickname
      str = this_player()->expand_nickname(str);
      junk = this_player()->query_spells();
      // Do a case insensative search.
      foreach (sname, data in junk) {
         if (lower_case(sname) == lower_case(str) && arrayp(data)) {
            file = data[S_OBJECT];
         }
      }
      if (!file) {
         notify_fail("Spell " + str + " not found.\n");
         map_delete(_globals, this_player());
         return 0;
      }
   }
   bug_spell_file(file, str);
   return 1;
} /* bug_spell() */

/** @ignore yes */
int bug_object_new(string name)
{
   string info;
   class errors bing;

   bing = new (class errors);
   bing->file = base_name(environment(this_player()));
   bing->error = "OBJECT " + _error_type + " " + name;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_object() */

/** @ignore yes */
int bug_object(object * obj,
               string str)
{
   string info;
   class errors bing;
   string name;
   string short;
   string* bits;

   bing = new (class errors);
   if (sizeof(obj) > 1) {
      notify_fail("More than one object can be identified with the name " +
                  str + "\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = base_name(obj[0]);
   switch (bing->file) {
   case "/std/room/basic/item":
      bing->file = base_name(environment(this_player()));
      info = sprintf("Room item %s.\n\n", str);
      break;
   case "/std/bit" :
      bing->file = "/std/races/happy_bit";
      break;
   case "/std/book" :
   case "/obj/armour":
   case "/obj/baggage":
   case "/obj/clothing":
   case "/obj/container":
   case "/obj/food":
   case "/obj/monster":
   case "/obj/weapon":
   case "/std/object":
      if (obj[0]->query_property("virtual name")) {
         bing->file = obj[0]->query_property("virtual name");
         info = sprintf("VObject: %s, Object: %s\nName: %s, Short: %s\n\n",
                        obj[0]->query_property("virtual name"),
                        bing->file,
                        obj[0]->query_name(), obj[0]->query_short());
         break;
      } else {
         bing->file = base_name(environment(this_player()));
      }
   default:
      bits = explode(bing->file, "/");
      name = bits[0];
      if (name == "obj" || name == "std") {
         // Put it in the room by default.
         if (sizeof(bits) == 2 ||
             (bits[1] != "food" && bits[1] != "armours" &&
             bits[1] != "weapons" && bits[1] != "amulets" &&
             bits[1] != "monster" && bits[1] != "music" &&
             bits[1] != "plants" && bits[1] != "rings" &&
             bits[1] != "furnitures" && bits[1] != "jewellery" &&
             bits[1] != "wands")) {
            bing->file = base_name(environment(this_player()));
         }
      }
      if (pointerp(obj[0]->query_name()))  { /* doors */
         name = (obj[0]->query_name())[0];
      } else {
         name = obj[0]->query_name();
      }
      if (!name) {
         name = "<Bad name>";
      }
      short = obj[0]->query_short();
      if (!short) {
         short = "<Bad short>";
      }
      info = sprintf("Name: %s, Short: %s\n\n", name, short);
      break;
   }
   bing->error = "OBJECT " + _error_type + " " + str;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}                               /* bug_object() */

/** @ignore yes */
void end_of_edit(string body)
{
   if (strlen(body)) {
      int ending;
      string name,
        trace = 0;
      mapping last_error;
      class errors bing;

      bing = _globals[this_player()];
      if (bing->extra) {
         body = bing->extra + body;
      }
      if (body[<1] != '\n') {
         ending = 1;
      }
      if (environment(this_player())) { // && bing->type != ROOM_BUG) {
         if (ending) {
            body += "\n";
            ending = 0;
         }
         body += sprintf("\nEnvironment: %s (%s)\n",
                         file_name(environment(this_player())),
                         environment(this_player())->short());
      }
      if (_use_last_error) {
         last_error = (mapping) this_player()->get_last_error();
         if (mapp(last_error)) {
            trace = (string) master()->standard_trace(last_error, 1);
            this_player()->set_last_error(0);
         }
      }

      if (ending) {
         body += "\n";
      }
      name = (string) this_player()->query_name();
      SMART_LOG->smart_log(bing->error, name, body, trace, bing->file);
      printf("Thank you for your %s report.\n", lower_case(_error_type));
   } else {
      printf("Not saving %s report, aborting.\n", lower_case(_error_type));
   }
   map_delete(_globals, this_player());
}                               /* end_of_edit() */

/** @ignore yes */
int clean_up()
{
   return 0;
}                               /* clean_up() */

/** @ignore yes */
void reset()
{
}                               /* reset() */

/** @ignore yes */
mixed *query_patterns()
{
   return ({ "command <string'name'>", (: bug_command($4[0]) :),
             "replies", (: bug_replies(0) :),
             "replies new", (: bug_replies(1) :),
             "web <string'url'>", (: bug_web($4[0]) :),
             "spell <string'name'>", (: bug_spell($4[0]) :),
             "spell {generic|wizards|witches}", (: bug_spell_file("/obj/spells/" + $4[0], $4[0]) :),
             "spell new", (: bug_spell_file("/obj/spells/generic", "generic") :),
             "object new",
             (: bug_object_new("new") :),
             "object name <string'name'>",
             (: bug_object_new($4[0]) :),
             "object <indirect:object:me-here'name of NPC or item'>",
             (: bug_object($1, $4[0]) :),
             "ritual <string'name'>", (: bug_ritual($4[0]) :),
             "ritual generic", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "ritual new", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "help <string'subject'>", (: bug_help($4[0]) :),
             "help", (: bug_help("") :),
             "soul <string'soul command'>", (: bug_command($4[0]) :),
             "soul new", (: bug_soul(0) :),
             "room", (: bug_room() :),
             "special {" +
               implode(filter(get_dir("/d/special/"),
                              (: file_size("/d/special/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_special($4[0]) :),
             "misc {" +
               implode(filter(get_dir("/obj/"),
                              (:  file_size("/obj/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_misc($4[0]) :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/report_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/base.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627052   Available: 13574406
Inodes: Total: 5242880    Free: 4960132
940 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627052   Available: 13574406
Inodes: Total: 5242880    Free: 4960132
2025-03-06 17:40:58.212488726 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// -*- LPC -*-
// /lib/cmds/base.c - Base command handler for Archaon MUD
// Purpose: Foundation for all command objects
// Last updated: March 07, 2025, 04:45 AM AEST

#include <config.h>
#include <log.h>
#include <command.h>

inherit "/std/object";

private string command_name;
private object user;
private string fail_message;

void create() {
    ::create();
}

void setup_cmd(string cmd, object who) {
    command_name = cmd;
    user = who;
}

void set_fail_message(string msg) {
    fail_message = msg;
}

object query_user() {
    return user;
}

string query_command_name() {
    return command_name;
}

void fail_msg() {
    if (fail_message) {
        tell_object(user, fail_message);
    } else {
        notify_fail("You fail to " + command_name + " in Faern.\n");
    }
}

int do_cmd(string str) {
    fail_msg();
    return 0;
}

void notify_usage() {
    tell_object(user, "Usage: " + command_name + " <arguments>\n");
}
// --- END [/mnt/home2/grok/lib/cmds/base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/errors_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/errors_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627052   Available: 13574406
Inodes: Total: 5242880    Free: 4960132
17837 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/errors_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627052   Available: 13574406
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Hey Emacs, this is -*- LPC -*- ! */
/* $Id: errors_base.c,v 1.5 2001/06/02 03:28:17 presto Exp pinkfish $ */

/**
 * This is the low level error database inheritable.  It handles all such
 * annoying things as connecting to the server and sending the queries.
 * There are 2 levels of functions, you can do your own queries or
 * leave the details to this object.
 * The errors database contains the following fields in the errors table:
 * <UL>
 * <LI>Id - The unique identifier for a report
 * <LI>DirEntryDate - The date the report was entered into the directory
 *     (changes when forwarded)
 * <LI>EntryDate - The date the report was made in time() format
 * <LI>FixDate - The date the report was fixed or marked otherwise in time()
 *     format
 * <LI>Directory - The directory the report belongs to
 * <LI>Filename - The filename of the object the report was made on
 * <LI>Category - The category the report belongs to, one of 'ROOM', 'OBJECT',
 *     'RITUAL', 'SPELL', 'HELP', or 'COMMAND'
 * <LI>Type - The type of the report, one of 'TYPO', 'BUG' or 'IDEA'
 * <LI>Name - The name of the object
 * <LI>Reporter - The name of the person who made the report
 * <LI>Fixer - The name of the person who fixed the report or otherwise marked
 *     it
 * <LI>Status - The status of the report, one of 'OPEN', 'FIXING',
 *     'CONSIDERING', 'DENIED', or 'FIXED'
 * <LI>Report - The text of the report as typed by the reporter
 * <LI>Runtime - The runtime error that may or may not(!) relate to the
 *     report
 * </UL>
 * There are is also a separate table for forwards, which has the following
 * fields:
 * <UL>
 * <LI>Id - The bug report id the forward belongs to
 * <LI>ForwardDate - The date the report was forwarder in time() format
 * <LI>Forwarder - The name of the person who forwarded the report
 * <LI>OldDirectory - The directory the report belonged to before forwarding
 * </UL>
 * Finally, a table for comments exists with the following fields:
 * <UL>
 * <LI>Id - The bug report id the comment belongs to
 * <LI>CommentDate - The date someone made a comment on the report in time()
 *     format
 * <LI>Commenter - The name of the person who commented on the report
 * <LI>Comment - The comment about the report
 * </UL>
 * @author Turrican
 */

#include <db.h>
#include <log.h>
#include <config.h>

/** @ignore yes */
private class _report {
  int row;
  string newstatus;
  string newdir;
  string newtype;
  int changed;
}

/** @ignore yes */
private class _bugs {
  int fd;
  mapping errors;
  int *rows;
  string *fieldnames;
  int changed;
}

#define FD ((class _bugs)globvars[key])->fd
#define ERRORS ((class _bugs)globvars[key])->errors
#define ROWS ((class _bugs)globvars[key])->rows
#define FIELDNAMES ((class _bugs)globvars[key])->fieldnames
#define CHANGED ((class _bugs)globvars[key])->changed

private nosave mapping globvars;

protected varargs mixed get_row(mixed key, int row, int nomap);

/**
 * This method initializes some state variables and connects to the errors
 * database.
 * @param key the unique key to use for the global variables
 * @param user the username used to connect to the database
 * @param replace set to 1 if an existing key should be replaced
 * @return 0 for succes, an error string for failure
 * @see save_changes()
 * @see finish_errors()
 */
protected varargs string init_errors(mixed key, string user, int replace) {
  string ret;

  if (!mapp(globvars)) {
    globvars = ([ ]);
  } else {
    if (!(replace || undefinedp(globvars[key]))) {
      return "key already in use";
    }
    if (globvars[key]) {
      catch(db_close(FD));
    }
  }
  globvars[key] = new(class _bugs);
  if ((ret = catch(FD = db_connect("localhost", "errors", user)))) {
    map_delete(globvars, key);
    return ret;
  }
  return 0;
} /* init_errors() */

/**
 * This method ends access to the database.  It doesn't save any pending
 * changes.
 * @param key the unique key for the global variables
 * @return 0 for succes, an error string for failure
 * @see init_errors()
 * @see save_changes()
 */
protected string finish_errors(mixed key) {
  string ret;

  if (!classp(globvars[key])) {
    return "unknown key";
  }
  ret = catch(db_close(FD));
  map_delete(globvars, key);
  return ret;
} /* finish_errors() */

/**
 * This method provides direct SQL access to the errors database.  You
 * have to give a valid SQL query.  It returns the number of rows the
 * query returned, which can be fetched using get_row().  For a higher
 * level of access to the database, use get_fields().
 * @param key the unique key for the global variables
 * @param query the SQL query to execute
 * @return the number of rows or an error string
 * @see get_row()
 * @see get_fields()
 */
protected varargs mixed sql_query(mixed key, string query, mixed *args ...) {
  string error;
  mixed ret;

  ERRORS = 0;
  ROWS = 0;
  FIELDNAMES = 0;
  error = catch(ret = db_exec(FD, query, args ...));
  if (error) {
    return error;
  }
  if (stringp(ret)) {
    return ret;
  }
  if (ret) {
    ROWS = allocate(ret + 1, (: $1 :));
  }
  return ret;
} /* sql_query */

/**
 * This method fetches the specified fields from the database.  You should
 * not call this too often as this is a very expensive operation.  Typically
 * it's called once, at the beginning of your object.
 * @param key the unique key for the global variables
 * @param directory the directory to get the reports from
 * @param fields a comma separated list of fields you wish to fetch
 * @return the number of reports that were found or an error string
 * @see get_bug()
 * @see get_forwards()
 * @see get_comments()
 */
protected varargs mixed get_fields(mixed key, string directory,
                                   string fields, string type) {
  string query, temp;
  mixed ret;

  if (!strlen(type)) {
    type = "OPEN";
  }
  ERRORS = 0;
  ROWS = 0;
  FIELDNAMES = 0;
  fields += ", Directory";
  query = sprintf("SELECT %s FROM errors WHERE Directory = '%s' AND "
                  "Status = '%s' ORDER BY DirEntryDate;", fields, directory,
                  type);
  temp = catch(ret = db_exec(FD, query));
  if (temp) {
    return temp;
  }
  if (stringp(ret)) {
    return ret;
  }
  if (ret) {
    ROWS = allocate(ret + 1, (: $1 :));
  }
  return ret;
} /* get_fields() */

/**
 * This method gets the forwarding info for a report in the database.
 * The info is given in a mapping indexed by column name where the
 * values are arrays of the values for the columns, ordered by
 * ForwardDate.
 * @param key the unique key for the global variables
 * @param row the row number to get the forwards for
 * @return a mapping with the forwards or an error string
 * @see get_fields()
 * @see get_comments()
 */
protected mixed get_forwards(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping forwards;
  int fd;

  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  query = sprintf("SELECT ForwardDate, Forwarder, OldDirectory FROM forwards "
                  "WHERE Id = %d ORDER BY ForwardDate;", ret["Id"]);
  err = catch(ret = db_exec(fd, query));
  if (err) {
    catch(db_close(fd));
    return err;
  }
  if (stringp(ret)) {
    catch(db_close(fd));
    return ret;
  }
  if (ret) {
    err = catch {
      int *dates, i;
      string *forwarders, *dirs;
      mixed *vals;

      dates = allocate(ret);
      forwarders = allocate(ret);
      dirs = allocate(ret);
      for (i = 0; i < ret; i++) {
        vals = db_fetch(fd, i + 1);
        dates[i] = vals[0];
        forwarders[i] = vals[1];
        dirs[i] = vals[2];
      }
      forwards = allocate_mapping(3);
      forwards["ForwardDate"] = dates;
      forwards["Forwarder"] = forwarders;
      forwards["OldDirectory"] = dirs;
    };
    if (err) {
      catch(db_close(fd));
      return err;
    }
  }
  catch(db_close(fd));
  return forwards;
} /* get_forwards() */

/**
 * This method gets the comments about a report in the database.
 * The info is given in a mapping indexed by column name where the
 * values are arrays of the values for the columns, ordered by
 * CommentDate.
 * @param key the unique key for the global variables
 * @param row the row number to get the comments for
 * @return a mapping with the comments or an error string
 * @see get_fields()
 * @see get_forwards()
 */
protected mixed get_comments(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping comments;
  int fd;

  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  query = sprintf("SELECT CommentDate, Commenter, Comment FROM comments "
                  "WHERE Id = %d ORDER BY CommentDate;", ret["Id"]);
  err = catch(ret = db_exec(fd, query));
  if (err) {
    catch(db_close(fd));
    return err;
  }
  if (stringp(ret)) {
    catch(db_close(fd));
    return ret;
  }
  if (ret) {
    err = catch {
      int *dates, i;
      string *commenters, *texts;
      mixed *vals;

      dates = allocate(ret);
      commenters = allocate(ret);
      texts = allocate(ret);
      for (i = 0; i < ret; i++) {
        vals = db_fetch(fd, i + 1);
        dates[i] = vals[0];
        commenters[i] = vals[1];
        texts[i] = vals[2];
      }
      comments = allocate_mapping(3);
      comments["CommentDate"] = dates;
      comments["Commenter"] = commenters;
      comments["Comment"] = texts;
    };
    if (err) {
      catch(db_close(fd));
      return err;
    }
  }
  catch(db_close(fd));
  return comments;
} /* get_comments() */

/**
 * This method returns a row of information from the database.  Note that
 * you get the original, not a copy, so any changes you make to the row
 * will also be reflected in a later get_row().  If you don't want this,
 * just make a copy(). The row consists of a mapping with the column names
 * being the keys.
 * @param key the unique key for the global variables
 * @param number the row number of the bug report
 * @param nomap set to 1 if the real row number is given
 * @return a row from the database or an error string
 * @see get_fields()
 * @see efun::copy()
 */
protected varargs mixed get_row(mixed key, int row, int nomap) {
  mixed *res;
  string ret, *keys;
  mapping rowvals;
  
  if (!arrayp(FIELDNAMES)) {
    /* Fetch the field names. */
    ret = catch(res = db_fetch(FD, 0));
    if (ret)
      return ret;
    keys = res;
    FIELDNAMES = res;
  } else {
    keys = FIELDNAMES;
  }
  if (!nomap) {
    row = ROWS[row];
  }
  /* Get the actual values of the row. */
  ret = catch(res = db_fetch(FD, row));
  if (ret)
    return ret;
  /* Put them in a mapping. */
  if (sizeof(keys) != sizeof(res)) {
    return "Database engine lost results(?)\n";
  }
  rowvals = allocate_mapping(keys, res);
  return rowvals;
} /* get_row() */

/**
 * This method changes the status of a bug report.  In the old system
 * it would delete the bug.
 * @param key the unique key for the global variables
 * @param row the row number to change the status of
 * @param status the new status of the report
 * @return 1 for succes, 0 for failure
 */
protected int set_status(mixed key, int row, string status) {
  int realrow = ROWS[row];
  
  /* Currently, this can't fail because of missing commit/rollback
     facilities in MySQL. We only actually save this later on. */
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  if (!classp(ERRORS[realrow])) {
    ERRORS[realrow] = new(class _report, row : realrow);
  }
  ((class _report)ERRORS[realrow])->newstatus = status;
  ((class _report)ERRORS[realrow])->changed = 1;
  ROWS = delete(ROWS, row, 1);
  CHANGED = 1;
  return 1;
} /* set_status() */

/**
 * This method changes the type of a bug report.
 * Possible types are 'IDEA', 'BUG' and 'TYPO'.
 * @param key the unique key for the global variables
 * @param row the row number to change the type of
 * @param type the new type of the report
 * @return 1 for succes, 0 for failure
 */
protected int set_type(mixed key, int row, string type) {
  /* Currently, this can't fail because of missing commit/rollback
     facilities in MySQL. We only actually save this later on. */
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  row = ROWS[row];
  if (!classp(ERRORS[row])) {
    ERRORS[row] = new(class _report, row : row);
  }
  ((class _report)ERRORS[row])->newtype = type;
  ((class _report)ERRORS[row])->changed = 1;
  CHANGED = 1;
  return 1;
} /* set_type() */

/**
 * This method forwards the bug report to a different directory.
 * @param key the unique key for the global variables
 * @param row the row number of the bug to forward
 * @param directory the name of the new directory
 * @return 1 for succes, 0 for failure
 */
protected int forward_bug(mixed key, int row, string directory) {
  int realrow = ROWS[row];

  /* Currently, this can't fail because of missing commit/rollback
     facilities in MySQL. We only actually save this later on. */
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  if (!classp(ERRORS[realrow])) {
    ERRORS[realrow] = new(class _report, row : realrow);
  }
  while (directory[<1] == '/') {
    directory = directory[0..<2];
  }
  ((class _report)ERRORS[realrow])->newdir = directory;
  ((class _report)ERRORS[realrow])->changed = 1;
  ROWS = delete(ROWS, row, 1);
  CHANGED = 1;
  return 1;
} /* forward_bug() */

/**
 * This method stores a comment about the report.
 * Unlike most other methods, this is immediately saved in the
 * comments table!
 * @param key the unique key for the global variables
 * @param row the row number of the bug to forward
 * @param who the name of the commenter
 * @param comment the text of the comment
 * @return 0 for succes, an error string for failure
 */
protected string comment_bug(mixed key, int row, string who, string comment) {
  string query, err;
  int fd;
  mixed ret;

  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  comment = db_escape(comment);
  query = sprintf("INSERT LOW_PRIORITY INTO comments VALUES "
                  "(%d, %d, '%s', '%s');",
                  ret["Id"], time(), who, comment);
  err = catch(ret = db_exec(fd, query));
  if (stringp(ret)) {
    err = ret;
  }
  catch(db_close(fd));
  return err;
} /* comment_bug() */

/** @ignore yes */
private string save_status(mixed key, int *ids, string user, string status) {
  string query, ret, err;
  mixed res;

  ret = "";
  if (sizeof(ids)) {
    if (sizeof(ids) == 1) {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id = %d;", status,
                      time(), user, ids[0]);
    } else {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id IN (%s);", status,
                      time(), user, implode(ids, (: "" + $1 + ", " + $2 :)));
    }
    err = catch(res = db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  return ret;
}

/**
 * This method saves any pending changes into the database.
 * @param key the unique key for the global variables
 * @param user the name of the person who made the changes
 * @return 0 for succes, an error string for failure
 * @see finish_errors()
 * @see init_errors()
 */
protected string save_changes(mixed key, string user) {
  class _report *reports, report;
  string query, *queries, ret, err;
  int *ids_fixed, *ids_denied, *ids_fixing, *ids_considering, *ids_open, ftime;
  mixed res, row;

  if (!CHANGED) {
    return 0;
  }
  reports = filter(values(ERRORS), (: ((class _report)$1)->changed :));
  ids_fixed = ids_denied = ids_fixing = ids_considering = ids_open = queries = ({ });
  ret = "";
  foreach (report in reports) {
    row = get_row(key, report->row, 1);
    if (stringp(row)) {
      ret += row;
      continue;
    }
    switch (report->newstatus) {
    case "FIXED":
      ids_fixed += ({ row["Id"] });
      break;
    case "DENIED":
      ids_denied += ({ row["Id"] });
      break;
    case "FIXING":
      ids_fixing += ({ row["Id"] });
      break;
    case "CONSIDERING":
      ids_considering += ({ row["Id"] });
      break;
    case "OPEN":
      ids_open += ({ row["Id"] });
      break;
    case 0:
    case "":
      if (report->newdir) {
        ftime = time();
        query = sprintf("UPDATE LOW_PRIORITY errors SET Directory = '%s', "
                        "DirEntryDate = %d WHERE Id = %d;",
                        report->newdir, ftime, row["Id"]);
        queries += ({ query });
        query = sprintf("INSERT LOW_PRIORITY INTO forwards VALUES "
                        "(%d, %d, '%s', '%s');",
                        row["Id"], ftime, user, row["Directory"]);
        queries += ({ query });
      }
      if (report->newtype) {
        query = sprintf("UPDATE LOW_PRIORITY errors SET Type = '%s' "
                        "WHERE Id = %d;", report->newtype, row["Id"]);
        queries += ({ query });
      }
      
      break;
    default:
      ret += sprintf("Unknown report status: %s\n", report->newstatus);
      break;
    }
  }
  ret += save_status(key, ids_fixed, user, "FIXED");
  ret += save_status(key, ids_denied, user, "DENIED");
  ret += save_status(key, ids_fixing, user, "FIXING");
  ret += save_status(key, ids_considering, user, "CONSIDERING");
  ret += save_status(key, ids_open, user, "OPEN" );
  foreach (query in queries) {
    err = catch(db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  if (ret == "") {
    ret = 0;
  }
  return ret;
} /* save_changes() */
// --- END [/mnt/home2/grok/lib/cmds/errors_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/position_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/position_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627047   Available: 13574401
Inodes: Total: 5242880    Free: 4960132
11054 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/position_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627047   Available: 13574401
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: position_base.c,v 1.9 2000/09/01 22:06:56 ceres Exp $
 * $Log: position_base.c,v $
 * Revision 1.9  2000/09/01 22:06:56  ceres
 * Made it use pluralize(position) rather than just "s" since that doesn't work for crouches
 *
 * Revision 1.8  2000/09/01 22:03:29  pinkfish
 *  Forcibly unlocked by ceres
 *
 * Revision 1.7  2000/06/09 23:52:38  pinkfish
 * Add in a silent option for putting people onto the floor.
 *
 * Revision 1.6  2000/03/22 00:39:06  taffyd
 * Added sit 'in' items.
 *
 * Revision 1.5  1999/07/06 23:38:18  olorin
 * I can no longer remember if I made any changes
 *
 * Revision 1.4  1998/04/04 18:34:17  pinkfish
 * Fix it up wto work correctly at all times!
 *
 * Revision 1.3  1998/03/26 11:40:53  pinkfish
 * Changes to fix up poroblems with not being able to do some
 * sort of actions
 *
 * Revision 1.2  1998/02/27 17:04:32  pinkfish
 * Handle allowing rooms to selectvely disable commands.
 *
 * Revision 1.1  1998/01/06 05:31:24  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";
#include <position.h>

string position;
string up_down;
string position_type;

int query_position_command() {
   return 1;
} /* query_position_command() */

string query_up_down() {
   return up_down;
} /* query_up_down() */

string query_position() {
   return position;
} /* query_position() */

string query_position_type() {
   return position_type;
} /* query_position_type() */

void setup_position(string pos, string up, string type) {
   position = pos;
   up_down = up;
   position_type = type;
} /* setup_position() */

int position(object person, int silent) {
   string pos_type;

   if (person->query_position() == position_type) {
      if (person == this_player()) {
         add_failed_mess("You are already "+position_type+".\n");
      }
      return 0;
   }

   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }

   if (!silent) {
      if (up_down != "") {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position+" " + up_down +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
                      person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$ "  + up_down +
                      " " + pos_type + " " +
                      person->query_position_on_short() + ".\n",
                      ({ person }));
         } else {
            tell_object(person, "You " + position+" " + up_down + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + "," +
                      position+"$V$ " +
                      up_down + ".\n",
                      ({ person }));
         }
      } else {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                             "$V$ " + pos_type + " " +
                             person->query_position_on_short() + ".\n",
               ({ person }));
         } else {
            tell_object(person, "You " + position + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$.\n",
               ({ person }));
         }
      }
   }
   person->set_position(position_type);
   return 1;
} /* position() */

int position_floor(object person, int silent) {
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
 
   if (person->query_position_on()) {
      if (!silent) {
         if (up_down != "") {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + " " + up_down + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + up_down + ".\n",
                ({ person }));
         } else {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$.\n",
                ({ person }));
         }
      }
      person->set_position(position_type);
      person->set_position_on(0);
      person->set_position_type(0);
      person->set_position_multiple(0);
      return 1;
   }
   return position(person, 0);
} /* position_floor() */

string *query_position_strings(object person) {
   string bit;
   string bit_other;

   switch (person->query_position_type()) {
      case AT_TYPE :
      case BESIDE_TYPE :
         bit = "move away from";
         bit_other = "moves away from";
         break;

      case ON_TYPE :
      default :
         bit = "get off";
         bit_other = "gets off";
         break;
   }
   return ({ bit, bit_other });
} /* query_position_strings() */

int position_object(object *obs, string pos_type, object person) {
   int i;
   int mult;
   string rabbit;
   string *pos_strings;

   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
 
   pos_strings = query_position_strings(person);

   for (i = 0; i < sizeof(obs); i++) {
      if (obs[i]->query_property(CAN_POSITION_PROPERTY)) {
         mult = obs[i]->query_property(MULTIPLE_POSITION_PROPERTY);
         if (person->query_position_on()) {
            if (person->query_position_on() == obs[i] &&
                person->query_position_type() == pos_type) {
               if (person->query_position() != position_type) {
                  return position(person, 0);
               }
               if (person == this_player()) {
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
               }
               return 0;
            }
            tell_object(person, "You " + pos_strings[0] + " " +
                person->query_position_on_short() +
                " and " + position + " " + pos_type+" "+
                obs[i]->a_short()+".\n");
            tell_room(environment(person),
                person->one_short() + " " + pos_strings[1] + " " +
                person->query_position_on_short() +
                      
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + pos_type + " " +
                obs[i]->a_short() + ".\n",
                ({ person }));
            person->set_position(position_type);
            person->set_position_on(obs[i]);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
         tell_object(person, "You " + position + " " + pos_type +
                             " " + obs[i]->a_short()+".\n");
         tell_room(environment(person),
                   person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                   "$V$ " + pos_type + " " +
                   obs[i]->a_short() + ".\n",
                   ({ person }));
         person->set_position(position_type);
         person->set_position_on(obs[i]);
         person->set_position_type(pos_type);
         person->set_position_multiple(mult);
         return 1;
      } else  {
         rabbit = obs[i]->query_position_string(position_type);
         if (rabbit) {
            mult = obs[i]->query_position_multiple(position_type);
            if (person->query_position_on()) {
               if (person->query_position_on() == rabbit &&
                   person->query_position_type() == pos_type) {
                  if (person->query_position() != position_type) {
                     return position(person, 0);
                  }
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
                  return 0;
               }
               tell_object(person, "You " + pos_strings[0] +  " " +
                   person->query_position_on_short() +
                   " and " + position + " " + pos_type + " " +
                   rabbit + ".\n");
               tell_room(environment(person),
                         person->one_short() + " " + pos_strings[1] + " " +
                         person->query_position_on_short() +
                         " and $V$0=" + pluralize(position) + ","+position+"$V$ " +
                         pos_type + " " +
                         rabbit + ".\n",
                         ({ person }));
               person->set_position(position_type);
               person->set_position_on(rabbit);
               person->set_position_type(pos_type);
               person->set_position_multiple(mult);
               return 1;
            }
            tell_object(person, "You "+position+" " + pos_type + " " +
                                 rabbit + ".\n");
            
            tell_room(environment(person),
                person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                      "$V$ "+pos_type + " " +rabbit + ".\n",
                      ({ person }));
            person->set_position(position_type);
            person->set_position_on(rabbit);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
      }
   }
   return 0;
} /* position_object() */

mixed *query_patterns() {
   return ({ "", (: position(this_player(), 0) :),
             "on [the] floor", (: position_floor(this_player(), 0) :),
             "{on|at|in|beside} <indirect:object>",
                    (: position_object($1, $4[0], this_player()) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/position_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/bug_replies.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/bug_replies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627044   Available: 13574398
Inodes: Total: 5242880    Free: 4960132
9734 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/bug_replies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627044   Available: 13574398
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: bug_replies.c,v 1.10 2003/07/08 06:55:58 pinkfish Exp $ 
 */
/**
 * THis is the base object for handleing error replies.
 * @author Pinkfish
 * @started Fri Feb 14 11:50:29 PST 2003
 */

#include <error_handler.h>
#include <db.h>
#include <nroff.h>

#define HELP_FILE "/doc/helpdir/bug_replies"

class player_data {
   int position;
   int date;
   class error_replies* replys;
}

nosave private mapping _player_replies;

void print_menu_input();

void create() {
   _player_replies = ([ ]);
}

void print_bug_replies(object player) {
   string str;
   class error_replies* replies;
   int i;
   int pos;

   replies = _player_replies[player]->replys;
   if (!sizeof(replies)) {
      tell_object(player, "No bug replies.\n");
      return ;
   }
   pos = _player_replies[player]->position;
   str = "";
   for (i = 0; i < sizeof(replies); i++) {
      if (i == pos) {
         str += ">";
      } else {
         str += " ";
      }
      switch (replies[i]->status) {
      case "NEW" :
         str += "N";
         break;
      case "DELETED" :
         str += "D";
         break;
      default :
         str += " ";
         break;
      }
      str += (i+1) + ") " + replies[i]->sender + " Sub: " +
             replies[i]->subject + "\n";
   }
   player->set_finish_func("finish_more_replies", this_object());
   tell_object(player, "$P$Bug replies$P$" + str);
}

void finish_more_replies() {
   print_menu_input();
}

void print_menu(object player) {
   int len;

   len = sizeof(_player_replies[player]->replys);
   if (len == 0) {
      tell_object(player, "[None] QDRULH?<num>: ");
   } else {
      tell_object(player, "[1-" + len + "] QDRULH?<num>: ");
   }
}

void delete_message(int start_pos, int end_pos) {
   int pos;

   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                           "DELETED",
                                           (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "DELETED";
   }
   if (start_pos != end_pos) {
      write("Delete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Delete error reply " + (pos) + ".\n");
   }
}

void undelete_message(int start_pos, int end_pos) {
   int pos;

   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                        "READ",
                                        (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "READ";
   }
   if (start_pos != end_pos) {
      write("Undelete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Undelete error reply " + (pos) + ".\n");
   }
}

int valid_message(int pos) {
   pos--;
   if (pos < 0 || pos >= sizeof(_player_replies[this_player()]->replys)) {
      return 0;
   }
   return 1;
}

void print_menu_input() {
   print_menu(this_player());
   input_to("bug_replies_menu");
}

void read_message(int pos) {
   class error_replies reply;

   pos--;
   reply = _player_replies[this_player()]->replys[pos];
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string("Date Sent: " + ctime(reply->senddate) + "\n"
         "From: " + reply->sender + "\n"
         "Subject: " + reply->subject + "\n\n" +
         reply->message + "\n");

   if (reply->status == "NEW") {
      ERROR_HANDLER->do_status_error_reply(reply->id, "READ", (: 1 :));
      reply->status = "READ";
   }
}

int read_next_new() {
   int i;
   class error_replies* replies;

   replies = _player_replies[this_player()]->replys;
   for (i = 0; i < sizeof(replies); i++) {
      if (replies[i]->status == "NEW") {
         read_message(i + 1);
         return 1;
      }
   }
   write("No new unread error replies.\n");
   return 0;
}

void finish_editing_message(string mess, int pos) {
   class error_replies reply;

   if (!mess || !strlen(mess)) {
      write("Aborting send of message.\n");
   } else {
      reply = _player_replies[this_player()]->replys[pos];
      ERROR_HANDLER->do_add_error_reply(reply->id,
                             this_player()->query_name(),
                             reply->sender,
                             "Re: " + reply->subject,
                             mess);
      write("Sent message to " + reply->sender + "\n");
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}

int reply_message(int pos) {
   write("Replying to message:\n");
   //read_message(pos);
   pos--;
   this_player()->do_edit("", "finish_editing_message", this_object(), 0, pos);
   return 1;
}

void help_command() {
   string nroff_fn;
   string str;

   nroff_fn = HELP_FILE + ".o";
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(HELP_FILE, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string(str);
}

void bug_replies_menu(string inp) {
   int pos;
   int new_pos;
   int end_pos;

   // First strip any start and end spaces.
   while (strlen(inp) && inp[0] == ' ') {
      inp = inp[1..];
   }
   while (strlen(inp) && inp[<1] == ' ') {
      inp = inp[0..<2];
   }
   end_pos = -1;
   // Now figure out what we have here.
   if (!strlen(inp)) {
      if (read_next_new()) {
         return ;
      }
   } else {
      if (inp[0] >= '0' && inp[0] <= '9') {
         // Number!
         while (pos < strlen(inp) && inp[pos] >= '0' && inp[pos] <= '9') {
            pos ++;
         }
         pos = to_int(inp[0..pos-1]);
         if (valid_message(pos)) {
            read_message(pos);
            return ;
         } else {
            write("Message " + pos + " is invalid.\n");
         }
      } else {
         // See if there is a number after us.
         while (pos < strlen(inp) && (inp[pos] < '0' || inp[pos] > '9')) {
            pos++;
         }
         if (pos < strlen(inp)) {
            new_pos = pos + 1;
            while (new_pos < strlen(inp) && inp[new_pos] >= '0' && inp[new_pos] <= '9') {
               new_pos++;
            }
            pos = to_int(inp[pos..new_pos-1]);
            if (inp[new_pos] == '-') {
               // Look for the next spot.
               end_pos = new_pos + 1;
               while (end_pos < strlen(inp) && inp[end_pos] >= '0' && inp[end_pos] <= '9') {
                  end_pos++;
               }
               end_pos = to_int(inp[new_pos + 1..end_pos-1]);
            }
         } else {
            pos = -1;
         }
         switch(lower_case(inp)[0]) {
         case 'q' :
            write("Exiting the system.\n");
            map_delete(_player_replies, this_player());
            return ;
         case 'r' :
            if (valid_message(pos)) {
               if (reply_message(pos)) {
                  return ;
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'd' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     delete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'u' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     undelete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'h' :
         case '?' :
            help_command();
            return ;
         case 'l' :
            print_bug_replies(this_player());
            return ;
         }
      }
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}

void bug_replies_result(int type, mixed* data, object player) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error retrieving replies.\n");
   } else {
      _player_replies[player] = new(class player_data, date : time(), 
                                    replys : data);
      print_bug_replies(player);
      //print_menu(player);
   }
}

/**
 * This method handles printing out any bug replies associated with
 * the player.
 * @param only_new only display new error replies
 */
int bug_replies(int only_new) {
  _player_replies[this_player()] = new(class player_data, date : time(), 
                                replys : ({ }));
   if (ERROR_HANDLER->do_error_replies(this_player()->query_name(), only_new,
                             (: bug_replies_result($1, $2, $(this_player()) ) :))) {
      input_to("bug_replies_menu");
      return 1;
   }
   add_failed_mess("Unable to find the bug replies.\n");
   return 0;
}
// --- END [/mnt/home2/grok/lib/cmds/bug_replies.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/skills.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627042   Available: 13574396
Inodes: Total: 5242880    Free: 4960132
5848 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627042   Available: 13574396
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: skills.c,v 1.7 2002/12/16 11:14:27 taffyd Exp $
 */
#include <skills.h>

inherit "/cmds/guild_base";

void create() {
   ::create();
   set_command_name("skills");
} /* create() */

string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }

    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}

/**
 * This is used for skills which don't have bonuses. eg. languages.
 */ 
string level_to_string( int level ) {
    switch( level ) {
        case 0..15:
            return "novice";
        case 16..30:
            return "apprentice";
        case 31..45:
            return "competent";
        case 46..60:
            return "proficient";
        case 61..75:
            return "skilled";
        case 76..85:
            return "adept";
        case 86..95:
            return "expert";
        default:
            return "master";
    }
} /* level_to_string() */

string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus, rp;
   string str, tp, tmp;

   rp = this_player()->query_role_playing();
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      /* Get the level of the skill at this point */
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      /* Is this part of the tree only a leaf heirachy? */
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      /*
       * If it is not a leaf heirachy, we show the levels and bonuses.
       * Or, if it is a leaf the show the bonuses is the level is
       *    above 0 and the we are not force showing all.
       */
      if (!(only_leaf || o_l) ||
          (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero)))) {
        if(rp) {
          str += sprintf( "%*'| 's%*'.'-s %4s\n",
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ), 
              args[ i ], 
              (no_bonus ? level_to_string(sk) : bonus_to_string( this_player()->query_skill_bonus( tp ) ) ), "" );
        } else {
          str += sprintf( "%*'| 's%*'.'-s %4d " + (no_bonus?"   -\n":"%4d\n"),
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
                          (int)this_player()->query_skill_bonus( tp ) );
        }
      }
      /* It is a leaf heirachy!  No bonuses, no level if this is not a leaf. */
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all 
                                                || ( sk > 5 * lvl ) ) ) {
         /* Generate the lower bits... */
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         /* Only put ourselves in if the list thingy generated something */
         /* Don't generate the list if it is the language heirachy... */
         if ((only_leaf || o_l) && (tmp != "")) {
           if(rp) {
             str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           } else {
             str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           }
         } else
           str += tmp;
      }
   }
   return str;
} /* rec_list() */

int cmd( string word ) {
   int i, rp;
   string result, *bits;
   mixed *args;
   result = "";

   // This is used to give ratty skills etc. during reincarnation.
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }

   rp = this_player()->query_role_playing();
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      if(rp) {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Proficiency" );
      } else {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Level/Bonus" );
      }
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   if(rp) {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Proficiency");
   } else {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Level/Bonus");
   }
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/guild-race/skills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/rearrange.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/rearrange.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627040   Available: 13574394
Inodes: Total: 5242880    Free: 4960132
7827 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/rearrange.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627040   Available: 13574394
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rearrange.c,v 1.5 2002/03/18 09:43:24 terano Exp $
 * $Log: rearrange.c,v $
 * Revision 1.5  2002/03/18 09:43:24  terano
 * Made the message even less open to interpreation, as players are STILL complaining they left points int he pool accidently.
 *
 * Revision 1.4  2000/03/25 06:34:32  taffyd
 * Fixed typo.
 *
 * Revision 1.3  2000/02/22 01:28:11  sin
 * added some logging.
 *
 * Revision 1.2  1998/08/19 10:20:59  pinkfish
 * Make it inherit the correct base.
 *
 * Revision 1.1  1998/01/06 05:27:04  ceres
 * Initial revision
 * 
*/

#include <playerinfo.h>

#define ME_CON points[ this_player() ][ "me_con" ]
#define ME_DEX points[ this_player() ][ "me_dex" ]
#define ME_INT points[ this_player() ][ "me_int" ]
#define ME_STR points[ this_player() ][ "me_str" ]
#define ME_WIS points[ this_player() ][ "me_wis" ]
#define POOL points[ this_player() ][ "pool" ]

inherit "/cmds/guild_base";

mapping points = ([ ]);

int cmd();

void create() {
   ::create();
   set_command_name("rearrange");
} /* create() */

void do_save() {
   int player, here;
   player = this_player()->query_real_con() +
      this_player()->query_real_dex() +
      this_player()->query_real_str() +
      this_player()->query_real_int() +
      this_player()->query_real_wis();
   here = ME_CON + ME_DEX + ME_STR + ME_INT + ME_WIS;
   if (player != here) {
      log_file("BAD_REARRANGE",
         sprintf("%s: %s had %d now has %d\n",
            ctime(time()),
            this_player()->query_name(),
            player, here));
      PLAYERINFO_HANDLER->add_entry(
         this_object(),
         this_player()->query_name(),
         "misc",
         sprintf("rearranged from %d points to %d points", player, here),
         0);
   }
   this_player()->set_con( ME_CON );
   this_player()->set_dex( ME_DEX );
   this_player()->set_int( ME_INT );
   this_player()->set_wis( ME_WIS );
   this_player()->set_str( ME_STR );
   this_player()->remove_known_command( "rearrange" );
   map_delete(points, this_player());
} /* do_save() */

void display_stats() {
   printf( "Con: %d Dex: %d Int: %d Str: %d Wis: %d Pool: %d\n",
         ME_CON, ME_DEX, ME_INT, ME_STR, ME_WIS, POOL );
} /* display_stats() */

int get_stat_bit( string word ) {
   int num;
   string stat;
   word = lower_case( word );
   if ( word == "save" ) {
      if ( POOL ) {
         write( "WARNING: You still have points left in your pool that "
		   "could be used to make your character more powerful. If you "
		   "leave these unspent now, you will not be able to get them again later. "
           "Are you sure you want to save? [y/n] " );
         input_to( "get_check" );
         return 1;
      }
      write( "Saving.\n" );
      do_save();
      return 1;
   }
   if ( word == "quit") {
      write( "Quitting.\n" );
      map_delete(points, this_player());
      return 1;
   }
   if ( word == "reset" ) {
      write( "Resetting to previous arrangement.\n" );
      return cmd();
   }
   if ( sscanf( word, "%s %d", stat, num ) != 2 )
      stat = word;
   if ( !stat || ( stat == "" ) )
      stat = "X";
   if ( num > POOL )
      if ( !POOL ) {
         write( "Cannot add to stat.  Need to add to the pool first.\n" );
         stat = "X";
      } else {
         write( "Pool has only "+ POOL +" points in it.  "+
               "Adding these to stat.\n" );
         num = POOL;
      }
   switch( stat[ 0 ] ) {
      case 'c' :
         if ( ( ME_CON + num ) < 8 ) {
            write( "Cannot set constitution to less than 8.\n" );
         } else
            if ( ( ME_CON + num ) > 23 ) {
               write( "Cannot set constitution to more than 23.\n" );
            } else {
               ME_CON += num;
               POOL -= num;
            }
         break;
      case 'd' :
         if ( ( ME_DEX + num ) < 8 ) {
            write( "Cannot set dexterity to less than 8.\n" );
         } else
            if ( ( ME_DEX + num ) > 23 ) {
               write( "Cannot set dexterity to more than 23.\n" );
            } else {
               ME_DEX += num;
               POOL -= num;
            }
         break;
      case 'i' :
         if ( ( ME_INT + num ) < 8 ) {
            write( "Cannot set intelligence to less than 8.\n" );
         } else
            if ( ( ME_INT + num ) > 23 ) {
               write( "Cannot set intelligence to more than 23.\n" );
            } else {
               ME_INT += num;
               POOL -= num;
            }
         break;
      case 's' :
         if ( ( ME_STR + num ) < 8 ) {
            write( "Cannot set strength to less than 8.\n" );
         } else
            if ( ( ME_STR + num ) > 23 ) {
               write( "Cannot set strength to more than 23.\n" );
            } else {
               ME_STR += num;
               POOL -= num;
            }
         break;
      case 'w' :
         if ( ( ME_WIS + num ) < 8 ) {
            write( "Cannot set wisdom to less than 8.\n" );
         } else
            if ( ( ME_WIS + num ) > 23 ) {
               write( "Cannot set wisdom to more than 23.\n" );
            } else {
               ME_WIS += num;
               POOL -= num;
            }
         break;
      default :
         break;
   }
   display_stats();
   write( "Enter [d|c|i|w|s|save|reset|quit] <num> : " );
   input_to( "get_stat_bit" );
   return 1;
} /* get_stat_bit() */

int get_check( string word ) {
   word = lower_case( word );
   if ( word[ 0 ] != 'y' ) {
      write( "Going back to stat entering.\n" );
      return get_stat_bit( "" );
   }
   do_save();
   write( "Saving.\n" );
   return 1;
} /* get_check() */

int cmd() {
   write( "Rearranging stats.\n\n" );
   points[ this_player() ] = ([ ]);
   ME_CON = (int)this_player()->query_real_con();
   ME_DEX = (int)this_player()->query_real_dex();
   ME_INT = (int)this_player()->query_real_int();
   ME_STR = (int)this_player()->query_real_str();
   ME_WIS = (int)this_player()->query_real_wis();
   POOL = 0;
   if ( ME_CON > 8)  {
      POOL += ME_CON - 8;
      ME_CON = 8;
   }
   if ( ME_DEX > 8) {
      POOL += ME_DEX - 8;
      ME_DEX = 8;
   }
   if ( ME_INT > 8 ) {
      POOL += ME_INT - 8;
      ME_INT = 8;
   }
   if ( ME_STR > 8 ) {
      POOL += ME_STR - 8;
      ME_STR = 8;
   }
   if ( ME_WIS > 8 ) {
      POOL += ME_WIS - 8;
      ME_WIS = 8;
   }
   write( "Type \"c 3\" to add 3 points to your constitution from the pool, "+
         "or \"c -4\" to remove 4 points from constitution and add them to "+
         "the pool.  Use \"save\" to save the current state and quit.  Note "+
         "that \"%^YELLOW%^reset%^RESET%^\" will return you to your "+
         "starting position, while \"%^YELLOW%^quit%^RESET%^\" will quit "+
         "without saving any changes.\n\n" );
   return get_stat_bit( "" );
} /* cmd() */

int teach( object thing ) { return 0; }

/* This is removed form here as documetation exists elswehere
 *( Which is a duplication of this.
string help() {
   return "Syntax: rearrange\n\n"
      "Once during the life of your character you may modify your stats for "
      "free.  Stats normally take values between 8 and 23 and you can "
      "distribute your stats as you choose by typing \"rearrange\" and "
      "following the instructions.  The idea of this command is to give your "
      "character unique strengths.  You should read the help on stats to "
      "find out what each one does and carefully consider your character's "
      "future career as a member of one of the " + mud_name() + " guilds before "
      "using this command.\n\n"
      "See also:\n"
      "    score\n";
} p* help() */

int clean_up() {
  if (sizeof(points))
    return 1;
  ::clean_up();
}

void reset() {
  if (sizeof(points))
    return;
  ::reset();
}

string query_name()
{
  return "Rearrange Command";
}
// --- END [/mnt/home2/grok/lib/cmds/guild-race/rearrange.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/crafts/leatherwork.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/crafts/leatherwork.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627038   Available: 13574392
Inodes: Total: 5242880    Free: 4960132
8906 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/crafts/leatherwork.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627038   Available: 13574392
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: leatherwork.c,v 1.16 2002/12/02 23:26:43 ceres Exp $
 * $Log: leatherwork.c,v $
 * Revision 1.16  2002/12/02 23:26:43  ceres
 * Modified for new skills tree
 *
 * Revision 1.15  2002/06/05 14:36:52  ohdamn
 * Fixed typo
 *
 * Revision 1.14  1999/10/24 12:01:58  taffyd
 * Fixes!
 *
 * Revision 1.13  1999/10/03 17:31:25  taffyd
 * Fixed typo.
 *
 * Revision 1.12  1999/04/05 18:57:06  ceres
 * Modified to use perform_task
 *
 * Revision 1.11  1998/09/22 06:05:00  ceres
 * Missed one.
 *
 * Revision 1.10  1998/09/22 05:53:08  ceres
 * Fixed bug with TM reporting
 *
 * Revision 1.9  1998/08/22 01:42:56  pinkfish
 * Change to the second bersion fo the command base.
 *
 * Revision 1.8  1998/08/19 10:51:00  pinkfish
 * Fix up to work withj the new base object.
 *
 * Revision 1.7  1998/03/14 18:26:49  pinkfish
 * Chnaged to a help file.
 *
 * Revision 1.6  1998/02/06 05:27:05  macchirton
 * board commonroom
 *
 * Revision 1.3  1998/02/02 01:08:19  macchirton
 * Fixed the teaching
 *
 * Revision 1.2  1998/01/24 17:53:16  macchirton
 * Fixed minimum cost problem
 *
 * Revision 1.1  1998/01/06 05:26:23  ceres
 * Initial revision
 * 
*/
#include <money.h>
#include <tasks.h>

#define TEACH_LEVEL 10
#define LEARN_LEVEL 10
#define SKILL "crafts.materials.leatherwork"
#define SKILLS ({ "crafts.materials.leatherwork", \
                  "crafts.materials.needlework" })
/*weaving is closest skill to sewing.*/

#define A_MAX 5
#define C_MAX 100
#define A_COND 5
#define C_COND 25
#define SCALE 50

inherit "/cmds/guild_base";
 
void create() {
   ::create();
   set_nroff_file("leatherwork");
   add_teach_skill(SKILL, 20, 10);
   set_command_name("leatherwork");
} /* create() */ 

int cmd( object *things, int costing ) {
   int bonus, cond, low, max, diff, cost, per, val, award;
   string place;

   if ( !environment( this_player() )->query_property( "leatherwork" )&&
      member_array(1,  (all_inventory(environment(this_player()))->
      query_property("leatherwork"))) == -1 )
      return notify_fail( "You are not in a leatherworking shop, "
            "so you cannot repair anything.\n" );
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) ){
 /* THIS IS WHERE ANY PLACE CHECKING SHOULD GO */
      place = "default";
   }
   if ( sizeof( things ) > 1 )
      return notify_fail( "You can only repair one thing at a time.\n" );
/*
   if (member_array("leather", things[0]->query_material()) != -1) 
*/
   if (things[0]->query_material() != "leather") 
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is not made of leather!  Wrong shop!\n" );
   if ( things[ 0 ]->query_worn_by() )
      return notify_fail( "You should probably remove "+
            (string)things[ 0 ]->the_short() +
            " before you jab yourself with a needle "
            "while trying to patch it up.\n" );
   per = 100 -
    (int)environment( this_player() )->query_discount( this_player() );

   if ( per < 0 )
      per = 0;
   val = (int)this_player()->query_value_in( place );
   if ( place != "default" )
      val += (int)this_player()->query_value_in( "default" );
   low = (int)things[ 0 ]->query_lowest_cond();
   if ( !low )
      low = 1;
   cond = (int)things[ 0 ]->query_cond();
   max = (int)things[ 0 ]->query_max_cond();
   if ( !max )
      max = 1;
   if ( 100 * cond > 98 * max )
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is already in top condition.\n" );
   diff = max - cond;

/* ********** Type 1. not very damaged. simple sewing wil do. */
   if ((100 * diff)/max > 70){
     bonus = (int)this_player()->query_skill_bonus( SKILLS[ 1 ] );
     cost = (( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) / 
       (max * 50) + 13);
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[1],
                                          diff, TM_COMMAND ) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the thread to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
      write( "%^YELLOW%^"+ replace( ({ "As you begin to fix $I, you realise "
            "how to make better use of the materials.", "As you work on $I, "
            "you find that you're able to fix it completely.", "You discover "
            "that you can fix $I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
      
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "You sew up all the holes in "+ (string)things[ 0 ]->the_short() +
            ", bringing it to top condition.\n" );
   else
      write( "You manage to sew up some of the holes in "+ (string)things[ 0 ]->the_short() +
            " but a few pop back open due to poor stitching.\n" );
   write( "The thread and sinew costs you "+
         (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
         (string)things[ 0 ]->a_short() +".\n" );
   return 1;

  }else{
/* ************************************************ */
  bonus = (int)this_player()->query_skill_bonus( SKILLS[ 0 ] );
  cost = ( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) / 
      (max * 3) +123;

   /* if it's too damaged, a patch is needed*/
   if ( !cond ) {
      write( "You begin to work on "+ (string)things[ 0 ]->the_short() +
            " when it falls apart!  It must have been too damaged to fix.\n" );
      say( (string)this_player()->one_short() +" begins to work on "+
            (string)things[ 0 ]->the_short() +" when it falls to scraps!\n" );
      things[ 0 ]->break_me();
      return 1;
   }
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[0],
                                          diff, TM_COMMAND) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the leather to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
     write("%^YELLOW%^"+ replace( ({ "As you begin to cut and sew the "
           "leather patches for $I, you realise how to make better use of "
           "the leather.", "As you work on $I, you find that you're able "
           "to repair it completely.", "You discover that you can repair "
           "$I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "Your patching of "+ (string)things[ 0 ]->the_short() +
            " goes quite well, and you bring it to top condition.\n" );
   else
      write( "You manage to create reasonably good patches for "+
             (string)things[ 0 ]->the_short() +
             ", but the size wasn't quite right, and the stitching doesn't "
             "look like it will hold very well.\n" );
   write( "The repair materials cost you "+
          (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
        (string)things[ 0 ]->a_short() +".\n" );
   return 1;
 }/*endtype of repairs if */
} /* cmd() */

int teach( object thing ) {
   if ( (int)this_player()->query_skill( SKILL ) < TEACH_LEVEL )
      return -1;
   if ( (int)thing->query_skill( SKILL ) < LEARN_LEVEL )
      return -2;
   thing->add_known_command( "leatherwork" ); 
   return 1;
} /* teach() */

mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1, 0) :),
            "cost <indirect:object:me>", (: cmd($1, 1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/guild-race/crafts/leatherwork.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/crafts/fix.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/crafts/fix.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627036   Available: 13574390
Inodes: Total: 5242880    Free: 4960132
8930 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/crafts/fix.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627036   Available: 13574390
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: fix.c,v 1.22 2003/06/07 01:51:38 pinkfish Exp $
 */
#include <money.h>
#include <tasks.h>

#define TEACH_LEVEL 10
#define LEARN_LEVEL 10
#define SKILL "crafts.smithing.black"
#define SKILLS ({ "crafts.smithing.black.weapons", \
                  "crafts.smithing.black.armour", \
                  "crafts.smithing.black.tools" })
#define A_MAX 5
#define C_MAX 100
#define A_COND 5
#define C_COND 25
#define SCALE 50


// These mapp to the SKILLS array up the top.
#define USE_WEAPON_SKILL 1
#define USE_ARMOUR_SKILL 2
#define USE_TOOL_SKILL 3

inherit "/cmds/guild_base";

int query_item_type( object ob );
int query_fix_cost( object player, object smithy, object item, int costing, int max, int cond, int low );
int test_fixed( object item );

/** @ignore yes */
void create() {
   ::create();
   set_nroff_file("fix");
   set_command_name("fix");
   add_teach_skill(SKILL, 10, 10);
} /* create() */

/**
 * This finds the smithy either as an object in the room or as the
 * room itself.
 */
object find_smithy(object player) {
   if (environment(player)->query_property("smithy")) {
      return environment(player);
   }

   foreach (object ob in all_inventory(player)) {
      if (ob->query_smithy()) {
         return ob;
      }
   }
   return 0;
}

/** @ignore yes */
int cmd( object *things, int costing ) {
    int type, bonus, cond, low, max, diff, cost, val, award;
    int new_cost;
    object here, item, fixer;
    string place;

    fixer = this_player();
    here = find_smithy(fixer);

    if ( !here || !here->query_property( "smithy" ) ) {
        add_failed_mess( "You are not in a smithy, so you cannot fix "
            "anything.\n" );
        return 0;
    }

    place = here->query_property( "place" );

    if ( !place || ( place == "" ) )
        place = "default";

    if ( sizeof( things ) > 1 ) {
        add_failed_mess( "You can only fix one thing at a time.\n" );
        return 0;
    }

    item = things[ 0 ];

    type = query_item_type( item );

    if ( !type ) {
      add_failed_mess( "$I is neither armour nor a weapon.\n", things );
      return 0;
    }

    if ( item->query_worn_by() ) {
        add_failed_mess( "You should probably remove $I before making it "
                         "hot and hitting it with a hammer.\n", things );
        return 0;
    }

    if( member_array( "leather", item->query_materials() ) != -1 ) {
      add_failed_mess( "$I would be destroyed if you put it in the fire.\n", 
                       things );
      return 0;
    }
    
    if( member_array( "wool", item->query_materials() ) != -1 ) {
      add_failed_mess( "Putting a woolen item in the fire isn't going "
                       "to improve its condition.\n", 
                       things );
      return 0;
    }
    
    if( item->query_unfixable() ) {
        add_failed_mess( "Sticking $I in a hot forge probably isn't "
            "going to do much for its condition.\n", things );
        return 0;
    }

    bonus = (int)fixer->query_skill_bonus( SKILLS[ type - 1 ] );

    val = (int)fixer->query_value_in( place );

    if ( place != "default" )
        val += (int)fixer->query_value_in( "default" );

    low = (int)item->query_lowest_cond();

    if ( !low )
        low = 1;

    cond = (int)item->query_cond();
    max = (int)item->query_max_cond();

    if ( !max )
        max = 1;

    if ( test_fixed( item ) ) {
        add_failed_mess( "$I is already in top condition.\n", things );
        return 0;
    }

    diff = max - cond;
    cost = query_fix_cost( this_player(), here, item, costing, max, cond, low );

    new_cost = here->generate_cost(cost, 0);
    if (new_cost == -1) {
       return 0;
    }
    if (new_cost) {
       cost = new_cost;
    }

    if ( ( diff > bonus ) && !costing ) {
        diff = ( 150 * diff ) / max;

        switch ( (int)TASKER->perform_task( fixer,
            SKILLS[ type-1 ], diff, TM_COMMAND ) ) {

            case AWARD :
                award = 1;

            case SUCCEED :
                diff = max - cond;
            break;

            default :
                diff = bonus;
        }
    }

    if ( ( val < cost ) &&
         !fixer->query_property( "freelance smith" ) && !costing ) {
        add_failed_mess( "You cannot afford the materials to fix "
            "$I.\n", things );
        return 0;
    }

    if ( costing ) {
      add_succeeded_mess( ({ "To attempt to fix $I, it would probably cost "
        "you about " + MONEY_HAND->money_value_string( cost, place ) +
        ".\n", "" }), things );
        return 1;
    }

    if ( !cond ) {
        add_succeeded_mess( ({ "You begin to work on $I when it breaks!  "
            "It must have been too damaged to fix.\n",
            "$N begin$s to work on $I when it breaks!\n" }), things );
        item->break_me();

        return 1;
    }

    item->adjust_cond( diff );

    /* This allows NPC smithies to work for free and then charge later. */

    if ( !fixer->query_property( "freelance smith" ) ) {
        fixer->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
            place ), place );
        here->generate_cost(cost, 1);
    }

    if ( award ) {
        write( "%^YELLOW%^"+ replace( ({ "As you begin to fix $I, you realise "
            "how to make better use of the materials.", "As you work on $I, "
            "you find that you're able to fix it completely.", "You discover "
            "that you can fix $I more effectively." })[ random( 3 ) ], "$I",
            item->the_short() ) +"%^RESET%^\n" );
    }
    if ( test_fixed( item ) )
        write( "You fix "+ item->the_short() +
        ", bringing it to top condition.\n" );
    else
        write( "You manage to fix "+ item->the_short() +
            " a little, although it's still not in top condition.\n" );

    write( "The repair materials cost you " +
        MONEY_HAND->money_value_string( cost, place ) +".\n" );

    add_succeeded_mess( ({ "", "$N fixes up $I.\n" }), things );
    return 1;
} /* cmd() */

/**
 * This returns whether or not a given item is considered to be 'fixed'
 * or not. This means it is in 98% of its maximum condition.
 * @param item the item to test for fixedness.
 * @return 1 if the item is fixed, 0 if it is not.
 */
int test_fixed( object item ) {
    return ( 100 * item->query_cond() > 98 * item->query_max_cond() );
} /* item() */

/**
 * This method returns the internal type of an item, to determine which
 * skill to use when fixing it.
 * @param item the item to test
 * @return 1 for crafts.smithing.black.weapons, 2 for
 * crafts.smithing.black.armour, 3 for tools
 */
int query_item_type( object ob ) {
// Arf. This is just nasty.
//     return ( ( ob->query_weapon() == 1 ) |
//        ( 1 * ( ob->query_material() == "metal" ) ) ) +
//    /* Could be a living thing, that they're carrying, that's fighting
//       and has been using a weapon... Unlikely, I know, but still... */
//        ( ( 2 * ob->query_armour() ) | ( 2 * ob->query_scabbard() ) );

    if ( ob->query_weapon() == 1 ) {
        return USE_WEAPON_SKILL;
    }

    if ( ob->query_armour() || ob->query_scabbard() ) {
        return USE_ARMOUR_SKILL;
    }

    if ( ob->query_material() == "metal" ) {
        return USE_TOOL_SKILL;
    }

    // Nothing!
    return 0;
} /* query_item_type() */

/**
 * This method is used to determine how much to give a rough
 * estimate as to how much it will cost to fix a given item.
 * @param player the person doing the fixing
 * @param item the item being fixed
 * @param costing whether or not the cost to fix is being estimated
 * @param max the maximum condition of the item (optional)
 * @param cond the current condition of the item (optional)
 * @param low the lowest condition of the item (optional)
 * @return the cost in brass coins to repair the item
 */
int query_fix_cost( object player, object smithy, 
                            object item, int costing, int max, int cond, int low ) {
    int cost, diff, per;

    if ( !max )
        max = item->query_max_cond();

    if ( !cond )
        cond = item->query_cond();

    if ( !low )
        low = item->query_lowest_cond();


    diff = max - cond;

    per = 100 - smithy->query_discount( player );

    if ( per < 0 )
        per = 0;

    cost = ( diff * sqrt( item->query_full_value() ) ) / max;
    cost *= A_MAX + ( C_MAX * ( max - low ) ) / max;
    cost *= A_COND + ( C_COND * ( cond - low ) ) / ( cond + !cond );
    cost /= SCALE;

    if ( costing ) {
        cost *= 2;
    }
    else {
        cost += roll_MdN( 4, cost / 4 );
    }

    cost = ( cost * per ) / 100;

    if ( cost < 100 ) {
        cost = 100;
    }

    return cost;
} /* query_fix_cost() */

/** @ignore yes */
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1, 0) :),
            "cost <indirect:object:me>", (: cmd($1, 1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/guild-race/crafts/fix.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/crafts/duplicate.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/crafts/duplicate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627033   Available: 13574387
Inodes: Total: 5242880    Free: 4960132
2860 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/crafts/duplicate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627033   Available: 13574387
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: duplicate.c,v 1.3 2000/06/23 03:40:56 pinkfish Exp $
 * $Log: duplicate.c,v $
 * Revision 1.3  2000/06/23 03:40:56  pinkfish
 * Fix up the references to find_match.
 *
 * Revision 1.2  1998/08/19 10:51:00  pinkfish
 * Fix up to work withj the new base object.
 *
 * Revision 1.1  1998/01/06 05:26:23  ceres
 * Initial revision
 * 
*/
#include <artifacts.h>
#include <move_failures.h>

#define COST 50
#define LEVEL 100
#define SHAPING "crafts.pottery.forming.shaping"
#define SMITHING "crafts.smithing"
#define TURNING "crafts.carpentry.turning"
#define WHITTLING "crafts.carpentry.whittling"

inherit "/cmds/guild_base";
inherit "/std/basic/cute_look";

void create() {
   ::create();
   set_nroff_file("duplicate");
} /* create() */

int cmd( object* things) {
   int i, bonus;
   object form;
   mapping map;
 
   for ( i = 0; i < sizeof( things ); i++ ) {
      if ( !function_exists( "query_artifact_type", things[ i ] ) ) {
         write( "You cannot duplicate "+  things[ i ]->the_short() +".\n" );
         continue;
      }
      if ( (int)this_player()->query_specific_gp( "crafts" ) < COST ) {
         write( "You don't have enough guild points to duplicate "+
               things[ i ]->the_short() +".\n" );
         continue;
      }
      switch( (string)things[ i ]->query_artifact_type() ) {
       case "wand" :
         bonus = (int)this_player()->query_skill_bonus( TURNING );
         break;
       default :
         write( "Oops, something went wrong with "+ things[ i ]->the_short() +
               ".  Please contact a creator.\n" );
        continue;
      }
      if ( bonus < LEVEL ) {
         write( "Your skill is insufficient to make a form from "+
               things[ i ]->the_short() +".\n" );
         continue;
      }
      this_player()->adjust_gp( -COST );
      switch ( (string)things[ i ]->query_artifact_type() ) {
       case "wand" :
         form = clone_object( "/obj/weapon" );
         break;
      }
      map = (mapping)things[ i ]->query_static_auto_load();
      if ( !m_sizeof( map ) ) {
         map = (mapping)things[ i ]->int_query_static_auto_load();
         form->init_static_arg( map );
      } else
      form->init_static_arg( map[ "::" ] );
      map = (mapping)things[ i ]->query_dynamic_auto_load();
      form->init_dynamic_arg( map[ "::" ] );
      form->set_enchant( 0 );
      form->set_value_info( "artifact", 0 );
      if ( bonus < LEVEL + random( LEVEL ) )
         form->remove_property( "artifact form" );
      write( "You duplicate a form from "+ things[ i ]->the_short() +".\n" );
      if ( (int)form->move( this_player() ) != MOVE_OK )
         form->move( environment( this_player() ) );
   }
   return 1;
} /* cmd() */

mixed *query_pattern() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/guild-race/crafts/duplicate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/gp.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/gp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627032   Available: 13574386
Inodes: Total: 5242880    Free: 4960132
4112 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/gp.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627032   Available: 13574386
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gp.c,v 1.3 1998/08/19 10:16:36 pinkfish Exp $
 * $Log: gp.c,v $
 * Revision 1.3  1998/08/19 10:16:36  pinkfish
 * Add in stuff to set the command name.
 *
 * Revision 1.2  1998/03/13 16:43:58  pinkfish
 * Make it use the new system of guild help.
 *
 * Revision 1.1  1998/01/06 05:27:04  ceres
 * Initial revision
 * 
*/
/*
 * Original by Manshoon of Newmoon in February 1995
 * Rewritten for Discworld by Deutha in March 1995
 */

/*
 * This command shows a player how many of their guild points are
 * available for use for different commands. With commands using
 * query_specific_gp( string type ) instead of the straight query_gp()
 * the various stupid paradoxes of the old system will be avoided by
 * making sure that a player's available points for a given command
 * depend on the points skill most relevant.
 */

#include <skills.h>

inherit "/cmds/guild_base";

void create() {
   ::create();
   set_nroff_file("gp");
   set_command_name("gp");
} /* create() */

int cmd() {
   int i, gp, max_gp, other_gp;
   gp = (int)this_player()->query_gp();
   max_gp = (int)this_player()->query_max_gp();
   write( "You have "+ gp +" ("+ max_gp +") guild points.\n" );
   for ( i = 0; i < sizeof( STD_SKILLS ); i += SKILL_ARR_SIZE ) {
      other_gp = (int)this_player()->query_skill_bonus( STD_SKILLS[ i ]
            +".points" ) + 50;
      if ( other_gp >= max_gp ) {
         write( "* All of your guild points can be used for "+
               STD_SKILLS[ i ] +" commands.\n" );
         continue;
      }
      if ( gp + other_gp <= max_gp ) {
         write( "* You cannot use any guild points for "+
               STD_SKILLS[ i ] +" commands until\n    your points "+
               "reach "+ ( max_gp - other_gp ) +".\n" );     
         continue;
      }
      write( "* You can use "+ ( gp + other_gp - max_gp ) +" ("+ other_gp +
            ") for "+ STD_SKILLS[ i ] +" commands.\n" );
   }
   return 1;
} /* cmd() */

/*
string help() {
   return "Syntax: gp\n\n"
         "Guild points determine how many times you are able to "
         "perform some action, often using commands or spells given "
         "to you by your guild or other guilds (hence the name).  "
         "The number of guild points that you have depends on your "
         "skill bonus in one of the points skills; for example, a "
         "wizard's guild points will be determined by his bonus in "
         "magic.points, while a fighter's will be determined by "
         "fighting.points.  However, a wizard will not just use "
         "magical commands nor a fighter just use fighting commands, "
         "and the number of times you are able to perform a given "
         "command, just like how well you are able to perform it, "
         "should depend on the most relevant skill, independent of "
         "your guild.  The command \"gp\", then, shows you how many "
         "of your guild points you have available for commands in "
         "each skill category using a system that avoids needing "
         "one type of guild points for every skill category.\n\n"
         "Example:\n\n"
         "> gp\n"
         "You have 276 (338) guild points.\n"
         "* You can use 13 (75) guild points for covert commands.\n"
         "* You cannot use any guild points for faith commands until\n"
         "    your points reach 288.\n"
         "* You can use 245 (307) guild points for fighting commands.\n"
         "* All of your guild points can be used for magic commands.\n\n"
         "See also:\n"
         "  commands, skills, spells\n\n"
         "Credit goes to Manshoon of Newmoon for this solution to "
         "the guild points problem.\n";
} * help() */

/* accompanying function for in /std/living/health.c

int query_specific_gp( string gp_type ) {
   int other_gp;
   if ( !gp_type )
      return 0;
   other_gp = (int)this_object()->query_skill_bonus( gp_type
         +".points" ) + 50;
   if ( other_gp >= max_gp )
      return gp;
   if ( gp + other_gp <= max_gp )
      return 0;
   return gp + other_gp - max_gp;
} query_specific_gp() */
// --- END [/mnt/home2/grok/lib/cmds/guild-race/gp.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/other/judge.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/other/judge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627031   Available: 13574385
Inodes: Total: 5242880    Free: 4960132
9397 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/other/judge.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627031   Available: 13574385
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <tasks.h>
#include <weapon.h>

// Remove this to disable logging to /log/BAD_WEAPONS
// and creator informs when judging
#undef DEBUG

#define COST 25
#define SKILL "other.evaluating.weapons"
#define QUEST_AVE 140
#define QUEST_MAX 300
#define LEARN 5
#define TEACH 50

inherit "/cmds/guild_base";

nosave string *_attack_types = ({ "blunt", "sharp", "pierce" });
nosave string *attacks;

void create() {
    ::create();
    set_nroff_file("judge");
    set_command_name("judge");
    add_teach_skill(SKILL, 50, 5);
} /* create() */

varargs int *calc_rating( object weapon, object player ) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;

    data = (mixed *)weapon->query_attack_data();

    if ( !( size = sizeof( data ) ) )
        return ({ 0, 0 });

    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
      debug_printf("[%s - ave: %d max: %d]\n", data[ i + W_TYPE],
                   ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100,
                   damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ]);
    }

    debug_printf("[%s - ave: %d max: %d]\n", weapon->short(), ave, max );
    return ({ ave, max });
} /* calc_rating() */

void judge_against( object player, object first, object second ) {
  int grain, rating, rating_1, rating_2, difficulty, margin, *data_1,
    *data_2;

  data_1 = calc_rating( first, player );
  data_2 = calc_rating( second, player );
  difficulty = data_1[ 0 ] - data_2[ 0 ];

    if ( difficulty > 0 )
        difficulty = QUEST_AVE - difficulty;
    else
        difficulty = QUEST_AVE + difficulty;

    margin = ( difficulty + ( difficulty * ( data_1[ 1 ] + data_2[ 1 ] ) ) /
        ( 2 * QUEST_MAX ) ) / 2;

    switch ( TASKER->perform_task(this_player(), SKILL, difficulty - 25,
        TM_COMMAND) ) {

        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapons$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to better judge "
                "$weapons$.", "As you inspect $weapons$, you feel a sense "
                "of surety in your judgement." })[ random( 3 ) ], "$weapons$",
                query_multiple_short( ({ first, second }), "the" ) ) +
                "%^RESET%^\n" );

        case SUCCEED:
            break;

        default:
            tell_object( player,
                "You examine "+ query_multiple_short( ({ first, second }),
                    "the" ) + " closely, but you're not sure which is "
                    "better.\n" );
            return;
    }
    grain = sqrt( (int)this_player()->query_skill_bonus( SKILL ) );

    if ( grain > 12 )
        grain = 12;

    rating_1 = QUEST_AVE * data_1[ 1 ] + QUEST_MAX * data_1[ 0 ];
    rating_1 = ( grain * rating_1 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating_2 = QUEST_AVE * data_2[ 1 ] + QUEST_MAX * data_2[ 0 ];
    rating_2 = ( grain * rating_2 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating = rating_1 - rating_2;

    if ( rating > 0 )
        rating++;
    else
        rating--;

    rating = 6 + rating / 2;

    if ( rating > 12 )
        rating = 12;

    if ( rating < 0 )
        rating = 0;

    if ( rating == 6 ) {
        tell_object( player, "You think that " +
            query_multiple_short( ({ first, second }), "the" ) +
            " are exactly the same.\n" );
        return;
    }

    tell_object( player, "You think that " + first->the_short() +" is "+ ({
         "amazingly worse", "extremely worse", "very much worse",
         "much worse", "worse", "a bit worse", "!", "a bit better",
         "better", "much better", "very much better",
         "extremely better", "amazingly better" })[ rating ] +" than "+
         second->the_short() +".\n" );
} /* judge_against() */

int judge_weapon( object player, object weapon ) {
    int grain, rating, margin, *data;
    string res;

    data = calc_rating( weapon, player );
    margin = ( data[ 0 ] + ( data[ 0 ] * data[ 1 ] ) / QUEST_MAX ) / 2;

    switch ( TASKER->perform_task(this_player(), SKILL,  data[ 0 ] + 25,
        TM_COMMAND) ) {

        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapon$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to judge "
                "$weapon$.", "As you inspect $weapon$, you feel a sense of "
                "surety in your judgement." })[ random( 3 ) ], "$weapon$",
                weapon->the_short() ) +"%^RESET%^\n" );

    case SUCCEED:
      break;

    default:
      tell_object( player, "You think that " + weapon->the_short() +
                   " is a good weapon, but you're not sure.\n" );
      return 0;
    }

    grain = sqrt( player->query_skill_bonus( SKILL ) / 2 );

    if ( grain > 14 )
      grain = 14;

    rating = QUEST_AVE * data[ 1 ] + QUEST_MAX * data[ 0 ];
    rating = ( grain * rating + QUEST_AVE * QUEST_MAX ) /
      ( 2 * QUEST_AVE * QUEST_MAX );

    rating += 14 - grain;

    if ( rating > 14 ) {
#ifdef DEBUG
      log_file( "BAD_WEAPON", "%s exceeds weapon specifications, rating is "
                "%d.\n", file_name( weapon ), rating );
#endif
      rating = 14;
      //tell_object( player, "Please inform a creator that " +
      //weapon->the_short() + " exceeds weapon specifications.\n" );
      //return 0;
    }

    // Figure out what special attacks this weapon can do.
    attacks = player->query_known_commands();
    attacks = filter(weapon->query_attack_names(),
                  (: (member_array($1, attacks) != -1) :));
    attacks -= ({ "crush" });
    attacks -= ({ "impale" });
    attacks -= ({ "behead" });

    if(member_array("smash", weapon->query_attack_names()) != -1 &&
       member_array("crush", player->query_known_commands()) != -1)
       attacks += ({ "crush" });
    if(member_array("pierce", weapon->query_attack_names()) != -1 &&
       member_array("impale", player->query_known_commands()) != -1)
       attacks += ({ "impale" });
    if(member_array("slice", weapon->query_attack_names()) != -1 &&
       member_array("behead", player->query_known_commands()) != -1)
       attacks += ({ "behead" });

    res = "You think that "+ weapon->the_short() +" is " + ({
      "an atrocius", "an extremely poor", "a very poor", "a rather poor",
        "a poor", "a pretty poor", "a quite poor", "a reasonable",
        "a quite good", "a pretty good", "a good", "a rather good",
        "a very good", "an extremely good", "an excellent" })[ rating ] +
      " weapon";
    debug_printf("attacks: %O", attacks);
    if(sizeof(attacks))
      res += " that can be used to " + query_multiple_short(attacks, "", 0, 1,
                                                            0);
    res += ".\n";
    tell_object(player, res);
    return rating;
}

int valid_weapon( object player, object ob ) {
  if ( living( ob ) ) {
    if ( ob == player ) {
      add_failed_mess( "You stare at your muscles for a moment, "
                       "and decide that you're more than capable of destroying "
                       "any enemy that decides to interfere with you.\n" );
      return 0;
    }

    add_failed_mess( "You stare at $I for a while, but decide it "
                     "would be better if you considered them instead.\n",
                     ({ ob }) );
    return 0;
  }

  if ( !ob->query_weapon() ) {
    add_failed_mess( "$C$$I is not a weapon.\n", ({ ob }) );
    return 0;
  }

  if(environment(ob) != this_player())
    return add_failed_mess("You can't find $I.\n", ({ ob }));

  return 1;
} /* valid_weapon() */


int cmd( object first, object second ) {
  object *indirect_obs;
  int cost;
  function judge_func;

  if ( !valid_weapon( this_player(), first ) ) {
    return 0;
  }

  cost = COST;

  if ( second ) {
    if ( !valid_weapon( this_player(), second ) ) {
      return 0;
    }

    cost *= 2;

    indirect_obs = ({ first, second });
    judge_func = (: judge_against :);
  } else {
    indirect_obs = ({ first });
    judge_func = (: judge_weapon :);
  }

  if ( this_player()->query_specific_gp( "other" ) < cost ) {
    add_failed_mess( "You can't muster the energy to scrutinise "
                     "$I at the moment.\n", indirect_obs );
    return 0;
  }

  this_player()->adjust_gp( -cost );

  call_out( judge_func, 0, this_player(), first, second );
  add_succeeded_mess( "$N look$s closely at $I.\n", indirect_obs );
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "<indirect:object'weapon'>", (: cmd( $1[0], 0 ) :),
              "<indirect:object:me'weapon'> against <indirect:object:me'weapon'>",
              (: cmd( $1[0][0], $1[1][0] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/guild-race/other/judge.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/other/vurdere.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/other/vurdere.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627029   Available: 13574383
Inodes: Total: 5242880    Free: 4960132
8624 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/other/vurdere.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627029   Available: 13574383
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <clothing.h>
#include <weapon.h>

#define COST 5
#define SKILL "other.evaluating.armour"
#define LEARN_LEVEL 2
#define TEACH_LEVEL 10

inherit "/cmds/guild_base";

void create() {
  ::create();
  set_nroff_file("vurdere");
  set_command_name("vurdere");
  add_teach_skill(SKILL, 10, 2);
} /* create() */

mixed *calc_ac( object ob ) {
  int j;
  string i;
  mapping ac;
  mixed *ret, bit;
  
  ac = (mapping)ob->query_armour_class();
  ret = ({ });
  foreach ( i in keys( ac ) ) {
    if ( member_array( ac[ i ][ A_TYPE ], ({ "blunt",
                                               "sharp", "pierce" }) ) == -1 )
      continue;
    bit = ac[ i ][ A_AC ];
    if( (j = member_array( ac[ i ][ A_TYPE ], ret )) == -1 ) {
      j = sizeof( ret );
      ret += ({ ac[ i ][ A_TYPE ], ({ 0, 0, 0 }) });
    }
    j++;
    if ( intp( bit ) ) {
      ret[ j ][ 1 ] += bit / 2; /* average */
      ret[ j ][ 2 ] += bit; /* maximun */
    } else
      switch ( sizeof( bit ) ) {
      case 1 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += bit[ 0 ];
        ret[ j ][ 2 ] += bit[ 0 ];
        break;
      case 2 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ]);
        break;
      case 3 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ]);
        break;
      default :
        write( "Barf!\n" );
      }
  }
  return ret;
} /* calc_ac() */

int calc_sausage( int sausage, int lvl ) {
  int tmp;
  tmp = 99 - (lvl * 99) / 200;
  if( tmp < 0 )
    tmp = 0;
  return random( sausage ) * tmp / 100 - random( sausage ) * tmp / 100 +
    sausage;
} /* calc_sausage() */

string check_string( int val, int bon ) {
  int dist;
  string s;

  dist = (350 - bon) / 10;
  if( dist > (val < 0 ? -val : val) )
    return " is the same as ";
  if( val > 0 )
    s = "better than ";
  else {
    s = "worse than ";
    val -= val;
  }
  if( !val )
    return " is exactly the same as ";
  if( val < 10 )
    return " is slightly " + s;
  if( val < 20 )
    return " " + s;
  if( val < 40 )
    return " is much " + s;
  return " is amazingly " + s;
} /* check_string() */

int cmd_against( object*from, object *to ) {
  int i, j, k, l, arm_lvl;
  object *ok, *fail;
  mixed *rat, *to_ac, *zip;

  arm_lvl = (int)this_player()->query_skill_bonus( SKILL );

  if(sizeof(from) + sizeof(to) > 10) {
    add_failed_mess("You cannot compare that many items at once.\n");
    return 0;
  }

  i = (COST*(sizeof(from)+sizeof(to)));
  if(this_player()->query_specific_gp("other") < i) {
    add_failed_mess("You cannot concentrate enough to compare these "
                       "items.\n");
    return 0;
  }
  this_player()->adjust_gp( -i);

  to_ac = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( to ); i++ ) {
    if( to[ i ]->query_armour() ) {
      rat = calc_ac( to[ i ] );
      to_ac += ({ to[ i ], rat });
    } else {
      fail += ({ to[ i ] });
      to = delete( to, i, 1 );
      i--;
    }
  }
  if( !sizeof( to ) ) {
    notify_fail( "None of " + query_multiple_short( fail ) +
                 " are armour.\n" );
    return 0;
  }
  fail = ({ });
  ok = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      if( !sizeof( to_ac ) ) {
        fail += ({ from[ i ] });
        continue;
      }
      rat = calc_ac( from[ i ] );
      zip = ({ });
      for( j = 0; j < sizeof( to_ac ); j += 2 ) {
        for( k = 0; k < sizeof( to_ac[ j + 1 ] ); k += 2 ) {
          if( (l = member_array( to_ac[ j + 1 ][ k ], rat )) == -1 ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          
          } else {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( (rat[ l + 1 ][ 0 ] + rat[ l + 1 ][ 1 ] +
                                  rat[ l + 1 ][ 2 ]) / 3 -
                                 (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          }
          
          zip += ({ to_ac[ j + 1 ][ k ] });
        }
        for( k = 0; k < sizeof( rat ); k += 2 ) {
          if( member_array( rat[ 0 ], zip ) ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] +
                                      rat[ j + 1 ][ 2 ]) / 3, arm_lvl ) +
                   to_ac[ j ]->short() + " at " + rat[ j ] + ".\n" );
          }
        }
      }
      if(member_array(from[i], ok) == -1) {
        ok += ({ from[ i ] });
      }
    } else {
      if(member_array(from[i], fail) == -1) {
        fail += ({ from[ i ] });
      }
    }
  }
  if( sizeof( fail ) ) {
    add_failed_mess( "Failed to compare " + query_multiple_short( fail ) +
                 " against " + query_multiple_short( to ) + ".\n" );
    return 0;
  }
  if( sizeof( ok ) ) {
    say( this_player()->query_cap_name() + " looks closely at " +
         query_multiple_short( uniq_array( ok + to ) ) + ".\n" );
  }
  return 1;
} /* cmd_against() */

int cmd_normal( object* from ) {
  int i, j;
  object *ok, *fail;
  mixed *rat, bing;
  string type, *types, *zones;

  ok = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      rat = calc_ac( from[ i ] );
      for( j = 0; j < sizeof( rat ); j += 2 ) {
        bing = (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] + rat[ j + 1 ][ 2 ]) / 3;
        bing /= 5;
        if( bing >= 10 ) {
          bing = 9;
        }
        if( bing < 0 ) {
          bing = 0;
        }
        write( from[ i ]->the_short() + ({ " is terrible",
                                       " is amazingly poor",
                                       " is pretty poor",
                                       " is poor",
                                       " is ok",
                                       " is average",
                                       " is good",
                                       " is very good",
                                       " is extremely good",
                                       " is excellent", })[ bing ] +
                                       " at stopping " + rat[ j ] +
                                       " attacks.\n" );

        ok += ({ from[ i ] });
      }
      if(!arrayp(from[i]->query_type())) {
        types = ({ from[i]->query_type() });
      } else {
        types = from[i]->query_type();
      }
      zones = ({ });
      foreach(type in types) {
        if(CLOTHING_HANDLER->query_equivilant_type(type)) {
          zones += CLOTHING_HANDLER->query_zone_names(CLOTHING_HANDLER->query_equivilant_type(type));
        } else {
          zones += CLOTHING_HANDLER->query_zone_names(type);
        }
      }

      if(!sizeof(zones)) {
      	write(from[i]->the_short() +
              " does not protect any parts of your body.\n");
      } else {
        write(from[i]->the_short() + " protects your " +
              query_multiple_short(zones, "poss") + ".\n");
      }
      continue;
    }
    fail += ({ from[ i ] });
  }
   from = uniq_array( from );

  if( !sizeof( ok ) ) {
    notify_fail( "You failed to vurdere " + query_multiple_short( from ) +
                 ".\n" );
    return 0;
  }
    ok = uniq_array( ok );
  say( this_player()->query_cap_name() + " peers carefully at " +
       query_multiple_short( ok ) + ".\n" );
  return 1;
} /* cmd() */

int teach( object ob ) {
  if( this_player()->query_skill( SKILL ) < TEACH_LEVEL )
    return -1;
  if( ob->query_skill( SKILL ) < LEARN_LEVEL )
    return -2;
  ob->add_known_command( "vurdere" );
  return 1;
} /* teach() */

mixed* query_patterns() {
   return ({ "<indirect:object:me'from'> against <indirect:object:me'to'>",
                (: cmd_against($1[0], $1[1]) :),
             "<indirect:object:me'normal'>",
                (: cmd_normal($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/guild-race/other/vurdere.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild-race/newb_ie.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild-race/newb_ie.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627026   Available: 13574380
Inodes: Total: 5242880    Free: 4960132
3320 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild-race/newb_ie.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627026   Available: 13574380
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newb_ie.c,v 1.14 2003/04/03 11:07:32 wyvyrn Exp $
 */
#include <player.h>
#include <language.h>
#include <cmds/options.h>
#include <newbiehelpers.h>

#define HIST "/obj/handlers/hist_handler"

#define SPAM_PROPERTY "newbie_tell"
#define TIME_OUT     30

#define TIME  0
#define WORDS 1

inherit "/cmds/guild_base";
inherit "/cmds/speech";

int newbie_history(object who);

void create() {
   ::create();
   set_nroff_file("newbie");
   set_command_name("newbie");
} /* create() */

int cmd( string words ) {
   mixed *array;

   if (words == "history") {
      return newbie_history(this_player());    
   }
   
   if ( this_player()->query_mature() &&
        !this_player()->query_creator() &&
        !this_player()->query_property( "newbie helper" ) &&
        !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      
      write( "You are no longer a newbie, being older than " + MATURITY +
             " hours.\n" );
      this_player()->remove_known_command( "newbie" );
      return 1;
   }

   if ( array = this_player()->query_property( SPAM_PROPERTY ) ) {
     if ( array[ WORDS ] == words ) {
       write( "You only said that a few seconds ago, why not wait for a "
         "response?\n" );
       return 1;
     }

     if ( time() < array[ TIME ] ) {
       write( "You only used the newbie channel a few seconds ago, why not "
         "wait for a response?\n" );
       return 1;
     }
   }

   if (this_player()->query_property("gagged")) { //  Added by Obilix 30/3/97
      write("You are gagged!  You will not be able to use the "
            "newbie channel until a creator removes your gag.\n");
      return 1;
   }

   if(this_player()->query_property(SHORTHAND_PROP))
     words = LANGUAGES->fix_shorthand(words);
   words = strip_colours (words); 

   write( "You newbie-tell: "+ words +"\n" );
   
   user_event("newbie", this_player()->query_cap_name() + ": "+words);
   
   HIST->add_chat_history("newbie", this_player()->query_name() + 
                          " newbie-told: ", words);

   if (!this_player()->query_creator() && 
       !this_player()->query_property( "newbie helper") &&
       !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
     this_player()->add_property( SPAM_PROPERTY, ({ time() + 5, words }),
                                  TIME_OUT );
     write( "Please remember: this command is for obtaining assistance; "
            "it is not a chat channel.  If you over use it players "
            "stop listening and you don't get assistance when you "
            "really need it!\n");
   }
   
   return 1;
} /* cmd() */

int newbie_history(object who) {
    mixed *history;
    string result;
    
    history = HIST->query_chat_history("newbie");
    
    if ( !arrayp( history ) || !sizeof( history ) ) {
        tell_object(who, "Nothing has been said on the newbie channel.\n");
    }
    else {
        result = "$P$Newbie Channel$P$";
        result += implode(map(history, (: "$I$5=$C$" + $1[0] + $1[1] +
                    "%^RESET%^" :)), "\n");
        tell_object(who, result);
    }
    
    return 1;
} /* newbie_history() */

mixed *query_patterns() {
    return ({ "<string'message'>", (: cmd($4[0]) :),
              "history", (: cmd("history") :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/guild-race/newb_ie.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/template.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/template.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627025   Available: 13574379
Inodes: Total: 5242880    Free: 4960132
871 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/template.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627025   Available: 13574379
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Help on the commands daemon is available as "help global.command". */

inherit "/cmds/base";

/* The entry point.  This function is what gets called by the commands
   daemon. */

mixed cmd(string args) {
  return 0;
}

/* Return a helpfull text about your command here, or write a nroff
   like document and remove this function. */

string help() {
  return "No help defined for this command, bug a creator about it!\n";
}

/* If your command is going be a guild-race command, you can define
   the following function, so your command is teachable.

int teach(object ob) {
  return 0;
}
*/

/* If you want to use the add_command() parser for your command, define
   the following function.  The default given here does no parsing at all,
   so the above cmd() function would work with it.

mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :) });
}
*/
// --- END [/mnt/home2/grok/lib/cmds/template.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/errors_base2.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/errors_base2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627025   Available: 13574379
Inodes: Total: 5242880    Free: 4960132
15889 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/errors_base2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627025   Available: 13574379
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Hey Emacs, this is -*- LPC -*- ! */
/* $Id: errors_base.c,v 1.5 2001/06/02 03:28:17 presto Exp $ */

/**
 * This is the low level error database inheritable.  It handles all such
 * annoying things as connecting to the server and sending the queries.
 * There are 2 levels of functions, you can do your own queries or
 * leave the details to this object.
 * The errors database contains the following fields in the errors table:
 * <UL>
 * <LI>Id - The unique identifier for a report
 * <LI>DirEntryDate - The date the report was entered into the directory
 *     (changes when forwarded)
 * <LI>EntryDate - The date the report was made in time() format
 * <LI>FixDate - The date the report was fixed or marked otherwise in time()
 *     format
 * <LI>Directory - The directory the report belongs to
 * <LI>Filename - The filename of the object the report was made on
 * <LI>Category - The category the report belongs to, one of 'ROOM', 'OBJECT',
 *     'RITUAL', 'SPELL', 'HELP', or 'COMMAND'
 * <LI>Type - The type of the report, one of 'TYPO', 'BUG' or 'IDEA'
 * <LI>Name - The name of the object
 * <LI>Reporter - The name of the person who made the report
 * <LI>Fixer - The name of the person who fixed the report or otherwise marked
 *     it
 * <LI>Status - The status of the report, one of 'OPEN', 'FIXING',
 *     'CONSIDERING', 'DENIED', or 'FIXED'
 * <LI>Report - The text of the report as typed by the reporter
 * <LI>Runtime - The runtime error that may or may not(!) relate to the
 *     report
 * </UL>
 * There are is also a separate table for forwards, which has the following
 * fields:
 * <UL>
 * <LI>Id - The bug report id the forward belongs to
 * <LI>ForwardDate - The date the report was forwarder in time() format
 * <LI>Forwarder - The name of the person who forwarded the report
 * <LI>OldDirectory - The directory the report belonged to before forwarding
 * </UL>
 * Finally, a table for comments exists with the following fields:
 * <UL>
 * <LI>Id - The bug report id the comment belongs to
 * <LI>CommentDate - The date someone made a comment on the report in time()
 *     format
 * <LI>Commenter - The name of the person who commented on the report
 * <LI>Comment - The comment about the report
 * </UL>
 * @author Turrican
 */

#include <db.h>
#include <log.h>
#include <config.h>

/** @ignore yes */
private class report {
  int row;
  string newstatus;
  string newdir;
  string newtype;
  int changed;
}

/** @ignore yes */
private class bugs {
  //int fd;
  mixed* errors;
  string user;
  int changed;
}

private nosave mapping _globvars;

protected varargs mixed get_row(mixed key, int row, int nomap);

/**
 * This method initializes some state variables and connects to the errors
 * database.  It doesn't do very much now we do not use the
 * internal database methods.
 * @param key the unique key to use for the global variables
 * @param user the username used to connect to the database
 * @param replace set to 1 if an existing key should be replaced
 * @return 0 for succes, an error string for failure
 * @see save_changes()
 * @see finish_errors()
 */
protected varargs string init_errors(mixed key, string user, int replace) {
  string ret;

  if (!mapp(_globvars)) {
    _globvars = ([ ]);
  } else {
    if (!(replace || undefinedp(_globvars[key]))) {
      return "key already in use";
    }
  }
  _globvars[key] = new(class bugs);
  _globvars[key]->user = user;
  _globvars[key]->errors = ([ ]);
  return 0;
} /* init_errors() */

/**
 * This method ends access to the database.  It doesn't save any pending
 * changes.
 * @param key the unique key for the global variables
 * @return 0 for succes, an error string for failure
 * @see init_errors()
 * @see save_changes()
 */
protected string finish_errors(mixed key) {
  string ret;

  if (!classp(_globvars[key])) {
    return "unknown key";
  }
  map_delete(_globvars, key);
  return ret;
} /* finish_errors() */

/**
 * This method is called when the request finishes.
 * @param key the key of the thingy which finished
 */
void event_finished_get_fields(string key) {
} /* event_finished_get_fiels() */

private void finished_get_fields(mixed key, int type, mixed* data) {
   _globvars[key]->errors = data;
   event_finished_get_fields(key);
} /* finished_get_fields() */

/**
 * This method fetches the specified fields from the database.  You should
 * not call this too often as this is a very expensive operation.  Typically
 * it's called once, at the beginning of your object.  This will finish
 * immeditately, a function called 'event_finished_get_fields' will be
 * called that you can do whatever you want with.
 * @param key the unique key for the global variables
 * @param directory the directory to get the reports from
 * @param fields a comma separated list of fields you wish to fetch
 * @return the number of reports that were found or an error string
 * @see get_bug()
 * @see get_forwards()
 * @see get_comments()
 */
protected void get_fields(mixed key, string directory,
                          string fields, string type) {
  string query;
  string temp;
  mixed ret;

  if (!strlen(type)) {
    type = "OPEN";
  }

  _globvars[key]->errors = ({ });

  fields += ", Directory";
  query = sprintf("SELECT %s FROM errors WHERE Directory = '%s' AND "
                  "Status = '%s' ORDER BY DirEntryDate;", fields, directory,
                  type);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_fields($(key), $1, $2) :));
} /* get_fields() */

void event_finish_get_forwards(mixed key, int row) {
} /* event_finish_get_forwards() */

protected void finish_get_forwards(mixed key, int row, int type, mixed* data) {
   _globvars[key]->forwards[row] = data;
   event_finish_get_forwards(key, row);
} /* finish_get_forwards() */

/**
 * This method gets the forwarding info for a report in the database.
 * The info is given in a mapping indexed by column name where the
 * values are arrays of the values for the columns, ordered by
 * ForwardDate.
 * @param key the unique key for the global variables
 * @param row the row number to get the forwards for
 * @return a mapping with the forwards or an error string
 * @see get_fields()
 * @see get_comments()
 */
protected void get_forwards(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping forwards;

  ret = _globvars[key]->errors[row];
  if (_globvars[key]->forwards[row]) {
     return _globvars[key]->forwards[row];
  }
  query = sprintf("SELECT ForwardDate, Forwarder, OldDirectory FROM forwards "
                  "WHERE Id = %d ORDER BY ForwardDate;", ret["Id"]);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_forwards($(key), $(row),
                                     $1, $2) :));
/*
  if (ret) {
    err = catch {
      int *dates, i;
      string *forwarders, *dirs;
      mixed *vals;

      dates = allocate(ret);
      forwarders = allocate(ret);
      dirs = allocate(ret);
      for (i = 0; i < ret; i++) {
        vals = db_fetch(fd, i + 1);
        dates[i] = vals[0];
        forwarders[i] = vals[1];
        dirs[i] = vals[2];
      }
      forwards = allocate_mapping(3);
      forwards["ForwardDate"] = dates;
      forwards["Forwarder"] = forwarders;
      forwards["OldDirectory"] = dirs;
    };
    if (err) {
      //catch(db_close(fd));
      return err;
    }
  }
  //catch(db_close(fd));
  return forwards;
 */
} /* get_forwards() */

void event_finish_get_comments(mixed key, int row) {
} /* event_finish_get_comments() */

protected void finish_get_comments(mixed key, int row, int type, mixed* data) {
   _globvars[key]->comments[row] = data;
   event_finish_get_comments(key, row);
} /* finish_get_comments() */

/**
 * This method gets the comments about a report in the database.
 * The info is given in a mapping indexed by column name where the
 * values are arrays of the values for the columns, ordered by
 * CommentDate.
 * @param key the unique key for the global variables
 * @param row the row number to get the comments for
 * @return a mapping with the comments or an error string
 * @see get_fields()
 * @see get_forwards()
 */
protected void get_comments(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping comments;
  int fd;

  ret = _globvars[key]->errors[row];
  if (_globvars[key]->comments[row]) {
     return _globvars[key]->comments[row];
  }
  query = sprintf("SELECT CommentDate, Commenter, Comment FROM comments "
                  "WHERE Id = %d ORDER BY CommentDate;", ret["Id"]);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_comments($(key), $(row),
                                     $1, $2) :));
} /* get_comments() */

/**
 * This method returns a row of information from the database.  Note that
 * you get the original, not a copy, so any changes you make to the row
 * will also be reflected in a later get_row().  If you don't want this,
 * just make a copy(). The row consists of a mapping with the column names
 * being the keys.
 * @param key the unique key for the global variables
 * @param number the row number of the bug report
 * @return a row from the database or an error string
 * @see get_fields()
 * @see efun::copy()
 */
protected void get_row(mixed key, int row) {
  mixed *res;
  string ret, *keys;
  mapping rowvals;

  return _globvars[key]->errors[row];  
} /* get_row() */

/**
 * This method changes the status of a bug report.  In the old system
 * it would delete the bug.
 * @param key the unique key for the global variables
 * @param row the row number to change the status of
 * @param status the new status of the report
 * @return 1 for succes, 0 for failure
 */
protected int set_status(mixed key, int row, string status) {
  int realrow = ROWS[row];
  
  /* Currently, this can't fail because of missing commit/rollback
     facilities in MySQL. We only actually save this later on. */
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newstatus = status;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
} /* set_status() */

/**
 * This method changes the type of a bug report.
 * Possible types are 'IDEA', 'BUG' and 'TYPO'.
 * @param key the unique key for the global variables
 * @param row the row number to change the type of
 * @param type the new type of the report
 * @return 1 for succes, 0 for failure
 */
protected int set_type(mixed key, int row, string type) {
  /* Currently, this can't fail because of missing commit/rollback
     facilities in MySQL. We only actually save this later on. */
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newtype = status;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
} /* set_type() */

/**
 * This method forwards the bug report to a different directory.
 * @param key the unique key for the global variables
 * @param row the row number of the bug to forward
 * @param directory the name of the new directory
 * @return 1 for succes, 0 for failure
 */
protected int forward_bug(mixed key, int row, string directory) {
  int realrow = ROWS[row];

  /* Currently, this can't fail because of missing commit/rollback
     facilities in MySQL. We only actually save this later on. */
  while (directory[<1] == '/') {
    directory = directory[0..<2];
  }
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newdir = directory;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
} /* forward_bug() */

/**
 * This method stores a comment about the report.
 * Unlike most other methods, this is immediately saved in the
 * comments table!
 * @param key the unique key for the global variables
 * @param row the row number of the bug to forward
 * @param who the name of the commenter
 * @param comment the text of the comment
 * @return 0 for succes, an error string for failure
 */
protected string comment_bug(mixed key, int row, string who, string comment) {
  string query, err;
  int fd;
  mixed ret;

  query = sprintf("INSERT LOW_PRIORITY INTO comments VALUES "
                  "(%d, %d, '%s', '%s');",
                  ret["Id"], time(), who, comment);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query);
  return 0;
} /* comment_bug() */

/** @ignore yes */
private string save_status(mixed key, int *ids, string user, string status) {
  string query, ret, err;
  mixed res;

  ret = "";
  if (sizeof(ids)) {
    if (sizeof(ids) == 1) {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id = %d;", status,
                      time(), user, ids[0]);
    } else {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id IN (%s);", status,
                      time(), user, implode(ids, (: "" + $1 + ", " + $2 :)));
    }
    MYSQL_HANDLER->make_sql_request("errors", USER, "", query);
  }
  return ret;
}

/**
 * This method saves any pending changes into the database.
 * @param key the unique key for the global variables
 * @param user the name of the person who made the changes
 * @return 0 for succes, an error string for failure
 * @see finish_errors()
 * @see init_errors()
 */
protected string save_changes(mixed key, string user) {
  class _report *reports, report;
  string query, *queries, ret, err;
  int *ids_fixed, *ids_denied, *ids_fixing, *ids_considering, *ids_open, ftime;
  mixed res, row;

  if (!CHANGED) {
    return 0;
  }
  reports = filter(values(ERRORS), (: ((class _report)$1)->changed :));
  ids_fixed = ids_denied = ids_fixing = ids_considering = ids_open = queries = ({ });
  ret = "";
  foreach (report in reports) {
    row = get_row(key, report->row, 1);
    if (stringp(row)) {
      ret += row;
      continue;
    }
    switch (report->newstatus) {
    case "FIXED":
      ids_fixed += ({ row["Id"] });
      break;
    case "DENIED":
      ids_denied += ({ row["Id"] });
      break;
    case "FIXING":
      ids_fixing += ({ row["Id"] });
      break;
    case "CONSIDERING":
      ids_considering += ({ row["Id"] });
      break;
    case "OPEN":
      ids_open += ({ row["Id"] });
      break;
    case 0:
    case "":
      if (report->newdir) {
        ftime = time();
        query = sprintf("UPDATE LOW_PRIORITY errors SET Directory = '%s', "
                        "DirEntryDate = %d WHERE Id = %d;",
                        report->newdir, ftime, row["Id"]);
        queries += ({ query });
        query = sprintf("INSERT LOW_PRIORITY INTO forwards VALUES "
                        "(%d, %d, '%s', '%s');",
                        row["Id"], ftime, user, row["Directory"]);
        queries += ({ query });
      }
      if (report->newtype) {
        query = sprintf("UPDATE LOW_PRIORITY errors SET Type = '%s' "
                        "WHERE Id = %d;", report->newtype, row["Id"]);
        queries += ({ query });
      }
      
      break;
    default:
      ret += sprintf("Unknown report status: %s\n", report->newstatus);
      break;
    }
  }
  ret += save_status(key, ids_fixed, user, "FIXED");
  ret += save_status(key, ids_denied, user, "DENIED");
  ret += save_status(key, ids_fixing, user, "FIXING");
  ret += save_status(key, ids_considering, user, "CONSIDERING");
  ret += save_status(key, ids_open, user, "OPEN" );
  foreach (query in queries) {
    err = catch(db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  if (ret == "") {
    ret = 0;
  }
  return ret;
} /* save_changes() */
// --- END [/mnt/home2/grok/lib/cmds/errors_base2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/check.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627021   Available: 13574375
Inodes: Total: 5242880    Free: 4960132
10651 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/check.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627021   Available: 13574375
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Check command
 *  @author Drakkos
 *  @started 18/07/2002 01:56
 *
 */


inherit "/cmds/base";
#include <playtesters.h>

string query_applicant_text();
string pt_protected();

varargs int cmd(string check, string name) {
  object ob = environment (this_player());
  int min, max;
  mixed *chats;
  mixed *chatsd, *chatsn;
  string day, night;
  string ret = "";
  int count;
  mixed *args, *args1; 

  if (ob->query_property ("restrict check")) {
    this_player()->add_failed_mess (this_object(), "The use of the check "
      "command in this room has been restricted.\n", ({ }));
    return 0;
  }
  
  switch (check) {
    case "chats": 
      args= ob->query_room_chats();  
      chatsd = ob->query_room_day_chats();
      chatsn = ob->query_room_night_chats();     
      if (!args && !sizeof (chatsd) && !sizeof (chatsn)) {
        tell_object (this_player(), "There are no chats defined here.\n");
        return 1;
      }
      
      if (args) {      
         min = args[0];
         max = args[1];
         if (!arrayp(args[2])) {
            ret += "%^BOLD%^%^RED%^Error in the room chats!%^RESET%^\n";
            chats = ({ });
         } else {
            chats = args[2];
         }
      } else {
         chats = ({ });
      }
      
      if (sizeof (chats)) {
        ret = "This room has the following chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
          
        for (int i = 0; i < sizeof (chats); i++) {
          if (!stringp(chats[i])) {
             ret += "%^BOLD%^%^RED%^Broken chat setup in room.%^RESET%^\n";
             break;
          }
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
            
      if (sizeof (chatsd)) {
        min = chatsd[0];
        max = chatsd[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room day chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsd[2];
        }
             
        ret += "\n\nThis room has the following day chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
          
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }   
           
      if (sizeof (chatsn)) {
        min = chatsn[0];
        max = chatsn[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room night chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsn[2];
        }
             
        ret += "\n\nThis room has the following night chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
          
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }  
        
    break;
    case "long":
      day = ob->query_day_long();
      night = ob->query_night_long();
        
      ret = "Day long description:\n\n" + day;
      ret += "\n\nNight long description:\n\n" + night;      
    break;
    case "items":
      ob = ob->query_item();
      
      if (!ob) {
        ret = "%^CYAN%^There are no add_items defined in this room.%^RESET%^\n";
      }
      else {
        args = ob->query_shrt();
        args1 = ob->query_lng();
        
        count = sizeof (args);

        ret += "%^YELLOW%^Main items:%^RESET%^\n";
        
        for (int i = 0; i < count; i++) {
          if (!sizeof (args[i])) {
            continue;
          }
          
          ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args1[i]) ?  ("*" + evaluate (args1[i]) + "*") : args1[i]);
          ret += "\n\n";     
        }
        args = ob->query_day_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no day items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Day Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?  
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";       
          }        
        }
        args = ob->query_night_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no night items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Night Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?  
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";       
          }        
        }
      }
    break;
    case "day items":
      args = ob->query_day_items();
      if (!sizeof (args)) {
        ret += "There are no day items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?  
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";       
        }        
      }
    break;    
    case "night items":
      args = ob->query_night_items();
      if (!sizeof (args)) {
        ret += "There are no night items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?  
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";       
        }        
      }    
    break;    
   
    case "protected":
      if (!PLAYTESTER_HAND->query_exec_access(this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "This facility is "
          "available only to PT Executives.\n", ({ }));
        return 0;
      }
      else {
        ret = pt_protected();
      }
    break;
  }    

  write("$P$Items$P$" + ret);
  return 1;
} /* cmd() */

private string time_string( int time_elapsed ) {
    string retval = "";
    int sec = time_elapsed % 60;
    int min = ( time_elapsed / 60 ) % 60;
    int hour = time_elapsed / 3600;

    if ( hour > 0 )
        retval += hour + "h";
    if ( min > 0 )
        retval += min + "m";
    if ( sec > 0 )
        retval += sec + "s";
    if ( sizeof( retval ) == 0 )
        return "0s";

    return retval;
} /* time_string() */


int do_check_quota() {
    string* bits;
    string shortdate;
    int* spam;
    int reports;
    int age;
    int curage;
    mapping spamtoo;

    // see adjust_quota() in /obj/handlers/playtesters.c
    bits = explode( ctime( time() ), " " ) - ({ "" });
    shortdate = bits[ 1 ] + " " + bits[ 4 ];

    spamtoo = PLAYTESTER_HAND->
        query_bugs( this_player()->query_name() );

    if ( mapp( spamtoo ) ) {
        spam = spamtoo[ shortdate ];

        if ( arrayp( spam ) ) {
            reports = spam[ 0 ];
            age = spam[ 1 ];
            curage = PLAYTESTER_HAND->get_age_uncached(this_player()->query_name());
            age += curage - spam[2];

            tell_object( this_player(), "This month (" + shortdate + "), you "
                         "have made " + reports + " report" +
                         ( ( reports == 1 ) ? "" : "s" ) +  " in " +
                         time_string( age ) + " online.\n" );

            //tell_object( this_player(), quota_message( reports, age ) );

            return 1;
        } else {
            tell_object( this_player(), "You cannot check your playtester "
                         "quota.\n" );
            return 1;
        }
    } else {
        tell_object( this_player(), "You cannot check your playtester "
                     "quota.\n" );
        return 1;
    }
}

int cmd_chats(object* obs) {
   mixed* chats;
   string ret;
   int i;
   object ob;

   // Find item and npc chats.
   ret = "";
   foreach (ob in obs) {
      ret += "$I$0=%^YELLOW%^$C$" + ob->the_short() + "%^RESET%^:\n";
      chats = ob->query_chat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_achat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Attack Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_chats();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Item Chats:%^RESET%^ (Min time " + chats[0] + ", "
                "Max time " + chats[1] + ")\n";
         foreach (string story in chats[2]) {
            ret += "$I$6=   " + story + "\n";
         }
      }
   }
   write("$P$Npc/Item chats$P$" + ret);
   return 1;
}

mixed *query_patterns() {
   mixed *patterns = 
    ({ 
      "{chats|long|items|day items|night items|"
        "protected}", (: cmd($4[0]) :),
      "chats <indirect:object>",
        (: cmd_chats :),
      "quota", (: do_check_quota :),             
    });
   
    return patterns;     
} /* query_patterns() */




string pt_protected() {
  object *obs = filter (users(), (: $1->query_playtester() :));
  string ret = "";
  
  obs = filter (obs, (: $1->query_pt_protection() :));
  
  if (!sizeof(obs)) {
    tell_object (this_player(), "No-one is currently using PT Protection.\n");
  }
  else {
    ret += "The following people have PT protection enabled:\n\n";

    foreach (object ob in obs) {
      ret += sprintf ("%s: %s (%s).\n\n", ob->query_name(), 
        environment(ob)->query_short(), base_name (environment (ob)));
    }
  }
  
  return ret;
}
// --- END [/mnt/home2/grok/lib/cmds/playtester/check.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/playtesting.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/playtesting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627018   Available: 13574372
Inodes: Total: 5242880    Free: 4960132
8950 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/playtesting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627018   Available: 13574372
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Playtester interface to the project handler system
 *  @author Drakkos
 *  @started ah... I forget.
 *
 */
 
#include <project_management.h>
#include <playtesters.h>

inherit "/cmds/base";

string format_array (string*);
string get_output (class project*, int);

mapping _globals = ([ ]);
varargs int cmd(string bing, string bong, string proj) {
  class project temp, *tmp = ({ });
  mapping query = ([ ]);
  string *blue, *blah;
  string ret = "";  
  int verbose = 0, i;
  
  if (!PLAYTESTER_HAND->query_tester (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "Only playtesters may "
      "use this command.\n", ({ }));
    return 0;
  }
  
  if (bing == "list" && sizeof (bong)) {
    if (find_object ("/d/" + lower_case (bong) + "/master")) {
      bing = "domain";
    }
    else if (PLAYTESTER_HAND->query_tester (lower_case (bong))) {
      bing = "playtester";
    }
    else {
      bing = "nomatch";
    }
    
  }
         
               
  switch (bing) {
    case "assignments":      
      bong = lower_case (bong);
      blue = PROJECT_HANDLER->query_pt_projects (bong);
      ret = sprintf (capitalize (bong) + " $I$5=%s.\n", (sizeof (blue) ? "is "
      "assigned to the following projects: " + query_multiple_short (blue) :
      "is not currently assigned to any projects"));
    break;      
    case "allassign":
      blue = sort_array (PLAYTESTER_HAND->query_playtesters(), 1);
      foreach (string b in blue) {
        blah = PROJECT_HANDLER->query_pt_projects (b);
        ret += sprintf ("$I$5=%s is assigned to %s.\n",
          capitalize (b), 
          (sizeof (blah) ? query_multiple_short (blah) : "nothing"));
      }      
    case "list":
      query["status"] = "playtesting";            
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "domain":
      query["status"] = "playtesting";    
      query["domains"] = lower_case (bong);        
      tmp = PROJECT_HANDLER->filter_by_query (query);      
    break;
    case "playtester":
      query["status"] = "playtesting";    
      query["playtesters"] = lower_case (bong);        
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "details":
    case "report":
    case "assign":
    case "unassign":
      query["status"] = "playtesting";
      query["projid"] = bong;
      
      temp = PROJECT_HANDLER->get_project_file (bong);

      if (!temp) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in the handler.  Remember case sensitivity.\n", ({ }));
        return 0;
      }


      if (temp->status != member_array ("playtesting", STATUS)) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in playtesting.\n", ({ }));
        return 0;
      }
      
      if (temp) {
        tmp += ({ temp });
      }
      
      verbose = 1;
    break;
    case "passign":
    case "punassign":
       temp = PROJECT_HANDLER->get_project_file (proj);
       if (temp) {
        tmp += ({ temp });
      }
      
    break;     

  }

  
  if (!sizeof (tmp) && !sizeof (ret)) {
    ret += "There are no projects in playtesting for this category.\n";
  }
  else {    
    switch (bing) {
      case "passign":
        blue = PROJECT_HANDLER->add_playtester (proj, ({ bong }));
        
        if (!sizeof (blue)) {
          ret = "You cannot perform this operation.";
        }
        else {
          ret = "You assign " + capitalize (bong) + " to project " +
            proj + ".\n";
        }        
      break;      
      case "punassign":
        i = PROJECT_HANDLER->remove_playtester (proj, ({ bong }));
        
        if (!i) {
          ret = "This project does not exist.";
        }
        else {
          ret = "You remove " + capitalize (bong) + " from project " +
            proj + ".\n";
        }        
      break;          
      break;
      case "list":
      case "domain":
      case "playtester":
      case "details":
        ret = get_output (tmp, verbose);
      break;
      case "report":
      tell_object (this_player(), "Please enter your report for project " +
        bong + ".\n");
      this_player()->do_edit(0, "end_of_report");
      _globals [this_player()->query_name()]  = bong;
      break;  
      case "assign":
      if (!PLAYTESTER_HAND->query_exec_access 
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "execs can assign themselves to projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->add_playtester (bong, 
          ({ this_player()->query_name() }), this_player()->query_name());    
        ret += "You assign yourself to the project " + bong;    
      }
      break;
      case "unassign":
      if (!PLAYTESTER_HAND->query_exec_access
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "Execs can unassign themselves from projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->remove_playtester (bong, 
          ({ this_player()->query_name() }), this_player()->query_name());        
        ret += "You unassign yourself from the project " + bong;    
      }
      break;
        
    }
  }
  
  if (sizeof (ret)) {
    this_player()->more_string (ret);
  }
    
  return 1;
} /* cmd() */

mixed *query_patterns() {
    mixed *patterns = ({ "list", (: cmd("list") :),
    "list <word>", (: cmd ( "list", $4[0]) :),
    "details <word>", (: cmd ( "details", $4[0]) :),
    "report <word>", (: cmd ( "report", $4[0]) :), 
    "assign <word>", (: cmd ("assign", $4[0]) :),
    "unassign <word>", (: cmd ("unassign", $4[0]) :),
    "assignments [for] <word>", (: cmd ("assignments", $4[0]) :),
    "assignments", (: cmd ("allassign") :),
    });

    if (PLAYTESTER_HAND->query_exec_access (this_player()->query_name())) {
      patterns += ({ 
        "unassign <word> from <word>", (: cmd ("punassign", $4[0], $4[1]) :),
        "assign <word> to <word>", (: cmd ("passign", $4[0], $4[1]) :),
      });
    }
    
    return patterns;
  
} /* query_patterns() */

string format_array (string *tmp) {
  
  if (!sizeof (tmp)) {
    return "None";
  }
  
  return query_multiple_short (map (tmp, (: capitalize ($1) :)));
}

string get_output (class project *tmp, int verbose) {
  int i;
  string ret = "";
  if (sizeof (tmp)) {
    if (!verbose) {
      ret += "The following projects match this query:\n";
      ret += sprintf ("%-20s %-40s %s\n\n", "Project ID", 
          "Name", "Domains");    
      foreach (class project p in tmp ) {
        ret += sprintf ("%-20s %-40s %s\n", p->id, 
          p->name, format_array (p->domains)); 
      }
    }
    else {
      ret += "The details for this project are:\n\n";
      foreach (class project p in tmp ) {

        i = PROJECT_HANDLER->find_project (p->id);
        
        ret += sprintf ("$I$5=Project ID: %s\n$I$5=Project Name: %s\n$I$5="
        "Project Leader: %s\n$I$5=Description: %s\n$I$5=Domains: %s\n$I$5="
        "Creators: %s\n$I$5=Assigned Playtesters: "
        "%s.\n$I$5=Size: %s.\n$I$5=Complexity: %s.\n$I$5=Next Rotation: %s\n"
        "$I$5=Rotation: %d of %d.\n"
        "$I$5=Guilds: %s.\n"
        "$I$5=Playtester notes: "
        "%s\n$I$5=Flagged for playtesting: %s", 
        p->id, p->name, capitalize (p->leader), 
        replace (p->description, ({"\n\n", "\n"})), 
        format_array (p->domains), format_array (p->creators), 
        format_array (p->playtesters), (p->size != -1 ? SIZE[p->size] : 
        "Unknown"), 
        (p->complexity != -1 ? COMPLEXITY[p->complexity] : "Unknown"), 
        (PROJECT_HANDLER->query_number_rotations() > p->current_rotation ? 
        ctime (PROJECT_HANDLER->next_rotation_time (i)) : "On last rotation"),
        PROJECT_HANDLER->query_rotation (i), 
        PROJECT_HANDLER->query_number_rotations (i),
        (sizeof (p->guild_specific) ? query_multiple_short (p->guild_specific) :
        "All guilds"), 
        (sizeof (p->pt_notes) ? p->pt_notes : 
        "None"), ctime(p->last_status_change));        
      }
    }
  }
  
  return ret;    
    
}

void end_of_report (string body) {
  int i = 0, j;
  
  if (!sizeof (body)) {
    tell_object (this_player(), "No report given.  Aborting.\n");
    return;
  }    
  
  do { 
    i++;
    j = PROJECT_HANDLER->find_note (_globals[this_player()->query_name()],
      capitalize (this_player()->query_name()) + "Report" + i);
  } while (j != -1);
  
  PROJECT_HANDLER->add_note_to_project (_globals[this_player()->query_name()], 
    capitalize (this_player()->query_name()) + "Report" + i, body, 
    this_player()->query_name());
  PLAYTESTER_HAND->adjust_quota( this_player()->query_name(), 1 ); 
  map_delete (_globals, this_player()->query_name());   
  tell_object (this_player(), "Thank you for your report!\n");   
}
// --- END [/mnt/home2/grok/lib/cmds/playtester/playtesting.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/ptapp_lications.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/ptapp_lications.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627016   Available: 13574370
Inodes: Total: 5242880    Free: 4960132
1154 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/ptapp_lications.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627016   Available: 13574370
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  PT Applications command
 *  @author Drakkos
 *  @started 27/08/2002
 *
 */


inherit "/cmds/base";
#include <playtesters.h>

string query_applicant_text();

varargs int cmd(string check, string name) {

  string ret = "";
  mixed args;
  
  switch (check) {
    case "comments":
      if (!sizeof (name)) {
        ret = PT_APPLICATION_HANDLER->get_comment_list();
      }
      else {
        ret = PT_APPLICATION_HANDLER->get_comments_on_applicant (name);
      }
    break;      
    break;    
    case "summary":
    case "list":
      ret = "";
      ret =   PT_APPLICATION_HANDLER->get_applicant_list();
    break;         
  }   
  
  tell_object (this_player(), ret);
  return 1;
}
       
  

mixed *query_patterns() {
   mixed *patterns = 
    ({ 
      "list", (: cmd("list") :),
    });
   
  if (this_player()->query_lord() || 
    load_object ("/d/playtesters/master")->query_deputy 
    (this_player()->query_name())) {      
    patterns += 
    ({ 
      "comments",  (: cmd ("comments") :),
      "comments for <string>", (: cmd ("comments", $4[0]) :),
    });
  }    
    return patterns;     
} /* query_patterns() */       
// --- END [/mnt/home2/grok/lib/cmds/playtester/ptapp_lications.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/senior/mail.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/senior/mail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627015   Available: 13574369
Inodes: Total: 5242880    Free: 4960132
515 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/senior/mail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627015   Available: 13574369
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mail.c,v 1.1 2002/07/19 01:41:38 pinkfish Exp $
 * $Log: mail.c,v $
 * Revision 1.1  2002/07/19 01:41:38  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* mail command, trial out by Turrican for a commands daemon. */

#include <mail.h>

mixed cmd(string str) {
  return (int)MAIL_TRACK->mail(str);
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/playtester/senior/mail.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/jumps.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/jumps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627015   Available: 13574369
Inodes: Total: 5242880    Free: 4960132
6803 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/jumps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627015   Available: 13574369
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the command to list the jump points and do other wonderful
 * jump point manipulations.
 * @author Pinkfish
 * @started Tue Jul 16 14:03:06 PDT 2002
 */
#include <playtesters.h>

#define LOG_FILE PT_LOGS + "badge_log"
inherit "/cmds/base";

void log_attackers (object);

int do_list() {
   mapping jumps;
   string str;
   string start;
   string tmp;
   string* dest;
   object there;
   object to_there;
   object* theres;

   jumps = PLAYTESTER_HAND->query_jump_points();
   if (!sizeof(jumps)) {
      add_failed_mess("No current jumps.\n");
      return 0;
   }
   str = "Current jumps:\n";
   foreach (start, dest in jumps) {
      if ( !( there = find_object( start ) ) ) {
         catch(load_object(start));
         there = find_object( start );
         if ( !there ) {
           str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                           start, "Someone happy" );
           continue;
         }
      }

      theres = ({ });
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              continue;
            }
         }
         theres += ({ to_there });
      }
      str += "$I$6= * From " + there->the_short() + " [" +
             explode(start, "/")[1] + "] you can get to " +
             query_multiple_short(theres, "the") + ".\n";
   }

   write("$P$Jump points$P$" + str);
   return 1;
}

int do_list_from_here() {
   string* dest;
   string here;
   string str;
   string tmp;
   object to_there;
   int pos;

   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (sizeof(dest)) {
      str = "";
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%s will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              return 1;
            }
         }
         str += sprintf("$I$6=   %c: %s\n", pos + 'A', to_there->the_short());
         pos++;
      }

      write("$I$3=From here you can get to:\n" + str);
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}

int do_jump(string id) {
   string here;
   string* dest;
   string real_dest;
   object to_there;
   int pos;

   if (strlen(id) > 1) {
      add_failed_mess("The id to jump to must be a single letter.\n");
      return 0;
   }
   id = lower_case(id);
   pos = id[0] - 'a';

   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (!sizeof(dest)) {
      add_failed_mess("There are no jump points here.\n");
      return 0;
   }

   if (pos < 0 || pos >= sizeof(dest)) {
      add_failed_mess("The id must be in 'A'..'" +
                      sprintf("%c", sizeof(dest) + 'A') + "'.\n");
      return 0;
   }

   real_dest = dest[pos];


   if (real_dest) {
      if ( !( to_there = find_object( real_dest ) ) ) {
         catch(load_object(real_dest));
         to_there = find_object( real_dest );
         if ( !to_there ) {
           write(sprintf( "$I$3=%s will not load, please contact %s.\n",
                           real_dest, "Someone happy" ) );
           return 1;
         }
      }

      catch( log_attackers( this_player() ) );

      write( "Moving you to "+ to_there->the_short() +"...\n" );
      this_player()->move_with_look( to_there,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}

int do_armoury() {
   string env;
   string ret;
   object ob;

   env = file_name(environment(this_player()));
   if (environment(this_player())->query_armoury()) {
        ret = this_player()->query_property("pt return");
        if (ret) {
           if (strsrch(ret, "#") != -1) {
              if (!find_object(ret)) {
                 ret = 0;
              }
            } else if (!load_object (ret)) {
              ret = 0;
            }
        }
        if (!ret) {
           // Eeek.
           ret = this_player()->query_start_pos();
        }
      write( "Moving you from the pt armoury.\n");
      // Return.
      this_player()->move_with_look( ret,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   } else {
      catch( log_attackers( this_player() ) );
      write( "Moving you to the pt armoury.\n");    
      if (explode (env,"/")[1] != "playtesters") {
        this_player()->add_property("pt return", env);
      }
      this_player()->move_with_look( PLAYTESTER_ARMOURY,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   }
   return 1;
}

protected void log_attackers( object o ) {
    string s;
    object* obs;
    object e;
    
    if ( sizeof( obs = o->query_attacker_list() ) > 0 ) {
        tell_object( o, "%^BOLD%^%^WHITE%^Please stop combat before using "
                     "the jumps command to go places.%^RESET%^\n" );
        
        e = environment( o );
        obs -= ({ 0 });
        obs = filter( obs, (: environment( $1 ) == $(e) :) );

        if ( sizeof( obs ) > 0 ) {
            s = ctime( time() ) + " - " + o->query_name() + " tried to "
                "teleport out of combat from " +
                ( environment( o ) ? file_name( environment( o ) ) :
                  "NULLSPACE" ) + "; query_attacker_list() == ({ ";

            foreach ( object ob in o->query_attacker_list() ) {
                s += "\"" + ob->query_short() + "\" [" +
                    file_name( ob ) + "]";

                if ( environment( ob ) != environment( o ) )
                    s += " (not in same room: " +
                        ( environment( ob ) ?
                          file_name( environment( ob ) ) :
                          "NULLSPACE" ) + ")";
                else
                    s += " (IN SAME ROOM)";
                
                s += ", ";
            }
            
            s += "});\n\n";
            log_file( LOG_FILE, s );
            // unguarded( (: write_file( LOG_FILE, $(s) ) :) );
        }
    }
} /* log_attackers() */

mixed* query_patterns() {
   return ({ "list", (: do_list :),
             "list here", (: do_list_from_here :),
             "goto <string'id'>", (: do_jump($4[0]) :),
             "armoury", (: do_armoury :) });
}
// --- END [/mnt/home2/grok/lib/cmds/playtester/jumps.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/comment.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/comment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627013   Available: 13574367
Inodes: Total: 5242880    Free: 4960132
1269 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/comment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627013   Available: 13574367
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <playtesters.h>

varargs int cmd(string name, string comment) {
  object ob = load_object (PT_APPLICATION_HANDLER);
  string ret = "";
  int i;
  
  if (!ob) {
    this_player()->add_failed_mess (this_object(), "Horrible, horrible "
      "error!\n", ({ }));
    return 0;
  }

  if (!sizeof (comment)) {
    this_player()->do_edit(0, "comment_editor", this_object(), "", name);
  }
  else {
    i =  ob->do_comment (name, comment);

    if (i) {
      tell_object (this_player(), "Thank you for your comments.\n");
    }
    else {
      tell_object (this_player(), "No candidate of that name registered.\n");
    }      
  }
    
  return 1;
} /* cmd() */

mixed* query_patterns() {
   return ({ 
      "<word'name'> <string'comment'>", (: cmd($4[0], $4[1]) :),
      "<word'name'>", (: cmd ($4[0]) :), 
  });
  
} /* query_patterns() */

void comment_editor (string comment, string name) {
  object ob = load_object (PT_APPLICATION_HANDLER);  
  int i;
  
  if (!sizeof (comment)) {
    return;
  }
  else {
   i =  ob->do_comment (name, comment);
  }
  if (i) {
    tell_object (this_player(), "Thank you for your comments.\n");
  }
  else {
    tell_object (this_player(), "No candidate of that name registered.\n");
  }      

}

  // --- END [/mnt/home2/grok/lib/cmds/playtester/comment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/spell.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/spell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627013   Available: 13574367
Inodes: Total: 5242880    Free: 4960132
872 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/spell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627013   Available: 13574367
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <network.h>

void finish_lookup(object player, string word, int result, mixed* results) {
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "Matches for " + word + ": None.\n");
      } else {
         tell_object(player, "Matches for " + word + ": " +
                             query_multiple_short(map(results, (: $1[1] :))) +
                             "\n");
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
} /* finish_lookup() */

int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->spell_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   write ("You look up a word.\n");
   return 1;
} /* cmd() */

mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/playtester/spell.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/pterrors.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/pterrors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627012   Available: 13574366
Inodes: Total: 5242880    Free: 4960132
5433 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/pterrors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627012   Available: 13574366
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This command will display the errors for the current room the
 * pt is standing in.
 * @author Pinkfish
 * @started Thu Feb  6 17:33:05 PST 2003
 */
inherit "/cmds/base";
#include <db.h>
#include <error_handler.h>
#include <player_handler.h>

void finish_lookup(object player, int type, mixed summary) {
   string bugs;
   class error_summary error;

   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bugs.\n" + summary + "\n");
      return ;
   }

   if (!sizeof(summary)) {
      tell_object(player, "No bugs found.\n");
      return ;
   }

   bugs = "";
   foreach (error in summary) {
      bugs += "#" + error->id + " " +
              ctime(error->entry_date)[4..15] +
              " by " + error->reporter + " (" +
              error->type + " - " + error->category + " - " +
              error->status + ")";
      if (error->assigned_to) {
         bugs += " assigned to " + error->assigned_to;
      }
      bugs += "\n";
   }
   tell_object(player, "$P$Bug List$P$" + bugs);
}

int cmd() {
   string fname;

   fname = base_name(environment(this_player()));
   if (!ERROR_HANDLER->do_query_open_bugs_for_fname(fname,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}

int do_query(string reporter, string status) {
   class error_query query;

   query = new(class error_query);
   if (status) {
      query->status = ({ status });
   }
   query->reporter = reporter;
   if (!this_player()->query_property("pterrors order")) {
      query->order_by = ERROR_ORDER_BY_DATE;
   } else {
      query->order_by = this_player()->query_property("pterrors order");
   }
   // Save it for two minutes.
   this_player()->add_property("pterrors query", query, 120);
   return ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :));
}

/**
 * Finds the next set of bugs based on the last query.
 */
int cmd_next() {
   class error_query query;

   query = this_player()->query_property("pterrors query");
   if (!query) {
      add_failed_mess("You have not done a bugs query recently enough.\n");
      return 0;
   }
   query->bug_offset += 150;
   this_player()->add_property("pterrors query", query, 120);
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}

int cmd_mine(string status) {
   if (!do_query(this_player()->query_name(), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}

int cmd_order(string order) {
   switch (order) {
   case "date" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DATE);
      break;
   case "filename" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_FILENAME);
      break;
   case "directory" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DIRECTORY);
      break;
   }
   write("Set your pterrors bug order to " + order + "\n");
   return 1;
}

int cmd_ptbugs(string name, string status) {
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("There is no player called " + name + ".\n");
      return 0;
   }
   if (!do_query(lower_case(name), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}


void finish_details(object player, int type, mixed details) {
   string bugs;
   class error_complete complete;
   class error_details error;

   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bug.\n" + details + "\n");
      return ;
   }

   if (!sizeof(details)) {
      tell_object(player, "No bugs found with that id.\n");
      return ;
   }

   bugs = "";
   foreach (complete in details) {
      error = complete->details;
      bugs += "%^BOLD%^#" + error->summary->id + " " +
              ctime(error->summary->entry_date)[4..15] +
              " by " + error->summary->reporter + " (" +
              error->summary->type + " - " + error->summary->category + " - " +
              error->summary->status + ")";
      if (error->summary->assigned_to) {
         bugs += " assigned to " + error->summary->assigned_to;
      }
      bugs += "\n%^RESET%^";
      bugs += error->report;
      if (player->query_creator()) {
         bugs += error->runtime;
      }
   }
   tell_object(player, "$P$Bug #" + error->summary->id + "$P$" + bugs);
}

int cmd_bug(int bug_id) {
   // This looks up the specific bug.
   if (!ERROR_HANDLER->do_query_bug_details(bug_id,
                   (: finish_details($(this_player()), $1, $2) :))) {
      add_failed_mess("Unable to lookup the bug.\n");
      return 0;
   }

   write("Looking up bug, please wait.\n");
   return 1;
}

mixed* query_patterns() {
   return ({ "", (: cmd :),
             "next", (: cmd_next() :),
             "mine", (: cmd_mine(0) :),
             "mine status {open|fixed|considering|denied}", (: cmd_mine($4[0]) :),
             "order {date|directory|filename}", (: cmd_order($4[0]) :),
             "player <string'name'>", (: cmd_ptbugs($4[0], 0) :),
             "player <string'name'> status {open|fixed|considering|denied}", (: cmd_ptbugs($4[0], $4[1]) :),
             "<number>", (: cmd_bug($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/playtester/pterrors.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/playtester/define.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/playtester/define.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627011   Available: 13574365
Inodes: Total: 5242880    Free: 4960132
925 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/playtester/define.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627011   Available: 13574365
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <network.h>

void finish_lookup(object player, string word, int result, mixed* results) {
   string ret;
   string* bing;

   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object (player, "No definitions for " + word + ".\n");
      } else {
         ret = "";
         foreach (bing in results) {
            ret += bing[1] + "\n" + bing[2] + "\n\n";
         }
         tell_object(player, "Definitions for " + word + ":\n" + ret);
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
} /* finish_lookup() */

int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->define_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   write ("You look up a word.\n");
   return 1;
} /* cmd() */

mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/playtester/define.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/theft_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/theft_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627010   Available: 13574364
Inodes: Total: 5242880    Free: 4960132
6112 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/theft_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627010   Available: 13574364
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 *
 * $Id: theft_base.c,v 1.12 2003/04/21 23:54:24 ceres Exp $
 *
 */


/*  Base for stealing. Does standard checks and has useful functions. */
#include <thief.h>
#include <obj_parser.h>
#include <player.h>

#define SKILL "covert.manipulation.stealing"
#define PERCEPTION "other.perception"

inherit "/cmds/guild_base";

int query_theft_command() { return 1; }

int victim_checks(object thief, object victim) {
  if(thief == victim)
    return notify_fail("Be serious!\n");
  
  if(thief->query_property("dead"))
    return notify_fail("Be serious, you're dead!\n");
  
  if(thief->query_auto_loading())
    return notify_fail("You don't have all your equipment yet..\n");

  if(victim->query_auto_loading())
    return notify_fail( "Be sporting; "+ (string)victim->the_short() +
                        " doesn't have "+ (string)victim->query_possessive() +
                        " equipment yet.\n" );

  if(userp(victim) && !interactive(victim))
    return notify_fail( "You can't " + query_verb() +
                        " from a net dead statue.\n");

  if(victim->query_property("nosteal"))
    return notify_fail("You cannot " + query_verb() + " from " +
                       victim->the_short() + ".\n");
  
  if(victim->query_sanctuary())
    return notify_fail("You can't snatch from someone who is protected.\n");

  if(pk_check(thief, victim))
    return notify_fail("You feel it would be wrong to " + query_verb() +
                       " from "+ victim->short()+".\n");

  if(victim->query_creator() && !thief->query_creator() ) {
    notify_fail("Stop trying to steal from creators.\n");
    thief->adjust_tmp_dex(-10);
    return 0;
  }

  return 1;
}

mixed get_item(object thief, mixed location, string str) {
  class obj_match result;
  
  result = (class obj_match)match_objects_in_environments(str, location, 0, thief);

  if(result->result != OBJ_PARSER_SUCCESS)
    return notify_fail("Pssst, they don't have one of those.\n");

  result->objects = filter(result->objects,
                           (: environment($1) == $(location) :));
  if(!sizeof(result->objects))
    return notify_fail("Pssst, they don't have one of those.\n");

  if(sizeof(result->objects) != 1)
    return notify_fail("You can only " + query_verb() +
                       " one thing at a time.\n");

  return result->objects[0];
}

int combat_checks(object thief, object victim) {
  if(thief->query_fighting()) {
    notify_fail("You can't attempt to " + query_verb() +
                " while in battle.\n");
    return 2;
  }
  
  if(member_array(thief, victim->query_attacker_list()) != -1) {
    notify_fail("You cannot attempt to " + query_verb() + " from someone "
                "that is fighting you.\n");
    return 1;
  }
  
  return 0;
}

int item_checks(object victim, object item, int wielded_ok, int worn_ok) {
  
  if(item->query_liquid() && item->query_food_object())
    return notify_fail("You cannot " + query_verb() + " liquids!\n");

  if(item->query_property("nosteal") ||
     (!wielded_ok && item->query_wielded() == victim) ||
     (!worn_ok && item->query_worn_by() == victim)) 
    return notify_fail("You cannot " + query_verb() + " " +
                       item->the_short() + " from " +
                       victim->the_short() + ".\n");

#ifdef QUOTA_CHECK  
  if(!check_player_quota(victim, item))
    return notify_fail("A quick reveals that " + query_verb() + "ing " +
                       item->the_short() + " would exceed " +
                       victim->query_possessive() + "'s theft quota.\n");
#endif  
  return 1;
}

int calc_value(object ob) {
  int value;
  object tmp, *inv;
  string name;


  //if object is /obj/package only check contents 
  //because package value is value of its contents
  sscanf( file_name( ob ), "%s#%*d", name );
  if( name = "/obj/package" ) {
    value = 0;
  }
  else {
    value = ob->query_value();
  }
  inv = deep_inventory(ob);
  if(sizeof(inv))
    foreach(tmp in inv)
      value += tmp->query_value();

  return value;
}

int check_player_quota(object victim, object ob) {
  object *things, thing;
  int quota, reported, valid, value;
  
  value = 0;
  things = ({ ob });
  things += deep_inventory(ob);
  
  foreach(thing in things) {
    if(thing->query_property("money") ) {
      value += thing->query_value_in("Ankh-Morpork");
    } else {
      value += thing->query_value();  
    }
  }

  quota = QUOTA->query_player_quota(victim->query_name());
  reported = QUOTA->query_player_reported(victim->query_name());
  valid = QUOTA->query_player_valid(victim->query_name());
  
  if((quota - (reported + valid)) < value)
    return 0;
  
  return 1;
}

int steal_item(object thief, object victim, object item) {
  object *stolen;
  string sh;
  
  if(item->move(thief))
    return notify_fail( "You cannot " + query_verb() + " " +
                        item->the_short()+" from "+
                        (string)victim->the_short() +".\n");

  stolen = ({ item });
  stolen += deep_inventory(item);
  tell_object(thief, "You steal "+query_multiple_short(stolen, "the" )+
              " from "+ victim->the_short() +".\n" );

  if( environment(thief)->query_theft_handler() && 
      regexp(environment(thief)->query_theft_handler(), "/d/am/") && 
        thief->query_name() == "wobin" )
      stolen = THEFT_INSURANCE->check_items(stolen, victim, thief);

  event( environment( thief ), "theft", thief, victim, stolen );
  event( stolen, "theft", thief, victim );

  //Simplify wards a bit.

  item->event_ward( thief, victim );
    
  if(thief->query_property("player") &&
     query_ip_number(thief) == query_ip_number(victim) &&
     sizeof(PLAYER_MULTIPLAYER_HANDLER->check_allowed(thief, ({victim})))) {
    sh = capitalize(thief->query_name())+ " stole " +
      query_multiple_short(stolen) +
      " from " + victim->query_name() + " while logged in from the same IP "
      "address.";
    user_event("inform", sh, "multiplayer");
    sh = victim->convert_message(sh);
    log_file("MULTIPLAYERS", ctime(time()) + ": " + sh + "\n");
  }
  
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/theft_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/guild_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/guild_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627009   Available: 13574363
Inodes: Total: 5242880    Free: 4960132
5938 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/guild_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627009   Available: 13574363
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: guild_base.c,v 1.6 2001/05/14 03:07:42 presto Exp $
 *
 * $Log: guild_base.c,v $
 * Revision 1.6  2001/05/14 03:07:42  presto
 * Use /include/cmds/guild_base.h
 *
 * Revision 1.5  1998/08/23 07:30:34  pinkfish
 * Fix up the basse with stuff.!
 *
 * Revision 1.4  1998/08/22 01:26:24  pinkfish
 * First go at makeing a base teaching guild command object.
 *
 * Revision 1.2  1998/03/26 10:37:45  pinkfish
 * Fix it up so the web version of the help file looks better..
 *
 * Revision 1.1  1998/03/13 16:46:53  pinkfish
 * Initial revision
 *
 */

/**
 * This is the base object for all the guild/race commands.  It handles
 * all the common bits of guild/race commands, including teachability
 * and help files.
 * @author Pinkfish
 */
inherit "/cmds/base";

#include <nroff.h>
#include <cmds/guild_base.h>

#define NROFF_SOURCE "/doc/known_command/"

/*
 * This is the base for guild commands.  Handles the
 * nroff file stuff.
 */
nosave string _nroff_fname;
nosave class teach_skill *_teach_skills;
nosave string _command_name;
nosave string _teach_guild;

void create() {
   _teach_skills = ({ });
} /* create() */

/**
 * Set the name of the nroff help file.
 * @param str the nroff help file name
 */
void set_nroff_file(string str) {
   _nroff_fname = str;
} /* set_nroff_file() */

/**
 * This method returns the name of the nroff help file associated with this
 * command.
 * @return the nroff help file name
 */
string query_nroff_file() {
  return _nroff_fname;
} /* query_nroff_file() */

/*
 * Makea string from a nroff input...
 */
private string nroff_file(string name, int html) {
   string nroff_fn;
   string str;

   if (name[0] != '/') {
      name = NROFF_SOURCE + name; 
   }
   nroff_fn = NROFF_DIR + replace(name, "/", ".");
   if (html) {
      str = NROFF_HAND->html_file(nroff_fn, 1);
   } else {
      str = NROFF_HAND->cat_file(nroff_fn, 1);
   }
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      if (html) {
         str = NROFF_HAND->html_file(nroff_fn, 0);
      } else {
         str = NROFF_HAND->cat_file(nroff_fn, 0);
      }
   }
   return str;
} /* nroff_file() */

/**
 * This method returns the help data as a function pointer.
 * The function pointer needs to be evaluated to create the actual text.
 * @return the function pointer for the help text
 */ 
function help_function() {
   if (_nroff_fname) {
      return (: nroff_file(_nroff_fname, 0) :);
   }
   return 0;
} /* help_function() */

/**
 * This method returns the help as a string.
 * @return the help as a string
 */
string help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 0);
   }
   return 0;
} /* help() */

/**
 * This method returns the help in a html format for use with the
 * web.
 * @return a html string
 */
string query_www_help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 1);
   }
   return 0;
} /* help() */

/**
 * This method sets the teach level for the command.  The player must
 * be over this level in the teaching skill to be able to teach this
 * command to the player.  If this is set to 0, then teaching is inhibited.
 * @param level the new teaching level
 */
void add_teach_skill(string skill, int teach, int learn) {
   class teach_skill bing;

   bing = new(class teach_skill);
   bing->skill = skill;
   bing->teach = teach;
   bing->learn = learn;
   _teach_skills += ({ bing });
} /* set_teach_level() */

/**
 * This method returns the current teach skill level.
 * @return the current teach skill level
 */
class teach_skill *query_teach_skills() {
   return _teach_skills;
} /* query_teach_skills() */

/**
 * This method sets the name of the command.  This is used in the teaching
 * to teach the command to the student.
 * @param name the new command name
 */
void set_command_name(string name) {
   _command_name = name;
} /* set_command_name() */

/**
 * This method returns the current command name of the command.
 * @return the current command name
 */
string query_command_name() {
   return _command_name;
} /* query_command_name() */

/**
 * This method sets the command to be only able to be taught to a specific
 * guild.  If this is set to 0 then the command can be taught to
 * any guild, this is the default.
 * @param guild the guild object it can be taught to
 */
void set_teach_guild(string guild) {
   _teach_guild = guild;
} /* set_teach_guild() */

/**
 * This method returns the currently set specific guild.  If this is 0 then
 * the command can be taught to any guild.
 * @return the current teach guild
 */
string query_teach_guild() {
   return _teach_guild;
} /* query_teach_guild() */

/**
 * This method checks to see if the command can be taught or not.
 * @param teacher the person doing the teaching
 * @param student the person being taught
 * @return 0 on failure, 1 on success, -1 if teacher is too low level, -2
 * if student is too low level
 */
int can_teach_command(object teacher, object student) {
   class teach_skill bing;

   if (!sizeof(_teach_skills) ||
       !_command_name) {
     return 0;
   }

   foreach (bing in _teach_skills) {
      if (teacher->query_skill(bing->skill) < bing->teach) {
         return -1;
      }

      if (student->query_skill(bing->skill) < bing->learn) {
         return -2;
      }
   }

   if (_teach_guild &&
       student->query_guild_ob() != _teach_guild) {
      return -3;
   }

   return 1;
} /* can_teach_command() */

/**
 * This method actually teaches the command to the student.
 * @param teacher the teacher of the command
 * @param student the student of the command
 * @return 0 on failure, 1 on success, -1 if teacher is too low level, -2
 * if student is too low level
 */
int teach_command(object teacher, object student) {
   int ret;

   ret = can_teach_command(teacher, student);
   if (ret == 1) {
      student->add_known_command(_command_name);
   }
   return ret;
} /* teach_command() */
// --- END [/mnt/home2/grok/lib/cmds/guild_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/sa_y.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/sa_y.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627007   Available: 13574361
Inodes: Total: 5242880    Free: 4960132
377 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/sa_y.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627007   Available: 13574361
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sa_y.c,v 1.11 2001/03/09 21:56:57 ceres Exp $
 * 
*/
/* command, trial out by Turrican for a commands daemon. */
#include <language.h>
#include <player.h>
#include <drinks.h>

inherit "cmds/base";
inherit "cmds/speech";

mixed cmd(string arg) {
  class message mess;
  mess = build_message(arg, 0, "say");
  return say_it(mess);
}
// --- END [/mnt/home2/grok/lib/cmds/living/sa_y.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/accept.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/accept.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627007   Available: 13574361
Inodes: Total: 5242880    Free: 4960132
6479 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/accept.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627007   Available: 13574361
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This method will buy the objects from the specified player.
 * @author Pinkfish
 * @started Mon Aug 17 07:45:07 EDT 1998
 */
#include <cmds/offer.h>
#include <money.h>
#include <move_failures.h>

inherit "/cmds/base";

int is_in(object ob, object source);

int do_buy(object *people) {
   object person;
   int ret;
   class offer_sale wombat;
   object *obs;
   object *moved;
   mixed *payment;
   object ob;
   int i;

   foreach (person in people) {
      wombat = this_player()->query_respond_command("sell", person);
      if (wombat) {
         // Check to make sure the objects are still in their inventory.
         obs = filter(wombat->sell_obs, (: is_in($1, $2) :),
                      wombat->seller);
         if (sizeof(obs) != sizeof(wombat->sell_obs)) {
            add_failed_mess("$I no longer has " +
                            query_multiple_short(wombat->sell_obs - obs) +
                            " to buy.\n",
                            ({ person }) );
         } else if (this_player()->query_value_in(wombat->place) <
                    wombat->value) {
            add_failed_mess("You no longer have enough money to buy " +
                            query_multiple_short(wombat->sell_obs) +
                            " from $I.\n", ({ person }));
         } else {
            // Get money (hopefully) from the nice array of money
            // the other person has.
            payment = MONEY_HAND->query_person_payments(wombat->value,
                                                        wombat->place,
                                                        this_player(), person);
            if (!payment) {
               add_failed_mess("You no longer have the correct change " 
                               "to pay for $I.\n", ({ person }) );
            } else {
               // Lets see if we can move stuff first.
               moved = ({ });
               foreach (ob in wombat->sell_obs) {
                  if (ob->move(this_player()) == MOVE_OK) {
                     moved += ({ ob });
                  }
               }
               // Check to see if all the objects were moved.
               if (sizeof(moved) != sizeof(wombat->sell_obs)) {
                  moved->move(person);
                  tell_object(person, "Unable to move " +
                                      query_multiple_short(wombat->sell_obs -
                                                           moved) +
                                      " out of your inventory, cancelling "
                                      "the sale.\n");
                  add_failed_mess("Unable to move some objects out "
                                  "of the inventory of $I, canceling sale.\n",
                                  ({ person }) );
               } else {
                  if (sizeof(payment[MONEY_PAY_CHANGE])) {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " from " + this_player()->the_short() + 
                              " and give back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " to " + person->the_short() +
                              " and receive back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                  } else {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " from " + this_player()->the_short() +".\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " to " + person->the_short() + ".\n");
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_RETURN]); i += 2) {
                     this_player()->adjust_money(-payment[MONEY_PAY_RETURN][i+1],
                                                 payment[MONEY_PAY_RETURN][i]);
                     person->adjust_money(payment[MONEY_PAY_RETURN][i+1],
                                          payment[MONEY_PAY_RETURN][i]);
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_CHANGE]); i += 2) {
                     person->adjust_money(-payment[MONEY_PAY_CHANGE][i+1],
                                                 payment[MONEY_PAY_CHANGE][i]);
                     this_player()->adjust_money(payment[MONEY_PAY_CHANGE][i+1],
                                          payment[MONEY_PAY_CHANGE][i]);
                  }
                  add_succeeded_mess("$N buy$s " +
                                     query_multiple_short(wombat->sell_obs) +
                                     " from $I.\n", ({ person }) );
                  ret++;
               }
            }
         }
         this_player()->remove_respond_command("sell", person);
      } else {
         add_failed_mess("Sorry, $I has not offered to sell you anything.\n",
                         ({ person }) );
      }
   }
   return ret;
} /* do_buy() */

/**
 * This method checks to make sure that ob is contained somewhere in the
 * source.
 */
int is_in(object ob, object source) {
   object env;

   if (!ob) {
      return 0;
   }
   env = ob;
   do {
      env = environment(env);
      if (env == source) {
         return 1;
      }
   } while (env);
   return 0;
} /* is_in() */

mixed *query_patterns() {
   return ({ "offer from <indirect:living'person'>", (: do_buy($1) :) });
} /* query_patterns() */

/* This is needed to so we can move stuff out of the players inventory. */
int query_theft_command() {
   return 1;
} /* query_theft_command() */
// --- END [/mnt/home2/grok/lib/cmds/living/accept.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/g_lance.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/g_lance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627005   Available: 13574359
Inodes: Total: 5242880    Free: 4960132
6766 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/g_lance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627005   Available: 13574359
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: glance.c,v 1.15 2003/01/30 08:29:01 pinkfish Exp $
 *
*/
/* glance command, trial out by Turrican for a commands daemon. */
/* Modified by Ceres to add glancing into adjacent rooms */
/* Oh I did some performance enhancements too */
#include <obj_parser.h>
#include <dirs.h>
#include <player.h>

inherit "/cmds/base";

int check_exists(string file);
string room_glance(object person, object room, int dark);
mixed cmd_direction(string dir);

int check_pre_stuff() {
   int dark;
   object room;

   room = environment(previous_object());
   if (!room) {
      return notify_fail("You are in limbo... sorry you can't look at "+
             "anything.\n");
   }

   if (!previous_object()->query_property("dead")) {
      dark = (int)previous_object()->check_dark((int)room->query_light());
   }

   if( dark < 0 ) {
      write("It's too dark to look at anything.\n");
      return 1;
   } else if( dark > 0 ) {
      write("It's too bright to look at anything.\n");
      return 1;
   }
   return 2;
} /* check_pre_stuff() */

mixed cmd_ob(object* obs) {
   object thing;
   int retval;
   int dark;
   object room;

   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }

   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }

   foreach (thing in obs) {
      string tmp;
      if(thing == this_player()) {
        write("That's you that is.\n");
      } else {
        tmp = (string)thing->a_short( dark );
        if (tmp) {
          write(capitalize(tmp) + ".\n");
        }
      }
   }
   return 1;
} /* cmd_ob() */

mixed cmd_direction(string dir, int from_string) {
   object room;
   int dark;
   int retval;
   string ret;
   string dest;
   mixed *func;

   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   retval = 0;

   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dir = EXPAND_EXIT(dir);

   if ( room->query_relative( dir ) ) {
      add_failed_mess( "You do not think that the "+ dir +" is here.\n" );
      return 0;
   }

   dir = (string)this_player()->find_abs(dir);

   if(room->query_exit(dir)) {
    // if there is an exit with the name that they looked at then see if they
    // can see into the next room.

      room->set_destination( dir );

      if ( check_exists( (string)room->query_destination( dir ) ) ) {
         write("You glance " + dir + " and see:\n");
         ret = room->query_look(dir);
         if (ret) {
            write(ret+"\n");
            return 1;
         }

         func = room->query_look_func(dir);
         if(sizeof(func)) {
            call_other(func[0], func[1], 1);
            return 1;
         }

         dest = room->query_destination(dir);
         if(room->query_door_open(dir) != 0) {
            // it mustn't be dark in either room.
            if (!dark && !previous_object()->query_property("dead") &&
                !previous_object()->query_creator()) {
               dark = previous_object()->check_dark(dest->query_light());
            }

            load_object(dest);
            this_player()->set_looked( find_object( dest ) );

            if (dark) {
               write("It's too dark to see that far.\n");
            } else  {
               write( (string)dest->a_short( dark ) +" "+
                     (string)dest->query_short_exit_string()+".\n"+
                     (string)dest->query_contents(""));
            }
            return 1;
         } else if(room->query_door_open(dir) == 0) {
            write("The "+dir+" door is closed.\n");
         }
      }
   }

   if (!retval) {
      add_failed_mess("You do not think that the "+dir+" is here.\n");
   }
   return retval;
} /* cmd() */

/**
 * This method does a glance around the room.  This can be used to do other
 * terribly exciting things as well.
 * @param person the person doing the glancing
 * @param room the room that is being glanced at
 * @param dark how dark it is
 * @return the glance string
 */
string room_glance(object person, object room, int dark) {
   string ret;
   string sees;
   object mirror;

   ret = "";
   if (person->query_creator()) {
      ret += " %^CYAN%^" + file_name(room) + "%^RESET%^";

      sees=(string)room->query_property("creator sees");
      if (sees) {
         ret += sees +"\n"+ (string)room->query_contents();
      }
   }

   mirror = room->query_mirror_room();
   if (mirror) {
      room = mirror;
   }

   if(!dark || previous_object()->query_creator()) {
      if (mirror) {
         //
         // Do the glance description of the room itself.
         //
         ret += ".\n" + (string)mirror->query_contents();
      } else {
         ret += (string)room->query_short_exit_string()+".\n"+
           (string)room->query_contents();
      }
   } else if((dark == 2) || (dark == -2)) {
      if (!mirror) {
         ret += (string)room->query_short_exit_string()+"\n";
      } else {
         ret += "\n";
      }
      if((string)room->query_contents("") != "") {
         ret += person->colour_event("inventory", "%^GREEN%^") +
           "Some objects you can't make out are here.%^RESET%^\n";
      }
   } else {
      ret += "\n";
   }

   if (dark == 1 || dark == -1) {
      ret += "You can't see your hand in front of your face.\n";
   } else  {
      ret = "$a_short:"+ file_name(room) + "$"+ ret;
   }

   if (mirror) {
      ret += "Around " + room->the_short() + " is:\n";
      ret += room_glance(person, mirror, dark);
   }

   return ret;
} /* room_glance() */

int cmd_here() {
   object room;
   int dark;
   int retval;
   string str;

   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }

   room = environment(previous_object());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }

   dark = previous_object()->check_dark((int)room->query_light());

   str = room_glance(previous_object(), room, dark);
   write(str);
   //this_player()->more_string(str, "glance");
   return 1;
} /* cmd_here() */

int check_exists(string file) {

  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    return 1;
  }
  return 0;
} /* check_exists() */

mixed* query_patterns() {
   return ({
             "", (: cmd_here() :),
             "exit <string'exit'>", (: cmd_direction($4[0], 1) :),
             "[at] <indirect:object>", (: cmd_ob($1) :),
             "<string'exit'>", (: cmd_direction($4[0], 0) :),
            });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/g_lance.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/kill.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/kill.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627003   Available: 13574357
Inodes: Total: 5242880    Free: 4960132
3605 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/kill.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627003   Available: 13574357
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: kill.c,v 1.18 2003/01/30 08:50:03 pinkfish Exp $
 */
#include <player.h>

inherit "/cmds/base";

int cmd( object* things ) {
   object thing;
   object *fighting;
   
   if ( !environment( this_player() ) ) {
      add_failed_mess( "You are in limbo...\n" );
      return 0;
   }
   if ( this_player()->no_offense() ) {
      add_failed_mess( "You cannot attack anyone at the moment.\n" );
      return 0;
   }

   things -= ({ this_player() });
   if ( !sizeof( things ) ) {
      add_failed_mess( "You shouldn't beat yourself up so much.\n");
      return 0;
   }
   foreach ( thing in things ) {
      if ( !userp( thing ) ) {
         if ( userp( this_player() ) ||
               !thing->query_property( "no attack" ) ) {
            this_player()->attack_ob( thing );
            thing->attack_by(this_player());
         }
         continue;
      }
      if ( !interactive( thing ) ) {
         write( (string)thing->the_short() +" is net-dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "guest" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +" is a guest.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "dead" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +
                " is already dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_auto_loading() ) {
         write( "Be sporting; "+ (string)thing->the_short() +
               " doesn't have "+ (string)thing->query_possessive() +
               " equipment yet.\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
           !this_player()->query_player_killer() ) {
         write( "You cannot summon the courage to attack "+
               (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
            !thing->query_player_killer() ) {
         write( "Something tells you that it would be wrong "
               "to attack "+ (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      call_out( (: this_player()->attack_ob( $(thing) ) :), 0);
      call_out( (: $(thing)->attack_by(this_player()) :), 0);
   }

    if ( sizeof( things ) ) {
      fighting = ({ });
      foreach(thing in things) {
        object *list;

        list = thing->query_attacker_list();
        if (arrayp(list)) {
           fighting += list;
        }
      }
      if(sizeof(fighting))
        fighting = filter(uniq_array(fighting),
                          (: $1 && environment($1) != environment(this_player()) :));
      if(!sizeof(fighting))
        this_player()->add_succeeded_mess(this_object(),
                                          ({ "You prepare to attack " + query_multiple_short(things) + ".\n", "" }), ({ }) );
      else
        this_player()->add_succeeded_mess(this_object(),
					  ({ "You prepare to attack " + query_multiple_short(things) + " who " + (sizeof(things) > 1 ? "are" : "is") + " already hunting " + query_multiple_short(fighting) + ".\n", "" }), ({ }) );
      
        return 1;
    } else {
        add_failed_mess("");
        return 0;
    }
   
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:living:here>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/kill.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/draw.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/draw.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627002   Available: 13574356
Inodes: Total: 5242880    Free: 4960132
4343 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/draw.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627002   Available: 13574356
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: draw.c,v 1.11 2002/12/03 09:04:29 dogbolter Exp $
 *
 *
 */

#include <move_failures.h>
#include <obj_parser.h>

#define DEFAULT -1
#define LEFT 0
#define RIGHT 1

inherit "/cmds/base";

int cmd( string weapon_str, object * scabbards, string hand_str ) {
   object scabbard, * weapons, weapon;
   class obj_match match;
   string *limbs;
   string *hands;
   int *what_in;
   int targeted, result;
   int hand;

   match = new( class obj_match );
   targeted = scabbards ? 1 : 0;

   debug_printf( "targeted = %d\nscabbards = %O\n", targeted, scabbards );

   if( !scabbards ) {
      scabbards = filter( all_inventory( this_player() ),
        (: $1->query_scabbard() :) );

      if( !sizeof(scabbards) ) {
         add_failed_mess( "Can't find any scabbards in your inventory.\n" );
         return 0;
      }

      foreach( scabbard in scabbards ) {
         match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
           0, this_player() );
         result = match->result;
         if( result == OBJ_PARSER_SUCCESS ) {
            weapons = match->objects;
            break;
         } else if( result == OBJ_PARSER_AMBIGUOUS ) {
            add_failed_mess( "Ambiguous reference to \"" + weapon_str
              + "\" in at least one scabbard.\n" );
         }
      }
      if( !sizeof(weapons) ) {
         add_failed_mess( "Cannot find " + weapon_str + " in any "
           "scabbard in your inventory.\n" );
         return 0;
      }
   } else {
      if( sizeof(scabbards) > 1 ) {
         add_failed_mess( "You can only draw from one scabbard at a "
           "time.\n" );
         return -1;
      }
      scabbard = scabbards[0];

      if( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not a scabbard.\n" );
         return 0;
      }

      if ( environment(scabbard) != this_player() ) {
         add_failed_mess( "You can only draw from a scabbard in your "
           "inventory.\n" );
         return -1;
      }

      match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
        0, this_player() );
      if( match->result == OBJ_PARSER_SUCCESS ) {
         weapons = match->objects;
      } else {
         add_failed_mess( "Cannot find " + weapon_str + " in " +
           scabbard->the_short() + ".\n" );
         return -1;
      }
   }
   weapon = weapons[0];

   if ( scabbard->query_closed() ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + "; it is closed.\n" );
      return targeted ? -1 : 0;
   }

   if( !scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }

   if ( weapon->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }

   if (!hand_str)  hand = -1;
   else hand = member_array(hand_str, this_player()->query_limbs());
   if ( !sizeof( weapon->hold_item( this_player(), hand ) ) ) {
      weapon->move( scabbard );
      add_failed_mess( "You cannot hold " + weapon->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }

   if (!hand_str)  {
      limbs = this_player()->query_limbs();
      what_in = find_member(weapon, this_player()->query_holding());
      hands = allocate(sizeof(what_in));
      for (hand = 0; hand < sizeof(what_in); hand++)
         hands[hand] = limbs[what_in[hand]];
      hand_str = query_multiple_short(hands);
   }

   this_player()->add_succeeded_mess(scabbard, "$N $V $I from $D into $p " +
                                     hand_str + ".\n",
     ({ weapon }) );
   return 1;
}

mixed * query_patterns() {
   string limbs;

   limbs = "{" + implode(this_player()->query_limbs(), "|") + "}";
   return ({
      "<string'weapon'>",
        (: cmd( $4[0], 0, 0 ) :),
      "<string'weapon'> from <indirect:object:me'scabbard'>",
        (: cmd( $4[0], $1, 0 ) :),
      "<string'weapon'> into [my] " + limbs,
        (: cmd($4[0], 0, $4[1]) :),
      "<string'weapon'> from <indirect:object:me'scabbard'> into [my] " + limbs,
        (: cmd( $4[0], $1, $4[2]) :),
   });
}
// --- END [/mnt/home2/grok/lib/cmds/living/draw.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/withdraw.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/withdraw.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627001   Available: 13574355
Inodes: Total: 5242880    Free: 4960132
1021 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/withdraw.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627001   Available: 13574355
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This command offers to sell an object to another thingy.
 * @author Pinkfish
 * @started Mon Aug 17 07:02:04 EDT 1998
 */
#include <money.h>
#include <cmds/offer.h>

inherit "/cmds/base";

int withdraw_offer(object *sell_to) {
   object *removed;
   object ob;

   removed = ({ });
   foreach (ob in sell_to) {
      if (ob->query_respond_command("sell", this_player())) {
         ob->remove_respond_command("sell", this_player());
         removed += ({ ob });
      }
   }

   if (sizeof(removed)) {
      /* Ok!  Now offer the sale. */
      add_succeeded_mess("$N withdraw$s $p offer of sale to $I.\n", removed);
      return 1;
   }

   add_failed_mess("You cannot withdraw your offer of sale to $I since "
                   "you have not offered to sell them anything in the "
                   "first place.\n", sell_to);
   return 0;
} /* withdraw_offer() */

mixed *query_patterns() {
   return ({ "offer {from|to} <indirect:living>",
             (: withdraw_offer($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/withdraw.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/th_row.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/th_row.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627000   Available: 13574354
Inodes: Total: 5242880    Free: 4960132
7034 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/th_row.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14627000   Available: 13574354
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: th_row.c,v 1.12 2003/01/30 06:21:28 pinkfish Exp $
 * $Log: th_row.c,v $
 * Revision 1.12  2003/01/30 06:21:28  pinkfish
 * Make it cost gp.
 *
 * Revision 1.11  2000/09/30 17:26:57  taffyd
 * Added item to thrown_at().
 *
 * Revision 1.10  2000/07/02 10:15:41  taffyd
 * Added event notification when thrown successfully. :)
 *
 * Revision 1.9  1999/10/23 11:00:57  taffyd
 * Recode to fix bugs that seem to have seeped in.
 *
 * Revision 1.8  1999/07/24 12:13:26  terano
 * Added the ability to throw at inanimate objects!
 *
 * Revision 1.7  1999/04/05 23:01:34  ceres
 * Modified to use perform_task
 *
 * Revision 1.6  1998/09/15 00:32:34  pinkfish
 * Really fix up the pk_check().
 *
 * Revision 1.5  1998/08/25 10:52:13  pinkfish
 * Make the messages use the_shrot();
 *
 * Revision 1.4  1998/06/23 03:41:26  sin
 * Terano fixed the pk_check
 *
 * Revision 1.3  1998/03/28 06:28:47  ceres
 * Added a repeat check since some people have been abusing this command.
 *
 * Revision 1.2  1998/02/08 22:15:57  ceres
 * moved to new skill tree
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/

//You can now throw items at inanimate objects that have the
//targetable property, the bonus for that object is counted
//as the value that this property is set to!
//IE: add_property( "targetable", 300 );
//When a player attempts to throw something, it calls thrown_at( object player, 
//int switch ) on the target, with 1 being a hit, and 0 being a miss.

#define CREATOR "Ceres"

#include <player.h>
#include <move_failures.h>
#include <tasks.h>

#define ASKILL "fighting.combat.range.thrown"
#define DSKILL "fighting.combat.dodging.range"
#define PSKILL "fighting.combat.parry.range"

#define COMMAND_GP_COST 5

inherit "/cmds/base";

int valid_target( object target, object thrower, object item );

int cmd( mixed *indirect_obs ) {
    object target, item;
    int dchance, damage;

    if ( sizeof( indirect_obs[ 0 ] ) > 1 ) {
        add_failed_mess( "You can only throw one item at a time!\n" );
        return 0;
    }

    item = indirect_obs[ 0 ][ 0 ];

    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You can only throw $I at one target at a time!\n",
            ({ item }) );
        return 0;
    }

    target = indirect_obs[ 1 ][ 0 ];

    if ( item->query_wielded() != this_player() ) {
        add_failed_mess( "You must be holding $I to throw it.\n",
            ({ item }) );
        return 0;
    }

    if ( this_player() == target ) {
        add_failed_mess( "You cannot throw $I at yourself!\n", ({ item }) );
        return 0;
    }

    if ( !living( target ) && !target->query_property( "targetable" ) ) {
        add_failed_mess( "Why do you want to throw $I at " + 
            target->the_short() + "?\n", ({ item }) );
        return 0;
    }

    if (this_player()->query_gp() < COMMAND_GP_COST) {
        add_failed_mess( "You need " + COMMAND_GP_COST + " points to "
            "throw " + item->the_short() + " at " + target->the_short() +
            ".\n");
        return 0;
    }

    if ( !valid_target( target, this_player(), item ) ) {
        add_failed_mess( "You decide against throwing $I at " + 
            target->the_short() + ".\n", ({ item }) );
        return 0;
    }

    if ( living( target ) ) {
        switch ( (string)target->query_combat_response() ) {
            
            case "dodge" :
                dchance = target->query_skill_bonus( DSKILL );
            break;
            
            default:
                dchance = target->query_skill_bonus( PSKILL );
        }
    } 
    else {
        dchance = target->query_property( "targetable" );
    }

    
    dchance += item->query_weight() / ( this_player()->query_str() / 2 );
    
    if( !this_player()->query_visible( target ) ) {
        dchance /= 2;
    }

    this_player()->adjust_gp(-COMMAND_GP_COST);
    
  
    // lets see if they hit or not.
    
    switch( TASKER->perform_task(this_player(), ASKILL, dchance, TM_FREE) ) {
        
        case AWARD:
            tell_object(this_player(), "%^YELLOW%^You feel that your "
                "skill in throwing weapons has increased.%^RESET%^\n");
        
        case SUCCEED:
            
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " and hit!\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() + 
                    " at " + target->the_short() + " and hits!\n", 
                    this_player() );
                    
            if ( living( target ) ) {
                
                damage = ( item->query_weight() / 4 ) + 
                    ( this_player()->query_str() * 2) + 
                    ( this_player()->query_skill_bonus( ASKILL ) / 3 );
     
                damage -= target->query_ac( "blunt", damage );
                
                target->attack_by( this_player() );
                target->adjust_hp( -damage, this_player() );
                this_player()->attack_ob( target );
                
                event( item, "thrown", this_player(), target );
                    this_player()->adjust_time_left(-(ROUND_TIME*2));
            }                
            
            target->thrown_at( this_player(), 1, item );
      
            if ( item->move( target ) != MOVE_OK ) {
                item->move( environment( target ) );
            }
            
        break;
      
        default:
            tell_object( this_player(), "You throw " + item->the_short() + 
                " at " + target->the_short() + " but miss.\n" );
            
            tell_room( environment( this_player() ), 
                this_player()->the_short() + " throws " + item->a_short() +
                " at " + target->the_short() + " but misses.\n", this_player() );
                
            item->move( environment( target ) );
            
            if( !interactive( target ) && living( target ) ) {
                this_player()->attack_ob( target );
                target->attack_by( this_player() );
            }
            
            target->thrown_at( this_player(), 0 ); //They missed, but lets note that anyway            
        break;
    }   
    

    return 1;
} /* cmd() */


int valid_target( object target, object thrower, object item ) {
    mixed owner;
    
    if ( target->query_property( "dead" ) || target->query_auto_loading() ) {
        return 0;
    }
    
    if ( userp( target ) && !interactive( target ) ) {
        return 0;
    }
    
    if ( pk_check( thrower, target ) )
        return 0;
        
    if ( ( owner = target->query_owner() ) && pk_check( thrower, owner ) ) {
        return 0;
    }
    
    return 1;
} /* valid_target() */

mixed *query_patterns() {
    return ({ "<indirect:object:me'weapon'> at <indirect:object'target'>", 
        (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/th_row.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/'_.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/'_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626998   Available: 13574352
Inodes: Total: 5242880    Free: 4960132
209 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/'_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626998   Available: 13574352
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: '_.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: '_.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include "/cmds/living/sa_y.c"
// --- END [/mnt/home2/grok/lib/cmds/living/'_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/offer.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/offer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626998   Available: 13574352
Inodes: Total: 5242880    Free: 4960132
4809 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/offer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626998   Available: 13574352
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This command offers to sell an object to another thingy.
 * @author Pinkfish
 * @started Mon Aug 17 07:02:04 EDT 1998
 */
#include <money.h>
#include <cmds/offer.h>

inherit "/cmds/base";

int offer_sale(object *to_sell, object *sell_to, string amt, int each) {
   int value;
   int num;
   string *fluff;
   string place;
   string *gumboot;
   object *fail;
   class offer_sale wombat;

   /* Try and figure out the value... */
   fluff = MONEY_HAND->query_all_places();
   gumboot = ({ });
   foreach (place in fluff) {
      value = MONEY_HAND->value_from_string(amt, place);
      if (value) {
        gumboot += ({ place });
      }
   }

   if (!sizeof(gumboot)) {
      add_failed_mess("Unable to understand the value of " + amt + ".\n",
                      to_sell);
      return 0;
   }

   if (member_array("Ankh-Morpork", gumboot) != -1) {
      gumboot = ({ "Ankh-Morpork" });
   }

   if (sizeof(gumboot) > 1) {
      add_failed_mess("Too many types of currency matched, matched currency "
                      "from " + query_multiple_short(gumboot) + ", try and "
                      "be more specific.  ie:  Ankh-Morpork dollars, not just "
                      "dollars.\n",
                      to_sell);
      return 0;
   }

   fail = this_player()->query_ignoring(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since you are "
                         "ignoring them.\n", fail);
         return 0;
      }
   }

   fail = this_player()->query_ignored_by(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since they are "
                         "ignoring you.\n", fail);
         return 0;
      }
   }

   /* Ok, so value must be the amount and gumboot[0] is the place. */
   place = gumboot[0];
   value = MONEY_HAND->value_from_string(amt, place);

   if (value < 0) {
      add_failed_mess("The value of the item was set too high.\n");
      return 0;
   }

   if (sizeof(sell_to) > 1) {
      add_failed_mess("Attempted to sell to $I, cannot sell to more than "
                      "one person.\n", sell_to);
      return 0;
   }

   if (sell_to[0] == this_player()) {
      add_failed_mess("You cannot sell $I to yourself.\n", to_sell);
      return 0;
   }

   if (each) {
      num = 0;
      
      foreach(object item in to_sell) { 
          // If it's collective, add up the individual number.
          if ( item->query_collective() || item->query_continuous() ) { 
             num += item->query_amount(); 
          }
          else {
            // If it's not, then it's just one item.
             num++;
          }
      }
      
      // Now multiply the value by the number of items.
      value = value * num;
   }

#ifdef CHECK_MONEY
   /* Check to see that the person has enough money. */
   if (sell_to[0]->query_value_in(gumboot[0]) < value) {
      add_failed_mess(sell_to[0]->the_short() + " does not have enough money "
                      "to buy $I.\n", to_sell);
      return 0;
   }

   /* And the right sort! of money. */
   if (!MONEY_HAND->query_person_payments(value, gumboot[0], sell_to[0], this_player())) {
      add_failed_mess(sell_to[0]->the_short() + " does not have the correct "
                      "change to pay " +
                      MONEY_HAND->money_value_string(value, gumboot[0]) +
                      " (and you do not have change to give back).\n");
      return 0;
   }
#endif

   wombat = new(class offer_sale);
   wombat->sell_obs = to_sell;
   wombat->seller = this_player();
   wombat->buyer = sell_to[0];
   wombat->value = value;
   wombat->place = gumboot[0];
   sell_to->add_respond_command("sell", this_player(), wombat);
   tell_object(sell_to[0],
               "You can accept the offer by typing:\n"
               "accept offer from " + this_player()->query_name() + "\n");
/*
   tell_object(this_player(), "You can withdraw the offer by typing in:\n"
                              "withdraw offer from " +
                              sell_to[0]->query_cap_name() + "\n");
 */
   /* Ok!  Now offer the sale. */
   add_succeeded_mess("$N offer$s to sell $I to " + sell_to[0]->the_short() +
                      " for " + MONEY_HAND->money_value_string(value,
                                            gumboot[0]) + ".\n", to_sell);

   return 1;
} /* offer_sale() */

mixed *query_patterns() {
   return ({
 "<indirect:object:me'sell object'> to <indirect:living> for <string>",
             (: offer_sale($1[0], $1[1], $4[2], 0) :),
 "<indirect:object:me'sell object'> to <indirect:living> for <string> each",
             (: offer_sale($1[0], $1[1], $4[2], 1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/offer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/echoto.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/echoto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626997   Available: 13574351
Inodes: Total: 5242880    Free: 4960132
1409 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/echoto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626997   Available: 13574351
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: echoto.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: echoto.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include <player.h>
#include <drinks.h>

inherit "/cmds/base";

#define TP this_player()

void my_mess(string fish, string erk);

mixed cmd(string str) {
  string who, what;
  object ob;
  if(!TP->query_creator() && !TP->query_property("echoto"))
    return notify_fail(NOT_ALLOWED);

  if(!str || str == "")
    return notify_fail("Syntax : echoto <player> <text>\n");

  if(sscanf(str, "%s %s", who, what) != 2)
    return notify_fail("Syntax : echoto <player> <text>\n");

  who = lower_case(who);
  who = (string)TP->expand_nickname(who);
  if(!TP->query_creator() && TP->adjust_sp(-ECHOTO_COST) < 0)
    return notify_fail(NO_POWER);

  ob = find_player(who);
  if(!ob)
    return notify_fail("Can't find "+who+".\n");

  if (TP->query_volume(D_ALCOHOL))
    what = TP->drunk_speech(what);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos "+
     "to "+who+": "+what+"\n" );
  what += "%^RESET%^";
  my_mess("You echo to " + who + ": ", what);
  event(ob, "player_echo_to", what + "\n", TP);
  return 1;
}

void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish), 
          TP->fix_string(erk));
} /* my_mess() */
// --- END [/mnt/home2/grok/lib/cmds/living/echoto.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/swim.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/swim.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626996   Available: 13574350
Inodes: Total: 5242880    Free: 4960132
404 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/swim.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626996   Available: 13574350
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: swim.c,v 1.1 2001/03/09 01:51:21 pinkfish Exp $
 * $Log: swim.c,v $
 * Revision 1.1  2001/03/09 01:51:21  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/position_base";
#include <position.h>

void create() {
   ::create();
   setup_position("swim", "around", SWIMMING);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/living/swim.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/drag.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/drag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626996   Available: 13574350
Inodes: Total: 5242880    Free: 4960132
3778 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/drag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626996   Available: 13574350
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <player.h>
#include <room.h>
#include <player_handler.h>

inherit "/cmds/base";

mixed cmd( object *indirect_obs, string direction) {
  string owner;
  object owner_ob;
  string *words, word;

  if( this_player()->query_property( "dead" ) )
    return add_failed_mess( "You're dead.  You can't drag anything.\n" );

  if( objectp( (object)this_player()->query_dragging() ) )
    return add_failed_mess( "You're already dragging something.\n" );

  if( sizeof( indirect_obs ) > 1 )
    return add_failed_mess( "You can only drag one thing at a time.\n" );

  if( indirect_obs[0] == this_player() )
    return add_failed_mess( "You try and drag yourself away from the keyboard, "
      "but you cannot.  Oh no!\n");

  /* For the moment, any living thing not passed out cannot be dragged. */
  if( living( indirect_obs[ 0 ] ) ) {
    if( !indirect_obs[ 0 ]->query_property( PASSED_OUT_PROP )
        || pk_check( indirect_obs[ 0 ], this_player() ) )
      return add_failed_mess( (string)indirect_obs[ 0 ]->the_short() +
        " doesn't want to be dragged away, thank you very much.\n" );
  } else
    if( base_name(indirect_obs[0]) == "/obj/corpse" ) {
      owner = indirect_obs[ 0 ]->query_owner();
      words = explode( lower_case( owner ),  " " );
      words = filter( words, (: PLAYER_HANDLER->test_user($1) :) );
      foreach( word in words ) {
          owner_ob = find_player( lower_case( word ) );
          if( owner_ob && userp( owner_ob ) &&
            pk_check( owner_ob, this_player() ) &&
            member_array ( this_player()->query_name(), indirect_obs[0]->
            query_permitted() ) == -1 )
            return add_failed_mess( "For some reason, you can't get hold of "+
              (string)indirect_obs[ 0 ]->the_short() +".\n" );
      }
  }

  if( ( environment( indirect_obs[ 0 ] ) != environment( this_player() ) ) ||
    indirect_obs[ 0 ]->get() )
      return add_failed_mess( "For some reason, you can't get hold of " +
        (string)indirect_obs[ 0 ]->the_short() +".\n" );
    
  write( "You get hold of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->one_short() + " gets hold of " +
    (string)indirect_obs[ 0 ]->a_short() + ".\n" );

  // Too heavy
  if( (int)indirect_obs[ 0 ]->query_complete_weight() +
    (int)this_player()->query_loc_weight() > 2 *
    (int)this_player()->query_max_weight() ) {
      write( "You struggle and strain, but you can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
      say( (string)this_player()->one_short() + " struggles and strains, but " +
        (string)this_player()->query_pronoun() + " can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
  } else {
    this_player()->set_dragging( indirect_obs[ 0 ] );
    // No exit that way
    if( !this_player()->exit_command( direction ) )
      write( "You can't drag " + (string)indirect_obs[ 0 ]->the_short() +
        " that way.\n" );
    else
      if( interactive( this_player() ) )
        indirect_obs[0]->add_property( "dropped",
          ({this_player()->query_name(), query_ip_number( this_player() ),
          time()}), 1800 );
    this_player()->reset_dragging();
  }
  write( "You let go of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->the_short() + " releases " +
    (string)this_player()->query_possessive() + " hold of " +
    (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return 
    ({ "<indirect:object:here> [to] <word'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :),
       "<indirect:object:here> [to] <string'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/drag.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/unh_old.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/unh_old.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626995   Available: 13574349
Inodes: Total: 5242880    Free: 4960132
1334 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/unh_old.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626995   Available: 13574349
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: unh_old.c,v 1.2 1998/10/08 09:52:49 pinkfish Exp pinkfish $
 * $Log: unh_old.c,v $
 * Revision 1.2  1998/10/08 09:52:49  pinkfish
 * Fixed up to work correctly with things that do not wish to be unheld.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

int cmd(object obs) {
  object *ok, *zip, *failed, ob, *using;
  string s;
  mixed ret;

  using = TP->query_holding();
  failed = ok = zip = ({ });

  foreach (ob in obs) {
    if (member_array(ob, using) != -1) {
      if (!sizeof(ret = TP->set_unhold(ob)) || !ret)
        failed += ({ ob });
      else
        ok += ({ ob });
    } 
    else
      zip += ({ ob });
  }
  if (!sizeof(ok)) {
    s = "";
    if (sizeof(failed))
      s += "Could not unhold "+query_multiple_short(failed)+".\n";
    if (sizeof(zip))
      s += capitalize("You are not holding " +
                      query_multiple_short(zip, "the") + ".\n");
    return notify_fail(s);
  }
  tell_object(TP, "You put down "+(s = query_multiple_short(ok))+".\n");
  tell_room(environment(TP), TP->one_short()+" puts down "+s+".\n", TP);
  TP->force_burden_recalculate();
  return 1;
} /* unhold() */

mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/unh_old.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/whi_sper.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/whi_sper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626994   Available: 13574348
Inodes: Total: 5242880    Free: 4960132
691 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/whi_sper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626994   Available: 13574348
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: whi_sper.c,v 1.10 2003/01/30 07:59:04 pinkfish Exp $
 */

inherit "/cmds/base";
inherit "/cmds/speech";

mixed cmd( object *others, string last ) {
  class message mess;

  if (sizeof(others) == 1 && others[0] == this_player()) {
     add_failed_mess("Whispering to yourself?  Neat trick.\n");
     return 0;
  }

  mess = build_message(last, others, "whisper");
  mess->type = "whisper";
  return say_it_to(mess, others, 1, "whisper");
}

mixed *query_patterns() {
   return ({ "<string'message'> to <indirect:living>", (: cmd($1, $4[0]) :),
             "<indirect:living> <string'message'>", (: cmd($1, $4[1]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/whi_sper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/dry.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/dry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626994   Available: 13574348
Inodes: Total: 5242880    Free: 4960132
2932 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/dry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626994   Available: 13574348
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: dry.c,v 1.5 2001/10/07 03:05:35 presto Exp $
 */
inherit "/cmds/base";

mixed cmd(mixed *things)
{
   int pwet;
   int twet;
   int max;
   int *enums;
   object thing;
   object with;

   thing = things[0][0];
   with = things[1][0];
   if (!with->id("towel") && !with->query_property("dryer")) {
      return notify_fail("You can't dry anyone with " +
                         (string) with->the_short() + ".\n");
   }
   if (environment(with) != this_player())  {
      return notify_fail(with->a_short() + " isn't going to do much good "
         "inside " + environment(with)->a_short() + ".\n");
   }
   if (thing->query_property("dead")) {
      return notify_fail((string) thing->the_short() + " is dead; " +
                         (string) thing->query_pronoun() +
                         " has more immediate problems than being wet.\n");
   }
   max = 200 * (int) with->query_weight();
   enums = (int *) with->effects_matching("object.wet");
   if (sizeof(enums)) {
      twet = (int) with->arg_of(enums[0]);
   }
   if (twet > max / 2) {
      return notify_fail((string) with->the_short() +
                         " is already dripping wet.  You can't dry anybody "
                         "with it.\n");
   }

   enums = (int *) thing->effects_matching("body.wetness");
   if (sizeof(enums)) {
      pwet = (int) thing->arg_of(enums[0]);
   }

   if (pwet < 10) {
      if (thing == this_player()) {
         return notify_fail("You don't need drying.\n");
      } else {
         return notify_fail((string) thing->the_short() +
                            " doesn't need drying.\n");
      }
   }
   if (pwet + twet > max) {
      pwet = max - twet;
   }
   pwet -= random(10);
   if (pwet > 0) {
      thing->add_effect("/std/effects/other/wetness", -pwet);
      with->add_effect("/std/effects/object/wet", pwet);
   }
   if (thing == this_player()) {
      write("You dry yourself with " + with->the_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) this_player()->query_objective() + "self with " +
          (string) with->poss_short() + ".\n");
   } else {
      write("You dry " + (string) thing->the_short() + " with " +
            (string) with->the_short() + ".\n");
      tell_object(thing, (string) this_player()->one_short() +
                  " dries you with " + (string) with->poss_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) thing->the_short() + " with " +
          (string) with->poss_short() + ".\n", thing);
   }
   return 1;
}                               /* cmd() */

mixed *query_patterns()
{
   return ({ "<indirect:living'person'> with <indirect:object:me>",
             (: cmd($1) :),
             "myself with <indirect:object:me>",
             (: cmd(({ ({ this_player() }), $1 })) :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/dry.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/emoteall.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/emoteall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626993   Available: 13574347
Inodes: Total: 5242880    Free: 4960132
1689 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/emoteall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626993   Available: 13574347
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: emoteall.c,v 1.5 2002/03/17 12:21:51 mansarde Exp $
 * $Log: emoteall.c,v $
 * Revision 1.5  2002/03/17 12:21:51  mansarde
 * Fixed previous fix.  Can you believe I missed a + " " ? Duh.
 *
 * Revision 1.4  2002/03/16 18:41:27  mansarde
 * Fixed the colouring so it colours the name, not just the message.
 *
 * Revision 1.3  2001/11/07 22:28:28  pinkfish
 * Make it bold red.
 *
 * Revision 1.2  2001/07/23 13:07:11  taffyd
 * Made to use colour in emoteall
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include <player.h>
#include <drinks.h>

inherit "/cmds/base";

#define TP this_player()
#define BEEP sprintf("%c",7)

void my_mess(string fish, string erk);

mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("emoteall")) {
    return notify_fail(NOT_ALLOWED);
  }

  if(!str || str == "") {
    return notify_fail("Syntax : emoteall <string>\n");
  }

  if(!TP->query_creator() &&
     TP->adjust_sp(-EMOTEALL_COST*((strlen(str)/10)+1)+100) < 0) {
    return notify_fail(NO_POWER);
  }

  str = replace(str, BEEP, "");
  if (TP->query_volume(D_ALCOHOL)) {
    str = TP->drunk_speech(str);
  }
  log_file("ECHOS", ctime(time())+" "+TP->query_name()+" emotes "+
           "to all: "+str+"\n");
  str += "%^RESET%^";
  my_mess("You emoteall : ", TP->query_cap_name()+" " + str);
  TP->comm_event(users(), "player_emote_all", "%^BOLD%^%^RED%^" + TP->query_cap_name() + " " + str + "\n");
  return 1;
}

void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish), 
          TP->fix_string(erk));
} /* my_mess() */
// --- END [/mnt/home2/grok/lib/cmds/living/emoteall.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/flip.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/flip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626992   Available: 13574346
Inodes: Total: 5242880    Free: 4960132
2459 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/flip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626992   Available: 13574346
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: flip.c,v 1.4 2002/01/21 12:32:12 taffyd Exp $
 * $Log: flip.c,v $
 * Revision 1.4  2002/01/21 12:32:12  taffyd
 * Changed to not allow you to flip currency which has a type of 'paper'.
 *
 * Revision 1.3  1999/10/25 23:05:41  pinkfish
 * Some bug fixes.
 *
 * Revision 1.2  1999/05/19 04:34:54  pinkfish
 * Fix some bugs and clean up the formating.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include <money.h>

#define EFFECTS "/obj/handlers/mag_eff_handler"
inherit "/cmds/base";

mixed cmd( object *things ) {
   int *effect;
   object place;
   mixed *stuff, *details;

   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only flip one thing at once.\n");
      return 0;
   }
   stuff = (mixed *)things[ 0 ]->query_money_array();
   if ( !sizeof( stuff ) ) {
      add_failed_mess( "You must have a coin to flip.\n" );
      return 0;
   }
   if ( ( sizeof( stuff ) > 2 ) || ( stuff[ 1 ] != 1 ) ) {
      add_failed_mess( "You can only flip one coin at a time.\n" );
      return 0;
   }

   details = (mixed *)MONEY_HAND->query_details_for( stuff[ 0 ] );
   
   if ( details[ MONEY_DETAILS_COMPOSITION ] == "paper" ) {
       add_failed_mess( "You cannot flip $I as you would a coin, because "
        "it is made of paper.\n", things );
       return -1;
   }

   write( "You flip "+ (string)things[ 0 ]->the_short() +".\n" );
   say( (string)this_player()->one_short() +" flips "+
         (string)things[ 0 ]->a_short() +".\n" );

   effect = (int *)EFFECTS->choose_effect(
         (int)EFFECTS->ambient_enchantment( things[ 0 ] ) );
   place = environment( this_player() );
   if ( random( 1000 ) < effect[ 0 ] ) {
      switch( effect[ 1 ] ) {
         case 0 :
            things[ 0 ]->move( place );
            tell_room( place, (string)things[ 0 ]->the_short() +
                  " lands on its edge.\n" );
            break;
         default :
            things[ 0 ]->move( "/room/rubbish" );
      }
      EFFECTS->do_effect( effect[ 1 ], (string)things[ 0 ]->the_short(),
            place );
      return 1;
   }
   things[ 0 ]->move( place );

   tell_room( place, (string)things[ 0 ]->the_short() +" falls "+
         (string)place->query_property( "here" ) +", "+
         details[ random( 2 ) ] +" up.\n" );
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/flip.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/give.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/give.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626992   Available: 13574346
Inodes: Total: 5242880    Free: 4960132
4914 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/give.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626992   Available: 13574346
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: give.c,v 1.22 2002/02/22 01:14:48 ceres Exp $
 */

#include <move_failures.h>
#include <player.h>

inherit "cmds/base";

#define TP this_player()
#define SUPPRESS_MESS "suppress give messages"

mixed cmd(mixed *indir, string *indir_match) {
  string sh;
  string s1;
  string failmess;
  int tot;
  int max;
  int ok;
  object *per;
  object *ret;
  object *fail;
  object pobj;
  object ob;
  object *obs;
  object *succ;
  object *keep;

  per = indir[1];
  succ = ({ });
  keep = ({ });
  failmess = "";
  
  foreach(pobj in per) {
    obs = indir[0];
    obs -= per;

    if (pobj->query_property("player") && !interactive(pobj)) {
      failmess = pobj->the_short()+" seems too chalky to accept your "
        "gift.\n";
      continue;
    }

    if (pobj == TP) {
     failmess = "You nag yourself for a while, but can't convince "
                 "yourself to accept things from yourself.\n";
     continue;
    }

    if (!sizeof(obs)) {
      failmess = "Nothing to give to "+ pobj->short() +".\n";
      continue;
    }
    ret = ({ });
    fail = ({ });
    foreach(ob in obs) {
      if ( member_array( ob, succ ) > -1 ) {
        continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      if (function_exists("do_give", ob) ||
          function_exists("command_control", ob)) {
        if (function_exists("do_give", ob)) {
          max = call_other(ob, "do_give", pobj, indir_match[0],
                                indir_match[1],
                                ({ indir_match[0], indir_match[1] }),
                                "<direct:object:me> to <indirect:living>");
        } else {
          max = ob->command_control("give", pobj, indir_match[0],
                                    indir_match[1],
                                    ({ indir_match[0], indir_match[1] }),
                                    "<direct:object:me> to <indirect:living>");
        }
        if (max == 0)  {
          fail += ({ ob });
          continue;
        }
      }
#ifndef __DISTRIBUTION_LIB__
      // this_player() drops the object
      PLAYER_MULTIPLAYER_HANDLER->record_object("give", TP, ob);
      
      // pobj picks it up again.
      if(pobj->query_property("player") && interactive(TP) &&
         "/obj/handlers/multiplayer"->check_multiplayers("give", pobj, ob)) {
        fail += ({ ob });
      } else 
#endif
      if (pobj->query_closed()  ||  ob->move(pobj) != MOVE_OK) {
        fail += ({ ob });
      } else  {
        ret += ({ ob });
        tot += ob->query_weight();
      }
    }
    if (sizeof(ret)) {
      ok = 1;
      succ += ret;
      if (pobj->query_clothing()) {
        s1 = pobj->query_pocket_mess();
      } else {
        s1 = "$ob_short$";
      }
      sh = query_multiple_short(ret);

      if ( interactive( pobj ) || !pobj->query_property( SUPPRESS_MESS ) ) {
        tell_object(TP, "You give "+ sh +" to "+
                  replace_string(s1, "$ob_short$", pobj->one_short())+
                  ".\n");
        tell_room(environment(TP), TP->one_short() + " gives " + sh +
               " to " + replace_string(s1, "$ob_short$",
                                      pobj->one_short()) +
               ".\n", ({ TP, pobj }));
        tell_object(pobj, capitalize(TP->one_short() ) + " gives "+
                    sh + " to you.\n" );
      }

      if (living(pobj) && (max = pobj->query_max_weight()))
        if ((max = tot*100/max) > 25)
          if (max >= 95) {
            tell_room(environment(TP),
                      pobj->the_short()+" staggers under a weight "+
                      pobj->query_pronoun()+" can only just carry.\n",
                      ({ pobj }) );
            pobj->event_say(TP, "You stagger under a weight you can only "
                            "just carry.\n");
          } else {
            tell_room(environment(TP), pobj->the_short()+ ({
              " is only mildly discomforted by the additional weight.\n",
              " braces "+pobj->query_objective()+"self to take the load.\n",
              " stumbles as "+pobj->query_pronoun()+" takes the load.\n"
              })[(max/25)-1], ({ pobj }) );
            pobj->event_say(TP, "You"+ ({
              " are only mildly discomforted by the additional weight.\n",
              " brace yourself under the load.\n",
              " stumble as you take the load.\n"
              })[(max/25)-1]);
          }
    }
    if (sizeof(fail)) {
      failmess += "You cannot give "+query_multiple_short(fail)+ " to "+
                  pobj->one_short() +".\n";
    }
  }
  if (!ok) {
    add_failed_mess(failmess);
    if (sizeof(keep)) {
       add_failed_mess("You have $I set to be kept.\n", keep);
    }
  }
  return ok;
}

mixed *query_patterns() {
  return ({ "<indirect:object:me> to <indirect:living>",
            (: cmd($1, $3) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/give.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/lsay.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/lsay.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626990   Available: 13574344
Inodes: Total: 5242880    Free: 4960132
874 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/lsay.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626990   Available: 13574344
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: lsay.c,v 1.13 2002/11/09 06:44:13 ceres Exp $
 * 
*/
/* command, trial out by Turrican for a commands daemon. */
#include <language.h>
#include <player.h>
#include <drinks.h>
#include <broadcaster.h>

inherit "/cmds/speech";

#define TP this_player()

mixed cmd(string arg) {
  int *co_ords;
  int status;
  class message mess;

  if (!arg)  arg = "";
  mess = build_message("@loudly " + arg, 0, "say");
  status = say_it(mess);
 
  // Broadcast it around a little.
  if(status && TP && environment(TP))  {
    co_ords = environment(TP)->query_co_ord();
    BROADCASTER->npc_shout_event(TP, mess->notify_mess, mess->text,
                                 mess->language, co_ords, 20);
  }

  return status;
} /* cmd() */

mixed *query_pattern() {
   return ({ "<string'message'>", (: cmd($4[0]) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/living/lsay.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/climb.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/climb.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626990   Available: 13574344
Inodes: Total: 5242880    Free: 4960132
7340 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/climb.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626990   Available: 13574344
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: climb.c,v 1.7 2002/10/24 14:08:22 danbala Exp $
 * 
 */
 
#include <tasks.h>

#define TP this_player()

// This is the default skill.  Note that it's possible to set
// this with the move parameter in set_wall().
#define SKILL "other.movement.climbing.rock"

inherit "/cmds/base";

void fall_off( object place, int number ) {
   if ( place->query_at_bottom() ) {
      write( "You try to climb, but you can't seem to get anywhere.\n" );
      say( (string)TP->one_short() + " tries to climb, but fails.\n" );
      return;
   }
   if ( random( (int)TP->query_dex() ) < number / 20 ) {
      write( "You begin to climb, but your fatigue makes you "+
            "clumsily lose your grip.\n" );
      say( (string)TP->one_short() +
            " begins to climb but clumsily loses "+
            (string)TP->query_possessive() +" grip.\n" );
      place->fall_down( TP );
      return;
   }
   write( "You begin to climb but wobble precariously and decide to "+
         "stay put for the moment.\n" );
   say( (string)TP->one_short() +
            " begins to climb, but wobbles precariously and stops.\n" ); 
} /* fall_off() */

mixed cmd( string words ) {
   int difficulty;
   object place;
   mixed ghost_action;
   mixed *move;
   string *move_descs = ({ "", "", "" }); // to player, from, to
   string skill;
   
   place = environment( TP );
   if ( !place ) {
      add_failed_mess( "You cannot climb anything: you're in limbo!\n" );
      return 0;
   }
   
   move = (mixed *)place->query_move( words );
   if ( !move ) {
      // Give a hint that it's possible to climb in some direction.
      if( sizeof( place->query_moves() ) )
         add_failed_mess( "You cannot climb \""+ words +"\" from here.\n" );
      else // They can stop trying
         add_failed_mess( "There is nothing to climb here.\n" );
      return 0;
   }

   // move[2] is either a string, containing the message given to the
   // destination when the player climbs in, or an array of strings with
   // the following contents:
   // ({ message to player,
   //    message to room they are climbing from,
   //    message to destination room })

   // If the old format, with just a destination string, is used,
   // fill in the blanks.
   if( stringp( move[2] ) ) {
      move_descs[0] =
         "You climb "+ words +".\n";
      move_descs[1] =
         "$N slowly climb$s "+ words +" and disappears from view.";
      move_descs[2] =
         copy( move[2] );
   } else if( sizeof( move[2] ) == 3 ) {
      // New and improved format - all is hoopy
      move_descs = copy( move[2] );
      move_descs[0] += "\n"; // Uses write rather than move_mess
   } else {
      // Unknown format
      return 0;
   }

   /* Ghosts and climbing */
   
   if ( TP->query_property( "dead" ) ) {
      ghost_action = place->query_ghost_action( place );
      
      /* no special action - no skill check for ghosts */
      if ( ! ghost_action ) {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
      
      /* set ghost action - ghosts aren't allowed to climb at all */
      else if ( intp( ghost_action ) && ghost_action == 1 ) {
          add_failed_mess( "How can you climb anything?  You're dead!\n");
          return 0;
      }
   
      /* string - we move to this location with a default message */
      else if ( stringp( ghost_action ) ) {
          write( "As you move to climb the wall, your inherent wispiness gets "
              "the better of you, and you fall through to the other side.\n" );
          TP->move_with_look( ghost_action,
              "$N wisps through the wall with some undue haste.",
              "$N tries to climb the wall, but falls through it." );
          add_succeeded_mess( "" );
          return 1;
      }
      
      /* array - move to a location with specified move messages */
      else if ( arrayp( ghost_action ) ) {
          write( ghost_action[ 1 ][ 0 ] + "\n" );
          TP->move_with_look( ghost_action[ 0 ],
              ghost_action[ 1 ][ 1 ], ghost_action[ 1 ][ 2 ] );
          add_succeeded_mess( "" );
          return 1;
      }
      
      /* default action - move with no skill check */
      else {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
   }
   
   // In the "old style", the difficulty parameter is just an int.  In that
   // case, we'll use the default SKILL.
   if( intp( move[0] ) ) {
      difficulty = move[0] + (int)TP->query_loc_weight() / 10;
      skill = SKILL;
   } else if( arrayp( move[0] ) && sizeof( move[0] ) > 1 ) {
      // In the "new style", the difficulty parameter is an array:
      // ({ base difficulty, skill to test })
      difficulty = move[0][0] + (int)TP->query_loc_weight() / 10;
      skill = move[0][1];
      debug_printf( "Base difficulty: %d, total difficulty: %d, skill: %s\n",
                    move[0][0], difficulty, move[0][1] );
   }

   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   
   TP->adjust_gp( -difficulty / 2 );
   switch ( (int)TASKER->perform_task(TP, skill, difficulty,
                                      TM_COMMAND)) {
      case AWARD :
         call_out( "advance_notice", random( 60 ), TP );
      case SUCCEED :
         write( move_descs[ 0 ] );
         TP->move_with_look( move[ 1 ], move_descs[ 2 ],
               move_descs[ 1 ] );
         return 1;
      default :
         break;
   }
   difficulty = random( difficulty );
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty );
   switch ( (int)TASKER->perform_task(TP, skill,  difficulty / 2,
                                      TM_COMMAND)) {
      case AWARD :
         write( "%^YELLOW%^You manage not to fall off!%^RESET%^\n" );
      case SUCCEED :
         write( "You begin to climb but wobble precariously and decide to "+
               "stay put for the moment.\n" );
         say( (string)TP->one_short() +
               " begins to climb, but wobbles precariously and stops.\n" );
         break;
      default :
         fall_off( place, difficulty );
         break;
   }
   add_succeeded_mess("");
   return 1;
} /* cmd() */

void advance_notice( object thing ) {
   if ( !thing )
      return;
   tell_object( thing, "%^YELLOW%^"+ ({
      "In a flash of inspiration, you realise how to balance better "+
            "when climbing.",
      "Thinking about your climb, you realise something important.",
      "You realise that you've been using better grips to climb.",
      "You realise you've discovered how to find better places to "+
            "support your feet.",
      "You find you've worked out a more sensible way to distribute "+
            "your weight as you climb.",
      "With all your climbing, you discover you've found a better way "+
            "to locate handholds."
   })[ random( 6 ) ] +"%^RESET%^\n" );
} /* advance_notice() */

mixed *query_patterns() {
   return ({ "<string'direction'>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/climb.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/debate.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/debate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626988   Available: 13574342
Inodes: Total: 5242880    Free: 4960132
6304 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/debate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626988   Available: 13574342
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: debate.c,v 1.9 2001/05/31 00:55:23 presto Exp $
 */
#include <tasks.h>

#define EFFECT "/std/effects/religious/theological_debate"
#define HANDLER "/obj/handlers/philosophies"

#define DEBATE_MULT 4

inherit "/cmds/base";

mapping _debaters;

void create() {
   _debaters = ([ ]);
} /* create() */

mixed cmd(object * indirect_obs,
          string indir_match,
          string dir_match,
          mixed *args,
          string pattern)
{
   int bonus;
   string topic;
   string type;
   string needed;
   object target;

   if (sizeof((int *)this_player()->effects_matching("debating"))) {
      return notify_fail("You are already engaged in a debate.\n");
   }
   if (_debaters[this_player()]) {
      tell_object(_debaters[this_player()][0],
                  this_player()->the_short() + " withdraws their debating "
                  "challenge from you.\n");
      map_delete(_debaters, this_player());
   }

   target = indirect_obs[0];
   if (target == this_player()) {
      return notify_fail("Debating with yourself?  Which one of your "
         "personalities are you trying to outwit?\n");
   }
   if (userp(target) && !interactive(target)) {
      return notify_fail("How can you debate anything with a net-dead "
                         "statue?\n");
   }
   topic = args[0];
   if (_debaters[target] && _debaters[target][0] == this_player()) {
      if ((_debaters[target][0] == this_player()) &&
          (_debaters[target][1] == topic)) {
         write("You accept " + (string) target->the_short() +
               "'s challenge to debate " + topic + ".\n");
         say((string) this_player()->the_short() + " accepts " +
             (string) target->the_short() + "'s challenge to debate " +
             topic + ".\n", target);
         tell_object(target, (string) this_player()->the_short() +
                     " accepts your challenge to debate " + topic + ".\n");
         map_delete(_debaters, target);
         this_player()->add_effect(EFFECT, target);
         target->add_effect(EFFECT, this_player());
         return 1;
      }
   }
   if (!HANDLER->query_philosophy(topic)) {
      return notify_fail("You cannot debate \"" + topic + "\".  You can " +
                         "debate " + query_multiple_short((string *) HANDLER->
                                                          query_philosophy_names
                                                          ()) + ".\n");
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) HANDLER->query_philosophy_bonus(topic);
   needed = (string) HANDLER->query_philosophy_needed(topic);
   if (this_player()->query_skill_bonus(type + ".points") < bonus) {
      return notify_fail(needed + " is not sufficient to debate " +
                         topic + " at the moment.\n");
   }
   if (this_player()->query_specific_gp(type) < bonus) {
      return notify_fail("You are too tired to debate " + topic +
                         " at the moment.\n");
   }
   this_player()->adjust_gp(-(bonus * DEBATE_MULT));
/*
   if (environment(this_player()) != environment(target)) {
      tell_object(_debaters[i - 1], "Your challenge is ignored.\n");
   }
 */
   write("You challenge " + (string) target->the_short() +
         " to a debate on " + topic + ".\n");
   say((string) this_player()->one_short() + " challenges " +
       (string) target->one_short() + " to a debate on " + topic + ".\n",
       target);
   tell_object(target,
               (string) this_player()->one_short() +
               " challenges you to a debate on " + topic + ".\n");
   _debaters[this_player()] = ({ target, topic });
   call_out("answer_challenge", 5, this_player(), target, topic);
   return 1;
}                               /* cmd() */

void answer_challenge(object challenger,
                      object target,
                      string topic)
{
   int bonus;
   int diff;
   string type;

   if (!challenger) {
      return;
   }
   if (!target) {
      return;
   }
   if (environment(challenger) != environment(target)) {
      return;
   }
   if (!_debaters[challenger]) {
      return;
   }
   if ((_debaters[challenger][0] != target) || (_debaters[challenger][1] != topic)) {
      return;
   }
   if (pk_check(challenger, target)) {
      tell_object(target, "Use \"debate " + topic + " with " +
                  (string) challenger->query_name() +
                  "\" to accept the challenge.\n");
      return;
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) target->query_skill_bonus(type + ".points");
   /* Query the challenger last as it'll be (s)he who is awarded a level. */
   diff = (int) target->query_skill_bonus(type + ".points") / 3;

   switch ((int) TASKER->perform_task(challenger, type + ".points", 2 * diff,
                                      TM_COMMAND)) {
   case AWARD:
      tell_object(challenger, "You feel " +
                  (string) HANDLER->query_philosophy_needed(topic) +
                  " surge for a moment.\n");
   case SUCCEED:
      tell_object(target, "You find yourself accepting " +
                  (string) challenger->the_short() +
                  "'s challenge to debate " + topic + ".\n");
      tell_room(environment(target),
                (string) target->the_short() + " accepts " +
                (string) challenger->the_short() + "'s challenge to debate " +
                topic + ".\n", ({ target, challenger }));
      tell_object(challenger,
                  (string) target->the_short() +
                  " accepts your challenge to debate " + topic + ".\n");
      map_delete(_debaters, target);
      this_player()->add_effect(EFFECT, target);
      target->add_effect(EFFECT, this_player());
      return;
   default:
      if (userp(target)) {
         tell_object(target, "Use \"debate " + topic + " with " +
                     (string) challenger->query_name() +
                     "\" to accept the challenge.\n");
      }
   }
}                               /* answer_challenge() */

mapping query_debaters()
{
   return _debaters;
}

mixed *query_patterns()
{
   return ({ "<word'topic'> with <indirect:living'person'>",
             (: cmd($1, $2, $3, $4, $5) :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/debate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/l_ook.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/l_ook.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626986   Available: 13574340
Inodes: Total: 5242880    Free: 4960132
14923 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/l_ook.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626986   Available: 13574340
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: l_ook.c,v 1.42 2003/05/22 18:04:37 ceres Exp $
 * 
 */
/* look command, trial out by Turrican for a commands daemon. */
/* Modified by Ceres to add looking into adjacent rooms */
/* Oh I did some performance enhancements too */

#include <player.h>
#include <weather.h>
#include <dirs.h>
#include <error_handler.h>
#include <db.h>
#include <terrain_map.h>

inherit "/cmds/base";

#define TP this_player()

string weather_long(string str);
int check_exists(string file);
string look_around();
mixed cmd_string(string arg);

void finish_bug_summary(object player, int type, mixed data) {
   class error_complete summ;
   class error_complete* errors;
   string str;
   int pos;

   if (type != DB_SUCCESS) {
      return ;
   }
   errors = data;
   if (!sizeof(errors)) {
      tell_object(player, "No errors for this room.\n");
      return ;
   }
   str = "";
   str = sprintf("#<bug id>  ( <date> ) %5-s %4-s %-4s by %11-s %11-s\n",
                 "Status", "Type", "Cat", "Reporter", "Assigned");
   foreach (summ in errors) {
      pos = strsrch(summ->details->report, "\n");
      if (pos < 0 || pos > player->query_cols() - 5) {
         pos = player->query_cols() - 5;
      } else {
         pos --;
      }
      str += sprintf("$I$3=#%d (%s) %5-s %4-s %-4s by %11-s %11-s\n%s\n",
                     summ->details->summary->id,
                     ctime(summ->details->summary->entry_date)[4..15],
                     summ->details->summary->status[0..4],
                     summ->details->summary->type,
                     summ->details->summary->category[0..3],
                     summ->details->summary->reporter,
                     summ->details->summary->assigned_to,
                     summ->details->report[0..pos]);
   }
   tell_object(player, str);
}

void show_error_summary(object player, string* types) {
   class error_query query;

   if (!arrayp(types) || !sizeof(types)) {
      return ;
   }

   query = new(class error_query);
   query->file_name = file_name(environment(player));
   // Just show the open bugs.
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   query->type = types;
   query->no_extra_details = 1;
   ERROR_HANDLER->do_query_multiple_bug_details(query, (: finish_bug_summary, player :));
}

int cmd_look_room()
{
   object room;
   int dark;
   string ret;
   int *coords;

   room = environment(TP);
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }

   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }

   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }

   if (TP->query_creator()) {
      coords = room->query_co_ord();
      if (sizeof(coords)) {
         ret = "  (" + coords[0] + "," + coords[1] + "," + coords[2] + ")";
      } else {
         ret = "  (unset)";
      }
      if (virtualp(room)) {
         write("%^CYAN%^" + file_name(room) + " [" +
                room->query_property("base path")  + "]" + ret + "%^RESET%^\n");
      } else {
         write("%^CYAN%^" + file_name(room) + ret + "%^RESET%^\n");
      }
   }

   if ((TP->query_creator() || TP->query_playtester()) &&
       TP->query_property(TERRAIN_MAP_IN_LOOK_PROP)) {
      ret = room->long_test(0, dark);
      if (ret) {
         write("$P$Look$P$" + ret);
      } else {
         write("$P$Look$P$" + (string) room->long(0, dark));
      }
   } else {
      write("$P$Look$P$" + (string) room->long(0, dark));
   }

   if (dark && TP->query_creator()) {
      write("%^YELLOW%^As a creator, you can see:%^RESET%^\n" +
            (string) room->long(0, 0));
   }

   // Ok, check and see if they want any errors shown.
   if (TP->query_creator() && TP->query_property(PLAYER_SHOW_ERRORS_PROP)) {
      show_error_summary(this_player(), TP->query_property(PLAYER_SHOW_ERRORS_PROP));
   }

   return 1;
}                               /* cmd_look_room() */

/**
 * This method returns the 'look' description of the object.  This should
 * be used for anyone want to do look like capabilities for their
 * objects.
 * @param thing the object to look at
 * @param player the player doing the looking
 * @param dark the darkness modifier
 * @param verb the verb to use when telling the player their item is being
 * looked at
 * @param arg the string used for the look
 * @return the look string
 */
string query_look_thing(object thing,
                        object player,
                        int dark,
                        string verb,
                        string arg)
{
   string ret;
   object env;
   string other;
   string replaced;

   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }

   ret = "";
   if (living(thing)) {
      if (thing == player) {
         ret += "Looking at yourself again?  What a narcissist!\n";
      } else {
         tell_object(thing, "$one_short:" + file_name(player) +
                     "$ $V$0=looks,look$V$ at you.\n");
      }
   } else {
      env = environment(thing);
      while (env && !living(env)) {
         env = environment(env);
      }
   }
   if (env && env != player) {
      tell_object(env, player->the_short() + " " + verb + " "
                  "at your " + thing->pretty_short() + ".\n");
      other = thing->query_long(arg, dark);
      if (other) {
         replaced = thing->replace_long_dollars(player, other); 

         if (replaced) { 
            ret += replaced;
         }
         else {
            ret += other;
         }
      }
      other = thing->query_long_details(arg, dark, player);
      if (other) {
         ret += other;
      }
   } else {
      ret += thing->long(arg, dark);
   }
   return ret;
}                               /* query_look_thing() */

mixed cmd_object(object * obs,
                 string arg)
{
   object thing;
   object room;
   int dark;
   int retval;
   string ret;

   room = environment(TP);

   if (LENGTHEN[arg]) {
     arg = LENGTHEN[arg];
   }

   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }

   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }


   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }

   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }

   ret = "";
   foreach(thing in obs) {
      ret += query_look_thing(thing, this_player(), dark, "looks", arg);
   }

   if (ret != "") {
      write("$P$Look$P$" + ret);
      retval = 1;
   }
   // Doors are a direction.
   if (room->query_exit(arg))
      cmd_string(arg);
   else {
      arg = (string) this_player()->find_abs(arg);
      if (room->query_exit(arg))
         cmd_string(arg);
   }
   return 1;
}                               /* cmd_object() */

mixed cmd_string(string arg)
{
   object room;
   int dark;
   int retval;
   string ret;
   string other;
   string orig_arg;
   mixed *func;

   room = environment(TP);

   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }

   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }

   switch (arg) {
   case "soul":
      write((string) "/obj/handlers/new_soul"->help_list());
      return 1;
   case "sun":
   case "moon":
   case "stars":
   case "weather":
   case "sky":
      write(weather_long(arg));
      return 1;
   case "around":
      write(look_around());
      return 1;
   }

   orig_arg = arg;

   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }

   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }

   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }

   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }

   if (!room->query_exit(arg)) {
      arg = (string) this_player()->find_abs(arg);
   }

   if (room->query_exit(arg)) {
      int tmp_ret_val;

      // got knows what this is for, as far as I know set_destination doesn't
      // even exist.
      room->set_destination(arg);
      other = (string) room->query_destination(arg);
      ret = room->query_look(arg);
      if (ret && ret != "") {
         write(ret + "\n");
         retval = 1;
         tmp_ret_val = 1;
      }

      func = room->query_look_func(arg);
      if (pointerp(func) && sizeof(func) >= 1 && func[0] && func[1]) {
         if (call_other(func[0], func[1], 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      } else if (functionp(func)) {
         if (evaluate(func, 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      }

      if (check_exists(other) && !tmp_ret_val) {
         object door;

         door = room->query_door_control(arg);

         if (room->query_door_open(arg) || door->query_transparent()) {
            // it mustn't be dark in the destination room.
            other->force_load();
            dark = (int) TP->check_dark((int) other->query_light());
            ret = other->long(0, dark);
            this_player()->set_looked(find_object(other));
            write(ret);
            retval = 1;
         } else {
            add_failed_mess(door->the_short() +
                            " is closed and not transparent.\n");
            retval = 0;
         }
      }
   }
   //notify_fail("You do not think that the "+orig_arg+" is here.\n");
   return retval;
}                               /* cmd() */

int check_exists(string file)
{
   int retval;

   if (objectp(find_object(file))) {
      return 1;
   }

   // Also check to see if it is a terrain or not.
   if (strsrch(file, ":")) {
      return 1;
   }

   if (file_size(file + ".c") > 0) {
      retval = 1;
   } else {
      retval = 0;
   }
   return retval;
}

string weather_long(string str)
{
   object env;
   string temp;
   string whandler;

   env = environment(TP);
   temp = (string) env->query_property("location");
   switch (temp) {
   case ("inside"):
      return "You are not outside.\n";
   }

   whandler = env->query_weather_handler() ;
   if ( ! whandler ) {
       whandler = WEATHER ;
   }
   
   if (str == "sun") {
      if (whandler->query_day(env)) {
         return "Ouch that hurts.\n";
      } else {
         return "The sun is not up, sorry.\n";
      }
   }

   if (str == "moon") {
      if (whandler->query_day(env)) {
         return "The moon is not up, try at night.\n";
      } else if ( (temp = whandler->query_moon_string(env)) ) {
         return temp;
      } else {
         return "The moon is not up at the moment, try again later.\n";
      }
   }

   if (str == "stars") {
       if (whandler->query_day(env)) {
           return "The stars are not out at the moment - try at night.\n" ;
       } else {
           if ( (temp = whandler->query_star_string(env)) ) {
               return temp ;
           } else {
               return "There aren't any visible stars right now.\n" ;
           }
       }
   }
   
   return "You look up at the sky.  " + whandler->weather_string(env) + ".\n";
}                               /* weather_long() */

string look_around()
{
   int i;
   int j;
   string prep;
   string room;
   string *parts;
   string *rooms;
   object place;
   object thing;
   object *contents;
   mixed *locations;

   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }

   place = environment(this_player());
   if (place->query_linked()) {
      rooms = (string *) place->query_rooms();
   } else {
      rooms = ({ });
   }
   locations = ({ });
   say((string) this_player()->one_short() + " $V$0=looks,look$V$ around.\n");
   foreach(room in rooms) {
      if (!find_object(room)) {
         continue;
      }
      if (this_player()->check_dark((int) room->query_light())) {
         continue;
      }
      contents = ({ });
      foreach(thing in all_inventory(find_object(room))) {
         if (living(thing) && thing->query_visible(this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         continue;
      }
      prep = (string) room->query_static_preposition();
      if (prep != "") {
         if (!stringp(prep)) {
            prep = sprintf("%O", prep);
         }
         prep += " ";
      }
      locations += ({ ({ contents, prep +
                         (string) this_player()->
                         convert_message((string) room->the_short())
                      }) });
   }
   if (!sizeof(locations)) {
      contents = ({ });
      if (this_player()->check_dark((int) place->query_light())) {
         return "You can't see well enough to look around here.\n";
      }
      foreach(thing in all_inventory(place)) {
         if (living(thing) && thing->query_visible(this_player()) &&
             (thing != this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         return "You do not see anyone else about.\n";
      }
      return "$C$" + query_multiple_short(contents) +
         " $V$0=is,are$V$ here.\n";
   }
   for (i = 0; i < sizeof(locations) - 1; i++) {
      for (j = i + 1; j < sizeof(locations); j++) {
         if (locations[i][1] == locations[j][1]) {
            locations[i][0] += locations[j][0];
            locations = delete(locations, j, 1);
            j--;
         }
      }
   }
   parts = ({ });
   for (i = 0; i < sizeof(locations); i++) {
      parts += ({ query_multiple_short(locations[i][0]) + " " +
                  locations[i][1] });
   }
   if (sizeof(parts) == 1) {
      return "You can see " + parts[0] + ".\n";
   }
   return "You can see " + query_multiple_short(parts) + ".\n";
}                               /* look_around() */

mixed *query_patterns()
{
   return ({ "", (: cmd_look_room() :),
             "<string'direction'>", (: cmd_string($4[0]) :),
             "<indirect:object>", (: cmd_object($1, $4[0]) :),
             "at <indirect:object>", (: cmd_object($1, $4[0]) :),
             "in <indirect:object>", (: cmd_object($1, $4[0]) :),
             "inside <indirect:object>", (: cmd_object($1, $4[0]) :),
             "around", (: cmd_string("around") :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/l_ook.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/double_quote.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/double_quote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626982   Available: 13574336
Inodes: Total: 5242880    Free: 4960132
209 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/double_quote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626982   Available: 13574336
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: "_.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: "_.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include "/cmds/living/lsay.c"
// --- END [/mnt/home2/grok/lib/cmds/living/double_quote.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/eq_uip.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/eq_uip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626982   Available: 13574336
Inodes: Total: 5242880    Free: 4960132
1832 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/eq_uip.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626982   Available: 13574336
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: eq_uip.c,v 1.6 2001/11/06 05:20:52 pinkfish Exp $
 * $Log: eq_uip.c,v $
 * Revision 1.6  2001/11/06 05:20:52  pinkfish
 * Fix up the errors with armour.
 *
 * Revision 1.5  2001/11/05 20:48:57  pinkfish
 * Make it only equip weapons.
 *
 * Revision 1.4  2001/11/05 20:38:54  pinkfish
 * Stop it equiping sheilds incorrectly.
 *
 * Revision 1.3  2001/03/08 10:02:29  mansarde
 * Fixed a typo in strnig. (although i think strnig is quite a
 * fun word)
 *
 * Revision 1.2  2001/03/08 09:04:49  pinkfish
 * Fixed up the formatting.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#define TP this_player()

inherit "/cmds/base";

int cmd() {
   int no_limbs;
   string stuff;
   object thing;
   object *equipped;
   object *things;

   equipped = ({ });
   things = all_inventory( TP ) - TP->query_wearing() -
            TP->query_holding();
   foreach ( thing in things ) {
      // DO the limb checkjing first
      no_limbs = thing->query_no_limbs();
      if ( no_limbs > TP->query_free_limbs() ) {
         continue;
      }
      if ( thing->query_wearable() ) {
         if ( !TP->wear_armour( thing, 0 ) ) {
            equipped += ({ thing });
         }
         continue;
      }
      if (thing->query_weapon() && no_limbs) {
         if ( sizeof( TP->set_hold( thing,
               member_array( 0, TP->query_holding() ) ) ) ) {
            equipped += ({ thing });
         }
      }
   }
   if ( !sizeof( equipped ) ) {
      return notify_fail( "You have no equippable items.\n" );
   }
   stuff = query_multiple_short( equipped );
   say( (string)TP->one_short() +" equips "+ stuff +".\n" );
   write( "You equip "+ stuff +".\n" );
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/eq_uip.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/sp_eak.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/sp_eak.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626981   Available: 13574335
Inodes: Total: 5242880    Free: 4960132
3335 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/sp_eak.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626981   Available: 13574335
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sp_eak.c,v 1.10 2002/11/12 23:35:45 ceres Exp $
 * $Log: sp_eak.c,v $
 * Revision 1.10  2002/11/12 23:35:45  ceres
 * Can't remember
 *
 * Revision 1.8  2002/07/16 20:11:03  pinkfish
 * Add in the default languiage information.
 *
 * Revision 1.7  2001/03/10 20:28:46  ceres
 * Fixed problems from womens day
 *
 * Revision 1.6  2001/03/10 20:27:50  taffyd
 *  Forcibly unlocked by ceres
 *
 * Revision 1.5  2001/03/07 21:52:22  pinkfish
 * Fix up a fail message in speak.
 *
 * Revision 1.4  2000/10/15 01:40:43  presto
 * Removed cap_words function.... now a simul_efun
 *
 * Revision 1.3  1999/05/19 04:31:06  pinkfish
 * Clear something up.
 *
 * Revision 1.2  1999/05/19 04:23:23  pinkfish
 * Capitalise the names.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";
#include <language.h>

#define TP this_player()

int cmd(string which)
{
   string *langs;
   string skill;
   int i;
   mapping skills;

   skills = TP->query_skills();
   if (!which) {
      langs = LANGUAGE_HAND->query_languages();
      for (i = 0; i < sizeof(langs); i++) {
         if (TP->
             query_skill(LANGUAGE_HAND->
                         query_language_spoken_skill(langs[i])) > 1
             || TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
         } else {
            langs = langs[0..i - 1] + langs[i + 1..];
            i--;
         }
      }
      write("You are currently speaking " +
            cap_words(TP->query_current_language()) + " and your default "
            "language is " + cap_words(TP->query_default_language()) + ".\n");
      write("You can speak " +
            query_multiple_short(map(langs, (: cap_words :)) +
                                 ({ "Grunt" })) + ".\n");
      write("Please note that the language you are speaking is used for "
            "writing as well, so some of the languages may be just written.\n");
      return 1;
   }

   which = lower_case(which);
   skill = LANGUAGE_HAND->query_language_spoken_skill(which);

   if (!skill) {
      return notify_fail("You cannot speak that language.\n");
   }

   if((!TP->query_skill(skill) && which != "grunt" && which != "general") ||
      (which == "general" && !TP->query_creator() && interactive(TP)))
      return notify_fail("You don't know that language.\n");

   if (which == this_player()->query_current_language()) {
      add_failed_mess("You are already speaking " + cap_words(which) + ".\n");
      return 0;
   }

   if (!TP->set_language(which)) {
      return notify_fail("Argh... something weird happened.\n");
   }

   write("Now using " + cap_words(which) + " for speaking and writing.\n");
   return 1;
}                               /* cmd() */

mixed *query_patterns()
{
   string *languages;
   string tmp;

   languages = LANGUAGE_HAND->query_languages();

   if ( TP->query_womens_day() ) {
       languages += ({ "wommon" });
   }

   tmp = implode(languages + map(languages, (: cap_words :)), "|");

   return ({ "{" + tmp + "}", (: cmd(implode($4, " ")) :), 
             "", (: cmd(0) :) });
/*    return ({ (TP->query_womens_day()? "wommon" : "{" + tmp + "}"),
             (: cmd(implode($4, " ")) :), "", (: cmd(0) :) }); */ 
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/sp_eak.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/facing.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/facing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626980   Available: 13574334
Inodes: Total: 5242880    Free: 4960132
2363 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/facing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626980   Available: 13574334
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This command is used to tell what direction the player or a living 
 * object is facing.
 * @author Taffyd
 * @started 28/03/99 1:02AM
 */
#include <dirs.h>

inherit "/cmds/base";

string find_direction( object who );
int check_reference_point( object where );

/** @ignore yes */
int cmd( object *indirect_obs ) {
    mapping details;
    object *oblist;
    string *show, dir;
    
    if ( !check_reference_point( environment( this_player() ) ) ) {
        add_failed_mess( "You can't make out a point of reference "
            "to use to determine which way you're facing!\n" );
        return 0;
    }
    
    
    if ( !indirect_obs || sizeof( indirect_obs ) == 1 && 
        indirect_obs[ 0 ] == this_player()) {
        tell_object( this_player(), "You are facing " +
            find_direction( this_player() ) + ".\n" );
        return 1;
    }   
    
    indirect_obs -= ({ this_player() });
    
    details = unique_mapping( indirect_obs, 
        (: find_direction( $1 ) :) );
    
    /* This doesn't quite work, you get:
       A is facing north and B and C is facing south.  */
//    details = map( details, (: query_multiple_short( $2 ) +
//         " $V$0=is,are$V$ facing " + $1 :) );

    /* So we will do this instead... -- Presto, 31 May 2000 */
    show = ({ });
    foreach(dir, oblist in details)  {
      if (sizeof(oblist) > 1)  {
        show += ({ query_multiple_short(oblist) + " are facing " + dir });
      }
      else  {
        show += ({ oblist[0]->one_short() + " is facing " + dir });
      }
    }
    write(query_multiple_short(show) + ".\n");

    return 1;
} /* cmd() */

/** @ignore yes */
string find_direction( object who ) {
    int facing;
    mapping directions;
    
    facing = who->query_facing()[ 0 ];
    directions = filter( ABS_FACING, (: $2 == $(facing) :) );
    
    if ( !sizeof( directions ) )
        return "north";
    
    return keys( directions )[ 0 ];
} /* find_direction() */

int check_reference_point( object where ) {
    string *relatives;
    
    relatives = map( where->query_direc(), 
        (: $(where)->query_relative( $1 ) :) );
    
    return member_array( 0, relatives ) > -1;
} /* check_reference_point() */


/** @ignore yes */
mixed *query_patterns() {
    return ({ "", (: cmd( 0 ) :),
        "<indirect:living:here>", (: cmd($1) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/living/facing.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/lie.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/lie.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626980   Available: 13574334
Inodes: Total: 5242880    Free: 4960132
323 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/lie.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626980   Available: 13574334
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: lie.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: lie.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/position_base";
#include <position.h>

void create() {
   ::create();
   setup_position("lie", "down", LYING);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/living/lie.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/sit.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/sit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626979   Available: 13574333
Inodes: Total: 5242880    Free: 4960132
489 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/sit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626979   Available: 13574333
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sit.c,v 1.2 2002/02/22 01:15:04 ceres Exp $
 * $Log: sit.c,v $
 * Revision 1.2  2002/02/22 01:15:04  ceres
 * Fixed typo
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/position_base";
#include <position.h>

void create() {
   ::create();
   if(this_player()->query_position() == "lying")
     setup_position("sit", "up", SITTING);
   else
     setup_position("sit", "down", SITTING);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/living/sit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/get.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/get.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626979   Available: 13574333
Inodes: Total: 5242880    Free: 4960132
9474 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/get.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626979   Available: 13574333
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: get.c,v 1.63 2002/02/22 00:48:08 ceres Exp $
 */
#include <obj_parser.h>
#include <move_failures.h>
#include <player.h>

// These were determined empirically (with my hand :) -- Jeremy
#define DROP_H 40
#define PINCH_H 120

#define MAX_GET_NUMBER 20

inherit "/cmds/base";

#define TP this_player()

object* find_matching_obs(string match_str, object dob) {
   class obj_match result;

   result = (class obj_match)match_objects_in_environments(match_str, dob);
   if (result->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(result));
      return 0;
   }
   return result->objects;
}

mixed cmd(object * obs, string dir, string indir, mixed *args) {
   object *dest;
   object ob;
   object dob;
   object *fail_dest;
   object *too_many;
   mixed *fail;
   mixed *ret;
   mixed amt;
   string sh;
   string hand_unit;
   string match_str;
   int i;
   int num;
   int cap;
   int perc;
   int handful;
   int total_num;
   mixed we;
   object env;
   object *bing;

   fail_dest = ({ });
   cap = (int) TP->query_max_weight();

   if (indir && sizeof(obs) > 10) {
      add_failed_mess("Please be more specific as to what you want "
                      "to get from.\n");
      return 0;
   }

   if (indir) {
      match_str = args[0];
      dest = obs;
   } else {
      if (environment(TP)->query_mirror_room()) {
         dest = ({ environment(TP), environment(TP)->query_mirror_room() });
      } else {
         dest = ({ environment(TP) });
      }
   }

   too_many = ({ });
   foreach(dob in dest) {
     if (!is_in_me_or_environment(dob, this_player())) {
         fail_dest += ({ dob });
         continue;
      }

      if (dob->cannot_get_stuff() || dob->query_closed()) {
         fail_dest += ({ dob });
         continue;
      }

      if (living(dob) && !dob->allowed_to_loot(this_player())) {
        fail_dest += ({ dob });
        continue;
      } else if (indir) {
         obs = find_matching_obs(match_str, dob);
      }
      if (!obs) {
         continue;
      }

      if (total_num + sizeof(obs) > MAX_GET_NUMBER) {
         if (total_num > MAX_GET_NUMBER) {
            too_many += obs;
            obs = ({ });
         } else {
            too_many += obs[MAX_GET_NUMBER - total_num..];
            obs = obs[0..MAX_GET_NUMBER - total_num - 1];
         }
      }
      total_num += sizeof(obs);
      ret = ({ ([ ]), ([ ]), ([ ]), ([ ]), ([ ]), });
      fail = ({ });
      foreach(ob in obs) {
        env = environment(ob);
        // If the environment of the object & the direct object are different
        // something is wrong. It'll either be that it's a collective object
        // that is in the wrong place or someone's using 'get xxx in yyy'
        if(env != dob) {
          if(ob->query_collective())
            ob->move(dob);
          else
            dob = env;
        }

        if ((living(dob) && !dob->allowed_to_loot(this_player(), ob)) ||
            (ob->query_liquid() && ob->query_food_object())) {
          fail += ({ ob });
          num++;
          continue;
        }

         if (ob->query_continuous()) {
            // Can only get a handful at a time.
            // Id like to make it so you need to have a free hand,
            // but I'm not sure if it's worth it...
            //if (!TP->query_free_limbs())
            //   continue;
            amt = ob->query_amount_types();
            if (amt["handful"]) {
               hand_unit = "handful";
               handful = amt["handful"][0];
            } else if ((amt["drop"]) && (ob->query_liquid())) {
               hand_unit = "drops";
               handful = amt["drop"][0] * DROP_H;
            } else if (amt["pinch"]) {
               hand_unit = "pinches";
               handful = amt["pinch"][0] * PINCH_H;
            } else {            // Dunno what to do here - I guess give it to them
               handful = ob->query_amount();
            }
            if (ob->query_amount() > handful) {
               // Knock it down to a carryable amount
               // (I hope this is right...)
               if (!match_str) {
                  match_str = ob->query_name();
               }
               if (i = strsrch(match_str, "of") >= 0) {
                  i += 3;
               }
               if (hand_unit == "handful") {
                  handful = 1;
               }
               match_str = handful + " " + hand_unit + " of " +
                  match_str[i..];
               fail += ({ "all of the " + ob->short() });
               ob = ob->query_parse_id(({ handful, match_str }));
               if (!ob) {
                  continue;
               }
               num++;
            }
         }

         if (function_exists("do_get", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_get", ob)) {
               we = (int) call_other(ob, "do_get", dob, 0, match_str,
                                     ({ 0, match_str }),
                                     "<direct:object> from <indirect:object>");
            } else {
               we = ob->command_control("get", dob, 0, match_str,
                                        ({ 0, match_str }),
                                        "<direct:object> from <indirect:object>");
            }
            if (!objectp(we)) {
               if (we) {
                  we = (int) ob->query_weight();
                  perc = (we * 100) / cap;
                  if (perc >= 95) {
                     i = 4;
                  } else {
                     i = perc / 25;
                  }
                  if (!ret[i][env]) {
                     ret[i][env] = ({ ob });
                  } else {
                     ret[i][env] += ({ ob });
                  }
               } else {
                  if (member_array(ob, this_player()->query_succ_mess_indir())
                      == -1 && !query_notify_fail() && !living(ob)) {
                     fail += ({ ob });
                  }
                  num++;
               }
               continue;
            } else {
               ob = we;
            }
         }
#ifndef __DISTRIBUTION_LIB__
         if(interactive(TP) &&
            PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("get", TP, ob)) {
           fail += ({ ob });
           num++;
         } else 
#endif
         if ((int) ob->move(TP) == MOVE_OK) {
            we = (int) ob->query_weight();
            perc = (we * 100) / cap;
            if (perc >= 95) {
               i = 4;
            } else {
               i = perc / 25;
            }
            if (!ret[i][env]) {
               ret[i][env] = ({ ob });
            } else {
               ret[i][env] += ({ ob });
            }
         } else {
            fail += ({ ob });
            num++;
         }
      }

      /* Print out the different weight messages */
      for (i = 0; i < sizeof(ret); i++) {
         if (sizeof(ret[i])) {
            /* Print out the different environments for the weights. */
            foreach(env, bing in ret[i]) {
               if (this_player()->query_succ_mess_dir()) {
                  bing -= this_player()->query_succ_mess_dir();
               }
               if (sizeof(bing)) {
                  sh = query_multiple_short(bing);
                  write("You " + ({ "get", "get with a bit of difficulty",
                                    "struggle somewhat to get",
                                    "find it very difficult to get",
                                    "use all your strength and just barely manage to get" })
                        [i] + " " + sh + " from " + inside_the_short(dob) +
                        ".\n");
                  say(capitalize((string) TP->one_short()) + " " +
                      ({ "gets", "gets with a bit of difficulty",
                         "struggles somewhat to get",
                         "finds it very difficult to get",
                         "uses all " + TP->query_possessive() +
                         " strength and just barely manages to get" })[i] +
                      " " + sh + " from " + inside_a_short(dob) + ".\n");
               }
            }
         }
      }

      if (sizeof(fail)) {
         add_failed_mess("You cannot get $I.\n", fail);
      }
   }

   //
   // This means everything failed.
   //
   if (num == total_num) {
      if (query_notify_fail()) {
         return 0;
      }
      if (indir) {
         //if (!num) {
            //add_failed_mess("There is no " + match_str + " in $I.\n", dest);
         //}
         if (sizeof(fail_dest)) {
            add_failed_mess("You cannot get anything from $I.\n", fail_dest);
         }
      } else {
         add_failed_mess("You cannot get $I.\n", obs);
      }
      return -1;
   } else {
      //
      // Success!
      //
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You cannot pick up more than " +
                               query_num(MAX_GET_NUMBER) +
                               " objects at a time; " "discarding $I.\n",
                               "" }), too_many);
      }
   }
   return 1;
}                               /* cmd() */

mixed *
query_patterns()
{
   return ({ "<indirect:object:here>", (: cmd($1, 0, 0, 0) :),
             "<string> from <indirect:object>", (: cmd($1, $2, $3, $4) :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/get.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/em_ote.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/em_ote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626976   Available: 13574330
Inodes: Total: 5242880    Free: 4960132
3203 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/em_ote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626976   Available: 13574330
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: em_ote.c,v 1.10 2001/11/22 17:53:05 taffyd Exp $
 * $Log: em_ote.c,v $
 * Revision 1.10  2001/11/22 17:53:05  taffyd
 * Patched to allow double spaces only.,
 *
 * Revision 1.9  2000/03/05 16:34:35  mansarde
 * added the same support for possessive emotes that i did with cre@
 *
 * Revision 1.8  1999/05/19 06:34:37  pinkfish
 * Fix up some stuff.
 *
 * Revision 1.7  1999/05/04 22:56:36  pinkfish
 * Fix it up to really capitlise npc names :)
 *
 * Revision 1.6  1999/05/04 22:23:51  pinkfish
 * Fix it up so that npcs capitalize correctly.
 *
 * Revision 1.5  1999/05/04 22:22:12  ceres
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.4  1999/04/28 05:36:38  pinkfish
 * Changed the emote length limit to only work on players.
 *
 * Revision 1.3  1999/04/26 22:16:32  ceres
 * Modified to prevent abuses.
 *
 * Revision 1.2  1998/11/01 12:10:34  terano
 * added a call too room->event_emote...
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include <library.h>
#include <player.h>

inherit "/cmds/base";

mixed cmd( string words ) {
  string pad = " ";
  
  if(!environment(this_player())) {
    return notify_fail("You are in limbo, you cannot emote.\n");
  }
  
  if ( userp( this_player() ) && !this_player()->query_creator() ) {
    if ( this_player()->query_property( "emote" ) ) {
      LIBRARY->set_quest( (string)this_player()->query_name(), "emote" );
      this_player()->remove_property( "emote" );
    }
    if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
                                     "emote" ) ) {
      return notify_fail( NOT_ALLOWED );
    }

    // so we can remove the permission to do emotes.
    if(this_player()->query_property("no emote")) {
      return notify_fail(NOT_ALLOWED);
    }
    
    if ( (int)this_player()->adjust_sp( -EMOTE_COST ) < 0 ) {
      return notify_fail( NO_POWER );
    }
  }

  if ( !words || ( words == "" ) ) {
    return notify_fail( "Syntax: emote <text>\n" );
  }

  words = strip_colours(words);
  // have a go at replacing multiple spaces with a single one. This should
  // stop anyone trying to format the emote to look as though it's an emote
  // followed by a tell or somesuch.
  words = replace(words, ({"        ", " ",
                           "       ", " ",
                           "      ", " ",
                           "     ", " ",
                           "    ", " ",
                           "   ", " ",
//                           "  ", " "}));
                            }) );

  
  this_player()->adjust_time_left( -5 );
  if (words[0..0] == "'") pad = "";
  environment( this_player() )->event_emote( this_player(),
                                             "$C$" + this_player()->one_short() + pad +
                                             words +"\n" );
  all_inventory( environment( this_player() ) )->
    event_emote( this_player(), "$C$" + this_player()->one_short() +
                                pad + words + "%^RESET%^\n" );
  write( "You emote: $C$"+
         (string)this_player()->pretty_short( this_player() ) + pad + words +
         "%^RESET%^\n" );
  return 1;
} /* cmd() */
// --- END [/mnt/home2/grok/lib/cmds/living/em_ote.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/protect.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/protect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626976   Available: 13574330
Inodes: Total: 5242880    Free: 4960132
2637 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/protect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626976   Available: 13574330
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: protect.c,v 1.3 1999/04/13 01:01:44 pinkfish Exp $
 * $Log: protect.c,v $
 * Revision 1.3  1999/04/13 01:01:44  pinkfish
 * Fix up a typo in the command.
 *
 * Revision 1.2  1998/07/25 02:49:50  pinkfish
 * Changed it to use add_command and to print out who you are protecting
 * and who is protecting you.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(object *things) {
  int i;
  object *protectees;

  things -= ({ TP });

  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot protect yourself!\n");
     return 0;
  }

  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much protection as a ghost.\n" );
    return 0;
  }
  protectees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_protector( TP ) ) {
      protectees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }

  if ( !sizeof( protectees ) ) {
    add_failed_mess("You cannot protect $I.\n", things);
    return 0;
  }

  if ( sizeof( things ) ) {
    write( "You cannot protect "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will protect $I.\n",
                        "$N moves to protect $I.\n" }),
	                protectees);

/*
  for ( i = 0; i < sizeof( protectees ); i++ ) {
    tell_object( protectees[ i ], capitalize( (string)TP->the_short() ) +
		" will protect "+
		query_multiple_short(delete(protectees, i, 1) + ({"you"})) +
		".\n" );
  }
 */
  return 1;
} /* cmd() */

int show_protectors() {
   object *protect;
   object womble;

   protect = this_player()->query_protectors();
   if (sizeof(protect)) {
      write("You are being protected by " + query_multiple_short(protect) +
            ".\n");
   } else {
      write("You are not being protected by anyone.\n");
   }
   protect = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_protectors()) != -1) {
            protect += ({ womble });
         }
      }
   }
   if (sizeof(protect)) {
      write("Of the people in this room, you are protecting " +
            query_multiple_short(protect) + ".\n");
   } else {
      write("You are not protecting anyone in this room.\n");
   }
   return 1;
} /* show_protectors() */

mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_protectors() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/protect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/watch.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/watch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626975   Available: 13574329
Inodes: Total: 5242880    Free: 4960132
1727 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/watch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626975   Available: 13574329
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: watch.c,v 1.3 2001/11/07 21:28:07 pinkfish Exp $
 * $Log: watch.c,v $
 * Revision 1.3  2001/11/07 21:28:07  pinkfish
 * Stop dead people from watching.
 *
 * Revision 1.2  1999/10/15 06:20:36  taffyd
 * Added watch stop.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#define COST 50

inherit "/cmds/base";

mixed cmd() {
   if ( this_player()->query_blinded() ) {
      add_failed_mess( "How can you watch anything?  You're blind.\n" );
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess( "Dead people don't watch. It is rude!\n");
      return 0;
   }
   if ( sizeof( (int *)this_player()->effects_matching( "mind.alertness" ) ) ) {
      add_failed_mess( "You are already alert and watching "
        "your surroundings.\n" );
      return 0;
   }
   if ( this_player()->query_specific_gp( "other" ) < COST ) {
      add_failed_mess( "You can't concentrate enough to watch "
        "your surroundings.\n" );
      return 0;
   }
   this_player()->adjust_gp( -COST );
   this_player()->add_effect( "/std/effects/other/alertness", 60 + 
     (int)this_player()->query_skill_bonus( "other.perception" ) / 2 );
   return 1;
} /* cmd() */

int stop_watching() { 
   int *enums, id;

   enums = this_player()->effects_matching( "mind.alertness" );

   if ( sizeof( enums ) ) {
      foreach( id in enums ) {
         this_player()->delete_effect( id );
      }
   }
   else {
      add_succeeded_mess( ({ "You are not currently watching!\n", "" }) );
   }

   return 1;
} /* stop_watching() */

mixed *query_patterns() {
   return ({ "stop", (: stop_watching() :),
     "", (: cmd() :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/living/watch.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/put.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/put.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626974   Available: 13574328
Inodes: Total: 5242880    Free: 4960132
4141 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/put.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626974   Available: 13574328
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: put.c,v 1.23 2003/04/30 19:43:46 ceres Exp $
 *
 */

#include <move_failures.h>
#include <player.h>

#define MAX_PUT_NUMBER 20

inherit "cmds/base";

#define TP this_player()
string con;

mixed cmd(mixed *indir,
          string *indir_match,
          string *args)
{
   string person;
   string thing;
   string sh;
   int tot;
   int max;
   object *per;
   object *ret;
   object *fail;
   object pobj;
   object ob;
   object *obs;
   object *succ;
   object *too_many;
   int num;

   con = args[1];
   per = indir[1];
   thing = indir_match[0];
   person = indir_match[1];
   succ = ({ });
   too_many = ({ });
   
   // Check to see if they have too many drated objects.
   //if (sizeof(indir[0]) > MAX_PUT_NUMBER) {
   //too_many = indir[0][MAX_PUT_NUMBER..];
   //indir[0] = indir[0][0..MAX_PUT_NUMBER - 1];
   //}

   foreach(pobj in per) {
      if (living(pobj) && !pobj->query_living_container()) {
         tell_object(TP,
                     "You cannot put things " + con + " living things.\n");
         continue;
      }
      obs = indir[0];
      obs -= per;
      if (!sizeof(obs)) {
         tell_object(TP, "Nothing to " + query_verb() + " " + con + " " +
                     inside_the_short(pobj) + ".\n");
         continue;
      }
      if (!is_in_me_or_environment(pobj, this_player())) {
         add_failed_mess("Cannot $V $I " + con + " " + pobj->the_short() +
                         ".\n", obs);
         continue;
      }

      ret = ({ });
      fail = ({ });
      foreach(ob in obs) {
         if (member_array(ob, succ) > -1) {
            continue;
         }
         if (num > MAX_PUT_NUMBER) {
            too_many += ({ ob });
            continue;
         }
         if (function_exists("do_put", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_put", ob)) {
               max = (int) call_other(ob, "do_put", pobj, thing, person,
                                      ({ thing, person }),
                                      "<direct:object> " + con +
                                      " <indirect:object>");
            } else {
               max = ob->command_control("put", pobj, thing, person,
                                         ({ thing, person }),
                                         "<indirect:object> " +
                                         con + " <indirect:object>");
            }
            if (max == 0) {
               fail += ({ ob });
               continue;
            }
         }
         if (pobj->query_closed() || ob->move(pobj) != MOVE_OK) {
            fail += ({ ob });
         } else {
            ret += ({ ob });
            tot += (int) ob->query_weight();

#ifndef __DISTRUBUTION_LIB__
            if(interactive(TP))
              PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif         
            num++;
         }
      }
      if (sizeof(ret)) {
         succ += ret;
         sh = query_multiple_short(ret);
         add_succeeded_mess("$N $V $I " + con + " " +
                            inside_the_short(pobj) + ".\n", ret);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot $V $I " + con + " " +
                         inside_the_short(pobj) + ".\n", fail);
      }
   }
   if (sizeof(too_many)) {
      if (sizeof(succ) > 0) {
         add_succeeded_mess(({ "You cannot handle more than " +
                               query_num(MAX_PUT_NUMBER) +
                               " objects with $V; discarding $I.\n", "" }),
                            too_many);
      } else {
         add_failed_mess("You cannot handle more than " +
                         query_num(MAX_PUT_NUMBER) +
                         " objects with $V; discarding $I.\n", too_many);
      }
   }
   return sizeof(succ) > 0;
}                               /* cmd() */

string query_con() {
  return con;
}

mixed *query_patterns()
{
   return ({ "<indirect:object:me> {in|on|into} <indirect:object>",
             (: cmd($1, $3, $4) :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/put.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/defend.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/defend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626973   Available: 13574327
Inodes: Total: 5242880    Free: 4960132
2243 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/defend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626973   Available: 13574327
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: protect.c,v 1.3 1999/04/13 01:01:44 pinkfish Exp $
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(object *things) {
  int i;
  object *defendees;

  things -= ({ TP });

  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much defense as a ghost.\n" );
    return 0;
  }
  
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot defend yourself!\n");
     return 0;
  }

  if(TP->query_combat_response() != "parry") {
    add_failed_mess("Dodging out of the way will not help " +
                    query_multiple_short(things) + ".\n");
    return 0;
  }
                    
  defendees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_defender( TP ) ) {
      defendees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }

  if ( !sizeof( defendees ) ) {
    add_failed_mess("You cannot defend $I.\n", things);
    return 0;
  }

  if ( sizeof( things ) ) {
    write( "You cannot defend "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will defend $I.\n",
                        "$N moves to defend $I.\n" }),
                  defendees);

  return 1;
} /* cmd() */

int show_defenders() {
   object *defend;
   object womble;

   defend = this_player()->query_defenders();
   if (sizeof(defend)) {
      write("You are being defended by " + query_multiple_short(defend) +
            ".\n");
   } else {
      write("You are not being defended by anyone.\n");
   }
   defend = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_defenders()) != -1) {
            defend += ({ womble });
         }
      }
   }
   if (sizeof(defend)) {
      write("Of the people in this room, you are defending " +
            query_multiple_short(defend) + ".\n");
   } else {
      write("You are not defending anyone in this room.\n");
   }
   return 1;
}

mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_defenders() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/defend.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/sh_out.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/sh_out.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626972   Available: 13574326
Inodes: Total: 5242880    Free: 4960132
9881 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/sh_out.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626972   Available: 13574326
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: sh_out.c,v 1.29 2002/08/03 23:16:49 danbala Exp pinkfish $
 */
#include <player.h>
#include <drinks.h>
#include <language.h>
#include <cmds/options.h>
#include "/d/am/path.h"

inherit "/cmds/base";
inherit "/cmds/speech";

#define TP this_player()
#define BEEP sprintf("%c",7)

#define NO_QUIT_INVENTORY 1
#define NO_QUIT_COMBAT    2
#define BROADCASTER "/obj/handlers/broadcaster"

int query_no_quit();
string query_shout_word_type(string str);
void my_mess(string fish, string erk);

/* ok... the shout cost is charged for every 5 letters, plus a bonus
 * one for the start charge..  SO a shout of yes will cost 1 social
 * point... where as a shout of lots a letters will cost lots
 */
mixed cmd(string str) {
  string s1, s2, s;
  object g;
  string cur_lang;
  object lag;
  int tim, cost;

  if(!str || str == "")
    return notify_fail("Syntax : shout <text>\n");

  if (!environment(this_player()))
    return notify_fail( "You appear to be in limbo...\n" );

  if(TP->query_property("dead") == 1)
    return notify_fail("You don't have any lungs, how can you shout?\n");

  if (TP->check_earmuffs("shout"))
    return notify_fail("Why shout when you can't hear people "
                       "shout back?\n");

  cur_lang = TP->query_current_language();

  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");

  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken "
                       "at a distance.\n");

  if (TP->query_invis())
    return notify_fail("Invisible people cannot shout, they cannot "
                       "see their arm in front of their face.  Shouting is "
                       "out of the question.\n");

  // Added by Obilix 9/4/97
  if (TP->query_property("gagged"))
    return notify_fail("You have been gagged!  You will not be able "
                       "to shout again until the gag is removed.  Perhaps "
                       "you should talk to a creator about this.\n");

  if (TP->query_property("recently shouted")) {
    return notify_fail("You have shouted very recently, perhaps you "
                       "should give your lungs a small break and try again "
                       "in a couple seconds.\n");
  }

  if(TP->query_property("player") == 1 && !TP->query_creator()) {
    cost = SHOUT_COST * ((strlen(str) / 5) + 1);
    // Capitals and punctuation cost extra.
    cost += sizeof(filter(explode(str, ""), (: $1 <= "Z" :))) / 2;

    if(TP->adjust_sp(-cost) < 0)
      return notify_fail(NO_POWER);

    TP->adjust_max_sp(- (cost / 5));
  }

  if (!interactive(TP)) {
    str = TP->convert_message( str );
    str = TP->fit_message( str );
  }

  s1 = query_shout_word_type(str);

  if (s1 != "yell")
    s = "shouts" + s1;
  else
    s = s1 + "s";

  if(TP->query_property(SHORTHAND_PROP))
    str = fix_shorthand(str);

  if(TP->query_volume( D_ALCOHOL))
    str = drunk_speech( str );
  TP->remove_hide_invis("hiding");

  if (s1 != "yell") {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You shout" + s1 + ": ", str);
  } else {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You " + s1 + ": ", str);
  }

  s2 =  " " + lower_case(str);

  /* Who zapped the old 8 code? */
  /* Damn it used to be quite clever... grrr.  could have least #ifdefed it
   * - pf */

  /* Remove this and face the wrath of Bel-Shamharoth. */
  /* And yes, this is in the books....                 */

  if (sscanf(" "+s2, "%s eight%s", s1, s1)==2 ||
      sscanf(s2, "%s8%s", s1, s1)==2) {

    s1 = replace(str, ({ "8", "", " eight", "", " ", "" }));

    switch (query_no_quit()) {
    case NO_QUIT_INVENTORY:
      return notify_fail("You only just arrived.  You are far too "
                         "busy strapping on equipment to shout like that.\n");
    case NO_QUIT_COMBAT:
      return notify_fail("You are too busy fighting to shout "
                         "like that.\n");
    default:
      if (s1 == "") {
        /* Was just a string of 8's and spaces.... */
        write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
      else {
        g = (object)TP->query_guild_ob();
        if (random(100) < 40 ||
            (g && (string)g->query_name() == "wizards"))
          write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
    }
  }


  /* Check for lag shouts... */
  /* This isn't in the books, but I don't care  */
  lag = load_object(SHORT + "short20")->lag_for_shout();
  if(lag && sscanf(" "+lower_case(s2), "%*s lag%*s") == 2) {

    //        catch(lag = LAG_ROOM->lag_for_shout());

    tim = TP->query_property("lag shout time");

    /* Make it time out so it does not clutter up stuff */
    TP->add_property("lag shout time", time(), 300);

    // that'll teach them! Ceres
    if((tim + 300 > time()) && lag != TP) {

      switch (query_no_quit()) {
      case NO_QUIT_INVENTORY:
        lag->init_command("hug "+ TP->query_name() +
                          " Welcome to " + mud_name() + "", 0);
        return notify_fail("The air is suddenly squeezed out "
                           "of you.\n");

      case NO_QUIT_COMBAT:
        lag->init_command("wedgie " + TP->query_name(), 0);
        return notify_fail("You are rudely interrupted "
                           "mid-shout.  Fortunately you are not distracted "
                           "from the fight.\n");

      default:
        call_out( "summon_bel_shamharoth", 10, TP, 1);
      }
    }
  }

  if(environment(this_player()) &&
     environment(this_player())->query_property("location") == "inside")
    tim = 10;
  else
    tim = 3;
  
  user_event( this_player(), "person_shout",
              (string)this_player()->a_short() +" "+ s,
              str, cur_lang,
              (int *)environment( this_player() )->query_co_ord(),
              ( 100 * ( (int)this_player()->query_con() +
                        (int)this_player()->query_str() ) ) / tim );
  /*
    TP->comm_event(users(), "person_shout", "$a_short:"+ file_name(TP) +
    "$ "+ s, str, cur_lang);
  */
  environment(TP)->event_person_shout( 0, (string)TP->a_short() +" "+ s,
                                       str + "%^RESET%^", cur_lang );

  BROADCASTER->npc_shout_event(TP, (string)TP->a_short() +" "+ s,
                               str + "%^RESET%^", cur_lang,
                               (int *)environment(TP)->query_co_ord(),
                               (100 * ((int)TP->query_con() +
                                       (int)TP->query_str() ) ) / 3);

  if (TP->query_property("player") == 1 && !TP->query_creator()) {
    TP->add_property("recently shouted", 1, 2);
  }

  return 1;
}

string query_shout_word_type(string str) {
  switch (str[<1]) {
  case '!':
    return "yell";
  case '?':
    return " asking";
  default:
    return "";
  }
}

void my_mess(string fish, string erk) {
  if(!interactive(TP))
    return;

  printf("%s%-=*s\n", fish, TP->query_cols() - strlen(fish),
         TP->fix_string(erk));
}

void summon_bel_shamharoth(object who, int lag_shout) {
  object env;

  if (!who || !objectp(who))
    return;

  if (!random(3))
    who->adjust_tmp_con(-2);

  if (!random(3))
    who->adjust_tmp_int(-2);

  if (!random(3))
    who->adjust_tmp_wis(-2);

  if (!random(3))
    who->adjust_tmp_dex(-2);

  env = environment(who);

  if ("/secure/master"->query_lord(geteuid(who))) {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                 "The heavens shake with a hideous roar and just as suddenly "
                 "all is quiet.\n$C$"+ who->query_name() + " chuckles in the "
                 "distance.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object(who, "Your lordliness saves you from a grizzly "
                "encounter with the Sender of Eight.\n");
  } else {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                             "a sudden chill passes through the land as $C$" +
                           who->query_name() + " is carried off screaming "
                           "to the land of shades.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object( who, "You think you'd best be careful what you "
                 "shout in the future as shadowy tentacles drag you "
                 "into the ground...\n" );

    if(lag_shout)
      BROADCASTER->broadcast_event(users(),
                                   (int *)env->query_co_ord(),
                                   ( 100 * ( (int)who->query_con() +
                  "The heavens shake with a hideous chuckle and in the "
                  "distance a booming yet apologetic voice says: Oops.\n",
                                             (int)who->query_str() ) ) / 3,
                                   1, 0);

    if(base_name(env) != "/room/departures")
      who->quit();
  }
}

/**
 * check to see if player can quit voluntarily
 * @returns non zero code if the player may not voluntarily quit
 */
int query_no_quit() {

  /* "You cannot quit yet: your inventory is still being generated.\n" */
  if (TP->query_save_inhibit() || TP->query_auto_loading()) {
    return NO_QUIT_INVENTORY;
  }

  /* "You cannot quit while in combat.\n" */
  if (sizeof(filter_array(TP->query_attacker_list(), (: living($1) :)))) {
    return NO_QUIT_COMBAT;
  }

  return 0;
}
// --- END [/mnt/home2/grok/lib/cmds/living/sh_out.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/und_efend.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/und_efend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626970   Available: 13574324
Inodes: Total: 5242880    Free: 4960132
983 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/und_efend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626970   Available: 13574324
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unp_rotect.c,v 1.6 1999/04/13 01:15:25 pinkfish Exp $
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(object *things) {
  object *defendees;
  object ob;
  object *fail;

  if(!things) {
    things = ({ });
  }
  things -= ({ TP });

  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot undefend yourself!\n");
    return 0;
  }

  defendees = ({ });
  fail = ({ });

  foreach ( ob in things) {
    if ( ob->remove_defender( TP ) ) {
      defendees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not defending " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(defendees)) {
     add_succeeded_mess("$N stop$s defending $I.\n", defendees);
     return 1;
  } else {
     return 0;
  }
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) }); 
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/und_efend.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/crawl.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/crawl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626969   Available: 13574323
Inodes: Total: 5242880    Free: 4960132
2672 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/crawl.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626969   Available: 13574323
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Wirble, Jan. 2001 */

/*
 * $Id: crawl.c,v 1.1 2001/03/09 01:50:53 pinkfish Exp $
 */

/**
 * This command allows a player to crawl when his legs are broken or pass
 * through low exits, for example.
 * @see /std/effects/other/crawling.c
 * @see /std/shadows/other/crawling.c
 * @author Wirble
 * @started Jan. 2001
 */

#define EFFECTPATH "/std/effects/other/"
#define PT "/obj/handlers/playtesters"

inherit "/cmds/base";

int is_in_water( object room );


/** @ignore */
varargs int cmd( string str ) {

   if( str == "stop" ) {
      if( !this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You should be crawling first in order"
                                         " to stop doing it, don't you "
                                         "think?\n",
                                         ({ }) );
         return 0;
      };

      this_player()->stop_crawling();
      return 1;
   };

   if( !str ) {
      if( this_player()->query_property( "dead" ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You appear to be dead.  There is no "
                                         "necessity to torture your morphogenic"
                                         " arms, you know?\n",
                                         ({ }) );
         return 0;

      } else if( this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are already crawling.\n",
                                         ({ }) );
         return 0;

      } else if( is_in_water( environment( this_player() ) ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are in water at the moment, so "
                                         "crawling is impossible.\n",
                                         ({ }) );
         return 0;

      } else {
         this_player()->add_effect( EFFECTPATH + "crawling" );
         return 1;
      };
   };

} /* int cmd() */


/* This is necessary to make 'syntax crawl' work correctly.
 * So please don't hit me for this not being in the shadow :) */
/** @ignore */
mixed* query_patterns() {

   return ({
      "", (: cmd() :),
      "stop", (: cmd( "stop" ) :)
   });

} /* mixed* query_patterns() */


/** @ignore */
int is_in_water( object room ) {

   if( inherits( "/std/water_inside.c", room ) ||
       inherits("/std/water_outside.c", room ) ||
       inherits("/std/uwater.c", room ) ) {
      return 1;

   } else
      return 0;

} /* int is_in_water() */

// --- END [/mnt/home2/grok/lib/cmds/living/crawl.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/unf_ollow.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/unf_ollow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626968   Available: 13574322
Inodes: Total: 5242880    Free: 4960132
1863 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/unf_ollow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626968   Available: 13574322
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unf_ollow.c,v 1.5 2002/04/08 09:19:10 trilogy Exp $
 * $Log: unf_ollow.c,v $
 * Revision 1.5  2002/04/08 09:19:10  trilogy
 * Made it so that you unfollow unseen when you're hidden
 *
 * Revision 1.4  2001/11/07 22:46:44  pinkfish
 * Opps, left in an error.
 *
 * Revision 1.3  2001/11/07 22:08:51  pinkfish
 * Nothing!
 *
 * Revision 1.2  2000/02/28 18:47:05  ceres
 * Fixed bug that allowed you to figure out who was alive and who wasn't.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

int cmd(object *obs) {
   mapping hide_invis;
   int hiding, sneaking;
  object *ok, ob;
  string s;

  ok = ({ });
  foreach (ob in obs) {
    if (ob->remove_follower(TP)) {
      ok += ({ ob });
    }
  }

  if (!sizeof(ok)) {
    if (member_array(TP, obs) == -1) {
      return notify_fail("You are not following "+query_multiple_short(obs)+
                         ".\n");
    } else {
      return notify_fail("You are not following " +
        query_multiple_short(obs - ({ TP }) + ({ "yourself" })) + ".\n");
    }
  }

  hide_invis = ( mapping )this_player()->query_hide_invis();

  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;

  if( hiding || sneaking )
   write("You stop following "+(s=query_multiple_short(ok))+" unseen.\n");
  else {
    write("You stop following "+(s=query_multiple_short(ok))+".\n");
    say(TP->the_short()+" stops following "+s+".\n", ok);
    foreach (ob in ok) {
      tell_object(ob, TP->the_short() +
                  " stops following "+query_multiple_short((ok + ({"you"})) -
                                                           ({ ob }))+".\n");
    }
  }
  return 1;
}

mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/unf_ollow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/remove.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/remove.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626968   Available: 13574322
Inodes: Total: 5242880    Free: 4960132
13001 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/remove.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626968   Available: 13574322
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: remove.c,v 1.19 2003/01/30 06:33:24 pinkfish Exp $
 * $Log: remove.c,v $
 * Revision 1.19  2003/01/30 06:33:24  pinkfish
 * Add in stuff to make sure they drop extra items.
 *
 * Revision 1.18  2002/06/18 20:51:06  presto
 * You know, I really think I might have it right this time.  No, really!
 *
 * Revision 1.17  2002/05/17 00:45:19  trilogy
 *  Forcibly unlocked by presto
 *
 * Revision 1.15  2002/05/16 01:54:40  trilogy
 *  Forcibly unlocked by presto
 *
 * Revision 1.13  2002/02/12 04:42:29  presto
 * Fixed so that an item never blocks itself (which is possible for items
 * of mixed type)
 *
 * Revision 1.12  2002/01/15 01:40:24  presto
 * So help me God, I hope it works now.
 *
 * Revision 1.11  2002/01/07 05:27:16  presto
 * Fixed mistake with not removing things that were *indirectly* blocked by
 * other things
 *
 * Revision 1.10  2002/01/06 05:37:27  presto
 * Rewrote.  Seems to work better now, and I think it's more understandable. :)
 * Will keep an eye on it
 *
 * Revision 1.9  2001/12/07 15:12:11  taffyd
 * Fixed typo and grammar oddity.
 *
 * Revision 1.8  2001/11/08 02:22:07  pinkfish
 * Fox up some little errors.
 *
 * Revision 1.7  2001/11/07 23:09:56  pinkfish
 * Fix up the auto removal a little more.
 *
 * Revision 1.6  2001/11/07 21:46:34  pinkfish
 * Make it so it automatically takes and puts stuff on and off.
 *
 * Revision 1.5  1999/12/08 04:09:04  ceres
 * Modified to use standard can_wear_or_remove() function in /obj/handlers/clot
 * hing_handler
 *
 * Revision 1.4  1998/09/15 00:28:32  pinkfish
 * Fix up the output errors for remove.
 *
 * Revision 1.3  1998/08/25 10:18:41  pinkfish
 * Change remove so it will order the thnigs to remove...  SO it takes
 * the toip off first.
 *
 * Revision 1.2  1998/03/27 20:49:01  pinkfish
 * To the new clothing handler.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include <clothing.h>
#include <tasks.h>

//#define DEBUG

#define SKILL "covert.manipulation.sleight-of-hand"
#ifdef DEBUG
#define TELL_ME "presto"
#endif

inherit "cmds/base";

int cmd(object *things)  {
   object  *removed = ({ });
   object  *blocking = ({ });
   object  *blocked;
   object  *total_blocking = ({ });
   object  *succeeded;
   object  *failed;
   object  *failed_rewear;
   object   ob;
   object   blocker;
   mapping  is_blocking = ([ ]);
   mapping  hide_invis;
   string   tmp1;
   string   tmp2;
   int      last_blocking;
   int      limit;
   int      i;
   int      hiding;
   int      sneaking;
   int      difficulty;
   int      light;
   int      my_light;

   succeeded = this_player()->query_wearing();
   failed = filter(things, (: member_array($1, $(succeeded)) == -1 :));
   things -= failed;
   if (sizeof(things) == 0)  {
      write("You are not wearing " + query_multiple_short(failed, "the") +
            ".\n");
      return 1;
   }

   succeeded = things;
   for (i = 0; i < sizeof(succeeded); i++)  {
      ob = succeeded[i];
      blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player()) -
                 ({ ob });
      if (sizeof(blocking))  {
         foreach (blocker in blocking)  {
            if (undefinedp(is_blocking[blocker]))
               is_blocking[blocker] = ({ ob });
            else
               is_blocking[blocker] |= ({ ob });
         }

         total_blocking |= blocking;

         /*
          * We need to add the blocking things to the things we are checking,
          * because the blocking things may themselves be blocked by something
          * that was not blocking the thing that the original blocker was
          * blocking.  Oh... you want an EXAMPLE.  OK:
          *
          * Example: a silk shirt is blocked by a mail shirt, but NOT by a
          * scabbard.  However, the mail shirt IS blocked by the scabbard, so
          * it has to be removed before we can remove the mail shirt; so that
          * we can remove the silk shirt.
          */

         succeeded = ({ things..., total_blocking... });
      }
   }

   /*
    * OK, here is the important, complicated bit.  At this point, the
    * is_blocking mapping is keeping track of everything that is blocking
    * something else, and what it is blocking.  We need to build an array of
    * blocking objects in order from outermost layer to innermost.  That way
    * there should be no failures when we remove the covering stuff to get
    * to the things that the player wants to remove.  Here is how this works:
    *
    * 1. Loop over all items that are blocking something else
    * 2. For each item, find the last thing in the array (so far) that would
    *    block the item.  Insert the item we are adding should immediately
    *    after that position.
    * 3. Loop over the array we are building up to the step 2 index and check
    *    whether each object would have been blocked by the new item, or by
    *    anything else that we moved already in a previous run through the
    *    loop.  If so, move the object after the new item and previously moved
    *    items.
    */
    
   total_blocking = ({ });
   foreach (ob, blocked in is_blocking)  {

#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
      tell_creator(TELL_ME, "ob == %s, blocked == %O\n",
                   ob->short(), blocked->short());
#endif
        
      /* Find the last thing that is blocking 'ob' */
      last_blocking = -1;
      for (i = sizeof(total_blocking) - 1; i >= 0; i--)  {
         if (member_array(ob, is_blocking[total_blocking[i]]) > -1)  {
            last_blocking = i;
            break;
         }
      }

      if (last_blocking == -1)  {
         /*
          * Nothing is blocking 'ob', so we can safely put it at the
          * front of the list, because then, even if it blocks something
          * else, it will get removed first.
          */
         total_blocking = ({ ob, total_blocking... });

#ifdef DEBUG
         if (this_player() == find_player(TELL_ME))
            tell_creator(TELL_ME, "Nothing is blocking ob, adding it to "
                         "the beginning\n%O\n", total_blocking->short());
#endif

         continue;
      }

      total_blocking = ({ total_blocking[0 .. last_blocking]...,
                          ob,
                          total_blocking[(last_blocking + 1) .. ]... });

#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
         tell_creator(TELL_ME, "Adding ob after last_blocking position "
                      "(%d)\n%O\n",
                      last_blocking, total_blocking->short());
#endif

      limit = last_blocking;
      blocking = copy(blocked);
      for (i = 0; i < limit; i++)  {
         /*
          * If the object we are checking is blocked by anything we have
          * moved so far, then we have to move it too
          */
         if (member_array(total_blocking[i], blocking) > -1)  {
            blocking += is_blocking[total_blocking[i]];
            if (i == 0)
               total_blocking =
                  ({ total_blocking[1 .. (last_blocking + 1)]...,
                     total_blocking[0],
                     total_blocking[(last_blocking + 2) .. ]... });
            else
               total_blocking =
                  ({ total_blocking[0 .. (i - 1)]...,
                     total_blocking[(i + 1) .. (last_blocking + 1)]...,
                     total_blocking[i],
                     total_blocking[(last_blocking + 2) .. ]... });
            --limit;
            --i;

#ifdef DEBUG
            if (this_player() == find_player(TELL_ME))
               tell_creator(TELL_ME, "Reordered list:\n%O\n",
                            total_blocking->short());
#endif

         }
      }
   }

   /* Remove stuff that's blocking the stuff we asked to remove */
   foreach (blocker in total_blocking)  {
      tmp1 = CLOTHING_HANDLER->can_wear_or_remove(blocker, this_player());
      if (tmp1)  { /* This *shouldn't* happen */
//         log_file("REMOVE_FAILURE", "things == %O\n", things);
//         log_file("REMOVE_FAILURE", "reason == %s\n", tmp1);
//         log_file("REMOVE_FAILURE", "blocker == %s (%s, %O)\n", blocker->short(), file_name(blocker), blocker);
//         log_file("REMOVE_FAILURE", "total_blocking == \n");
//         for (i = 0; i < sizeof(total_blocking); i++)  {
//            log_file("REMOVE_FAILURE", "   %O (%s)\n", total_blocking[i], total_blocking[i]->short());
//         }
//         log_file("REMOVE_FAILURE", "is_blocking == \n");
//         foreach (ob, blocked in is_blocking)  {
//            log_file("REMOVE_FAILURE", "   %O (%s): \n", ob, ob->short());
//            for (i = 0; i < sizeof(blocked); i++)  {
//               log_file("REMOVE_FAILURE", "      %O (%s)\n", blocked[i], blocked[i]->short());
//            }
//         }
//         log_file("REMOVE_FAILURE", "removed == %O\n", removed);
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " " + tmp1 + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else if (this_player()->remove_armour(blocker))  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " because you cannot remove " + blocker->one_short() + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else removed += ({ blocker });
   }

   /* Now remove the stuff we really wanted to */
   /*
    * Start with things we already removed because they were blocking
    * something else
    */
   succeeded = things & removed;
   failed = ({ });

   /* Now try to remove the rest */
   foreach (ob in things - removed)  {
      if (this_player()->remove_armour(ob))
         failed += ({ ob });
      else
         succeeded += ({ ob });
   }

   if (sizeof(succeeded) > 0)  {
      removed -= things;
      tmp2 = query_multiple_short(succeeded, "the") ;
      if (sizeof(removed) > 0)  {
         tmp1 = query_multiple_short(removed, "the");
         write("You remove " + tmp1 + " so you can remove " + tmp2 + ".\n");
         say(this_player()->the_short() + " removes " + tmp1 + " so " +
             this_player()->query_pronoun() + " can remove " + tmp2 + ".\n");
      }
      else  {
        hide_invis = ( mapping )this_player()->query_hide_invis();
        hiding = hide_invis[ "hiding" ] ? 1 : 0;
        sneaking = this_player()->query_sneak_level() ? 1 : 0;
      
        if( hiding || sneaking ) {
          my_light = this_player()->query_light();
          light = environment( this_player() )->query_light();
        
          difficulty = light + ( 4 * my_light ) / ( light + 1 );
      
          difficulty += succeeded[0]->query_complete_weight();
      
          debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                        difficulty, SKILL, this_player()->
                        query_skill_bonus( SKILL ) );
          switch( TASKER->perform_task( this_player(), SKILL, difficulty,
            TM_FREE ) ) {
            case AWARD :
              write( "%^YELLOW%^" + ({
                "You discover something that lets your fingers move more "
                  "nimbly.",
                "You find yourself capable of deceiving the eye with greater "
                  "ease than before.",
                "You realise how to deceive the eye more effectively."
              })[ random(3) ] + "%^RESET%^\n" );
            case SUCCEED :
              add_succeeded_mess( ({ "$N $V " + tmp2 + ", managing to stay "
                "unnoticed.\n",
                "" }) );
              break;
            default :
              this_player()->add_succeeded_mess( this_object(), "$N "
                "unsuccessfully tr$y to " + query_verb() + " " + tmp2 +
                " while staying unnoticed.\n", ({ }) );
              break;
          }
        } else {
          this_player()->add_succeeded_mess( this_object(), "$N $V " + tmp2 +
            ".\n", ({ }) );
        }
      }
   }

   /* Put stuff back on that we took off */
   succeeded = ({ });
   failed_rewear = ({ });
   foreach (ob in removed)  {
      if (this_player()->wear_armour(ob))
         failed_rewear += ({ ob });
      else
         succeeded += ({ ob });
   }

   if (sizeof(succeeded) > 0)  {
      // Make sure they drop extra items
      this_player()->force_burden_recalculate();
      tmp1 = query_multiple_short(succeeded, "the");
      write("You wear " + tmp1 + ".\n");
      say(this_player()->the_short() + " wears " + tmp1 + ".\n");
   }

   if (sizeof(failed_rewear) > 0)  {
      write("You cannot put " +
            query_multiple_short(failed_rewear, "the") + " back on.\n");
   }

   if (sizeof(failed) > 0)  {
      write("You cannot remove " + query_multiple_short(failed, "the") +
            ".\n");
   }

   return 1;
}


mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/remove.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/stand.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626964   Available: 13574318
Inodes: Total: 5242880    Free: 4960132
330 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/stand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626964   Available: 13574318
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: stand.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: stand.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/position_base";
#include <position.h>

void create() {
   ::create();
   setup_position("stand", "up", STANDING);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/living/stand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/fo_llow.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/fo_llow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626964   Available: 13574318
Inodes: Total: 5242880    Free: 4960132
1767 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/fo_llow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626964   Available: 13574318
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: fo_llow.c,v 1.5 2002/04/08 09:18:49 trilogy Exp $
 */
inherit "/cmds/base";

#define TP this_player()

int cmd(object *obs) {
   object *ok, ob;
   object *already;
   string s;
   mapping hide_invis;
   int hiding, sneaking;
   
   ok = ({ });
   already = ({ });
   foreach (ob in obs) {
      if (member_array(TP, ob->query_followers()) == -1) {
         if (ob->add_follower(TP)) {
            ok += ({ ob });
         }
      } else {
         already += ({ ob });
      }
   }

   if (!sizeof(ok)) {
      if (sizeof(already)) {
         add_failed_mess("You are already following $I.\n", already);
      }
      obs -= already;
      if (sizeof(obs)) {
         if(member_array(TP, obs) == -1) {
            add_failed_mess("You cannot follow " + query_multiple_short(obs) +
                                          ".\n");
         } else {
            add_failed_mess("You can't follow " +
                          query_multiple_short(obs - ({TP}) + ({"yourself"})) +
                          ".\n");
         }
      }
      return 0;
   }

  hide_invis = ( mapping )this_player()->query_hide_invis();

  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;

  if( hiding || sneaking )
    write("You follow " + ( s = query_multiple_short( ok ) ) + " unseen.\n" );
  else {
   write("You follow "+(s=query_multiple_short(ok))+".\n");
   say(TP->one_short(1)+" follows "+s+".\n", ok);
   foreach (ob in ok)
      tell_object(ob, TP->one_short(1)+
                      " follows "+query_multiple_short((ok + ({"you"})) -
                      ({ ob }))+".\n");
  }
   return 1;
}

mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/fo_llow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/sayto.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/sayto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626963   Available: 13574317
Inodes: Total: 5242880    Free: 4960132
628 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/sayto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626963   Available: 13574317
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sayto.c,v 1.6 2001/11/07 22:02:50 pinkfish Exp $
 */
#include <language.h>
#include <player.h>
#include <drinks.h>

inherit "cmds/base";
inherit "/cmds/speech";

#define TP this_player()

mixed cmd(object *obs, string str) {
  class message mess;

  obs = filter(obs, (: $1 && $1 != this_player() :));
  if(!sizeof(obs)) {
    return notify_fail("Be serious.\n");
  }
  
  mess = build_message(str, obs, "say");
  return say_it_to(mess, obs, 0, "person_say");
}

mixed *query_patterns() {
   return ({ "<indirect:living> <string>", (: cmd($1, $4[1]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/sayto.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/learn.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/learn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626963   Available: 13574317
Inodes: Total: 5242880    Free: 4960132
9976 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/learn.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626963   Available: 13574317
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: learn.c,v 1.19 2003/01/31 06:27:31 pinkfish Exp $
 * 
 */
#include <skills.h>
#include <tune.h>
#include <cmds/teach.h>
#include <command.h>

inherit "/cmds/base";

#define TP this_player()
mixed cmd(string str, object *obs);

mixed cmd(string str, object *obs) {
  object *diff_lvl;
  object *no_xp;
  object *not_offer;
  object *ok;
  object *moved;
  object ob;
  int time;
  string skill;
  string cmd;
  string cmd_ob;
  string *bits;
  string levelstr;
  class teaching_skill womble;

  if (TP->query_property("dead")) {
    notify_fail("Your dead.  Your mind slips off the task and goes for "
                "a wander down memory lane.\n");
    return 0;
  }

  skill = str;

  /* Figure out the skill thingy. */
  bits = explode(implode(explode(skill, " "), "."), ".");
  skill = SKILL_OB->query_skill(bits);
  if (!skill) {
    /* Ok, not a skill...  Check to see if it is a command. */
    ok = ({ });
    cmd = str;
    if (sizeof(CMD_D->GetPaths(cmd)) &&
        CMD_D->GetPaths(cmd)[0]) {
       cmd_ob = CMD_D->GetPaths(cmd)[0] + "/" + cmd;
       foreach (ob in obs) {
          bits = TP->query_respond_command(TEACH_COMMAND_TYPE, ob);
          if (pointerp(bits) && member_array(cmd, bits) != -1) {
             cmd_ob->teach_command(ob, this_player());
             ok += ({ ob });
             bits -= ({ cmd });
             if (sizeof(bits)) {
                TP->add_respond_command(TEACH_COMMAND_TYPE, ob, bits);
             } else {
                TP->remove_respond_command(TEACH_COMMAND_TYPE, ob);
             }
             event(environment(this_player()), "teach", "command", ob, this_player());
             break;
          }
       }
       if (sizeof(ok)) {
          add_succeeded_mess("$N learn$s " + cmd + " from $I.\n", ok);
          return 1;
       }
       add_failed_mess("The skill \"" + cmd + "\" is invalid, or $I "
                       "is not trying to teach you the \"" + cmd + "\" "
                       "command.\n");
    } else {
       add_failed_mess("The skill '" + cmd + "' is invalid.\n");
    }
    return 0;
  }

  moved = ok = not_offer = no_xp = diff_lvl = ({ });
  foreach (ob in obs) {
    womble = TP->query_respond_command(TEACH_SKILL_TYPE, ob);
    if (!womble) {
      not_offer += ({ ob });
      continue;
    }
    if (skill != womble->skill) {
      not_offer += ({ ob });
      continue;
    }
    if ((int)TP->query_xp() < womble->xp ||
        !womble->xp) {
      no_xp += ({ ob });
      continue;
    }
    if (TP->query_skill(womble->skill) != womble->lvl) {
      diff_lvl += ({ ob });
      TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
      continue;
    }
    if (sizeof(ok)) {
      continue;
    }
    if(womble->num == 1)
      levelstr = "level";
    else
      levelstr = "levels";

    if (environment(this_player()) != womble->room) {
       moved += ({ ob });
       TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
       continue;
    }
    
    if (ob != TP) {
      write(ob->short()+" starts to teach you " + womble->num + " " +
            levelstr + " of " + womble->skill + " for " + womble->xp +
            " xp.\n");
      tell_object(ob, "You start to teach " + TP->short() +
                  " " + womble->num + " " + levelstr +
                  " of " + womble->skill +
                  " for " + womble->xp + " xp.\n");
      say(ob->short()+" starts to teach "+TP->short()+" some skills.\n",
          ({ TP, ob }));
      ok += ({ ob });
    } else {
      write("You start to teach yourself " + womble->num + " " +
            levelstr + " in "+
            womble->skill + " for " + womble->xp + " xp.\n");
      say(TP->short()+" starts to teach " + TP->query_objective() +
          "self some skills.\n", ({ TP }));
    }
    /*
     * Ok...  We now change the time on both people and wait...
     * After they have both finished everything is hunky womble.  If one
     * types stop, we dont teach them anything...
     */
    time = womble->xp / TIME_DIV;
    if(time > 1000) {
      time = 1000;
    }
    
    TP->adjust_time_left(-time);
    womble->teacher = ob;
    womble->taught = TP;
    TP->set_interupt_command("stop_teaching_skills", file_name(this_object()),
                             womble);

    if (TP != ob) {
      ob->adjust_time_left(-time);
      ob->set_interupt_command("stop_teaching_skills", TP, womble);
    }
  }
  if (sizeof(not_offer)) {
    if(sizeof(not_offer) == 1) {
      if(not_offer[0] != this_player())
        write(capitalize(query_multiple_short(not_offer)) +
              " is not offering to teach you "+ skill+".\n");
      else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach yourself "+ skill+".\n");
    } else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach you "+ skill+".\n");
  }
  if (sizeof(moved)) {
    write("You appear to have moved away from the excellent teaching "
          "environment selected by "+
          query_multiple_short(moved)+".\n");
  }
  if (sizeof(no_xp)) {
    write("You do not have enough xp to learn "+skill+" from "+
          query_multiple_short(no_xp)+".\n");
  }
  if (sizeof(diff_lvl)) {
    write("You were a different level in "+skill+" when "+
          query_multiple_short(diff_lvl)+" offered to teach you.\n");
  }
  if (sizeof(ok)) {
    say(TP->short()+" learns some skills from "+query_multiple_short(ok)+
        ".\n", ok);
  }
  return 1;
} /* cmd() */

/**
 * The method to call when we stop teaching skills.  THis will stop the
 * stuff being taught if the stop is successful, and only teach partial
 * amounts if we are not finished yet.
 * @param left the amount of time left
 * @param bing the data associated with the command
 */
void stop_teaching_skills(int time_left, class teaching_skill womble,
                          object us, object interupter, string cmd) {
   object ob;
   mixed *stuff;
   string levelstr;
   
   if (time_left > 0) {
      /* Someone did a stop!  Naughty frogs! */
      if (womble->teacher == us) {
         /* Only print the messages once. */
         if (womble->teacher == womble->taught) {
            say(womble->taught->short() + " stops teaching " +
                womble->taught->query_objective() + "self some "
                "skills.\n");
         } else if (us == interupter) {
            ob = womble->teacher;
            tell_object(ob, womble->taught->short() + " interupts your "
                            "training.\n");
         } else {
            tell_object(us, interupter->short() + " interupts your "
                            "training.\n");
         }
         say(interupter->short() + " stops teaching some skills to " +
             womble->taught->short() + ".\n",
             ({ us, interupter }));
      }

      /* Interupt the other person. */
      if (us == womble->teacher) {
         ob = womble->taught;
      } else {
         ob = womble->teacher;
      }
      if (ob) {
         stuff = ob->query_interupt_command();
         if (stuff) {
            if (stuff[0] == "stop_teaching_skills") {
               ob->interupt_command(us);
            }
         }
      }
      us->adjust_time_left(-((int)womble->taught->query_time_left()));
      us->set_interupt_command(0);

      return ;
   }
  
   if (interupter != us) {
      /* First make sure we dont get the level twice... */
      return ;
   }

   if (environment(womble->taught) != environment(womble->teacher) ||
       environment(womble->taught) != womble->room) {
      tell_object(us, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      tell_object(womble->teacher, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      return;
   }

   // additional test added by ceres coz people are getting put into negative
   // xp by getting taught twice somehow.
   if(womble->taught->query_xp() < womble->xp) {
      write("Something has gone wrong. :(\n");
      return;
   }
   /* Ok...  We did it!  Finished! */
   if (womble->taught != womble->teacher) {
      womble->teacher->adjust_xp(womble->xp / 10);
   }
   womble->taught->adjust_xp(-womble->xp);

   if(womble->num == 1)
     levelstr = "level";
   else
     levelstr = "levels";
   
   if(womble->taught->add_skill_level(womble->skill, womble->num, womble->xp))
     {
       
       if (us != womble->teacher) {
         tell_object(us, "You finish learning " + womble->num +
                     " " + levelstr + " of "
                     + womble->skill + " from " + womble->teacher->short() +
                     ".\n");
         tell_object(womble->teacher, womble->taught->short() + " finishes " +
                     "learning " + womble->num + " " + levelstr + " of "
                     + womble->skill + " from you.\n");
         say(us->short() + " finishes learning some skills "+
             "from "+ womble->teacher->short()+".\n",
             ({ us, womble->teacher }));
       } else {
         tell_object(us, "You finish teaching yourself " + womble->num +
                     " " + levelstr + " of " +
                     womble->skill + ".\n");
         say(us->short() + " finishes learning some skills "
             "from " + us->query_objective() + "self.\n",
             ({ us, womble->teacher }));
       }
     } else {
       tell_object(womble->taught, "Something went wrong learning " +
                   womble->skill + " from " + womble->teacher->query_short() +
                   ".\n");
     }
   womble->taught->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
} /* stop_teaching_skills() */

mixed *query_patterns() {
   return ({ "<string'skill/command'> from <indirect:living>",
             (: cmd($4[0], $1) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/living/learn.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/show.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/show.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626960   Available: 13574314
Inodes: Total: 5242880    Free: 4960132
6079 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/show.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626960   Available: 13574314
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id: show.c,v 1.14 2002/06/21 01:54:57 presto Exp $
 * $Locker:  $
 */

/**
 * This is the command to show things
 * to players without having to give them
 * up.  Other than do_show_object(), there's
 * nothing interesting in this file that
 * can be used externally.
 *
 * @author Tape
 */

#include <command.h>
#define READ ( DIR_LIVING_CMDS "/r_ead" )

inherit "/cmds/base";

int do_show_object( object shower, object item, object owner, object target, int no_mess );

#ifdef DEBUG
int notify_fail(string str) {
  tell_object(find_player("tape"), "%^YELLOW%^"+
              this_player()->query_short()+" "+str+"%^RESET%^\n");
  return efun::notify_fail(str);
}
#endif


/** @ignore */
int cmd( object item, object target )
{
   return do_show_object( this_player(), item, this_player(), target, 0 );
} /* cmd() */


/**
 * You can use this function to indirectly access the show command and
 * have an npc show an 'item' that he is not carrying to someone.  If
 * he is carrying the 'item', you might as well use the command
 * normally with do_command().
 *
 * Although the 'shower' does not have to be carrying the 'item',
 * the parameter 'owner' is checked when the show offer is accepted,
 * to see if the 'item' is still contained inside it.  If owner is
 * 0, the offer is processed successfully _always_.  This means that
 * you can still show objects with no environment, but it isn't
 * recommended.  And no, I can't think of an outright reason why not.
 *
 * When a player uses the command, 'shower' == 'owner' == this_player().
 *
 * @param shower the person doing the showing
 * @param item the item being shown
 * @param owner the object that the item is contained in
 * @param target the person you're showing it to
 * @param nomess set this to 1 if you don't want any "X offers to show Y to you"
 *
 * @return 1 if the command succeeded, 0 if failed
 */
int do_show_object( object shower, object item, object owner, object target, int nomess )
{
   tell_creator( shower, "%O\n%O\n", item, target );

   if( target == shower ) {
      add_failed_mess( "Why not just look at it?\n");
      return 0;
   }
   
   if( !shower->query_visible( target ) ) {
      add_failed_mess( "It appears that " + target->the_short() +
         " can't see you or your item.\n" );
   
      return 0;
   }
   
   if( target->query_property( "ignoring" ) ) {
      if( member_array( shower->query_name(),
         target->query_property( "ignoring" ) ) != -1 ) {
         add_failed_mess( target->the_short() + " ignores you.\n" );
         return 0;      
      }
   }

   if( item->query_worn_by() ) {
      add_failed_mess( item->the_short() + " must be removed before it can be "
         "shown.\n" );
      return 0;
   }
   
   target->add_respond_command( "show offer", this_object(),
      ({ item, owner, shower }) );
   
   if( !nomess )
   {
      tell_room( environment( shower ), shower->the_short() +
         " offers to show " + item->a_short() + " to " +
         target->a_short() + ".\n",
         ({ target, shower }) );

      tell_object( shower, "You offer " + item->the_short() +
         " to " + target->the_short() + " for inspection.\n" );
      
      tell_object( target, shower->the_short() + " offers you " +
         item->a_short() + " for inspection.  Use \"show accept offer "
         "from " + shower->query_name() + "\" to view it.\n" );
   }
   
   return 1;
   
} /* cmd() */


/** @ignore */
int accept_show( object target, int read ) {

   mixed *stuff;
   object from;
   object owner;
   object item;
   string message;
      
   if( target == this_player() ) {
      add_failed_mess( "You cannot show stuff to yourself.\n");
      return 0;
   }
      
   stuff = this_player()->query_respond_command(
      "show offer", this_object() );
   
   if( !sizeof( stuff ) ) {
      add_failed_mess( "No one has offered to show you anything.\n");
      return 0;
   }

   item     = stuff[ 0 ];
   owner    = stuff[ 1 ];
   from     = stuff[ 2 ];
   
   /* Object 'from' and the 'owner' of the 'item' might not be one and the
      same.  Although they are when a player shows an object, support
      has been built for npcs to show objects that are not in their
      inventories.  The object 'owner' is the environment of the item
      being shown, while 'from' is the person doing the showing. */
         
   if( !from || target != from ) {
      add_failed_mess( target->the_short() + " hasn't offered "
         "to show you anything.\n" );
      return 0;
   }
   
   if( !item || ( owner && environment( item ) != owner ) )
   {
      add_failed_mess( "It appears that " + target->the_short() +
         " has misplaced " + target->query_possessive() + " item.\n");
      return 0;
   }

   this_player()->remove_respond_command( "show offer", this_object() );
   
   tell_room( environment( this_player() ), this_player()->the_short() +
      " accepts the offer from " +
      target->the_short() +
      " to see " + item->the_short() + ".\n", ({ this_player(), target }) );

   message = "You accept " + target->the_short() + "'s offer.\n";
   
   tell_object( target, "You show " + item->the_short() + " to " +
      this_player()->the_short() + ".\n" );
   
   message += "\n";
   
   if( this_player()->query_creator() ) {
      message += "%^CYAN%^" + file_name( item ) + ":%^RESET%^\n";
   }
   
   message += item->long();
   
   if( sizeof( item->query_read_mess() ) ) {
      message += item->the_short() + " also contains some writing.\n";
      message += item->query_readable_message(this_player());
   }

   write("$P$Show$P$" + message);
   
   return 1;
   
} /* accept_show() */


/** @ignore */
mixed *query_patterns() {
   return ({ 
      "<indirect:object:me'item'> to <indirect:living'living'>",
         (: cmd( $1[ 0 ][ 0 ], $1[ 1 ][ 0 ] ) :),
/*
      "accept [offer] [from] <indirect:living'living'> [and] read [it]",
         (: accept_show( $1[ 0 ], 1 ) :),
 */
      "accept [offer] [from] <indirect:living'living'>",
         (: accept_show( $1[ 0 ], 0 ) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/living/show.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/wi_eld.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/wi_eld.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626959   Available: 13574313
Inodes: Total: 5242880    Free: 4960132
382 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/wi_eld.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626959   Available: 13574313
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wi_eld.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: wi_eld.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

mixed cmd(string str) {
  if (!interactive(this_player()))
    return "/cmds/living/ho_ld"->cmd(str);
  return notify_fail("Use hold; see help hold for more details.\n");
}
// --- END [/mnt/home2/grok/lib/cmds/living/wi_eld.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/meditate.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/meditate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626958   Available: 13574312
Inodes: Total: 5242880    Free: 4960132
352 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/meditate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626958   Available: 13574312
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: terano $
 * $Id: meditate.c,v 1.1 1998/01/06 05:28:43 ceres Exp terano $
 * $Log: meditate.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/position_base";
#include <position.h>

void create() {
   ::create();
   setup_position("meditate", "", MEDITATING);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/living/meditate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/teach.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/teach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626958   Available: 13574312
Inodes: Total: 5242880    Free: 4960132
24309 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/teach.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626958   Available: 13574312
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: teach.c,v 1.48 2003/02/25 17:20:10 trilogy Exp $
 */
#include <skills.h>
#include <tune.h>
#include <command.h>
#include <cmds/teach.h>
#include <playtesters.h>
#include <player.h>

inherit "/cmds/base";

//#define DEBUG 1
#define DEBUGGER "ceres"

/** If this is defined it enforces a maximum level to teach others. */
#undef ENFORCE_MAX_TEACH_LEVEL

int command_teach( object *obs, string comm, object teacher );
int spell_teach(object *obs, string spell, object teacher);
int teach_skill(object *obs, string str, object teacher);
int cmd_int(string str, object *obs, object teacher);
int check_ignoring(object ignorer, object ignoree);

int query_auto_teaching(object teacher, object learner) {
   return teacher->query_property(TEACH_COMMAND_AUTO_PROPERTY);
} /* query_auto_teaching() */

int cmd(string str, object *obs, object player) {
  int ret;
  object ob;
  object* ear;

  if (this_player()->query_property(PASSED_OUT_PROP)) {
     add_failed_mess("You cannot teach while passed out.\n");
     return 0;
  }

  if (this_player()->query_fighting()) {
    add_failed_mess("You cannot teach or learn anything while you are "
                    "fighting!\n");
    return 0;
  }

  if (this_player()->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }

  if (player) {
    ear = filter(obs, (: userp($1) && !interactive($1) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$C$$I does not have enough responsiveness to teach "
                      "you.\n", ear);
      if (!obs) {
        return 0;
      }
    }

    ear = filter(obs, (: $1->check_earmuffs("teach") :));
    if (sizeof(ear)) {
      obs -= ear;
      if (sizeof(ear) == 1) {
        add_failed_mess("$I has " + ear[0]->query_possessive() + " earmuffs "
                        "on.\n", ear);
      } else {
        add_failed_mess("$I have their earmuffs on.\n", ear);
      }
      if (!obs) {
        return 0;
      }
    }

    ear = filter(obs, (: check_ignoring($1, this_player()) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is ignoring you, or you are ignoring them.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }

    ear = filter(obs, (: $1->query_property(PASSED_OUT_PROP) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is passed out and looks rather worse for wear.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }

    ear = filter(obs, (: $1->query_fighting() :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is currently beating stuff up, please wait "
                      "for them to finish.\n", ear);
      if (!obs) {
        return 0;
      }
    }

    obs = filter(obs, (: !$1->query_creator() :) );
    if (!sizeof(obs)) {
      add_failed_mess("None of those people are allowed to teach you.\n");
      return 0;
    }

    obs = filter(obs, (: query_auto_teaching($1, this_player()) :));
    if (!sizeof(obs)) {
      add_failed_mess("None of those people have auto teaching turned "
                      "on.\n");
      return 0;
    }
    obs = filter(obs, (: $1->query_time_left() > 0 :));
    if (!sizeof(obs)) {
      add_failed_mess("All the people you are trying to learn from appear "
                      "to be busy.\n");
      return 0;
    }

    foreach (ob in obs) {
      ret |= cmd_int(str, ({ this_player() }), ob);
    }
    return ret;
  }

  return cmd_int(str, obs, this_player());
} /* cmd() */


int cmd_int(string str, object *obs, object teacher) {
  if (teacher->query_property("dead")) {
    add_failed_mess("You wave your arms around, and your lips move but "
                       "they can't hear what you are saying.\n");
    return 0;
  }
   
  obs = filter(obs,  (: !$1->query_property("dead") :));
  if (!sizeof(obs)) {
    add_failed_mess("You must teach someone, preferably living.\n");
    return 0;
  }

  if (sizeof(obs) > 1) {
    add_failed_mess("You can only teach one person at a time.\n");
    return 0;
  }
  
  if (!command_teach(obs, str, teacher) &&
      !spell_teach(obs, str, teacher) &&
      !teach_skill(obs, str, teacher))
  {
    return 0;
  }

  return 1;
} /* cmd() */


int check_ignoring(object ignorer, object ignoree) {
  return (ignorer->query_property("ignoring") &&
          member_array(ignoree->query_name(),
                       ignorer->query_property("ignoring")) != -1);
} /* check_ignoring() */


int command_teach(object *obs, string comm, object teacher) {
  string cmd_ob;
  object *succ;
  object *no_go;
  object *me_low;
  mixed *him_low;
  object *know_already;
  object *ear_muffed;
  object *ignored;
  object *ignoring;
  object ob;
  string *tmp_stuff;
  int i;
  class command cmd = new(class command, verb : comm);
  mixed tmp;

  if (member_array(comm, teacher->query_known_commands()) == -1 ||
      !CMD_D->HandleStars(cmd))
  {
    if (CMD_D->HandleStars(cmd)) {
      if (teacher == this_player()) {
        add_failed_mess("You do not know the command " + comm + ".\n");
      } else {
        add_failed_mess(teacher->the_short(1) +
                        " does not know the command " + comm + ".\n");
      }
    }
    return 0;
  }
  obs -= ({ teacher });
  if (!sizeof(obs)) {
    add_failed_mess("You cannot teach yourself a command.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    if (teacher == this_player()) {
      add_failed_mess("You have teaching earmuffed.\n");
    } else {
      add_failed_mess(teacher->the_short(1) + " has teaching earmuffed.\n");
    }
    return 0;
  }
  cmd_ob = CMD_D->GetPaths(cmd->verb)[0] + "/" + cmd->verb;
  succ = ({ });
  ear_muffed = ({ });
  know_already = ({ });
  no_go = ({ });
  me_low = ({ });
  him_low = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (!living(ob)) {
      continue;
    }
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (member_array(comm, ob->query_known_commands()) != -1) {
      know_already += ({ tmp });
    } else if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
    } else if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
    } else {
      switch (cmd_ob->can_teach_command(teacher, ob)) {
        case 1:
          succ += ({ ob });
          break;

        case 0 :
          no_go += ({ tmp });
          break;
        case -1 :
          me_low += ({ tmp });
          break;

        case -2 :
          him_low += ({ tmp });
          break;
      }
    }
  }
  if (!succ || !sizeof(succ)) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + comm + " from you automatically, "
                  "but failed.\n");
    }

    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() + " cannot teach " + comm +
                      " to $I.\n", no_go);
    }
    if (sizeof(me_low)) {
      if (teacher == this_player()) {
        add_failed_mess(teacher->the_short() +
                        " are too low a level to teach " + comm +
                        " to $I.\n", me_low);
      } else {
        add_failed_mess(teacher->the_short() +
                        " is too low a level to teach " + comm +
                        " to $I.\n", me_low);
      }
    }
    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("$I has teaching events earmuffed, you are unable "
                      "to teach them.\n", ear_muffed);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " +
                      ((sizeof(him_low) == 1  &&
                        him_low[0] != this_player()) ? "is" : "are") +
                      " too low a level to learn " + comm + ".\n", him_low);
    }
    if (sizeof(know_already)) {
      add_failed_mess("$I already know" +
                      (sizeof(know_already) > 1  ||
                       teacher != this_player()? "" : "s") +
                      " the command " + comm + ".\n", know_already);
    }
    if (sizeof(ignoring)) {
      if (this_player() == teacher) {
        add_failed_mess("You are ignoring $I.\n", ignoring);
      } else {
        add_failed_mess(teacher->the_short(1) + " is ignoring $I.\n",
                        ignoring);
      }
    }
    if (sizeof(ignored)) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    return 0;
  }
  write(teacher->the_short() + " offer" +
        (this_player() == teacher ? "" : "s") + " to teach " + comm +
        " to " + query_multiple_short(succ) + ".\n");
  if (teacher == this_player()) {
    if (sizeof(no_go)) {
      write("You cannot teach " + comm + " to " +
            query_multiple_short(no_go, "the", 0, 1 ) + ".\n");
    }
    if (sizeof(ear_muffed) > 0) {
      write(capitalize(query_multiple_short(ear_muffed, "the", 0, 1)) +
            " has teaching events earmuffed, you are unable "
            "to teach them.\n");
    }
    if (sizeof(me_low) > 0) {
      write("You are too low a level to teach " + comm + " to " +
            query_multiple_short(me_low, "the", 0, 1) + ".\n");
    }
    if (sizeof(him_low) > 0) {
      write(capitalize(query_multiple_short(him_low, "the", 0, 1)) +
            ((sizeof(him_low) == 1) ? " is" : " are") +" too low a "
            "level to learn " + comm + ".\n");
    }
  } else {
    tell_object(teacher,
                "You automatically offer to teach " + comm + " to " +
                query_multiple_short(succ) + ".\n");
  }
  say(capitalize((string)teacher->short()) + " teaches something to " +
      query_multiple_short(succ) + ".\n", succ + ({ teacher }));

  for (i = 0; i < sizeof(succ); i++) {
    tell_object(succ[i], capitalize(teacher->the_short()) +
                " offers to teach " +
                query_multiple_short(delete(succ, i, 1) +
                ({ "you" }) ) + " the command \"" + comm + "\".\n"
                "Type \"learn " + comm + " from " +
                teacher->query_name() + "\" to learn the command.\n");
    tmp_stuff = succ[i]->query_respond_command(TEACH_COMMAND_TYPE, teacher);
    if (!tmp_stuff) {
      tmp_stuff = ({ comm });
    } else if (member_array(comm, tmp_stuff) == -1) {
      tmp_stuff += ({ comm });
    }
    succ[i]->add_respond_command(TEACH_COMMAND_TYPE, teacher, tmp_stuff);
  }
  add_succeeded_mess("");
  return 1;
} /* command_teach() */


int spell_teach(object *obs, string spell, object teacher) {
  object *succ, *no_go, *me_low, *him_low, ob;
  object *ignoring;
  object *ignored;
  object *ear_muffed;
  string ret;
  string is_are;
  mapping spells;
  mixed tmp;
   
  spells = teacher->query_spells();
 
  if (!spells[spell]) {
    return 0;
  }

  if (teacher == this_player()) {
    is_are = "are";
  } else {
    is_are = "is";
  }
 
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  ear_muffed = succ = no_go = me_low = him_low = ({ });
 
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (living(ob)) {
      if (ob->check_earmuffs("teach")) {
        ear_muffed += ({ ob });
        continue;
      } else if (check_ignoring(ob, teacher)) {
        ignored += ({ ob });
      } else {
        if (teacher == this_player()) {
          tmp = ob;
        } else {
          tmp = "you";
        }
        switch (spells[spell][0]->teach(ob, spell)) {
          case 1:
            succ += ({ ob });
            break;

          case 0:
            no_go += ({ ob });
            break;

          case -1:
            me_low += ({ ob });
            break;

          case -2:
            him_low += ({ ob });
            break;
        }
      }
    }
  }
  if (sizeof(succ) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + spell +
                  " from you automatically, but failed.\n");
    }
    ret = "";
    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() +
                      " cannot teach " + spell + " to $I.\n", no_go);
    }
    if (sizeof(me_low) > 0) {
      add_failed_mess(teacher->the_short() + 
                      " " + is_are + 
                      " too low a level to teach $I " + spell + ".\n",
                      me_low);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " + is_are + " too low a level to learn " +
                       spell + ".\n", him_low);
    }
    if (sizeof(ignoring)) {
       add_failed_mess("You are ignoring $I.\n", ignoring);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("$I has teaching earmuffed.\n", ignored);
    }
    return 0;
   }
   if (teacher == this_player()) {
     write(teacher->the_short() +
           " successfuly teach " + query_multiple_short(succ) + " " +
           spell + ".\n");
     if (sizeof(no_go) > 0) {
       write("You cannot teach " + spell + " to " +
             query_multiple_short(no_go, "the", 0, 1) + ".\n");
     }
     if (sizeof(me_low) > 0) {
       write("You are too low a level to teach " +
             query_multiple_short(me_low, "the", 0, 1) + " " + spell +
             ".\n");
     }
     if (sizeof(him_low) > 0) {
       write(capitalize(query_multiple_short(him_low, 0, 1)) +
             (sizeof(him_low) == 1 ? " is " : " are ") +
             "too low a level to learn " + spell + ".\n");
     }
     if (sizeof(ignoring) > 0) {
       add_failed_mess("You are ignoring " +
                       query_multiple_short(ignoring, "the", 0, 1) +
                       ".\n");
     }
     if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by " +
                       query_multiple_short(ignored, "the", 0, 1) + ".\n");
     }
   } else {
     write(teacher->the_short() +
           " successfuly teaches " + query_multiple_short(succ) + " " +
           spell + ".\n");
   }
   return 1;
} /* spell_teach() */
     
#define CANNOT 0
#define TOO_LOW 1
#define ONLY_LEAF 2
#define TOO_HIGH 3
#define CANNOT_TEACH 4

int teach_skill(object *obs, string str, object teacher) {
  int num;
  int lvl;
  int my_lvl;
  int lvl_up;
  int j;
  int cost;
  int total;
  int total2;
  int sk;
  int depth;
  object *ok;
  object *too_little;
  mixed  *too_low;
  object *cannot_teach;
  object *only_leaf;
  object *ignored;
  object *ignoring;
  object *ear_muffed;
  object *too_high;
  object ob;
  string skill;
  string skill_start;
  mixed *bits;
  class teaching_skill frog;
  float k;
  mixed tmp;

  num = 1;
  if (sscanf(str, "%d levels of %s", num, skill) != 2) {
    if (sscanf(str, "%d level of %s", num, skill) != 2) {
      if (sscanf(str, "%d %s", num, skill) != 2) {
        num = 1;
        skill = str;
      }
    }
  }
  if (num < 1) {
    add_failed_mess("You cannot teach a negative or zero number of "
                    "levels.\n");
    return 0;
  }
  if (num > 50) {
    add_failed_mess("You cannot teach more than 50 levels at a time.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  /* Make sure its a valid skill */
  skill_start = skill;
  bits = explode(implode(explode(skill, " "), "."), ".") - ({ "" });
  if (!bits || !(skill = (string)SKILL_OB->query_skill(bits))) {
    if (member_array(skill_start, teacher->query_known_commands()) != -1) {
      return 0;
    }
    add_failed_mess("The skill " + implode(bits, ".") + " is invalid.\n");
    return 0;
  }
  
  bits = explode(skill, ".");
  /*
   * We don't do the teaching here.  Figure out how much xp it will cost
   * to go up the levels, and inform the person we are teaching...
   */
  my_lvl = teacher->query_skill_bonus(skill, 1);
  ear_muffed = ({ });
  too_high = ({ });
  only_leaf = ({ });
  too_low = ({ });
  ok = ({ });
  too_little = ({ });
  cannot_teach = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }

  foreach (ob in obs) {
    /*
     * First make sure the skill can be taught.  There are only restrictions
     * (currently) on teaching of languages.  You cannot teach yourself
     * levels in a language.  You have to go and research them.
     */
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (!interactive(ob)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (!SKILL_OB->query_allowed_to_teach(skill)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
      continue;
    }
    if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
      continue;
    }
    if (SKILL_OB->query_only_leaf(skill) &&
        sizeof((mixed *)SKILL_OB->query_immediate_children(skill)))
    {
      only_leaf += ({ tmp });
      continue;
    }
    lvl = (int)ob->query_skill(skill);

    if (ob != teacher) {
      if ((int)ob->calc_bonus(lvl + num, skill, 1) > my_lvl) {
        add_failed_mess(teacher->the_short() +
                        " cannot teach $I, since their bonus is " +
                        (teacher == this_player() ? "higher" : "lower") +
                        " than yours.\n", ({ tmp }));
        continue;
      }
#ifdef ENFORCE_MAX_TEACH_LEVEL
      /*
       * Check to see if your level, or the level being taught too is
       * too high.
       */
      if (lvl + num > SKILL_MAX_TEACH) {
        too_high += ({ tmp });
        continue;
      }
#endif
    }

    if (sizeof(bits) > 1) {
      lvl_up = ob->query_skill(implode(bits[0 .. sizeof(bits) - 2], "."));
    } else {
      lvl_up = lvl;
    }

    depth = SKILL_OB->query_skill_depth(bits);
    if (!SKILL_OB->query_only_leaf(skill) && depth * 5 > lvl_up) {
      too_low += ({ tmp });
      continue;
    }

    total = 0;
    total2 = 0;

    foreach (sk in SKILL_OB->query_all_children(skill)) {
      if (SKILL_OB->query_immediate_children(sk) != ({ })) {
        continue;
      }
      my_lvl = teacher->query_skill_bonus(sk, 1);
      lvl = (int)ob->query_skill(sk);
      cost = DEFAULT_COST;
      cost *= STD_COST / 5;

      if (!my_lvl) {
        my_lvl = 1;
      }

      for (j = 0; j < num; j++) {
        k = 0.5 * (int)ob->calc_bonus(lvl + j, sk, 1 ) / my_lvl + 1.0;
        total2 += 500 + to_int(cost * (lvl+j) * exp((lvl + j) / 500.0) * k);
        if (total > total2) {
          num = j;
          break;
        } else {
          total = total2;
        }
      }

#ifdef DEBUG
      tell_object(find_player(DEBUGGER),
                  sprintf("%s:%s j:%d, lvl: %d, mylvl: %d, newbonus: %d, "
                          "total: %d\n",
                          this_player()->query_name(),
                          ob->query_name(),
                          j, lvl,
                          my_lvl,
                          (int)ob->calc_bonus(lvl + j, sk, 1),
                          lvl,
                          total2));
#endif

      if (!total) {
        total = cost;
      }
    }

    if (total > (int)ob->query_xp()) {
      if (teacher == this_player()) {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to $I.\n", ({ ob }));
      } else {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to you from " + teacher->the_short() +
                        ".\n");
      }
      too_little += ({ tmp });
      continue;
    }

    if (ob != teacher) {
      if (teacher == this_player()) {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\nUse "
                    "\"learn\" to learn the skill.\n");
        write("You offer to teach $M$$the_short:" + file_name(ob) +
              "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
              skill + " for " + total + " xp.\n");
      } else {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for "+total+" xp.\nUse \"learn\" "
                    "to learn the skill.\n");
        tell_object(teacher,
                    "You offer to teach $M$$the_short:" + file_name(ob) +
                    "$$M$ " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\n");
      }
    } else {
      write("You can teach yourself " + num + " level" +
            (num > 1 ? "s" : "") + " of " + skill + " for " + total +
            " xp.\nUse \"learn\" to learn the skill.\n");
      write("You offer to teach $M$$the_short:" + file_name(ob) +
            "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
            skill + " for " + total + " xp.\n");
    }
    ok += ({ tmp });
    frog = new(class teaching_skill);
    frog->num = num;
    frog->lvl = ob->query_skill(skill);
    frog->skill = skill;
    frog->xp = total;
    frog->room = environment(this_player());
    ob->add_respond_command(TEACH_SKILL_TYPE, teacher, frog);
  }
  if (sizeof(ok) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher,
                  this_player()->the_short() + " tried to learn " + skill +
                  " from you automatically but failed.\n");
    }

    if (sizeof(only_leaf) > 0) {
      add_failed_mess("You cannot teach the skill " + skill +
                      ", as it is only possible to teach leaf skills in "
                      "this skill tree.\n");
    }

    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      " to $I, they have teaching earmuffed and cannot "
                      "hear you.\n", ear_muffed);
    }

    if (sizeof(cannot_teach) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      "; you need to look for alternative methods of "
                      "advancement.\n");
    }

    if (sizeof(too_low) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_low) > 1    ||
                        too_low[0] == teacher  ||
                        teacher != this_player()) ? " are " : " is ") +
                      "not at a high enough level in the outer skills to "
                      "learn " + num + " levels of " + skill + ".   See "
                      "'help skills' for more details.\n");
    }

    if (sizeof(too_high) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_high) > 1     ||
                        teacher != this_player() ||
                        too_low[0] == teacher) ? " are " : " is ") +
                      "too high a level to learn " + num + " levels of " +
                      skill + ", they must be less than " +
                      SKILL_MAX_TEACH + " to learn from someone else.\n");
    }

    if (sizeof(ignoring) > 0) {
      add_failed_mess("You are ignoring $I.\n", ignoring);
    }

    if (sizeof(ignored) > 0) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
  }

  return sizeof(ok);
} /* teach_skill() */

mixed *query_patterns() {
   return ({
      "<string:'skill|n levels of skill|command'> to <indirect:living>",
                   (: cmd($4[0], $1, 0) :),
      "me <string:'skill|n levels of skill|command'> from <indirect:living>",
                   (: cmd($4[0], $1, this_player()) :)});
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/teach.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/sheathe.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/sheathe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626952   Available: 13574306
Inodes: Total: 5242880    Free: 4960132
2705 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/sheathe.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626952   Available: 13574306
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sheathe.c,v 1.7 2002/01/28 20:28:12 tannah Exp $
 *
 *
 */

#include <move_failures.h>

inherit "/cmds/base";

int cmd( object * weapons, object * scabbards ) {
   object weapon;
   object scabbard;

   if( sizeof(weapons) > 1 ) {
      add_failed_mess( "You can only sheathe one thing at a time.\n" );
      return 0;
   }
   weapon = weapons[0];

   if ( ( scabbard = environment( weapon ) )->query_scabbard() &&
        scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( weapon->the_short() + " is already sheathed.\n" );
      return 0;
   }

   if ( environment( weapon ) != this_player() ) {
      add_failed_mess( weapon->the_short() + " is not in your inventory.\n" );
      return 0;
   }

   if ( scabbards ) {
      if ( sizeof(scabbards) > 1 ) {
         add_failed_mess( "For shame! Trying to sheathe your weapon "
           "in more than one object at a time?\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if ( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not even a "
           "scabbard!\n" );
         return -1;
      }
      if( !scabbard->test_type_ok( weapon ) ) {
        return add_failed_mess( "$C$"+scabbard->the_short() + " is not a "
                                "suitable scabbard for " + weapon->a_short()
                                + ".\n" );
      }
   } else {
      scabbards = filter( all_inventory( this_player() ),
                          (: $1->query_scabbard() &&
                             $1->test_type_ok( $(weapon) ) :) );
      if ( !sizeof( scabbards ) ) {
         return add_failed_mess( "Can't find any suitable scabbards in "
           "your inventory.\n" );
      }

      scabbards = filter( scabbards, (: $1->test_add( $(weapon), 0, 1 ) :) );
      if ( !sizeof(scabbards) ) {
         return add_failed_mess( "Can't find any empty scabbards in your "
           "inventory.\n" );
      }

      scabbard = scabbards[0];
   }

   if ( weapon->query_wielded() &&
       !sizeof( this_player()->set_unhold(weapon) ) )
   {
      return add_failed_mess( "You cannot let go of " + weapon->the_short()
        + ".\n" );
   }

   if ( weapon->move(scabbard) != MOVE_OK ) {
      this_player()->add_failed_mess( scabbard, "You cannot $V $I in $D.\n",
        ({ weapon }) );
      return 0;
   }

   this_player()->add_succeeded_mess( scabbard, "$N $V $I in $D.\n",
     ({ weapon }) );
   return 1;
}

mixed * query_patterns() {
   return ({
      "<indirect:object:me'weapon'>",
        (: cmd( $1, 0 ) :),
      "<indirect:object:me'weapon'> in <indirect:object:me'scabbard'>",
        (: cmd( $1[0], $1[1]) :)
   });
}
// --- END [/mnt/home2/grok/lib/cmds/living/sheathe.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/crouch.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/crouch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626951   Available: 13574305
Inodes: Total: 5242880    Free: 4960132
336 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/crouch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626951   Available: 13574305
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: crouch.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: crouch.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/position_base";
#include <position.h>

void create() {
   ::create();
   setup_position("crouch", "down", CROUCHING);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/living/crouch.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/lo_se.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/lo_se.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626951   Available: 13574305
Inodes: Total: 5242880    Free: 4960132
1449 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/lo_se.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626951   Available: 13574305
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: lo_se.c,v 1.2 2000/04/22 05:33:22 ceres Exp $
 * $Log: lo_se.c,v $
 * Revision 1.2  2000/04/22 05:33:22  ceres
 * Fixed bug with error return
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

mixed cmd(object *obs, string str) {
  object *ok, ob;
  string s;

  if (str == "everyone")
    obs = this_player()->query_followers();
  
  if (!sizeof(obs)) {
    write("You are not being followed by anyone.\n");
    return 1;
  }

  ok = ({ });
  foreach (ob in obs)
    if (this_player()->remove_follower(ob))
      ok += ({ ob });

  if (!sizeof(ok)) {
    if (member_array(this_player(), obs) == -1)
      return notify_fail("You are not being followed by "+
                         query_multiple_short(obs)+".\n");
    else
      return notify_fail("You are not being followed by " +
                         query_multiple_short(obs - ({this_player()}) +
                                              ({"yourself"})) + ".\n");
  }
  
  write("You lose "+(s=query_multiple_short(ok))+".\n");
  say(this_player()->the_short()+" loses "+s+".\n", ok);
  foreach (ob in ok)
    tell_object(ob, this_player()->the_short() + " loses " +
                query_multiple_short((ok + ({ "you" })) - ({ ob }))+".\n");
  return 1;
}

mixed *query_patterns() {
  return ({ "everyone", (: cmd(0, "everyone") :),
            "<indirect:living>", (: cmd($1, 0) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/lo_se.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/ho_ld.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/ho_ld.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626950   Available: 13574304
Inodes: Total: 5242880    Free: 4960132
11124 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/ho_ld.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626950   Available: 13574304
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ho_ld.c,v 1.12 2002/08/16 00:11:52 presto Exp $
 * $Log: ho_ld.c,v $
 * Revision 1.12  2002/08/16 00:11:52  presto
 * Changed to allow you to switch from one hand to the other, or between
 * one hand and two hands without unholding first
 *
 * Revision 1.11  2002/08/03 19:25:36  ceres
 * New combat system version
 *
 * Revision 1.9  2001/03/13 05:04:22  pinkfish
 * Fix up holding if you are already holding one of the items.
 *
 * Revision 1.8  2001/03/09 01:50:43  pinkfish
 * Fix up some problems in hold.
 *
 * Revision 1.7  2001/03/07 22:02:49  pinkfish
 * *** empty log message ***
 *
 * Revision 1.6  2001/03/07 21:59:30  terano
 *  Forcibly unlocked by pinkfish
 *
 * Revision 1.5  2000/03/10 23:27:18  gruper
 * I *hope* I fixed an index out of bounds bug,
 * but who knows - maybe I broke it even worse :)
 *
 * Revision 1.4  1999/07/07 23:24:52  pinkfish
 * Fix up some problems with hold that caused it not to work with things
 * that fiddled with the number of limbs available.
 *
 * Revision 1.3  1999/06/04 00:59:35  pinkfish
 * Fix up hold to unhold from multiple hands.
 *
 * Revision 1.2  1998/10/08 09:52:49  pinkfish
 * Fixed up to work correctly with things that do not wish to be unheld.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
/* Command to hold weapons. This _should_ be fairly simple, however it is */
/* complicated by dealing with 1. a variable number of limbs and 2. printing */
/* out all the appropriate holding/unholding/failing/suceeding messages. */

inherit "/cmds/base";

#define TP this_player()

int cmd(object * obs,
        string str)
{
   int num_limbs;               // this players limb count
   int avail;                   // limbs available
   int old_avail;               // old limbs available, used for sanity checking
   int reqd;                    // limbs required
   int i;                       // general counter
   int pos;                     // which limb position
   int success;                 // did we succeed
   int *used;                   // limbs used by set_hold or set_unhold
   int *already_used;           // limbs used by already held weapons
   int *limbs_used;             // limb positions used by already held objects

   object ob;
   object weapon;
   object *using;               // limbs currently in use
   object *fails;               // weapons we failed to hold
   object *unfails;             // weapons we failed to unhold
   object *holds;               // weapons we sucessfully held
   object *unholds;             // weapons we successfully unheld
   object *already;             // weapons already held
   object *no_change;           // objects that we are already holding the way
                                //   we requested

   string *limbs;               // limb names;
   string *hhands;              // hands we successfully held weapons in
   string *uhands;              // hands we successfully unheld weapons from

   // calc how many hands will be needed
   limbs = TP->query_limbs();
   num_limbs = sizeof(limbs);
   avail = TP->query_free_limbs();
   no_change = ({ });

   already = filter(obs, (: $1->query_holder() :));

   if (sizeof(already) > 0) {
      using = this_player()->query_holding();
      foreach (ob in already)  {
         limbs_used = find_member(ob, using);
         if (str)  {
            if (sizeof(limbs_used) == 1  &&
                member_array(str, limbs) == limbs_used[0])
            {
               no_change += ({ ob });
            }
            else already -= ({ ob });
         }
         else if (sizeof(limbs_used) != ob->query_no_limbs())
            already -= ({ ob });
      }
      if (sizeof(obs) == sizeof(no_change))  {
         add_failed_mess("You are already holding " +
                         query_multiple_short(obs) +
                         " in your " + str + ".\n");
         return -1;
      }
      else if (sizeof(obs) == sizeof(already)) {
         return notify_fail("You are already holding " +
                            query_multiple_short(obs) + ".\n");
      } else {
         obs -= already;
         if (sizeof(already) > 0)
            write(sprintf("You are already holding %s, you instead try to "
                          "hold %s.\n", query_multiple_short(already),
                          query_multiple_short(obs)));
         already_used = map(already, (: $1->query_my_limb() :));
      }
   } else {
      already_used = ({ });
   }

   fails = holds = unholds = hhands = uhands = unfails = ({ });

   // deal with specific hands first
   if (str && obs[0]) {
      pos = member_array(str, limbs);
      if (pos == -1) {
         if (!sizeof(limbs)) {
            return
               notify_fail("You seem to have a singular lack of limbs.\n");
         }
         return notify_fail("Incorrect limb type, must be one of " +
                            query_multiple_short(limbs) + ".\n");
      }

      using = TP->query_holding();

      // clear the appropriate hand
      if (sizeof(unfails) == 0  &&  using[pos]) {
         used = TP->set_unhold(using[pos]);
         if (sizeof(used) == 0) {
            /* This means we cannot hold the object for sure. */
            unfails += ({ using[pos] });
            uhands += ({ limbs[pos] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ using[pos] });
         }
      }

      // Put it down if we are already holding it in another hand
      if ((i = member_array(obs[0], using - unholds)) != -1)  {
         used = TP->set_unhold(obs[0]);
         if (sizeof(used) == 0) {
            /* This means we cannot hold the object for sure. */
            unfails += ({ obs[0] });
            uhands += ({ limbs[i] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ obs[0] });
         }
      }

      if (sizeof(unfails) == 0) {
         // hold in the appropriate hand
         used = TP->set_hold(obs[0], pos, 1);
         if (sizeof(used) == 0) {
            fails += ({ obs[0] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               hhands += ({ limbs[used[i]] });
            }
            holds += ({ obs[0] });
            success = 1;
         }
      }

   } else {                     // now deal with normal holding

      foreach(ob in obs) {
         reqd += ob->query_no_limbs();
      }

      if (reqd > num_limbs) {
         add_failed_mess("You do not have enough limbs to hold $I.\n", obs);
         return 0;
      }

      old_avail = -1;
      // if necessary put down items until the required hands are available
      // No need for a while, if it canont be done.  It cannot be done.
      // If nothign was able to be put down after one sweep through, we are
      // out of luck.
      while ((avail < reqd) && (avail < num_limbs)) {
         if ((reqd > num_limbs - sizeof(unfails)) || (old_avail == avail)) {
            if (sizeof(unfails)) {
               add_failed_mess
                  ("You do not have enough limbs to hold $I, since " +
                   query_multiple_short(unfails) + " failed " "to unhold.\n",
                   obs);
            } else {
               add_failed_mess
                  ("Not able to free up enough limbs to hold $I.\n", obs);
            }
            return 0;
         }
         old_avail = avail;
         using = TP->query_holding();
         for (i = 0; i < sizeof(using); i++) {
            weapon = using[i];
            if (weapon && member_array(i, already_used) == -1) {
               used = TP->set_unhold(weapon);
               if (sizeof(used)) {
                  for (i = 0; i < sizeof(used) && used[i] < sizeof(limbs);
                       i++) {
                     uhands += ({ limbs[used[i]] });
                  }
                  unholds += ({ weapon });
                  avail = TP->query_free_limbs();
                  break;
               } else {
                  if (member_array(weapon, unfails) == -1) {
                     unfails += ({ weapon });
                  }
                  uhands += ({ limbs[i] });
               }
            }
         }
      }

      if (!sizeof(unfails)) {
         // now try holding the new items
         foreach(ob in obs) {
            using = TP->query_holding();
            pos = 0;

            if (!ob->query_no_limbs() || avail < ob->query_no_limbs()) {
               fails += ({ ob });
               break;
            }
            // hold the new items
            while ((using[pos]) && (pos < num_limbs)) {
               pos++;
            }

            used = TP->set_hold(ob, pos, ob->query_no_limbs());
            if (used == ({ })) {
               fails += ({ ob });
            } else {
               for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
                  hhands += ({ limbs[used[i]] });
               }
               holds += ({ ob });
               success = 1;
               avail = TP->query_free_limbs();
            }
         }
      }
   }

   // printout all the different sodding message types
   if (sizeof(unfails)) {
      tell_object(TP,
                  "You fail to put down " + query_multiple_short(unfails) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " fails to put down " +
          query_multiple_short(unholds) + " from " + TP->query_possessive() +
          " " + query_multiple_short(uhands) + ".\n");
   }

   if (sizeof(unholds)) {
      tell_object(TP, "You put down " + query_multiple_short(unholds) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " puts down " + query_multiple_short(unholds) +
          " from " + TP->query_possessive() + " " +
          query_multiple_short(uhands) + ".\n");
   }

   if (sizeof(holds)) {
      tell_object(TP,
                  "You hold " + query_multiple_short(holds) + " in your " +
                  query_multiple_short(hhands) + ".\n");
      say(TP->one_short() + " holds " + query_multiple_short(holds) + " in " +
          TP->query_possessive() + " " + query_multiple_short(hhands) +
          ".\n");
   }
   // don't print the failed to hold messages if we managed to hold stuff.
   if (!success && sizeof(fails)) {
      tell_object(TP,
                  "You fail to hold " + query_multiple_short(fails) + ".\n");
      say(TP->one_short() + " fails to hold " + query_multiple_short(fails) +
          ".\n");
   }

   return 1;
}                               /* cmd() */

mixed *query_patterns()
{
   return ({ "<indirect:object:me>", (: cmd($1, 0) :),
             "<indirect:object:me> in [my] {" +
             implode(this_player()->query_limbs(), "|") + "}",
             (: cmd($1, implode($4[1..], " ")) :) });
}                               /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/ho_ld.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/unp_rotect.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/unp_rotect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626947   Available: 13574301
Inodes: Total: 5242880    Free: 4960132
1577 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/unp_rotect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626947   Available: 13574301
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unp_rotect.c,v 1.6 1999/04/13 01:15:25 pinkfish Exp $
 * $Log: unp_rotect.c,v $
 * Revision 1.6  1999/04/13 01:15:25  pinkfish
 * Fix this up to handle errors when your not protecting anyone and you
 * type unproctect all.
 *
 * Revision 1.5  1998/09/15 00:42:38  pinkfish
 * Fix up the messages.
 *
 * Revision 1.4  1998/08/25 09:31:34  pinkfish
 * Fix it up to look a little nicer.
 *
 * Revision 1.3  1998/08/22 13:52:18  gototh
 * Was runtiming because things wasn't getting set to obs.
 *
 * Revision 1.2  1998/08/22 05:50:53  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(object *things) {
  object *protectees;
  object ob;
  object *fail;

  if(!things) {
    things = ({ });
  }
  things -= ({ TP });

  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot unprotect yourself!\n");
    return 0;
  }

  protectees = ({ });
  fail = ({ });

  foreach ( ob in things) {
    if ( ob->remove_protector( TP ) ) {
      protectees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not protecting " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(protectees)) {
     add_succeeded_mess("$N stop$s protecting $I.\n", protectees);
     return 1;
  } else {
     return 0;
  }
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) }); 
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/unp_rotect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/take.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/take.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626947   Available: 13574301
Inodes: Total: 5242880    Free: 4960132
210 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/take.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626947   Available: 13574301
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: take.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: take.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/living/get";
// --- END [/mnt/home2/grok/lib/cmds/living/take.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/:_.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/:_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626947   Available: 13574301
Inodes: Total: 5242880    Free: 4960132
292 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/:_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626947   Available: 13574301
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: :_.c,v 1.2 1999/05/04 23:24:03 pinkfish Exp $
 * $Log: :_.c,v $
 * Revision 1.2  1999/05/04 23:24:03  pinkfish
 * Fix up the way this works.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/living/em_ote";
// --- END [/mnt/home2/grok/lib/cmds/living/:_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/tactics.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/tactics.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626946   Available: 13574300
Inodes: Total: 5242880    Free: 4960132
7970 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/tactics.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626946   Available: 13574300
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: tactics.c,v 1.4 2002/10/24 04:19:04 ceres Exp $
 * $Log: tactics.c,v $
 * Revision 1.4  2002/10/24 04:19:04  ceres
 * fixed typo
 *
 * Revision 1.3  2002/09/21 02:29:32  ceres
 * Added attack hand
 *
 * Revision 1.2  2002/08/12 00:19:11  presto
 * Fixed typo: opponents --> opponent's
 *
 * Revision 1.1  2002/08/03 19:27:13  ceres
 * Initial revision
 *
 * Revision 1.2  2000/04/22 05:33:22  ceres
 * Fixed bug with error return
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
*/
inherit "/cmds/base";

#include <combat.h>

int cmd() {
  class tactics tactics;

  tactics = (class tactics) this_player()->query_tactics();
  
  write("Your combat options are:\n\n" );
  write("   Attitude - "+ tactics->attitude +".\n" );
  write("   Response - "+ tactics->response +".\n" );
#ifdef USE_SURRENDER
  write("   Mercy - "+ (tactics->mercy?tactics->mercy:"none") + ".\n");
#endif  
  write("   Focus - "+ (tactics->focus_zone?tactics->focus_zone:"none") + ".\n" );
#ifdef USE_DISTANCE
  write("   Target distance - "+ (tactics->ideal_distance?tactics->ideal_distance:"none") + ".\n" );
#endif  
  write("You will use "+
        (tactics->attack == "both" ? "both hands" :
         "your "+ (tactics->attack?tactics->attack:"either") +" hand" ) +
        " to attack.\n" );
  write("You will use "+
        (tactics->parry == "both" ? "both hands" :
         "your "+ (tactics->parry?tactics->parry:"either") +" hand" ) +
        " to parry.\n" );
  write("\nYou will"+ ( tactics->parry_unarmed ? " " : " not " ) +
        "attempt to parry unarmed.\n" );
  return 1;
}

int attitude(string word) {
  class tactics my_tactics;

  my_tactics = new(class tactics);
  my_tactics = (class tactics) this_player()->query_tactics();
  
  switch(word) {
  case "insane":
  case "offensive":
  case "neutral":
  case "defensive":
  case "wimp":
    if((my_tactics->attitude) == word) {
      write("Your attitude is already " + word + ".\n");
    } else {
      my_tactics->attitude = word;
      write("Your attitude is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics attitude "
                       "insane|offensive|neutral|defensive|wimp.\n");
  }
}

int response(string word) {
  class tactics my_tactics;

  my_tactics = this_player()->query_tactics();

  switch(word) {
  case "dodge":
  case "neutral":
  case "parry":
    if(my_tactics->response == word) {
      write("Your response is already " + word + ".\n");
    } else {
      my_tactics->response = word;
      write("Your response is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics response dodge|neutral|parry\n");
  }
}

int parry(string word) {
  class tactics my_tactics;

  my_tactics = this_player()->query_tactics();

  switch(word) {
  case "unarmed":
    my_tactics->parry_unarmed = 1 - my_tactics->parry_unarmed;
    write("You will"+ ( my_tactics->parry_unarmed ? " " : " not " ) +
          "now attempt to parry unarmed.\n" );
    this_player()->set_tactics(my_tactics);
    return 1;
  case "left":
  case "right":
  case "both":
    if(my_tactics->parry == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
    } else {
      my_tactics->parry = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics parry "+
                        "left|right|both [hand(s)]\n        "
                        "tactics parry unarmed\n" );
  }
}

int attack(string word) {
  class tactics my_tactics;

  my_tactics = this_player()->query_tactics();

  switch(word) {
  case "left":
  case "right":
  case "both":
    if(my_tactics->attack == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
    } else {
      my_tactics->attack = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics attack "+
                        "left|right|both [hand(s)]\n" );
  }
}

int focus(string word) {
  class tactics my_tactics;

  my_tactics = this_player()->query_tactics();

  switch(word) {
  case "head":
  case "neck":
  case "chest":
  case "abdomen":
  case "arms":
  case "hands":
  case "legs":
  case "feet":
  case "upper body":
  case "lower body":
    if(my_tactics->focus_zone == word) {
      write("You are already focussing on your opponent's "+ word + ".\n");
    } else {
      my_tactics->focus_zone = word;
      write("You will now focus on your opponent's "+ word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  case "none":
    if(!my_tactics->focus_zone) {
      write("You are not currently focussing on any particular target "
            "area.\n");
    } else {
      my_tactics->focus_zone = 0;
      write("You will no longer focus on a specific target area.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics focus " +
                        "upper body|lower body|head|neck|chest|abdomen|arms|hands|legs|feet|none\n");
  }
}

int distance(string word) {
  class tactics my_tactics;

  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "long":
  case "medium":
  case "close":
  case "hand-to-hand":
    if(my_tactics->ideal_distance == word) {
      write("You are already set for " + word + " range.\n");
      return 1;
    }
    my_tactics->ideal_distance = word;
    write("You will now aim for "+ word + " range combat.\n");
    this_player()->set_tactics(my_tactics);
    return 1;

  case "none":
    if(!my_tactics->ideal_distance) {
      write("You are not currently aiming for any specific combat distance.\n");
    } else {
      my_tactics->ideal_distance = 0;
      write("You will no longer aim for a specific combat distance.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics distance " +
                        "{long|medium|close|hand-to-hand\n");
  }
}

#ifdef USE_SURRENDER
int mercy(string word) {
  class tactics my_tactics;

  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "always":
  case "ask":
  case "never":
    if(my_tactics->mercy == word) {
      write("Your mercy is already " + word + ".\n");
    } else {
      my_tactics->mercy = word;
      write("Your mercy is now "+ word +".\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics mercy always|ask|never\n");
  }
}
#endif

mixed *query_patterns() {
  return ({ "", (: cmd() :),
              "attitude <word'insane|offensive|neutral|defensive|wimp'>",
              (: attitude($4[0]) :),
              "response <word'dodge|neutral|parry'>", (: response($4[0]) :),
#ifdef USE_SURRENDER              
              "mercy <word'always|ask|never'>", (: mercy($4[0]) :),
#endif              
              "parry <word'left|right|both|unarmed'>", (: parry($4[0]) :),
              "attack <word'left|right|both'>", (: attack($4[0]) :),
              "focus <string'upper body|lower body|head|neck|chest|abdomen|"
              "arms|hands|legs|feet|none'>", (: focus($4[0]) :),
#ifdef USE_DISTANCE             
              "distance <word'long|medium|close|hand-to-hand|none'>",
              (: distance($4[0]) :),
#endif              
              });
}
// --- END [/mnt/home2/grok/lib/cmds/living/tactics.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/wea_r.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/wea_r.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626944   Available: 13574298
Inodes: Total: 5242880    Free: 4960132
7048 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/wea_r.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626944   Available: 13574298
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wea_r.c,v 1.10 2003/03/25 19:46:47 presto Exp $
 * $Log: wea_r.c,v $
 * Revision 1.10  2003/03/25 19:46:47  presto
 * Forcibly released due to inactivity
 *
 * Revision 1.9  2002/07/10 16:55:23  trilogy
 * Put a taskmaster thingie in for wearing clothes covertly.
 *
 * Revision 1.8  2002/02/03 19:22:25  tannah
 * Changed a "they" to a TP->query_pronoun() so that it agrees with the
 * subject
 *
 * Revision 1.7  2001/11/07 21:54:06  pinkfish
 * Make it so wear automatic removes and wears stuff if you want to wear
 * stuff lower down.
 *
 * Revision 1.6  2001/03/08 04:21:16  presto
 * Fixed so you can't wear things you aren't carrying in your immediate inventory.
 *
 * Revision 1.5  1999/12/08 04:08:54  ceres
 * Modified to use standard can_wear_or_remove() function in /obj/handlers/clothing_handler
 *
 * Revision 1.4  1999/11/15 10:37:17  pinkfish
 * Make some small changes to the wear code.
 *
 * Revision 1.3  1998/08/25 10:26:02  pinkfish
 * Change them to handle ordering the object to remove/wear so that under
 * can be safely handled.
 *
 * Revision 1.2  1998/03/27 20:49:16  pinkfish
 * To the new clothing handler.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 *
*/
#include <clothing.h>
#include <tasks.h>

inherit "/cmds/base";

#define TP this_player()
#define SKILL "covert.manipulation.sleight-of-hand"

mapping add_to_failed(mapping failed, string word, object thing);

int cmd(object *things) {
  int i;
  string result;
  string stuff;
  string *reasons;
  object *okay;
  object *blocking;
  object *total_blocking;
  object ob;
  object tmp;
  mapping failed;
  mapping hide_invis;
  int hiding, sneaking, difficulty, light, my_light;

  okay = ({ });
  failed = ([ ]);
  things = sort_array(things, (: CLOTHING_HANDLER->query_clothing_depth($2->query_type()) -
                                 CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :) );
  total_blocking = ({ });
  foreach (ob in things) {
    if (environment(ob) != this_player())  {
      failed = add_to_failed(failed, "not carrying", ob);
      continue;
    }
    if ( !ob->query_wearable() ) {
      failed = add_to_failed( failed, "cannot wear", ob);
      continue;
    }
    if (member_array(ob, TP->query_wearing()) != -1) {
      failed = add_to_failed(failed, "already wearing", ob);
      continue;
    }
    if (ob->cannot_be_worn()) {
      failed = add_to_failed(failed, "cannot wear", ob);
      continue;
    }

    blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player());
if (this_player() == find_player("presto"))
printf("blocking == %O\n", blocking);
    if (sizeof(blocking)) {
       // Try and remove them all.
       total_blocking += blocking;
       foreach (tmp in blocking) {
          TP->remove_armour(tmp);
       }
    }
    result = CLOTHING_HANDLER->can_wear_or_remove(ob, this_player());
if (this_player() == find_player("presto"))
printf("ob == %s, result == %s\n", ob->short(), result);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    result = TP->wear_armour(ob, 0);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    okay += ({ ob });
  }
  if (total_blocking) {
    foreach (tmp in total_blocking) {
      TP->wear_armour(tmp);
    }
  }
  result = "";
  if (sizeof(failed)) {
    reasons = keys(failed);
    for (i = 0; i < sizeof(reasons); i++) {
      stuff = query_multiple_short(failed[reasons[i]], "the");
      switch (reasons[i]) {
      case "cannot wear" :
        if (!sizeof(okay)) {
           result += capitalize(stuff) +" cannot be worn.\n";
        }
        break;
      case "already wearing" :
        result += "You are already wearing "+ stuff +".\n";
        break;
      case "already holding" :
        result += "You cannot wear "+ stuff +" as you do not "
          "have enough free limbs.\n";
        break;
      case "oh dear" :
        result += "I'm not sure why you can't wear "+ stuff +
          "; something has probably gone wrong, so please "
          "contact a creator.\n";
        break;
      case "not carrying":
        result += "You aren't carrying " + stuff + ".\n";
        break;
      default :
        result += "You cannot put on "+ stuff +" "+ reasons[i] +".\n";
      }
    }
  }
  if (!sizeof(okay)) {
    return notify_fail(result);
  }
  stuff = query_multiple_short(okay);
  if (sizeof(total_blocking)) {
     tell_room(environment(TP), TP->one_short() + " removes " +
               query_multiple_short(total_blocking) + " so " +
               TP->query_pronoun() + " can wear "+
               stuff +".\n" + TP->one_short() + " wears " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
     write("You remove " +
               query_multiple_short(total_blocking) + " so you can wear "+
               stuff +".\nYou wear " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
  } else {
    hide_invis = ( mapping )this_player()->query_hide_invis();
    hiding = hide_invis[ "hiding" ] ? 1 : 0;
    sneaking = this_player()->query_sneak_level() ? 1 : 0;
  
    if( hiding || sneaking ) {
      my_light = this_player()->query_light();
      light = environment( this_player() )->query_light();
    
      difficulty = light + ( 4 * my_light ) / ( light + 1 );
  
      if( sizeof( total_blocking ) ) {
        difficulty += 50 * sizeof( total_blocking );
      }
  
      difficulty += okay[0]->query_complete_weight();

      debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                    difficulty, SKILL, this_player()->
                    query_skill_bonus( SKILL ) );
      switch( TASKER->perform_task( this_player(), SKILL, difficulty,
        TM_FREE ) ) {
        case AWARD :
          write( "%^YELLOW%^" + ({
            "You discover something that lets your fingers move more "
              "nimbly.",
            "You find yourself capable of deceiving the eye with greater "
              "ease than before.",
            "You realise how to deceive the eye more effectively."
          })[ random(3) ] + "%^RESET%^\n" );
        case SUCCEED :
          add_succeeded_mess( ({ "$N $V " + stuff + ", managing to stay "
            "unnoticed.\n",
            "" }) );
          break;
        default :
          this_player()->add_succeeded_mess( this_object(), "$N "
            "unsuccessfully tr$y to " + query_verb() + " " + stuff +
            " while staying unnoticed.\n", ({ }) );
          break;
      }
    } else {
      this_player()->add_succeeded_mess( this_object(), "$N $V " + stuff +
        ".\n", ({ }) );
    }
  }
  return 1;
} /* cmd() */

mapping add_to_failed(mapping failed, string word, object thing) {
  if (!failed[word]) {
    failed += ([ word : ({ thing }) ]);
  } else {
    failed[word] += ({ thing });
  }
  return failed;
} /* add_to_failed() */

mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/wea_r.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/concentrate.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/concentrate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626942   Available: 13574296
Inodes: Total: 5242880    Free: 4960132
1441 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/concentrate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626942   Available: 13574296
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

int concentrate_list( ) {
   object conc;

   conc = this_player()->query_concentrating();
   if ( !conc ) {
      write("You are not currently concentrating on "
                  "any particular opponent.\n" );
   } else {
      write("You are currently concentrating on "+
            conc->the_short() + ".\n");
   }
   return 1;
} /* concentrate_list() */

int concentrate(object *things ) {
   if ( sizeof( things ) > 1 ) {
      return notify_fail( "You can only concentrate on one thing at once.\n" );
   }
   if (!sizeof(this_player()->query_attacker_list())) {
      add_failed_mess("You are not fighting anyone.\n");
      return 0;
   }
   if ( things[0] == this_player() ) {
      return notify_fail( "It would be silly to concentrate on yourself.\n" );
   }
   if (member_array(things[0], this_player()->query_attacker_list()) == -1) {
     return notify_fail("You can only concentrate on people you are "
                        "fighting.\n");
   }
   if (this_player()->set_concentrating(things[0])) {
        add_succeeded_mess(({"You are now concentrating on $I.\n", "" }),
                           things);
   } else {
      add_succeeded_mess(({"Unable to concentrate on $I.\n", "" }), things);
   }
   return 1;
} /* concentrate() */

mixed *query_patterns() {
   return ({ "[on] <indirect:living>", (: concentrate($1) :),
             "", (: concentrate_list() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/concentrate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/kneel.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/kneel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626942   Available: 13574296
Inodes: Total: 5242880    Free: 4960132
332 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/kneel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626942   Available: 13574296
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: kneel.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: kneel.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/position_base";
#include <position.h>

void create() {
   ::create();
   setup_position("kneel", "down", KNEELING);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/living/kneel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/wring.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/wring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626941   Available: 13574295
Inodes: Total: 5242880    Free: 4960132
1460 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/wring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626941   Available: 13574295
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

int cmd(object *things)  {
   object *towels;
   int    *enums;
   int     wetness;
   int     success;
   string  str;

   towels = filter(things,
                   (: $1->id("towel")  ||  $1->query_property("dryer") :));
   things -= towels;

   str = "";

   if (sizeof(towels) == 1)  {
      enums = towels[0]->effects_matching("object.wet");
      if (sizeof(enums)) {
         wetness = towels[0]->arg_of(enums[0]);
      }
      if (wetness < 36 - this_player()->query_str())  {
         str = "You can't wring any more moisture out of " +
               towels[0]->one_short();
         success = 0;
      } else  {
         towels[0]->add_effect("/std/effects/object/wet",
            -wetness / ((36 - this_player()->query_str()) / 4));
         str = "You wring some moisture out of " +
               towels[0]->one_short();
         success = 1;
      }
   } else if (sizeof(towels))  {
      str = "You can only wring out one thing at a time";
      success = 0;
   }

   if (sizeof(things))  {
      if (success) {
         str += ", but you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      } else {
         str += ", and you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      }
   } else {
      str += ".\n";
   }

   write(str);

   return 1;
}

mixed *query_patterns()  {
   return ({ "[out] <indirect:object:me'towel'>", (: cmd($1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/wring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/drop.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/drop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626941   Available: 13574295
Inodes: Total: 5242880    Free: 4960132
4623 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/drop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626941   Available: 13574295
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: drop.c,v 1.13 2001/11/05 21:49:55 pinkfish Exp $
 * $Log: drop.c,v $
 * Revision 1.13  2001/11/05 21:49:55  pinkfish
 * Make them now drop kept items.
 *
 * Revision 1.12  2001/08/27 18:57:16  pinkfish
 * Fix up the stuff.
 *
 * Revision 1.11  2001/08/27 18:55:48  pinkfish
 * Fix up multipleayer defines.
 *
 * Revision 1.10  2001/08/17 04:05:58  ceres
 * Improved the multiplayer checks
 *
 * Revision 1.9  2000/07/31 23:36:33  taffyd
 * Added a few things for custom messages when dropping items.
 *
 * Revision 1.8  2000/04/15 03:51:53  ceres
 * Made a cockup with the timed property
 *
 * Revision 1.7  2000/04/09 12:01:00  ceres
 * Modified to track who dropped what.
 *
 * Revision 1.6  1999/08/14 15:27:34  presto
 * rewrote the if-else sieve after calling do_drop on the object
 *
 * Revision 1.5  1999/06/11 18:42:14  ceres
 * Removed list of discarded objects when dropping too many -- was causing over evaluation
 *
 * Revision 1.4  1999/03/24 10:19:05  taffyd
 * Fixed small bug with failure messages not being displayed.
 *
 * Revision 1.3  1998/10/01 07:05:43  pinkfish
 * Fix to work correctly with add_command and put in a cap on the number
 * of objects dealt with at once.
 *
 * Revision 1.2   1998/03/06 14:48:30   pinkfish
 * Changes to handle the extended inventory code.
 *
 * Revision 1.1   1998/01/06 05:28:43   ceres
 * Initial revision
 * 
*/
#include <move_failures.h>
#include <player.h>

#define MAX_DROP_NUMBER 20

inherit "/cmds/base";

#define TP this_player()

mixed cmd(object *obs, string str) {
   int num, max;
   object bing;
   string env_sh;
   object ob;
   object *fail;
   object *too_many;
   object *keep;
   mapping ret;
   object env;
   string drop_mess;
   //string sh;
   
   ret = ([ ]);
   fail = ({ });
   too_many = ({ });
   keep = ({ });
   if (sizeof(obs) > MAX_DROP_NUMBER) {
      too_many = obs[MAX_DROP_NUMBER..];
      obs = obs[0..MAX_DROP_NUMBER-1];
   }
   foreach(ob in obs) {
      if (!ob->short()) {
         continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      env = environment(ob);
      if (function_exists("do_drop", ob) ||
            function_exists("command_control", ob)) {
         if (function_exists("do_drop", ob)) {
            max = (int)call_other(ob, "do_drop", ({ }), str, 0, ({ str }),
                                             "<direct:object:me>");
         } else {
            max = ob->command_control("drop", ({ }), str, 0, ({ str }),
                                                   "<direct:object:me>");
         }
         if (max == 0)  {
            fail += ({ ob });
            continue;
         }
      }
      if (ob->move(environment(TP)) == MOVE_OK) {
         if (ret[env]) {
            ret[env] += ({ ob });
         } else {
            ret[env] = ({ ob });
         }
#ifndef __DISTRUBUTION_LIB__
         if(interactive(TP))
           PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif         
      } else {
        fail += ({ ob });
      }
   }
   if (sizeof(ret)) {
      foreach (env, bing in ret) {
         //sh = query_multiple_short(bing);
         if (env != this_player()) {
            env_sh = " from inside " + inside_the_short(env);
         } else {
            env_sh = "";
         }
         
         /* If you want to define your own message for when you
          * drop an item... return the string here.
          */
         if ( drop_mess = this_player()->query_drop_mess() ) {
            add_succeeded_mess( drop_mess, bing );
         }
         else {
            add_succeeded_mess("$N $V $I" + env_sh + ".\n", bing);
         }
      }
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding.\n", "" }));
      }
   } else {
      if (sizeof(keep)) {
         add_failed_mess("You are keeping $I.\n", keep);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot drop $I.\n", fail);
         return 0;
      }
      if (sizeof(too_many)) {
         add_failed_mess("You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding $I.\n", too_many);
         return 0;
      }
   }


   num = sizeof(fail)+sizeof(ret);

   if (!num) {
//      return notify_fail("Cannot drop "+str+".\n");
        return 0;
   }

   return 1;
}

mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1, $3) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/drop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/echo.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/echo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626940   Available: 13574294
Inodes: Total: 5242880    Free: 4960132
1085 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/echo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626940   Available: 13574294
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: echo.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: echo.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include <player.h>
#include <drinks.h>

inherit "/cmds/base";

#define TP this_player()

void my_mess(string fish, string erk);

mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("echo"))
    return notify_fail(NOT_ALLOWED);
  
  if (!str || str == "")
    return notify_fail("Syntax : echo <text>\n");

  if (!TP->query_creator() && TP->adjust_sp(-ECHO_COST) < 0)
    return notify_fail(NO_POWER);
  
  if (TP->query_volume(D_ALCOHOL))
    str = TP->drunk_speech(str);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos: "+
     str+"\n");
  str += "%^RESET%^";
  my_mess("You echo: ", str);
  TP->comm_event(environment(TP), "player_echo", str + "\n");
  return 1;
}

void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish), 
          TP->fix_string(erk));
} /* my_mess() */
// --- END [/mnt/home2/grok/lib/cmds/living/echo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/r_ead.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/r_ead.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626939   Available: 13574293
Inodes: Total: 5242880    Free: 4960132
4546 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/r_ead.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626939   Available: 13574293
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: ceres $
 * $Id: r_ead.c,v 1.19 2003/01/30 07:12:19 pinkfish Exp ceres $
 * $Log: r_ead.c,v $
 * Revision 1.19  2003/01/30 07:12:19  pinkfish
 * Add in a nerw line on the end.
 *
 * Revision 1.18  2001/09/08 01:42:48  ceres
 * Fixed bright/dark mixup
 *
 * Revision 1.17  2001/03/07 21:38:18  pinkfish
 * Make the bright/dark messages correct.
 *
 * Revision 1.16  2000/01/03 10:12:16  taffyd
 * Fixed typo and changed the success array so names would merge together. (three gold rings)
 *
 * Revision 1.15  1999/12/16 23:07:28  pinkfish
 * Stop people reading stuff in other peoples inventories.
 *
 * Revision 1.14  1999/08/19 01:21:53  pinkfish
 * Fix up this so it doesn't give weird messages for reading yourself.
 *
 * Revision 1.13  1999/08/19 01:09:09  pinkfish
 * Change it so you cannot read in the dark.
 *
 * Revision 1.12  1998/11/23 06:33:09  pinkfish
 * Really fixed the error.
 *
 * Revision 1.11  1998/11/23 06:20:10  pinkfish
 * Fix up a bug with add_items() and read.
 *
 * Revision 1.10  1998/09/15 21:30:01  pinkfish
 * Fix up read to say: reads rather than rs.
 *
 * Revision 1.9  1998/09/15 00:35:51  pinkfish
 * Make the read short stuff work if the function doesn't exist.
 *
 * Revision 1.8  1998/09/11 08:07:07  pinkfish
 * Fix up the sillyness with the read failures.
 *
 * Revision 1.7  1998/09/11 07:50:59  pinkfish
 * Fix this up to do the error messages correctly.
 *
 * Revision 1.6  1998/09/11 06:45:32  pinkfish
 * Stop it printing that silly 0.
 *
 * Revision 1.5  1998/09/11 05:56:24  pinkfish
 * Fixed up the read command to be better done.  Following real oo paradim
 * ideas.
 *
 * Revision 1.3  1998/08/16 03:09:47  tape
 * Minor typo fix when reading living things.
 *
 * Revision 1.2  1998/01/31 20:11:55  pinkfish
 * Allow the items on things to be readadable again.
 *
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
#include <language.h>

inherit "/cmds/base";

varargs string create_text( object thing, int label );

mixed cmd( object *things ) {
   string gendstr;
   string text;
   string read;
   string reader;
   string *others;
   string r_short;
   object thing;
   mapping hide_invis;
   int dark;
 
   dark = this_player()->check_dark(environment(this_player())->query_light());
   if (dark < 0) {
      add_failed_mess("It is too dark to read $I.\n", things);
      return 0;
   }
   if (dark > 0) {
      add_failed_mess("It is too bright to read $I.\n", things);
      return 0;
   }

   reader = "";
   others = ({ });
   foreach( thing in things ) {
      if (!is_in_me_or_environment(thing, this_player())) {
          add_failed_mess("You cannot read $I.\n", ({ thing }));
          continue;
      }

      text = thing->query_readable_message(this_player());
      read = thing->query_read_short();
      if (!read) {
         read = "$name$";
      }
      if ( !text) {
        /* This oculd be a tricky item obvject... */
        if (living(thing)) {
            gendstr = thing->query_objective();
        } else {
           gendstr = "it";
        }
        r_short = thing->query_read_short();
        if (!r_short) {
           r_short = "$name$";
        }
        if (!thing->command_control("read")) {
            if (thing != this_player()) {
               reader += "$C$"+ replace_string(r_short,
                                        "$name$",
                                        thing->a_short()) +
                     " does not have anything written on " +
                     gendstr + ".\n";
            } else {
               reader += "You cannot read yourself.\n";
            }
         } else {
            others += ({ replace( read, "$name$", (string)thing->a_short() ) });
            reader += "";
         }
         continue;
      }
      reader += "You read "+ replace_string( read, "$name$",
            (string)thing->the_short() ) +":\n"+ text + "\n";
      if ( read == "$name$" ) {
          others += ({ thing });
      }
      else {     
          others += ({ replace( read, "$name$", (string)thing->a_short() ) });
      }
   }
   /* Print success and failure messages. */
   if ( !sizeof( others ) ) {
      add_failed_mess(reader);
      return 0;
   }
   write( "$P$Read$P$"+ reader );

   hide_invis = this_player()->query_hide_invis();
   if(!hide_invis["hiding"]) {
      add_succeeded_mess(({ "", "$N read$s $I.\n" }), others);
   }
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/living/r_ead.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/attack.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/attack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626938   Available: 13574292
Inodes: Total: 5242880    Free: 4960132
215 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/attack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626938   Available: 13574292
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: attack.c,v 1.1 1998/01/06 05:28:43 ceres Exp $
 * $Log: attack.c,v $
 * Revision 1.1  1998/01/06 05:28:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/living/kill";
// --- END [/mnt/home2/grok/lib/cmds/living/attack.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/living/surr_ender.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/living/surr_ender.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626938   Available: 13574292
Inodes: Total: 5242880    Free: 4960132
1023 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/living/surr_ender.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626938   Available: 13574292
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:42.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: surr_ender.c,v 1.3 1998/02/23 23:50:08 sin Exp $
 * $Log: surr_ender.c,v $
 * Revision 1.3  1998/02/23 23:50:08  sin
 * Ok, everything is working with the surrender command now.
 *
 * Revision 1.2  1998/02/23 23:18:17  sin
 * *blush* I made a boo-boo
 *
 * Revision 1.1  1998/02/23 23:17:06  sin
 * Initial revision
 *
 * 
*/
inherit "/cmds/base";

mixed cmd(int mode, int val) {
  if (!mode) {
    int surr = this_player()->query_surrender();

    if (surr)
      write(sprintf("You will surrender at %d%% of your max hps.\n", surr));
    else
      write("You will not surrender.\n");
    return 1;
  } else {
    if (val < 0 || val > 100)
      return notify_fail("Your surrender must be between 0 and 100.\n");
    this_player()->set_surrender(val);
    write(sprintf("Surrender set to %d%%\n", this_player()->query_surrender()));
    return 1;
  }
} /* cmd() */

mixed *query_patterns()
{
  return ({ "", (: cmd(0, 0) :),
            "<number>", (: cmd(1, $4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/living/surr_ender.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/speech.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/speech.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626937   Available: 13574291
Inodes: Total: 5242880    Free: 4960132
9898 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/speech.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626937   Available: 13574291
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: speech.c,v 1.36 2003/04/15 17:46:43 ceres Exp $
*/
/* command, trial out by Turrican for a commands daemon. */
#include <language.h>
#include <player.h>
#include <drinks.h>
#include <cmds/options.h>

#define TP this_player()
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)

#define REPLACEMENTS (["ne1":"anyone",\
                       "u":"you",\
                       "r":"are", \
                       "NE1":"anyone",\
                       "U":"you",\
                       "R":"are", \
                       "ur":"you are",\
                       "teh":"the", \
                       "some1":"someone"])

class message {
   string text;
   string emote;
   string language;
   string type;
   string notify_mess;
   int status;
}

varargs string query_word_type(string str, string def) {
  int i;
  
  if (!str || strlen(str) < 1)
    return "";
  
  for (i = strlen(str) - 1; i >= 0 && str[i] == ' '; i--);

  // Make sure the string is not just spaces
  if (i < 0) {
    return "discombobulate";
  }

  switch (str[i]) {
  case '!':
    return "exclaim";
  case '?':
    return "ask";
  default:
    if (def)
      return def;
    else
      return "say";
  }
}

string mangle_tell(string mess, object dest) {
  int i;
  string ret;
  
  if (!TP || !environment(TP))
    return mess;
  
  if (environment(TP)->query_property("reverse_tell") &&
      !dest->query_creator() && !TP->query_creator()) {
    for (i = 0; i < strlen(mess); i++)
      ret = mess[i..i] + ret;
    return ret;
  }
  return mess;
}                               /* mangle_tell() */

string drunk_speech(string str) {
  /* I think I like replace already */
  return replace(str, ({ "S", "sh", "r", "rr", "ing", "in'", "x", "xsh",
                           "S", "SH", "R", "RR" }));
}

string de_eight(string arg) {
  object g;
  string replace_num;
  
  g = (object) TP->query_guild_ob();
  
  if (g && ((string) g->query_name() == "wizards") && !TP->query_creator()) {
    arg = "@ " + arg + "@";
    replace_num = ({ " seven plus one", " nine minus one",
                       " two to the power of three",
                       " four times two" })[random(4)];
    arg = implode(explode(arg, " eight"), replace_num);
    replace_num = ({ "(7+1)", "(9-1)", "(2^3)", "(4*2)" })[random(4)];
    arg = implode(explode(arg, "8"), replace_num);
    arg = arg[2.. < 2];
  }
  return arg;
}

/**
 * Replace "ne1" with "anyone" and suchlike.
 */
string fix_shorthand(string mess) {
  string *bits, name, value;
  mixed *tmp;
  int index, i;
  
  bits = explode(mess, " ");
  foreach(name, value in REPLACEMENTS) {
    tmp = regexp(bits, "(^|[^A-Za-z]+)"+name+"($|[^A-Za-z]+)", 1);
    if(sizeof(tmp)) {
      for(i=0; i<sizeof(tmp); i+=2) {
        index = tmp[i+1]-1;
        bits[index] = replace(bits[index], name, value);
      }
    }
  }
  return implode(bits, " ");
}

/* to properly columnate word_typed things */
void my_mess(string fish, string erk) {
  int bing;
  
  if (!interactive(TP)) {
    return;
  }
  bing = strlen(fish);
  if (bing > 15) {
    bing = 15;
  }
  efun::tell_object(TP, TP->fix_string(sprintf("%s%s\n", fish, erk),
                                       (int) TP->query_cols(), bing));
}

class message build_message(string arg, mixed target, string word_type) {
  string lang;
  string s1;
  string emotion;
  string word;
  string *langs;
  int i;
  class message mess;
  int done;
  
  mess = new (class message);
  
  if (!arg || arg == "" || arg == " ") {
    mess->status = NO_MESSAGE;
    return mess;
  }
  // Look for words starting #, @ or :. Take up to two in either order.
  while (!done && (!lang || !emotion)) {
    switch (arg[0]) {
    case '#':
      if(word_type == "tell") {
        done = 1;
        continue;
      }
      
      if (arg[1] == '\'' && sscanf(arg, "#'%s' %s", lang, arg) == 2)
        continue;

      if (sscanf(arg, "%s %s", lang, arg) == 2) {
        lang = lang[1..];
        // Try and do partial matching.
        langs = LANGUAGE_HAND->query_languages();
        if (member_array(lang, langs) == -1) {
          for (i = 0; i < sizeof(langs); i++) {
            if (TP->query_skill(LANGUAGE_HAND->
                                query_language_spoken_skill(langs[i])) > 1 ||
                TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
              if (langs[i][0..strlen(lang)-1] == lang) {
                lang = langs[i];
              }
            }
          }
        }
      } else {
        done = 1;
      }
      break;
    case '@':
      //case ':':
      if (sscanf(arg, "%s %s", emotion, arg) == 2) {
        emotion = emotion[1..] + " ";
      } else {
        done = 1;
      }
      break;
    default:
      done = 1;
    }
  }
  
  if (!emotion)
    emotion = "";

  if(lang == "general" && interactive(TP) && !TP->query_creator()) {
    mess->status = NOT_KNOWN;
    return mess;
  }

  if(!lang)
    lang = (string) TP->query_current_language();
  
  mess->language = lang;
  if(!LANGUAGE_HAND->query_language_spoken(lang)) {
    mess->status = NOT_SPOKEN;
    return mess;
  }
  if(word_type == "shout" && !LANGUAGE_HAND->query_language_distance(lang)) {
    mess->status = NOT_DISTANCE;
    return mess;
  }
  if(word_type != "tell" &&
     !TP->query_skill(LANGUAGE_HAND->query_language_spoken_skill(lang)) &&
     !LANGUAGE_HAND->query_language_always_spoken(lang)) {
    mess->status = NOT_KNOWN;
    return mess;
  }

  
  if (!interactive(TP)) {
    arg = TP->convert_message(arg);
    arg = TP->fit_message(arg);
  }
  
  // remove any unwanted stuff from the message.
  arg = replace(arg, ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                            "[D", "", "%^", " " }));

  if(TP->query_property(SHORTHAND_PROP))
    arg = LANGUAGES->fix_shorthand(arg);

  if(word_type != "tell") {
    if(TP->query_volume(D_ALCOHOL))
      arg = drunk_speech(arg);
    
    // General speech modifications (curses, etc)
    s1 = TP->mangle_speech(arg);
    if (stringp(s1))
      arg = s1;
  
    if(TP && environment(TP) &&
       function_exists("mangle_speech", environment(TP)))
      arg = (string) environment(TP)->mangle_speech(word_type, arg, target);
  
    arg = de_eight(arg);
  }
  
  word = query_word_type(arg, word_type);
  
  mess->text = arg;
  mess->type = word;
  mess->emote = emotion;
  mess->status = MESSAGE_OK;
  if (target)
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$ $target$: ";
  else
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$: ";
  
  return mess;
}


int say_it(class message mess) {
  string accent;

  if (!environment(TP))
    write("You are in limbo, noone can hear you.\n");
  
  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  
  TP->remove_hide_invis("hiding");
  accent = TP->query_nationality_accent_ob();
  
  TP->comm_event(environment(TP), "person_say",
                 mess->notify_mess, mess->text, mess->language, accent);
  
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    my_mess("You " + mess->emote + mess->type + " in " +
            capitalize(mess->language) + ": ", mess->text);
  } else {
    my_mess("You " + mess->emote + mess->type + ": ", mess->text);
  }
  
  TP->adjust_time_left(-5);
  return 1;
}

int say_it_to(class message mess, mixed targets, int priv, string event) {
  string lstr;
  string extra;
  string accent;
  
  if (!environment(TP)) {
    write("You are in limbo, noone can hear you.\n");
  }

  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  
  if (!sizeof(targets)) {
    return 0;
  }
  
  targets -= ({ this_player() });
  TP->remove_hide_invis("hiding");
  this_player()->adjust_time_left(-5);
  accent = TP->query_nationality_accent_ob();
  
  switch (mess->type) {
  case "exclaim":
  case "whisper":
  case "say":
    extra = "to ";
    break;
  default:
    extra = "";
  }
  
  switch (priv) {
  case 2:                     // Only recipients see anything.
    break;
  case 1:                     // Everyone sees it happen but not what's said
    TP->comm_event_to(environment(this_player()), event,
                      (string) this_player()->one_short(1) +
                      " " + mess->emote + mess->type + "s " +
                      extra, mess->text, targets, mess->language,
                      this_player(), accent);
    break;
    
  case 0:                     // Everyone hears it all.
    TP->comm_event(environment(TP), event,
                   "$one_short:" + file_name(TP) + "$ " + mess->emote +
                   "$V$0=" + mess->type + "s," + mess->type + "$V$ " +
                   extra + query_multiple_short(targets, "the") + ": ",
                   mess->text, mess->language, accent);
    break;
  }
  
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    lstr = " in " + cap_words(mess->language);
  } else {
    lstr = "";
  }
  
  write("You " + mess->emote + mess->type + " " + extra +
        query_multiple_short(targets, "the") + lstr + ": " +
        mess->text + "\n");
  return 1;
} /* say_it_to() */
// --- END [/mnt/home2/grok/lib/cmds/speech.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/statthief.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/statthief.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626935   Available: 13574289
Inodes: Total: 5242880    Free: 4960132
1847 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/statthief.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626935   Available: 13574289
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: statthief.c,v 1.3 2003/03/21 02:03:30 ceres Exp $
 * $Log: statthief.c,v $
 * Revision 1.3  2003/03/21 02:03:30  ceres
 * Modified to use player handler
 *
 * Revision 1.2  2000/04/03 18:10:48  dragonkin
 * Added a check to make sure that the person actually had a quota, as it otherwise created one then...
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <player_handler.h>

inherit "/cmds/base";

#define QUOTA "/obj/handlers/guild_things/quota"
#define MONEY "/obj/handlers/money_handler"

string cost_str(int amt);
string time_str(int time);

int cmd(string str) {
  if(!str || !PLAYER_HANDLER->test_user(str))
    return notify_fail("Get thief stats for who?\n");

  if( !QUOTA->query_quota_data( str ) )
    return notify_fail("Sorry, "+str+" does not have a quota.\n");
  
  printf("Thief statistics for: %s\n", str);
  printf("  Quota: \n");
  printf("    Min %s\n", cost_str((int)QUOTA->query_thief_minquota(str)));
  printf("    Max %s\n", cost_str((int)QUOTA->query_thief_maxquota(str)));
  
  printf("  Debts:\n");
  printf("    Debts %s\n", cost_str(QUOTA->query_thief_debts(str)));
  printf("    Fines %s\n", cost_str(QUOTA->query_thief_fines(str)));
  
  printf("  This period:\n");
  printf("    Stolen %s\n", cost_str(QUOTA->query_total_stolen(str)));
  printf("    Time left %s\n", time_str(QUOTA->query_time_to_reset(str)));
  return 1;
}

string cost_str(int amt) {
  return MONEY->money_string(MONEY->create_money_array(amt, "Ankh-Morpork"));
}

string time_str(int time) {
  string str;

  str = "";
  if (time > 86400)
    str += sprintf("%d days, ", time/86400);
  if (time > 3600)
    str += sprintf("%d hours, ", (time/3600)%24);
  str += sprintf("%d minutes and %d seconds", 
                     (time/60)%60, time%60);
  return str;
}  
// --- END [/mnt/home2/grok/lib/cmds/creator/statthief.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/callouts.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/callouts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626934   Available: 13574288
Inodes: Total: 5242880    Free: 4960132
4144 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/callouts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626934   Available: 13574288
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: callouts.c,v 1.4 2003/03/27 11:38:02 taffyd Exp $
 * $Log: callouts.c,v $
 * Revision 1.4  2003/03/27 11:38:02  taffyd
 * Rewritten for easy maintainence of various (legacy?) functions, added a new "before|at|after" time syntax.
 *
 * Revision 1.3  2000/05/16 21:41:27  ceres
 * Modified so it doesn't try sorting if there's more than 1000 callouts -- this caused over evals :(
 *
 * Revision 1.2  1999/10/28 02:00:15  ceres
 * improved filtering
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/

#define CALL_OUT_SORT_THRESHOLD 1000
#define CALL_OUT_FILE_NAME 0
#define CALL_OUT_FUNCTION 1
#define CALL_OUT_TIME 2

inherit "/cmds/base";


private mixed *get_call_outs() {
    mixed *junk;

    junk = call_out_info();
    
    // Only sort the array if we have less than CALL_OUT_SORT_THRESHOLD
    // elements in the array.
    if (sizeof(junk) < CALL_OUT_SORT_THRESHOLD) {
        junk = sort_array( junk, (: ( $1[ 2 ] > $2[ 2 ] ) -  
            ( $1[ 2 ] < $2[ 2 ] ) :) );
    } 
    
    return junk; 
} /* get_call_outs() */ 

int count_callouts() {
    mixed *call_outs = get_call_outs();
    mapping count = ([ ]);
    string ret = ""; 

    foreach( mixed *func in call_outs) {
        count[ file_name( func[ CALL_OUT_FILE_NAME ] ) + ":" + 
            func[ CALL_OUT_FUNCTION ] ] += 1; 
    }
    
    foreach( string key, int value in count ) {
        ret += sprintf( "%-30s %d\n", key, value );
    }
    
    this_player()->more_string( ret, "Callouts" ); 
    return 1; 
} /* count_callouts() */ 

int count_clean() {
    mixed *call_outs = get_call_outs();
    string ret = ""; 

    foreach( mixed *func in call_outs) {
        if ( base_name( func[CALL_OUT_FUNCTION] ) != "effect_timer" &&
          base_name( func[CALL_OUT_FUNCTION] ) != "print_messages" ) { 
            ret += sprintf( "%O: %O in %O\n", 
                        file_name( func[ CALL_OUT_FILE_NAME ] ),
                        func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
        }
    }

    this_player()->more_string( ret, "Callouts" ); 
    return 1; 
} /* count_clean() */ 

int count_for_file( string str ) {
    mixed *call_outs = get_call_outs();
    string ret = ""; 

    foreach( mixed *func in call_outs) {
        if ( sscanf( file_name( func[ 0 ] ), "%*s"+ str +"%*s" ) == 2 ) { 
            ret += sprintf( "%O: %O in %O\n", 
                file_name( func[ CALL_OUT_FILE_NAME ] ),
                func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
        }
    }

    this_player()->more_string( ret, "Callouts" ); 
    return 1; 
} /* call_out_for_file() */ 

int count_time(string choice, int mtime ) {
    mixed *call_outs = get_call_outs();
    string ret = ""; 

    foreach( mixed *func in call_outs) {
        if ( choice == "before" && func[ CALL_OUT_TIME ] >= mtime ) {
            continue;
        } else if ( choice == "after" && func[ CALL_OUT_TIME ] <= mtime ) {
            continue;
        } else if ( choice == "at" && func[ CALL_OUT_TIME ] != mtime ) { 
            continue;
        }

        ret += sprintf( "%O: %O in %O\n", func[ CALL_OUT_FILE_NAME ],
            func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
    }

    if ( ret == "" ) {
        add_failed_mess( "No callouts matching that criteria found.\n" );
        return -1; 
    }

    this_player()->more_string( ret, "Callouts" ); 
    return 1;
} /* count_time() */ 

int cmd() {
    mixed *call_outs = get_call_outs();
    string ret = ""; 

    foreach( mixed *func in call_outs) {
        ret += sprintf( "%O: %O in %O\n", func[ CALL_OUT_FILE_NAME ],
            func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
    }

    this_player()->more_string( ret, "Callouts" ); 
    return 1; 
} /* cmd() */

mixed *query_patterns() {
    return ({ "{-c|count}", (: count_callouts :), 
              "{-b|no effects}", (: count_clean :),
              "<string'file'>", (: count_for_file( $4[0] ) :), 
              "{before|at|after} <number'time'>", 
                (: count_time($4[0], $4[1]) :),
              "", (: cmd :), 
    }); 

} /* query_patterns() */ // --- END [/mnt/home2/grok/lib/cmds/creator/callouts.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/qp_eople.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/qp_eople.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626933   Available: 13574287
Inodes: Total: 5242880    Free: 4960132
655 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/qp_eople.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626933   Available: 13574287
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: qp_eople.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: qp_eople.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* qpeople command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <peopler.h>
#include <creator.h>

mixed cmd(string str) {
   mixed *stuff;

   stuff = this_player()->query_property("qpeople list");
   if (!stuff) {
      stuff = D_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/qp_eople.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/trace.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/trace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626932   Available: 13574286
Inodes: Total: 5242880    Free: 4960132
1236 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/trace.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626932   Available: 13574286
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: trace.c,v 1.2 2000/04/17 17:25:23 ceres Exp $
 * $Log: trace.c,v $
 * Revision 1.2  2000/04/17 17:25:23  ceres
 * Removed apply since it seems to crash the driver.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* call command, trial out by Turrican for a commands daemon. */

#include <creator.h>
#include <parser.h>

inherit "/cmds/base";

#define OPTIONS ({ "off", "call", "call_other", "return", "args", "exec", "heart_beat", })
  
mixed cmd(string arg) {
  string *args;
  int     i, j, trace_arg;
  
  /* ok lets make this clever...
   */
  notify_fail( "Usage: trace <" + implode(OPTIONS, "|") + ">\n" );

  if( !arg ) return 0;

  args = explode( arg, " " );
  
  if( !sizeof( args ) )
    return 0;
  
  for( i = 0; i < sizeof( args ); i++ )
    if( (j = member_array( args[ i ], OPTIONS )) != -1 )
    {
      if( !j )
      {
        trace( 0 );
        write( "Trace off.\n" );
        return 1;
      }
      else
        trace_arg |= ({ 0, 1, 2, 4, 8, 16, 32, 64, 128 })[ j ];
    }
    else if( sscanf( args[ i ], "%d", j ) && j != 64)
      trace_arg |= j;

  trace( trace_arg | 128 );
  write( "Trace level: " + trace_arg + "\n" );
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/trace.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/terms.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/terms.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626932   Available: 13574286
Inodes: Total: 5242880    Free: 4960132
644 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/terms.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626932   Available: 13574286
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: terms.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: terms.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* terms command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <peopler.h>
#include <creator.h>

mixed cmd(string str) {
   mixed *stuff;

   stuff = this_player()->query_property("term list");
   if (!stuff) {
      stuff = T_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/terms.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/mail.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/mail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626931   Available: 13574285
Inodes: Total: 5242880    Free: 4960132
442 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/mail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626931   Available: 13574285
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mail.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: mail.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* mail command, trial out by Turrican for a commands daemon. */

#include <mail.h>

mixed cmd(string str) {
  return (int)MAIL_TRACK->mail(str);
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/mail.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/gag.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/gag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626931   Available: 13574285
Inodes: Total: 5242880    Free: 4960132
1742 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/gag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626931   Available: 13574285
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Gagger object originally coded by Obilix 9 April 1997.
 * Turned into gag and ungag commands by Gruper 20 March 2000.
 */

#include <playerinfo.h>

inherit "/cmds/base";


int cmd( object victim, string reason, int number ) {

   // Gag them and log it
   victim->add_property( "gagged", reason, 60 * number );
   log_file( "GAG", ctime(time()) +": "+ this_player()->query_short()
             + " gagged " + victim->query_short() + " for " + number 
             + " minutes.  Reason: " + reason +".\n");
   PLAYERINFO_HANDLER->add_entry( this_player(), victim->query_name(),
             "gag", "Gagged for " + number + " minutes.  Reason: '" + reason +
             "'.\n");

   // Write leetle messages about it
   tell_object( victim,
         "%^RED%^%^BOLD%^You have been gagged by " + 
         this_player()->query_short() + " for the reason: '" + reason +
         "'.\nYou will not be able to shout, chat or use the newbie "
         "channel until the gag is removed.%^RESET%^\n" );

   write( "Okay, gagged " + victim->query_short() + " for " + number +
          " minutes.  Now please discuss your reason for gagging with "
          "them.  IMPORTANT! You should only be gagging for deliberately "
          "offensive language.\n" );

   event( users(), "inform", this_player()->query_short()
          + " gagged " + victim->query_short() + " for: " + reason, "gag");

   return 1;

} /* cmd() */


mixed *query_patterns() {
   return ({ "<indirect:player'player'> <string'reason'>",
                (: cmd( $1[0], $4[1], 15 ) :), // Default time is 15 minutes
             "<indirect:player'player'> <string'reason'> <number'minutes'>",
                (: cmd( $1[0], $4[1], $4[2] ) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/gag.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/usage.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/usage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626931   Available: 13574285
Inodes: Total: 5242880    Free: 4960132
583 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/usage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626931   Available: 13574285
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: usage.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: usage.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/

mixed cmd(string arg) {
	mapping info;

  info = rusage();
	
  printf("Current statistics are:\n"+
				 "Memory: %d\nMajorfaults: %d\nUser time: %d\nSystem time: %d\n",
				 info["maxrss"], info["majflt"], info["minflt"],
				 info["utime"] / 1000, info["stime"] / 1000);
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/usage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/dest_ruct.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/dest_ruct.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626930   Available: 13574284
Inodes: Total: 5242880    Free: 4960132
3428 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/dest_ruct.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626930   Available: 13574284
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dest_ruct.c,v 1.2 2000/10/27 03:31:10 taffyd Exp $
 * $Log: dest_ruct.c,v $
 * Revision 1.2  2000/10/27 03:31:10  taffyd
 * Fixed buglets!
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* destruct command, trial out by Turrican for a commands daemon. */

#include <creator.h>

inherit "/cmds/base";

void main_dest_bit(object *ob);

void ask_dest(object *obs) {
  if (!pointerp(obs) || !sizeof(obs)) {
    write("No more things to dest.\n");
    return;
  }
  write("Dest object " + WIZ_PRESENT->desc_object(obs[0]) + " ? ");
  input_to("dest_answer", 0, 0, obs);
  return;
} /* ask_dest() */

void dest_answer(string s, int majd, object *obs) {
  string err, shrt;

  if (this_player()->affirmative(s)) {
    if (majd) {
      shrt = (string)obs[0]->short();
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
        write("It REALLY doesn't want to be dested.\n");
        err = catch(destruct(obs[0]));
        this_player()->handle_error(err, "destruct()");
      }
      majd = 0;
      if (obs[0]) write("It didn't dest.\n");
      else {
        say((string)this_player()->query_cap_name()+" disintegrates "+
            (shrt ? shrt : "something") +".\n"); 
        write("Ok.\n");
      }
      ask_dest(obs[1..]);
      return;
    } else {
      obs[0]->move("/room/rubbish");
      err = catch(obs[0]->dest_me());
      this_player()->handle_error(err, "dest_me");
      if (obs[0]) {
        write("This object does NOT want to be dested.  Are you sure? ");
        input_to("dest_answer", 0, 1, obs);
        return;
      } 
      write("Ok.\n");
      ask_dest(obs[1..]);
      return;
    }
  } else if (s == "q" || s == "quit") {
    write("Ok.  No more objects will be destd.\n");
    return;
  }
  write("Ok.  Not destd.\n");
  ask_dest(obs[1..]);
  return;
} /* dest_answer() */
         
mixed cmd(string str) {
  object *ob, *dest_obj;
  string qstr;

  dest_obj = ({ });
  notify_fail("Can't find " + str + " to dest.\n");
  
  if ( !str || ( str == "" ) )
    return notify_fail( "Destruct what?\n" );
  if (this_player()->query_name() == "simidh") {
     write("Bye bye...\n");
     this_player()->dest_me();
     return 1;
  }

  if (sscanf(str, "query %s", qstr) == 1) {
    dest_obj = WIZ_PRESENT->wiz_present(qstr, this_player());
    if (!sizeof(dest_obj)) return 0;
    ask_dest(dest_obj);
    return 1;
  }
  ob = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ob)) return 0;
  main_dest_bit(ob);
  return 1;
} /* cmd() */

void main_dest_bit(object *ob) {
  object thing, *rest, *dest_obj;
  string err, shrt, dobj;

  rest = ({ });
  dest_obj = ({ });
  foreach (thing in ob) {
    if (interactive(thing) && sizeof(ob) != 1) {
      write("You DON'T destruct " + thing->query_name() + ".\n");
      continue;
    }
    catch(shrt = (string)thing->short());
    dobj = WIZ_PRESENT->desc_object(thing);
    thing->move("/room/rubbish");
    err = catch(thing->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (thing) 
      dest_obj += ({ thing });
    else {
      write("You destruct " + dobj + ".\n");
      say((string)this_player()->query_cap_name()+" disintegrates "+
          (shrt ? shrt : "something") + ".\n"); 
    }
  }
  if (sizeof(dest_obj) > 0) {
    ask_dest(dest_obj);
    return;
  }
  return;
} /* main_dest_bit() */
// --- END [/mnt/home2/grok/lib/cmds/creator/dest_ruct.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/mo_re.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/mo_re.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626929   Available: 13574283
Inodes: Total: 5242880    Free: 4960132
771 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/mo_re.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626929   Available: 13574283
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mo_re.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: mo_re.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* more command, trial out by Turrican for a commands daemon. */

#include <creator.h>

mixed cmd(string str) {
  object *things;

  seteuid(geteuid(this_player()));

  if(!str) {
    notify_fail("More which file(s)/object?\n");
    return 0;
  }
  if(sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    str = file_name(things[0]);
    sscanf(str, "%s#%*d", str);
    if (file_size(str) <= 0)
      str += ".c";
  }
  return this_player()->more_file(str);
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/mo_re.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/gob_ack.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/gob_ack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626929   Available: 13574283
Inodes: Total: 5242880    Free: 4960132
1787 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/gob_ack.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626929   Available: 13574283
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: gob_ack.c,v 1.5 1999/07/03 19:56:33 sin Exp $
 * $Log: gob_ack.c,v $
 * Revision 1.5  1999/07/03 19:56:33  sin
 * Fixed another bug in my terrain support.
 *
 * Revision 1.4  1999/07/02 18:42:38  sin
 * Fixed an error.
 *
 * Revision 1.3  1999/07/02 18:37:28  sin
 * Added some support for terrains.
 *
 * Revision 1.2  1999/06/19 03:05:54  ceres
 * Slight tweak
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* goto command, trial out by Turrican for a commands daemon. */
#include <terrain.h>

mixed cmd(string str) {
  mixed dest;
  string tname;

  dest = this_player()->query_last_location();
  if(!dest)
    return notify_fail("No stored location.\n");
  if (stringp(dest)) {
    /* Player was in a normal room */
    dest = load_object(dest);
  } else if (arrayp(dest) && stringp(dest[0]) && arrayp(dest[1])) {
    /* Player was in a terrain */
    dest = TERRAIN_MAP->find_location(dest[0], dest[1]);
  } else {
    return notify_fail("I don't understand your stored location.\n");
  }
  tname = environment(this_player())->query_property("terrain name");
  if (tname) {
    /* Player is in a terrain.  Store terrain name and coords. */
    this_player()->set_last_location(
      ({ tname, environment(this_player())->query_co_ord() })
      );
  } else {
    /* Player was in a normal room.  Store file name. */
    this_player()->set_last_location(
      base_name(environment(this_player()))
      );
  }
  this_player()->move_with_look( dest,
                                 this_player()->query_mmsgin(),
                                 this_player()->query_mmsgout() );
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/gob_ack.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/mk_dir.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/mk_dir.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626928   Available: 13574282
Inodes: Total: 5242880    Free: 4960132
855 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/mk_dir.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626928   Available: 13574282
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mk_dir.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: mk_dir.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* mkdir command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
   seteuid(geteuid(this_player()));

   if (!str || str == "") {
      notify_fail("Make what directory?\n");
      return 0;
      }
   str = this_player()->get_path(str);

   str = replace(str, " ", "_");
   
   if (!str)
      return 1;
 
   if (file_size(str) != -1) {
      notify_fail(str + " already exists.\n");
      return 0;
      }
 
   if (!mkdir(str)) {
      notify_fail("Couldn't make dir.\n");
      return 0;
   }
   write("Ok.\n");
   return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/mk_dir.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/fds.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/fds.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626928   Available: 13574282
Inodes: Total: 5242880    Free: 4960132
195 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/fds.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626928   Available: 13574282
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: fds.c,v 1.2 2000/02/18 13:36:24 turrican Exp $
 */

inherit "/cmds/base";

mixed cmd(string) {
  this_player()->more_string(dump_file_descriptors());
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/fds.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ptest_ers.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ptest_ers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626928   Available: 13574282
Inodes: Total: 5242880    Free: 4960132
5282 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ptest_ers.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626928   Available: 13574282
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  PT Applications command
 *  @author Drakkos
 *  @started 27/08/2002
 *
 */


inherit "/cmds/base";
#include <playtesters.h>
#include <project_management.h>

string query_applicant_text();

varargs int cmd(string check, string name, string reason) {

  int i;
  string *names, *projects;
  string ret = "";
  class project *tmp, *tmp2;
  
  switch (check) {
    case "ptinfo":
      ret = PLAYTESTER_HAND->query_show_list_colour();
      tell_object (this_player(), ret);
      return 1;
    break;
    case "assign":
      i = PROJECT_HANDLER->find_project (name);
      
      if (i == -1) {
        this_player()->add_failed_mess (this_object(), "There is no project "
          "of that ID.\n", ({ }));
        return 0;
      }        
      else {
        names = PROJECT_HANDLER->assign_pts_to_project (i);
        
        if (!sizeof (names)) { 
          this_player()->add_failed_mess (this_object(), "Something went " 
            "wrong!\n", ({ })); 
            return 0; 
        }        
        else { 
          tell_object (this_player(), sprintf ("$I$5=You assign %s to project %s.\n", 
          query_multiple_short (map (names, (: capitalize ($1) :))), name)); 
        return 1; 
      } 
    }        
    break; 
    case "allassign": 
      tmp = PROJECT_HANDLER->get_playtesting_projects();
      
      tmp2 = filter (tmp, (: sizeof ($1->guild_specific) :));
      
      tmp -= tmp2;
      
      if (!sizeof (tmp) && !sizeof (tmp2)) {
          this_player()->add_failed_mess (this_object(), "There are no "
            "projects currently in playtesting.\n", ({ }));
          return 0;
      }
      else {
        
        for (int c = 0; c < 2; c++) {
          if (c == 0) {
            projects = map (tmp2, (: $1->id :));
          }
          else {
            projects = map (tmp, (: $1->id :));
          }
                    
          foreach (string p in projects) {
            names = PROJECT_HANDLER->assign_pts_to_project (p);
            if (!sizeof (names)) {
              continue;
            }
            ret += sprintf ("$I$5=You assign %s to project %s.\n", 
              query_multiple_short (map (names, (: capitalize ($1) :))), p);
          }
        }
                
        tell_object (this_player(), ret);
        return 1;          
    }
    break;          
    case "add":
      i = PLAYTESTER_HAND->add_playtester (name);
      
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N add$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot add this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;         
    case "remove":
      i = PLAYTESTER_HAND->remove_playtester (name, reason);
      
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N remove$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;     
    case "shortlist":
            
      PT_APPLICATION_HANDLER->set_shortlist (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
      return 1;
    break;          
    case "investigate":
        PT_APPLICATION_HANDLER->set_considering (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
        return 1;
    break; 
    case "delete":
      i =  PT_APPLICATION_HANDLER->delete_applicant (name);
            
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N delete$s someone "
          "as from the application process.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player from the application process.\n", ({ }));
        return 0;
      }
    break;
    case "holiday":
      i =  PLAYTESTER_HAND->query_leave(name);
            
      if (i) {
        PLAYTESTER_HAND->reset_leave(name);
        this_player()->add_succeeded_mess (this_object(), "$N reset$s someones "
          "playtester leave.\n", ({ }));
        return 1;
      }
      else {
        PLAYTESTER_HAND->set_leave(name, reason);
        this_player()->add_succeeded_mess (this_object(), "$N set$s someone "
          "as on leave.\n", ({ }));
        return 1;
      }
    break;               
  }   
  
}
       
  

mixed *query_patterns() {
   mixed *patterns = 
    ({ 
      "add <word>", (: cmd ("add", $4[0]) :),
      "remove <word'name'> <string'reason'>", (: cmd ("remove", $4[0], $4[1]) :),
      "holiday <word> <string>", (: cmd ("holiday", $4[0], $4[1]) :),
      "shortlist <word>", (: cmd ("shortlist", $4[0]) :),
      "investigate <word>", (: cmd ("investigate", $4[0]) :), 
      "delete <word>", (: cmd ("delete", $4[0]) :),
      "assign all", (: cmd ("allassign", "all") :),
      "assign <word>", (: cmd ("assign", $4[0]) :),         
      "info", (: cmd ("ptinfo") :) 
      });
    
  return patterns;     
} /* query_patterns() */       // --- END [/mnt/home2/grok/lib/cmds/creator/ptest_ers.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/he_ad.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/he_ad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626926   Available: 13574280
Inodes: Total: 5242880    Free: 4960132
757 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/he_ad.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626926   Available: 13574280
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: he_ad.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: he_ad.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* head command, by Wodan. */

mixed cmd(string str) {
  int i;
  string *files;

  seteuid(geteuid(this_player()));
  if (!str)
    return notify_fail("Usage: head <file>\n");
  files = this_player()->get_files(str);
  if (!sizeof(files))
    return notify_fail("File does not exist.\n");
  str = files[0];
  i = file_length(str);
  if (i < 0) {
    printf("File not found.\n");
    return 1;
  }
  if (i > 20) i=20;
  write(read_file(str,1,i));
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/he_ad.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/panic.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/panic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626926   Available: 13574280
Inodes: Total: 5242880    Free: 4960132
896 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/panic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626926   Available: 13574280
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: panic.c,v 1.2 2002/05/12 09:02:01 taffyd Exp $
 * $Log: panic.c,v $
 * Revision 1.2  2002/05/12 09:02:01  taffyd
 * Disabled command, can be re-enabled later.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <panic.h>

inherit "/cmds/base";

int cmd( ) {
    /* We don't need this, let's just return 0 now. */
    return 0;
/*
   if (!PLAYER_TESTER(previous_object())) {
    this_player->add_failed_mess(this_object(), "You need to be a player tester "
                                                "to use this command.\n", ({ }));
    return 0;
  }
 */
  PANIC_HANDLER->do_startup(previous_object());
  this_player()->add_succeeded_mess(this_object(),
                  "$N panic$s hopefully.", ({ }) );
  return 1;
} /* cmd() */

mixed *query_pattern() {
  return ({ "", (: cmd() :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/creator/panic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/multipl_ayer.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/multipl_ayer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626925   Available: 13574279
Inodes: Total: 5242880    Free: 4960132
2811 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/multipl_ayer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626925   Available: 13574279
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: multipl_ayer.c,v 1.9 2003/03/25 09:42:40 wyvyrn Exp ceres $
 */

/* multiplayer command to add/delete names to the list
 * of checked players and enter multiplay events into playerinfos
 */
#include <creator.h>
#include <player.h>

inherit "/cmds/base";

varargs int cmd(string command, string name, string what, string extra) {
  switch (command) {
  case "add":
    if (!call_other(PLAYER_MULTIPLAYER_HANDLER, "add_" + what, name, extra)) {
      printf("\"%s\"%s isn't known here.\n", name, (extra ? " and/or \"" + 
                extra + "\"" : ""));
    } else {
      if (what == "allowed") {
        printf("\"%s\" and \"%s\" added as allowed together.\n", name, extra);
      } else {
        printf("\"%s\" added.\n", name);
      }
    }
    break;
  case "del":
    if(!call_other(PLAYER_MULTIPLAYER_HANDLER, "delete_" + what, name)) {
      printf("\"%s\" isn't on the list.\n", name);
    } else {
      printf("\"%s\" deleted.\n", name);
    }
    break;
  case "log":
    PLAYER_MULTIPLAYER_HANDLER->mark_log(name, extra);
    if (extra) {
      printf("Added \"multiplay\" playerinfo event for \"%s\": \"%s\".\n",
           name, extra);
    } else {
      printf("Marked \"multiplay\" playerinfo events for \"%s\" as handled.\n", 
           name);
    }
    break;
  case "list":
    write("The list currently consists of: $I$5=\n" +
          query_multiple_short(sort_array(call_other(PLAYER_MULTIPLAYER_HANDLER,
                                                     "query_" + what),
                                          (: strcmp($1, $2) :)))
          + "$I$0=\n");
    break;
  case "site":
    if(find_player(name)) {
      name = query_ip_number(find_player(name));
    }
    if("/secure/bastards"->change_multi(name, 1, time() + 3600)) {
      write("Site " + name + " has been permitted for multiplayers "
            "for the next hour.\n");
    } else {
      write("Error permitting site " + name + " for multiplayers.\n");
    }
    break;
  default:
    write("Unknown option.\n");
  }
  return 1;
} /* cmd */

mixed *query_patterns() {
  return ({ "[list]",  (: cmd("list", 0, "gits") :),
              "{list allow}", (: cmd("list", 0, "allowed") :),
            "add git <word'name'>", (: cmd("add", $4[0], "git") :),
            "add allowed <word'first name'> <word'second name'>",
            (: cmd("add", $4[0], "allowed", $4[1]) :),
            "allow site <word'address|name'>", (: cmd("site", $4[0], "allowed") :),
            "del allowed <word'name'>", (: cmd("del", $4[0], "allowed") :),
            "log <word'name'>", (: cmd("log", $4[0], "git") :),
            "log <word'name'> <string'log text'>", (: cmd("log", $4[0], "git",
                                                       implode($4[1..], " ")) :)
         });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/multipl_ayer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/family.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/family.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626924   Available: 13574278
Inodes: Total: 5242880    Free: 4960132
7281 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/family.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626924   Available: 13574278
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: family.c,v 1.5 2003/03/21 02:03:45 ceres Exp $
 * $Log: family.c,v $
 * Revision 1.5  2003/03/21 02:03:45  ceres
 * Modified to use player handler
 *
 * Revision 1.4  1999/04/28 22:53:53  pinkfish
 * Change to use a pager.
 *
 * Revision 1.3  1999/04/16 00:53:16  presto
 * Added #include <money.h>
 *
 * Revision 1.2  1999/04/07 01:01:12  pinkfish
 * Add in balance stuff.
 *
 * Revision 1.1  1999/01/30 10:46:43  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
 */
#include <clubs.h>
#include <money.h>

inherit "/cmds/base";
inherit "/std/basic/club_listing";

#include <player_handler.h>
#include <playerinfo.h>

mixed family_reverse(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string opp;
  string relation;

  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }

  foreach (relation in relations_from) {
    opp = CLUB_HANDLER->query_opposite_relationship(relation);
    if (!opp) {
      write("Unable to swap " + relation + ".\n");
    } else {
      if (!CLUB_HANDLER->remove_relationship(family_from,
                                             from,
                                             family_to,
                                             to,
                                             relation)) {
        write("Could not remove relationship " + relation + " between " +
              from + " and " + to + ".\n");
      } else {
        CLUB_HANDLER->add_relationship(family_from,
                                       from,
                                       family_to,
                                       to,
                                       opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      from,
                                      "family",
                                      "Changed relationship with " + to + " to " +
                                      opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      to,
                                      "family",
                                      "Changed relationship with " + from + " to " +
                                      relation);
        write("Swapped relationship " + relation + " between " +
              from + " and " + to + ".\n");
      }
    }
  }
  return 1;
} /* family_reverse() */

int family_remove(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string relation;

  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }

  foreach (relation in relations_from) {
    if (!CLUB_HANDLER->remove_relationship(family_from,
                                           from,
                                           family_to,
                                           to,
                                           relation)) {
      write("Could not remove relationship " + relation + " between " +
            from + " and " + to + ".\n");
    } else {
      write("Removed relationship " + relation + " between " +
            from + " and " + to + ".\n");
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    from,
                                    "family",
                                    "Removed relationship with " + to);
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    to,
                                    "family",
                                    "Removed relationship with " + from);      
    }
  }
  return 1;
} /* family_remove() */

private int do_balance(string club_name) {
   int balance;
   string place;

   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("There is no family called '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   }
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   balance = CLUB_HANDLER->query_balance(club_name);
   write("The balance of the family '" +
         CLUB_HANDLER->query_club_name(club_name) + "' is " +
         MONEY_HAND->money_value_string(balance, place) + ".\n");
   return 1;
} /* do_balance() */

private int do_all_balance() {
   string *clubs;
   string club;
   string place;
   mapping bing;
   string ret;

   clubs = CLUB_HANDLER->query_clubs();
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   bing = ([ ]);
   foreach (club in clubs) {
      if (!CLUB_HANDLER->is_family(club)) {
         continue;
      }
      bing[club] = CLUB_HANDLER->query_balance(club);
   }

   clubs = keys(bing);
   clubs = sort_array(clubs, (: $3[$1] - $3[$2] :), bing);
   ret = "";
   foreach (club in clubs) {
      ret += sprintf("Family '%-20s': %s\n",
            CLUB_HANDLER->query_club_name(club),
            MONEY_HAND->money_value_string(bing[club], place));
      
   }
   write("$P$Club Balances$P$" + ret);
   return 1;
} /* do_all_balance() */

mixed *query_patterns() {
  return ({ "info <word'family name'>",
              (: family_info($4[0], this_player()->query_name()) :),
            "reverse relationship <word'player name'> <word'player name'>",
              (: family_reverse($4[0], $4[1]) :),
            "remove relationship <word'player name'> <word'player name'>",
              (: family_remove($4[0], $4[1]) :),
            "balance <string'family name'>", (: do_balance($4[0]) :),
            "balance all", (: do_all_balance() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/family.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ob_ject.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ob_ject.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626922   Available: 13574276
Inodes: Total: 5242880    Free: 4960132
1903 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ob_ject.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626922   Available: 13574276
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ob_ject.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: ob_ject.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* object command, trial out by Turrican for a commands daemon. */
/* obvar stuff -> Ember 12/4/93 */
/* obvar changed slighty by pinkfish... 17/4/93 (New call syntax added) */

#include <creator.h>

mixed cmd(string str) {
  int i, j, cols;
  string obvarname, start, end;
  mixed *names, *objects;

  if (str) {
    if (sscanf(str, "%s=%s", obvarname, str) != 2)
      return notify_fail("USAGE: object ObVarName=ObjectSpec\n");
    notify_fail("Can't find object.\n");
    objects = WIZ_PRESENT->wiz_present(str, this_player());
    if (!sizeof(objects))
      return 0;
    if (sizeof(objects) > 1) 
      write("Only using first object of several matched.\n");
    this_player()->set_obvar(obvarname, objects[0]);
    write("Var "+obvarname+" now attached to "+
        WIZ_PRESENT->desc_object(objects[0])+".\n");
    return 1;
  }
  objects = m_values((mapping)this_player()->get_obvars());
  names = m_indices((mapping)this_player()->get_obvars());
  j = sizeof(objects);
  cols = this_player()->query_cols();
  for (i=0; i<sizeof(objects); i++) {
    if (!objects[i]) {
      j--;
      this_player()->del_obvar(names[i]);
      break;
    }
    if (objectp(names[i]))
      start = WIZ_PRESENT->desc_object(names[i]);
    else
      start = sprintf("%O", names[i]);
    if (objectp(objects[i]))
      end = WIZ_PRESENT->desc_object(objects[i]);
    else {
/* Need to do something cunning... */
      end = sprintf("%O", objects[i]);
      end = replace(end, "\n", "");
    }
    printf("%s; %*-=s\n", start, cols-strlen(start)-2, end);
  }

  if (!j) write("No obvars set.\n");
  return 1;

}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/ob_ject.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/random_name.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/random_name.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626922   Available: 13574276
Inodes: Total: 5242880    Free: 4960132
1430 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/random_name.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626922   Available: 13574276
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: random_name.c,v 1.2 2000/10/20 18:45:32 pinkfish Exp $
 * $Log: random_name.c,v $
 * Revision 1.2  2000/10/20 18:45:32  pinkfish
 * Add in a method to generate names from test languages.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <random_names.h>
inherit "/cmds/base";

string lang_list;

void create() {
  lang_list = implode(RANDOM_NAME_GENERATOR->query_languages() +
                      RANDOM_NAME_GENERATOR->query_test_languages(), "|");
} /* create() */

mixed cmd(string pattern, string my_lang) {
  string *langs;
  int i;

  if (pattern == "") {
    write("Generating one word from each language.  To generate more "
          "words in a particular language, specify the language on the "
          "command line.\n");
    langs = (string *)RANDOM_NAME_GENERATOR->query_languages() +
            RANDOM_NAME_GENERATOR->query_test_languages();
    for (i=0;i<sizeof(langs);i++) {
      write(capitalize(langs[i])+": "+
            (string)RANDOM_NAME_GENERATOR->random_name(langs[i])+"\n");
    }
    return 1;
  }
  write("Generateing 10 names in "+my_lang+"\n\n");
  for (i=0;i<10;i++) {
    write( (string)RANDOM_NAME_GENERATOR->random_name(my_lang)+"\n");
  }
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "", (: cmd($5, "") :),
            "{"+lang_list+"}", (: cmd($5, $4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/random_name.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/denied.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/denied.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626921   Available: 13574275
Inodes: Total: 5242880    Free: 4960132
848 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/denied.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626921   Available: 13574275
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
int db;

int cmd(string who){
  mixed rows;
  string ret;
  db = db_connect("localhost", "errors");
  if(who == "all")
    rows = db_exec(db, "select Reporter, count(*) as bing from errors "
		   "where Status = 'DENIED' "
                   "group by Reporter order by bing desc");
  else
    rows = db_exec(db, sprintf("select Reporter, count(*) from errors "
                               "where Reporter = '%s' and Status = 'DENIED' "
			       "group by Reporter", 
                               who));
  if(intp(rows)){
    ret = sprintf("%-15s %s\n", "player", "reports");
    ret += implode(allocate(rows, function(int i){
      mixed *tmp = db_fetch(db, i+1);
      return sprintf("%-15s %s", tmp[0], ""+tmp[1]);
    }), "\n");
    ret += "\n";
    db_close(db);
    this_player()->more_string(ret);
  } else printf(rows);
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/denied.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/addalt.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/addalt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626921   Available: 13574275
Inodes: Total: 5242880    Free: 4960132
630 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/addalt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626921   Available: 13574275
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Addalt - adds a record about a player's alt character.
 * @author Fiona
 */
#include <creator.h>
#include <playerinfo.h>

inherit "/cmds/base";

// Command entry point
int add_alt(string s1, string s2) {
  string *alts, alt;

  s1 = this_player()->expand_nickname(lower_case(s1));
  alts = explode(lower_case(s2)," ") - ({ "" }) - ({ 0 });

  foreach(alt in alts)
    write(PLAYERINFO_HANDLER->add_alt(this_player(), s1, alt));

  return 1;
}

// Answer the command patterns
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <string'alt-name alt-name ...'>",
        (: add_alt($4[0],$4[1]) :)
    });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/addalt.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/sh_adows.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/sh_adows.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626920   Available: 13574274
Inodes: Total: 5242880    Free: 4960132
1240 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/sh_adows.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626920   Available: 13574274
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sh_adows.c,v 1.2 2001/12/28 10:12:58 taffyd Exp $
 * $Log: sh_adows.c,v $
 * Revision 1.2  2001/12/28 10:12:58  taffyd
 * Changed to use query_patterns() and /cmds/base instead of old method.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* shadows command, trial out by Turrican for a commands daemon. */

#include <creator.h>

inherit "/cmds/base";

int cmd(object *indirect_obs) {
  object *objs, *shadows, ob, shad, nobj;

/*
  if (!s || s == "") s = "me";
  objs = WIZ_PRESENT->wiz_present(s, this_player());
  if (sizeof(objs) == 0) {
    notify_fail("Can't find object.\n");
    return 0;
  }
*/
   objs = indirect_obs;

  foreach (ob in objs) {
    shadows = ({ });
     nobj = ob;
     while(nobj = shadow(nobj, 0))
       shadows += ({ nobj });
     if(!sizeof(shadows)) {
       write(WIZ_PRESENT->desc_f_object(ob) + " is not being shadowed.\n");
     } else {
       write(WIZ_PRESENT->desc_f_object(ob) + " is being shadowed by:\n");
       foreach (shad in shadows)
         write("    " + file_name(shad) + "\n");
    }
  }
  return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd( $1 ) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/sh_adows.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ungag.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ungag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626920   Available: 13574274
Inodes: Total: 5242880    Free: 4960132
1188 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ungag.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626920   Available: 13574274
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Gagger object originally coded by Obilix 9 April 1997.
 * Turned into gag and ungag commands by Gruper 20 March 2000.
 */

#include <playerinfo.h>

inherit "/cmds/base";


int cmd( object victim ) {

   // Ungag them and log it
   if( !victim->query_property( "gagged" ) )
      return notify_fail( victim->query_short() +" is not gagged.\n" );
   
   victim->remove_property("gagged");
   log_file("GAG", ctime(time()) + ": " + this_player()->
         query_short() + " ungagged " + victim->query_short() + ".\n");
   //PLAYERINFO_HANDLER->add_entry( this_player(), victim->query_name(),
   //      "gag", "Ungagged." );

   // Messages...
   tell_object( victim, this_player()->query_short() + " ungags you.\n"
                        "%^YELLOW%^Be more careful with what you say "
                        "in future.%^RESET%^\n" );

   write( "Okay, ungagged " + victim->query_short() + ".\n" );

//   event( users(), "inform", this_player()->query_short()
//          + " ungagged " + victim->query_short(), "gag");

   return 1;

} // cmd()


mixed *query_patterns() {
   return ({ "<indirect:player'player'>",
                (: cmd( $1[0] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/ungag.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/show_help.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/show_help.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626919   Available: 13574273
Inodes: Total: 5242880    Free: 4960132
1823 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/show_help.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626919   Available: 13574273
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: show_help.c,v 1.2 1999/05/05 20:06:36 pinkfish Exp $
 * $Log: show_help.c,v $
 * Revision 1.2  1999/05/05 20:06:36  pinkfish
 * Make it add an playerinfo thingy automaticly.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* showhelp command, trial out by Turrican for a commands daemon. */
#include <playerinfo.h>
inherit "/cmds/base";

#define WHO(n) globals[n]

private nosave mapping globals = ([]);

mixed show_help(object *player, string helpname) {
   player[0]->set_finish_func("who_did_it", this_object());
   WHO(player[0]) = capitalize(this_player()->query_name());
   if (!player[0]->eventForce("help "+ helpname)) {
      map_delete(globals, player[0]);
      return notify_fail("The help command failed ... Did you specify the "
              "correct help subject ?\n");
   }
   event(users(), "inform", capitalize(this_player()->query_name())+
         " showed help on \"" + helpname + "\" to " + player[0]->the_short(),
         "help");
   write("Okay, showed help on \"" + helpname + "\" to " +
         player[0]->query_cap_name() + ".\n");
   PLAYERINFO_HANDLER->add_entry(this_player(),
                                 player[0]->query_name(),
                                 "showhelp",
                                 "Showed help on " + helpname,
                                 0);
   return 1;
} /* cmd() */

int who_did_it() {
   /* previous_object() is the player, I think :-) */
   tell_object(previous_object(), WHO(previous_object()) +
         " wanted you to read this help file.\n");
   map_delete(globals, previous_object());
   return 1;
} /* who_did_it() */

mixed *query_patterns() {
   return ({ "<indirect:player> <string'help file'>",
             (: show_help($1, $4[1]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/show_help.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/tasks.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/tasks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626919   Available: 13574273
Inodes: Total: 5242880    Free: 4960132
3962 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/tasks.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626919   Available: 13574273
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: tasks.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: tasks.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <skills.h>

#define SAVE_FILES "/save/tasks/"

inherit "/cmds/base";

mapping awards;

void create() { seteuid( "Root" ); }

void main_menu( string word ) {
   int i, j, *numbers;
   string text, *words;
   if ( !word || ( word == "" ) )
      word = " ";
   switch ( word[ 0 ] ) {
      case 'Q' :
      case 'q' :
         return;
      case 'L' :
      case 'l' :
         words = get_dir( SAVE_FILES +"*.o" );
         if ( !sizeof( words ) ) {
            printf( "No tasks have been logged.\n" );
            return;
         }
         for ( i = sizeof( words ) - 1; i > -1; i-- ) {
            words[ i ] = words[ i ][ 0 .. strlen( words[ i ] ) - 3 ];
            if ( sizeof( (string *)SKILL_OB->
                  query_immediate_children( words[ i ] ) ) )
               words[ i ] += sprintf( "%*s", 60 - strlen( words[ i ] ),
                     "[non-primary]" );
         }
         this_player()->set_finish_func( "main_menu", this_object() );
         this_player()->more_string( "Skills with logged tasks are:\n   "+
               implode( words, "\n   " ) +"\n", "Tasks", 1 );
         return;
      case 'C' :
      case 'c' :
         if ( strlen( word ) < 4 ) {
            printf( "Syntax: C <skill>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( file_size( SAVE_FILES + word +".o" ) < 1 ) {
            printf( "There are no tasks logged for "+ word +".\n" );
            break;
         }
         unguarded( (: restore_object, SAVE_FILES + word :) );
         numbers = allocate( 5 );
         text = "Skill awards made for "+ word +":\n";
         foreach ( i in sort_array( keys( awards ), 1 ) ) {
            j = 0;
            foreach ( word in keys( awards[ i ] ) )
               j += awards[ i ][ word ];
            text += sprintf( "   level%5d awarded by%5d tasks\n", i, j );
            if ( i < 301 )
               switch ( j ) {
                  case 1 .. 4 :
                     numbers[ 0 ]++;
                     break;
                  case 5 .. 9 :
                     numbers[ 1 ]++;
                     break;
                  case 10 .. 19 :
                     numbers[ 2 ]++;
                     break;
                  case 20 .. 49 :
                     numbers[ 3 ]++;
                     break;
                  default :
                     numbers[ 4 ]++;
               }
         }
         text += sprintf( "Coverage at the  1 task level is%4d%%.\n",
               ( numbers[ 0 ] + numbers[ 1 ] + numbers[ 2 ] +
               numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the  5 task level is%4d%%.\n",
               ( numbers[ 1 ] + numbers[ 2 ] + numbers[ 3 ] +
               numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 10 task level is%4d%%.\n",
               ( numbers[ 2 ] + numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 20 task level is%4d%%.\n",
               ( numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 50 task level is%4d%%.\n",
               numbers[ 4 ] / 3 );
         this_player()->set_finish_func( "main_menu", this_object() );
         this_player()->more_string( text, "Tasks", 1 );
         return;
      case 'H' :
      case 'h' :
         printf( "\nTasks editor commands:\n\n"+
               "Q         : quit the quest editor\n"+
               "L         : list tasked skills\n"+
               "C <skill> : examine coverage for <skill>\n"+
               "H         : get this list of commands\n\n" );
         break;
      default :
   }
   printf( "Choose one of Q, L, C or H (for help) : " );
   input_to( "main_menu" );
} /* main_menu() */

int cmd() {
   main_menu( "L" );
   return 1;
} /* cmd() */
// --- END [/mnt/home2/grok/lib/cmds/creator/tasks.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/pe_ople.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/pe_ople.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626918   Available: 13574272
Inodes: Total: 5242880    Free: 4960132
2179 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/pe_ople.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626918   Available: 13574272
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: pe_ople.c,v 1.3 2001/05/02 03:39:24 ceres Exp $
 * $Log: pe_ople.c,v $
 * Revision 1.3  2001/05/02 03:39:24  ceres
 * Added domain sort
 *
 * Revision 1.2  1999/10/28 02:35:38  ceres
 * added more options
 * .my
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* people command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";
#include <creator.h>
#include <peopler.h>

int num_sort(object first, object second) {
  int one, two;

  one = first->query_level();
  two = second->query_level();

  //  reset_eval_cost();
  if(one < two)
    return 1;
  if(one > two)
    return -1;
  return 0;
}

int guild_sort(object first, object second) {
  object g1, g2;

  g1 = first->query_guild_ob();
  g2 = second->query_guild_ob();
  
  return strcmp(g1 ? g1->query_name() : "",
                g2 ? g2->query_name() : "");
}

int domain_sort(object first, object second) {
  object d1, d2;

  d1 = environment(first);
  d2 = environment(second);
  
  return strcmp(d1 ? file_name(d1) : "", d2 ? file_name(d2) : "");
}

int age_sort(object first, object second) {
  int one, two;

  one = first->query_time_on();
  two = second->query_time_on();

  if(one < two)
    return -1;
  if(one > two)
    return 1;
  return 0;
}

mixed cmd(string str) {
  mixed *stuff;
  string bit, *bits;
  function sort_func;
  
  stuff = this_player()->query_property("people list");
  if (!stuff)
    stuff = P_DEFAULT;

  if(str) {
    bits = explode(str, " ");
    str = 0;
    foreach(bit in bits) {
      switch(bit) {
      case "-l":
        sort_func = (: num_sort :);
        break;
      case "-g":
        sort_func = (: guild_sort :);
        break;
      case "-a":
        sort_func = (: age_sort :);
        break;
      case "-d":
        sort_func = (: domain_sort :);
        break;
      default:
        if(str)
          str += " " + bit;
        else
          str = bit;
      }
    }
  }
  return (int)PEOPLER->do_command(stuff, str, sort_func);
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/pe_ople.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/crea_tor.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/crea_tor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626917   Available: 13574271
Inodes: Total: 5242880    Free: 4960132
773 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/crea_tor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626917   Available: 13574271
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: crea_tor.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: crea_tor.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* creator command, trial out by Turrican for a commands daemon. */

#include <creator.h>

mixed cmd(string str) {
  object *ov, ob;
 
  notify_fail("Creator of what?\n");
  ov = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ov)) return 0;

  foreach (ob in ov) {
    write("Creator of " + WIZ_PRESENT->desc_object(ob) + ": " +
        master()->creator_file (file_name(ob)) + ", uid: " +
        getuid(ob) + ", euid: "+geteuid(ob)+"\n");
  }
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/crea_tor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/mem_stat.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/mem_stat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626917   Available: 13574271
Inodes: Total: 5242880    Free: 4960132
3191 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/mem_stat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626917   Available: 13574271
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mem_stat.c,v 1.3 2003/03/11 22:48:10 wodan Exp $
 * $Log: mem_stat.c,v $
 * Revision 1.3  2003/03/11 22:48:10  wodan
 * reactivated.
 *
 * Revision 1.2  2002/02/24 06:24:47  taffyd
 * Disabled command
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <creator.h>

#define OBJ_LIMIT 50
#define TP this_player()

inherit "/cmds/base";

string help();

mixed cmd(string str) {
  int memtotal, limit, i = TP->query_cols() -7 -1, j;
  string ret, str2, str3;
   object *objlist;


  if (!str || str == "")
    return notify_fail(help());

  // Remove excess whitespace
  while (strlen(str) && str[0] == ' ')
    str = str[1..];

  if (sscanf(str, "-%s%d %s", str3, limit, str2) == 3) {
    if (str3[0..0] != "l")
      return notify_fail("Error: Only valid character following '-' is 'l' at "
                         "this time.\n");
    str = str2;
  }

  seteuid(geteuid(TP));
  // Get the list of corresponding objects
  objlist = WIZ_PRESENT->wiz_present(str, TP);

  if (!arrayp(objlist) || sizeof(objlist) < 1) {
    mixed *filelist;

    str = TP->get_path(str);

    notify_fail("Unable to find any objects or files corresponding"
                " to the given name.\n");

    if (sizeof(filelist = TP->get_files(str)) > 0) {
      filelist = filter(filelist, (: (sizeof($1) > 2) &&
                                   ($1[sizeof($1) - 2..] == ".c") :));

      if (sizeof(filelist) < 1)
        return 0;

      filelist = filter(filelist, (: find_object($1) :));
      objlist = map(filelist, (: find_object($1) :));
    } else
      return 0;
  }

  ret = sprintf("%-"+ i +"s %-7s\n", "Object name", "Memory");
  ret += sprintf("%-"+ i +"s %-7s\n", "------------", "-------");

  if (!limit)
    limit = OBJ_LIMIT;
  
  if (limit > sizeof(objlist))
    limit = sizeof(objlist);

  if (limit == 1)
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   WIZ_PRESENT->desc_f_object(objlist[sizeof(objlist) - 1]),
                   memory_info(objlist[sizeof(objlist) - 1]));
  else
    for (j = 0; j < limit; j++)
      ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                     WIZ_PRESENT->desc_f_object(objlist[j]),
                     memory_info(objlist[j]));

  if (sizeof(objlist) > 1) {
    for (j = 0; j < sizeof(objlist); j++)
      memtotal += memory_info(objlist[j]);

    ret += sprintf("%-"+ i +"."+ i +"s %7.7s\n",
                   "", "=======");
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   "Total memory used for all "+ sizeof(objlist) +
                   " object(s):", memtotal);
  }
  TP->more_string(ret);
  return 1;
}

string help() {
  return "Usage: memstat [-l<number>] [<filename(s)>|<wiz_present syntax>]\n\n"
"Memstat lists the guestimated amount of memory the specified object(s) use. "
"Using the -l option, a maximum amount of objects to be listed may be "
"specified otherwise a default limit of "+ OBJ_LIMIT +" objects are listed. "
"Paths including wildcards are taken as a way of specifying more than one "
"file.\n";
}

mixed *query_patterns() { 
    return ({ "<string>", (: cmd( $4[0] ) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/mem_stat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/snoope_rs.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/snoope_rs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626916   Available: 13574270
Inodes: Total: 5242880    Free: 4960132
900 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/snoope_rs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626916   Available: 13574270
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: snoope_rs.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: snoope_rs.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* snoopers command, trial out by Turrican for a commands daemon. */

#include <creator.h>

mixed cmd(string str) {
  object *obs;
  int i;

  obs = (object *)PEOPLER->get_people(str);
  obs = filter_array(obs, "check_snoop", this_object());
  if (!sizeof(obs)) {
    notify_fail("No one is being snooped by anyone.\n");
    return 0;
  }
  for (i=0;i<sizeof(obs);i++)
    write(obs[i]->query_cap_name()+" is snooping "+
          obs[i]->query_snoopee()->query_cap_name()+".\n");
  return 1;
}

int check_snoop(object ob) {
  if((object)ob->query_snoopee())
    return 1;
  else
    return 0;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/snoope_rs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/whe_reis.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/whe_reis.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626915   Available: 13574269
Inodes: Total: 5242880    Free: 4960132
1560 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/whe_reis.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626915   Available: 13574269
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: whe_reis.c,v 1.3 2001/03/10 06:15:38 shrike Exp $
 * $Log: whe_reis.c,v $
 * Revision 1.3  2001/03/10 06:15:38  shrike
 * fixing a long-standing (query_terano()?"design flaw":"bug") with the way objects in null-space are handled.
 *
 * Revision 1.2  2000/04/03 13:39:40  taffyd
 * Tried to fix a lord invis bug..
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 *
*/
/* whereis command, trial out by Turrican for a commands daemon. */

#include <creator.h>


inherit "/cmds/base";

int cmd( object *indirect_obs ) {
    object ob, e;
    int described;
    string txt;

    if ( !sizeof( indirect_obs ) ) {
        add_failed_mess( "Where is what?\n" );
        return 0;
    }

    txt = "$P$Whereis$P$";

    foreach ( ob in indirect_obs ) {
        if ( ob->query_hidden() )
            continue;

        described = 0;
        e = ob;

        while ( e = environment( e ) ) {
            if ( interactive( e ) && !reference_allowed( e, this_player() ) )
                break;

            if ( !described ) {
                txt += WIZ_PRESENT->desc_object(ob) + " is : \n";
                described = 1;
            }

            txt += "  in " + WIZ_PRESENT->desc_f_object(e) + "\n";
        }
        if ( !described )
            txt += WIZ_PRESENT->desc_object(ob) + " is in Null-space.\n";
    }

    tell_object( this_player(), txt + "\n" );
    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd($1) :) });
} /* query_patterns() */// --- END [/mnt/home2/grok/lib/cmds/creator/whe_reis.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ptguilds.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ptguilds.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626915   Available: 13574269
Inodes: Total: 5242880    Free: 4960132
1071 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ptguilds.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626915   Available: 13574269
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * PTGuilds command
 * @author Taffyd
 */

#include <player.h>

/** @ignore yes */
string format_guild_list( string guild_path, string *members ) {
    return "Members of the " + (guild_path->query_short() 
      ? guild_path->query_short() : "Misc.") + ": " + 
        query_multiple_short( sort_array( map( members, 
           (: capitalize( $1 ) :) ), 1 ) ) + ".";
} /* format_guild_list() */

/** @ignore yes */
int cmd( string guild ) {
    mapping data;
    string txt;
    string *members;
   
    data = PLAYTESTER_HAND->query_playtester_guilds();
    txt = "Playtester listing by Guild\n\n";
   
    if ( guild && ( members = data[ guild ] ) ) {
        txt = format_guild_list( guild, members );
    }
    else {
        txt += implode( values( map( data, 
            (: format_guild_list( $1, $2 ) :) ) ), "\n\n" );
    }

    tell_object( this_player(), txt + "\n" );
    return 1;
} /* cmd() */

/** @ignore yes */
mixed *query_patterns() {
    return ({ "", (: cmd(0) :),
              "<string'guild'>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/ptguilds.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/meteor.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/meteor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626914   Available: 13574268
Inodes: Total: 5242880    Free: 4960132
2465 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/meteor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626914   Available: 13574268
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: meteor.c,v 1.4 1999/10/03 20:06:10 taffyd Exp $
 * $Log: meteor.c,v $
 * Revision 1.4  1999/10/03 20:06:10  taffyd
 * Fixed bugge with gender
 *
 * Revision 1.3  1998/11/17 03:59:27  pinkfish
 * Changes to work with the new player info stuff.
 *
 * Revision 1.2  1998/11/01 11:51:03  pinkfish
 * Add in fiona's meteor stuff.
 * I mean player info stuff.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <playerinfo.h>
inherit "/cmds/base";

mixed cmd(string words) {
  string player, reason;
  object ob;

  if(this_player()->query_name() == "macchirton") {
    return notify_fail("You cannot use meteor.\n");
  }
   
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: meteor <player> <reason>\n");
  }
  ob = find_player(this_player()->expand_nickname(player));
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y|n): ");
  input_to("are_sure", ob, reason);
  return 1;
} /* cmd() */

void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("Good little "+gender+"!  Now go play nice with "
      +ob->one_short()+".\n");
    return;
  }
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("NUKE", "%s: %s nuked %s: %s\n", ctime(time()), 
    this_player()->query_short(), ob->query_short(), reason);
  shout("You see a very large %^YELLOW%^meteor%^RESET%^ up in the sky.\n");
  write("Nuking player "+ob->query_name()+".\n");
  call_out("nuke2", 2, ob);
} /* are_sure() */

void nuke2(object ob) {
  shout("The %^YELLOW%^meteor%^RESET%^ rushes towards the ground.\n");
  tell_object(ob, "It looks like it's heading for you.\n");
  call_out("nuke3", 5, ob);
} /* nuke2() */

void nuke3(object ob) {
  tell_object(ob, "The %^YELLOW%^meteor%^RESET%^ hits you ......"+
    "%^RED%^WALLOP.%^RESET%^\n");
  shout(ob->query_cap_name()+" has been struck by a meteor.\n"+
        capitalize(ob->query_pronoun())+" is no more.\n");
  ob->save();
  ob->quit();
} /* nuke3() */

// --- END [/mnt/home2/grok/lib/cmds/creator/meteor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/iloc_ate.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/iloc_ate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626913   Available: 13574267
Inodes: Total: 5242880    Free: 4960132
598 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/iloc_ate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626913   Available: 13574267
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: iloc_ate.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: iloc_ate.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* locate command, trial out by Turrican for a commands daemon. */

#include <network.h>

mixed cmd(string who) {
  if (!who) {
    notify_fail("Syntax: locate <name>\n");
    return 0;
  }
  SERVICES_D->eventSendLocateRequest(who);
  printf("Locating %s. Don't explode !\n", who);
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/iloc_ate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/hliaison.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/hliaison.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626913   Available: 13574267
Inodes: Total: 5242880    Free: 4960132
1393 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/hliaison.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626913   Available: 13574267
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: hliaison.c,v 1.1 2001/01/18 01:49:16 pinkfish Exp $
 * $Log: hliaison.c,v $
 * Revision 1.1  2001/01/18 01:49:16  pinkfish
 * Initial revision
 *
 * Revision 1.2  2001/01/18 01:35:17  pinkfish
 * Fix up the code.
 *
 * Revision 1.1   1998/01/06 05:25:41   ceres
 * Initial revision
 * 
*/
/* hcre command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <broadcaster.h>

mixed cmd(string) {
   int i;
   mixed *hist;

   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("liaison");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the liaison channel.\n");
   }
   write("The liaison channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(), 
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0], 
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(), 
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/hliaison.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/cst_at.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/cst_at.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626912   Available: 13574266
Inodes: Total: 5242880    Free: 4960132
1616 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/cst_at.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626912   Available: 13574266
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cst_at.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: cst_at.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* stats command, trial out by Turrican for a commands daemon. -*- LPC -*- */

#include <creator.h>

mixed cmd(string str) {
  object *ob, thing;
  mixed *ob1, *thing1;
  string s, bing;
  string long_fields, temp;   /* added by ember to produce long and short fields */
  int long_length;  /* fields are divided into long and short fields by this */

  bing = "";
  str = (string)this_player()->expand_nickname(str);
  ob = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ob)) {
    write("No such object.\n");
    return 1;
  }
  foreach (thing in ob) {
    ob1 = (mixed *)thing->stats();
    if (!pointerp(ob1))
      continue;
    s = "";
    long_fields = "";
    long_length = ( (int)this_player()->query_cols() / 3 ) - 1;
    foreach (thing1 in (pointerp(ob1[0][0])?ob1[0]:ob1))
      if ( thing1[ 1 ] && !sscanf(thing1[0],"(%s)",temp)) {
        temp = thing1[0] +": "+ thing1[ 1 ] +"\n";
/* this test will incorrectly assess some fields which have line feeds in
 * them as 'long fields', but who really cares? */
        if (strlen(temp) > long_length) long_fields += temp;
        else s += temp;
      }
    bing += sprintf("%-*#s\n", this_player()->query_cols(), long_fields) +
        sprintf( "%-*#s\n", this_player()->query_cols(), s );
  }
  this_player()->more_string(bing);
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/cst_at.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/host.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/host.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626912   Available: 13574266
Inodes: Total: 5242880    Free: 4960132
1240 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/host.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626912   Available: 13574266
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */

/*
** The equivalent of the nslookup or host commands in unix.
** -- Arienne, 10/Mar/2001
*/

inherit "/cmds/base";

mapping lookups = ([]);

int cmd( string w ) {
    string ip = lower_case( this_player()->expand_nickname( w ) );
    string ip2;
    
    if ( find_player( ip ) ) {
        ip2 = query_ip_number( find_player( ip ) );
        lookups[ resolve( ip2, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip +
                     " (" + ip2 + ").\n" );
    } else {
        lookups[ resolve( ip, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip + ".\n" );
    }
    
    return 1;

} // cmd()

void lookup_callback( string address, string resolved, int key ) {
    if ( lookups[ key ] ) {
        tell_object( lookups[ key ], "Resolved " +
                     ( address ? address : "?unknown" ) +
                     " to " +
                     ( resolved ? resolved : "?unknown" ) + ".\n" );
    }
    map_delete( lookups, key );
} // lookup_callback


mixed *query_patterns() {
   return ({ "<string'ip-address, host or player'>",
                 (: cmd( $4[0] ) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/host.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/debug.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/debug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626911   Available: 13574265
Inodes: Total: 5242880    Free: 4960132
460 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/debug.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626911   Available: 13574265
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

#include <creator.h>
 
/**
 * This dumps out stuff about the object.
 */
int cmd(object *obs, int detail) {
   object ob;
 
   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(detail, ob) + "\n");
   }
   return 1;
} /* cmd() */
 
mixed *query_patterns() {
  return ({ "-v <indirect:wiz-present>", (: cmd($1, 2) :),
              "<indirect:wiz-present>", (: cmd($1, 1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/debug.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/inh_eritance.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/inh_eritance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626911   Available: 13574265
Inodes: Total: 5242880    Free: 4960132
3253 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/inh_eritance.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626911   Available: 13574265
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: inh_eritance.c,v 1.3 2002/11/09 02:41:00 ceres Exp $
 * $Log: inh_eritance.c,v $
 * Revision 1.3  2002/11/09 02:41:00  ceres
 * Fixed error if part isn't loaded
 *
 * Revision 1.2  2001/10/23 18:04:23  taffyd
 * Updated to use wiz-present to make it easier to find out the inheritance of objects. ie: inh tree in taffyd
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <creator.h>

inherit "/cmds/base";

private string inherith(string ob, string ind, string leaf);

private int cmd(string fn, string fn2) {
    object ob, ob2;

    // notify_fail("Syntax: inh[eritance] <filename> [<filename>]\n");

    // I'd like to use WIZ_PRESENT here, but I'm not sure how to handle
    // the optional filename at the end.

    fn = this_player()->get_path( fn ); 

    if (!( ob = find_object( fn ))) {
        add_failed_mess( "No such object: " + fn + "\n" );
        return 0;
    }

    if ( fn2 ) { 
        fn2 = this_player()->get_path( fn2 ); 

        if (!( ob2 = find_object( fn2 ))) {
            add_failed_mess( "No such object: " + fn2 + "\n" );
            return 0;
        }
    }

    fn = file_name(ob);
    write(fn + "\n" + inherith(fn, "  ", fn2 ));
    return 1;
} /* cmd() */ 

/* Print inherit hierarchy */
private string inherith(string ob, string ind, string leaf) {
    string *fn, rtn = "", s;
    int i;

    if(!load_object(ob))
      return ind + "unable to find " + ob + "\n";
    fn = inherit_list(find_object(ob));
    for (i = 0; i < sizeof(fn); i++) {
        //write("*Scanning " + fn[i] + "\n");
        if (leaf && (find_object(fn[i]) == find_object(leaf))) {
            //write("**Leaf match\n");
            rtn += ind + fn[i] + "\n";
        } else {
            //write("**No leaf match\n");
            s = inherith(fn[i], ind + "  ", leaf);
            if (!leaf || (s != "")) {
                //write("***Good branch\n");
                rtn += ind + fn[i] + "\n" + s;
            }
        }
    }
    return rtn;
} /* inherith() */ 

// Experimental wiz present interface to this command. 
// Argle.
//
// x0r
int wiz_present_cmd( mixed indirect_obs ) { 
    object fo, fo2; 
    string fn, fn2; 
    if ( !arrayp( indirect_obs ) ) {
        return 0;
    }

    if ( sizeof( indirect_obs ) < 1 ) { 
        return 0;
    }

    if ( arrayp( indirect_obs[0] ) ) { 
        fo = indirect_obs[0][0];

        if ( sizeof( indirect_obs ) == 2 ) {
            fo2 = indirect_obs[ 1 ][ 0 ]; 
        }
    }
    else {
        fo = indirect_obs[ 0 ];

        if ( sizeof( indirect_obs ) == 2 ) { 
            fo2 = indirect_obs[ 1 ]; 
        }
    }

    if ( fo ) {
        fn = file_name( fo );
    }

    if ( fo2 ) {
        fn2 = file_name( fo2 );
    }

    debug_printf( "%O, %O\n", fn, fn2 );

    return cmd( fn, fn2 ); 
} /* wiz_present_cmd() */ 

public mixed *query_patterns() { 
    return ({ 
              "<word> [with] <word>", (: cmd( $4[0], $4[1] ) :),              
              "<word>", (: cmd( $4[0], 0 ) :),
              "<indirect:wiz-present> with <indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
              "<indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
    });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/inh_eritance.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/sql.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/sql.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626910   Available: 13574264
Inodes: Total: 5242880    Free: 4960132
3533 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/sql.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626910   Available: 13574264
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * sql interface command
 * @author Wodan
 */
#include <config.h>
#include <db.h>

inherit "/cmds/base";

private mapping fd = ([]), com = ([]);
#define FD fd[this_player()]
#define COM com[this_player()]

void prompt(string db, string user, string pass, object player){
   if(!strlen(COM)) {
      tell_object(player, "sql> ");
   } else {
      tell_object(player, "  -> ");
   }
   input_to("main", 0, db, user, pass);
}

int cmd(string arg, string user, string passwd){
   string err;

   if(!passwd){
      passwd = "";
   }
   if(!user){
      user = CONFIG_DB_USER;
   }

   if (stringp(err)){
      return notify_fail(err);
   }
  
   write("Welcome to the " + mud_name() + " SQL monitor.  Commands end with ; .\n\nType 'help' for help."
        "\n\n");
   COM = "";
   prompt(arg, user, passwd, this_player());
   return 1;
}

void finish_query(int result, mixed params, string db, string user,
                  string passwd, object player) {
   mapping row;
   string *keys;
   string key;
   if (result != DB_SUCCESS) {
      tell_object(player, "Failed: " + params + ".\n");
      return ;
   }
   foreach (row in params) {
      if (!keys) {
         keys = keys(row);
         foreach (key in keys) {
            tell_object(player, key + "   ");
         }
      }
      foreach (key in keys) {
         tell_object(player, row[key] + "   ");
      }
      tell_object(player, "\n");
   }
   prompt(db, user, passwd, player);
} /* finish_quer() */

void main(string input, string db, string user, string passwd){
   if(strlen(input)) {
      while(input[<1] == ' ') {
         input = input[0..<2];
      }
      while(input[0] == ' ') {
         input = input[1..];
      }
   }

  switch(input){
  case "clear":
    COM = "";
    return prompt(db, user, passwd, this_player());
  case "edit":
    this_player()->do_edit(COM, "edfin", this_object(), 0, ({ db, user, passwd }));
    return;
  case "quit":
    printf("Use 'exit' to quit.\n");
    return prompt(db, user, passwd, this_player());
  case "exit":
    //db_close(FD);
    map_delete(fd, this_player());
    map_delete(com, this_player());
    return;
  case "help":
    printf(@END
'help' prints this help.
'clear' clears the command you are working on.
'edit' enters the editor so you can edit your query.
'exit' quits sql.
END);
    return prompt(db, user, passwd, this_player());
  default:
    if(strlen(input) && input[<1] == ';'){

      COM += input[0..<2] + "\n";
      //
      // Do the request.
      //
      DB_HANDLER->make_sql_request(db, user, passwd, input,
                                  (: finish_query($1, $2, $(db), $(user), $(passwd), $(this_player())) :));
      input_to("main", db, user, passwd);
      COM="";
     tell_creator ("drakkos", "Bing %s.\n", input);
      return ;
/*
      if(stringp(rows)){
        printf("%s\n", rows);
        return prompt(db, user, passwd);
      }
      for(i = 0; i <= rows; i++){
        printf("%s\n", implode(db_fetch(FD, i), (:$1 + " " + $2:), ""));
      }
 */
    } else {
      COM += input + "\n";
    }
    prompt(db, user, passwd, this_player());
  }
}

void edfin(string input, string* args){
  COM=input;
  prompt(args[0], args[1], args[2], this_player());
}

mixed *query_patterns() { 
   return ({ "<word'database'>", (:cmd($4[0], CONFIG_DB_USER, 0) :),   
            "<word'database'> -u <word'user'>", (:cmd($4[0], $4[1], 0):),
            "<word'database'> -u <word'user'> -p <word'password'>",
                                    (:cmd($4[0], $4[1], $4[2]):)});
}
// --- END [/mnt/home2/grok/lib/cmds/creator/sql.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/rmd_ir.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/rmd_ir.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626909   Available: 13574263
Inodes: Total: 5242880    Free: 4960132
1184 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/rmd_ir.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626909   Available: 13574263
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rmd_ir.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: rmd_ir.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* rmdir command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
   string *filenames;
   int fsize, loop;
 
   seteuid(geteuid(this_player()));
   if (!str || str == "") {
      notify_fail("Remove what dir?\n");
      return 0;
   }
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail("No such directory : " + str + "\n");
      return 0;
   }
 
   for(loop = 0; loop < sizeof(filenames); loop++) {
      str = filenames[loop];
      fsize = file_size(str);
      if (fsize == -1) {
         notify_fail(str + " doesn't exist.\n");
         return 0;
      }
      if (fsize != -2) {
         notify_fail(str + " is not a directory.\n");
         return 0;
      }
      if (!rmdir(str)) {
         notify_fail("Couldn't remove dir : " + str + "\n");
         return 0;
      }
   }
   write("Ok.\n");
   return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/rmd_ir.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/autodocadd.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/autodocadd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626909   Available: 13574263
Inodes: Total: 5242880    Free: 4960132
848 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/autodocadd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626909   Available: 13574263
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: autodocadd.c,v 1.1 1998/03/06 11:32:32 pinkfish Exp $
 * $Log: autodocadd.c,v $
 * Revision 1.1  1998/03/06 11:32:32  pinkfish
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#include <autodoc.h>

int cmd(string str) {
   string *files;
   string file;

   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->add_file(file)) {
         write("Added file " + file + ".\n");
      } else {
         write("Unable to add file " + file + ".\n");
      }
   }
   return 1;
} /* cmd() */

mixed *query_patterns() { 
   return ({ "<string>", (: cmd($4[0]) :) });
 } /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/autodocadd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/dbxwhere.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/dbxwhere.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626908   Available: 13574262
Inodes: Total: 5242880    Free: 4960132
629 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/dbxwhere.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626908   Available: 13574262
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dbxwhere.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: dbxwhere.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* Beek - 10/4/94 */

inherit "/cmds/base";

mixed cmd(string str) {
  mapping error;
  object ob;

  if (str) {
    str = this_player()->expand_nickname(str);
    ob = find_player(str);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  } else
    ob = this_player();
  if (error = (mapping)ob->get_last_error()) {
    printf("%s\n", master()->standard_trace(error, 1));
  } else write("No error.\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/dbxwhere.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/suspend.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/suspend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626908   Available: 13574262
Inodes: Total: 5242880    Free: 4960132
4946 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/suspend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626908   Available: 13574262
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: suspend.c,v 1.10 2002/03/11 01:45:26 pinkfish Exp $
 * 
 */
#include <parser.h>
#include <access.h>

inherit "/cmds/base";

// #define SUSPEND_MULTI 1
#define MULTI_SUSPEND 28*24 // Two weeks.
#define LIAISON "/d/liaison/master"

private int do_suspend(string, int, string);

// The lord version of suspend.
private int cmd(string name, int tim, string type, string reason) {

  if (this_player() != this_player(1)) {
    return 0;
  }

  if (!master()->query_lord(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail("You must be a lord or liaison deputy to suspend "
                       "someone.");
  }

  if ( type[<1] != 's' ) { 
      type += "s";
  }

  switch (type) {
    case "days":
        tim *= 24;
    break;

    case "weeks":
        tim *= 24 * 7;
    break;

    case "months":
        tim  *= 24 * 7 * 4;
    break;

    case "years":
        tim *= 24 * 365; 
    break; 
    
    case "hours":
        // Do nothing.
    break; 

    default:
//         add_failed_mess( "You must give a reason.\n" ); 
//        return -1; 
  }
  
  if (!master()->query_lord (geteuid(previous_object())) 
      && LIAISON->query_deputy(geteuid(previous_object()))
      && tim > MULTI_SUSPEND) {
    return notify_fail ("You can only suspend for a maximum of " +
      query_num (MULTI_SUSPEND) + " hours.");
  }

  return do_suspend(name, tim, reason);
}

// The normal creator suspend
private int suspend(string who, string reason) {
  if(this_player() != this_player(1))
    return 0;

  if (!master()->query_lord(geteuid(previous_object())) &&
      !master()->query_senior(geteuid(previous_object())) &&
      !LIAISON->query_member(geteuid(previous_object()))) {
    return notify_fail("Only liaisons or seniors can do that.\n");
  }

  return do_suspend(who, 2, reason);
}

#ifdef SUSPEND_MULTI
// The liaison multiplayer suspend
private int suspend_multi(string who) {
  if(this_player() != this_player(1))
    return 0;

  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail("You must be a lord or liaison deputy to suspend "
                       "someone for multiplaying.");
  }

  return do_suspend(who, MULTI_SUSPEND, "Multiplaying");
}
#endif

private int do_suspend(string name, int tim, string reason) {
  notify_fail("We failed!\n");

  if (!"/secure/bastards"->suspend_person(name, tim*60*60, reason)) {
    return 0;
  }

  write(name+" suspended until "+ctime(time()+tim*60*60)+"\n");
  return 1;
}

int help() {
  if(!"/secure/master"->query_lord(geteuid(previous_object())) &&
     !LIAISON->query_member(this_player()->query_name()))
    return notify_fail("You cannot use suspend.\n");

  
  if(this_player()->query_lord() ||
     master()->query_senior(geteuid(previous_object())) ||
     LIAISON->query_member(geteuid(previous_object())))
    write("suspend <name> <reason> -- will suspend a player for 2 hours.\n");

#ifdef SUSPEND_MULTI
  if(this_player()->query_lord() ||
     LIAISON->query_deputy(geteuid(this_player())))
    write("suspend <name> multiplaying -- will suspend a multiplayer for "
          "2 weeks.\n");
#endif

  if (LIAISON->query_deputy(geteuid(this_player()))) {
    write("suspend <name> <time> <reason> where time is in hours.\n");
    write ("You may suspend people for a maximum of " 
      + query_num (MULTI_SUSPEND) + " hours as a liaison deputy.\n");
  }

  if ("/secure/master"->query_lord(geteuid(this_player()))) {
    write("suspend <name> <time> <reason> where time is in hours.\n");
    write("suspend <name> <time> <hours|days|weeks|months|years> <reason> "
        "where time is in the units specified in the command.\n");
  }

  return 1;
}

public mixed *query_patterns() {
  mixed retval;
  
  retval = ({ "help", (: help() :) });

  if( master()->query_lord(geteuid(this_player())) ||
     master()->query_senior(geteuid(previous_object())) ||     
     LIAISON->query_member(geteuid(previous_object())))
    retval += ({ "<word'player'> <string'reason'>",
                   (: suspend($4[0], implode($4[1..], " ")) :) });
  
#ifdef SUSPEND_MULTI
  if(this_player()->query_lord() ||
     LIAISON->query_deputy(geteuid(this_player())))
    retval += ({ "<word'player'> multiplaying",
                   (: suspend_multi($4[0]) :) });
#endif
  
  if( master()->query_lord(geteuid(this_player())) ||
        LIAISON->query_deputy(geteuid(this_player()))) { 
        retval += ({ "<word'player'> <number'time'> <string'reason'>",
                   (: cmd($4[0], $4[1], "hours", implode($4[2..], " ") ) :) });
        retval += ({ "<word'player'> <number'time'> "
            "<word'hours|days|weeks|months|years'> <string'reason'>",
                   (: cmd($4[0], $4[1], $4[2], implode($4[3..], " ") ) :) });
  }

  return retval;
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/suspend.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/hcode.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/hcode.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626906   Available: 13574260
Inodes: Total: 5242880    Free: 4960132
1378 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/hcode.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626906   Available: 13574260
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: hcode.c,v 1.1 2001/01/18 01:49:16 pinkfish Exp $
 * $Log: hcode.c,v $
 * Revision 1.1  2001/01/18 01:49:16  pinkfish
 * Initial revision
 *
 * Revision 1.2  2001/01/18 01:35:17  pinkfish
 * Fix up the code.
 *
 * Revision 1.1   1998/01/06 05:25:41   ceres
 * Initial revision
 * 
*/
/* hcre command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <broadcaster.h>

mixed cmd(string) {
   int i;
   mixed *hist;

   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("code");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the code channel.\n");
   }
   write("The code channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(), 
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0], 
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(), 
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/hcode.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/playerinfo.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/playerinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626906   Available: 13574260
Inodes: Total: 5242880    Free: 4960132
6486 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/playerinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626906   Available: 13574260
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Print info - prints playerinfo database entries for a given player.
 * If the reason argument is given, print only entries referring to that
 * event.
 *
 * @author Fiona
 */
#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>

#define LOGGING

inherit "/cmds/base";

int do_report( string player, string event, int lastn, int interleaved ) {
   string who = this_player()->expand_nickname( lower_case(player) );
   string ret;

   if( !PLAYER_HANDLER->test_user(who) ) {
      tell_object( this_player(), "%^RED%^%^BOLD%^NOTE: %^RESET%^"
        "This is a player that either "
        "never existed or no longer exists.  Some deleted players' "
        "dossiers remain, while others do not.\n" );
   }

#ifdef LOGGING
   log_file( "/d/admin/log/PLAYERINFO.log", "%s: %s read dossier of %s.\n",
     ctime( time() ), this_player()->query_name(), who );
#endif

   if( interleaved ) {
     ret = PLAYERINFO_HANDLER->query_interleaved(this_player(), who, 
                                                 event);
   } else if( !event ) {
     ret = PLAYERINFO_HANDLER->query_dossier( this_player(), who, lastn );
   } else {
     ret = PLAYERINFO_HANDLER->query_event( this_player(), who,
                                            lower_case(event) );
   }
   ret = this_player()->fix_string(ret, this_player()->query_cols());
   return this_player()->more_string(ret, "Playerinfo", 1);
} /* do_report() */

int list_events() {
   string * list;
   string event, myself, result;

   list = sort_array( PLAYERINFO_HANDLER->query_events(), 1 );
   myself = base_name(this_object());

   result = "";
   foreach( event in list )
     result += ( event == list[0] ) ? event : ( ", " + event );
   write( "The following events exist: " + result + ". \n" );

   list = filter( list,
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );

   write( "You can manually add the following events: "
     + query_multiple_short(list) + ". \n" );
   return 1;
} /* list_events() */

// Update the database with the data the user has entered
void update_database( string comment, string * data ) {
   if( !comment )
      return;
   if( PLAYERINFO_HANDLER->add_entry( this_player(), data[0], data[1],
                                      comment + "\n" ) ) {
      write( capitalize( data[0] ) + "'s dossier updated.\n" );
   } else {
      write( "Cannot update " + capitalize( data[0] ) + "'s dossier.\n" );
   }
} /* update_database() */

int do_acknowledge( string player, string event, int idx, string update ) {
   if( !(PLAYERINFO_HANDLER->is_alert( player, idx ) ) ) {
      add_failed_mess( "That event is not an alert, so cannot be "
        "acknowledged.\n" );
      return -1;
   }

   if( !PLAYERINFO_HANDLER->acknowledge_alert( this_player(), player,
     event, idx, update, 0 ) ) {
      add_failed_mess( "You do not have the permission to acknowledge that alert, "
        "or the event type is invalid.\n" );
      return -1;
   }
   add_succeeded_mess( ({ "Event acknowledged.\n", "" }) );
   return 1;
} /* do_acknowledge() */

int list_alerts( int foo ) {
   string * names;

   if( foo )
      names = PLAYERINFO_HANDLER->query_online_alerts();
   else
      names = keys( PLAYERINFO_HANDLER->query_alerts() );

   if( !sizeof( names ) )
      write( "There are no players with unacknowledged alerts.\n" );
   else
      write( "The following players have unacknowledged alerts: "
        + query_multiple_short( names ) + ". (" + sizeof( names ) +
        ")\n" );

   return 1;
} /* list_alerts() */

int add_event( string player, string event, string comment ) {
   string *events;
   string myself;

   player = this_player()->expand_nickname( lower_case(player) );
   event = lower_case(event);

   if( !PLAYER_HANDLER->test_user(player) ) {
      add_failed_mess( "No such player: " + player + ".\n" );
      return 0;
   }

   myself = base_name( this_object() );

   events = filter( PLAYERINFO_HANDLER->query_events(),
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );
   if( member_array( event, events ) == -1 ) {
      add_failed_mess( "Incorrect event type '" + event
        + "': it must be one of " + query_multiple_short(events) + ".\n" );
      return 0;
   }

   if( comment ) {
      update_database( comment, ({ player, event }) );
      return 1;
   }
   write( "Please enter your comments:\n" );
   this_player()->do_edit( 0, "update_database", this_object(), 0,
     ({ player, event }) );
   return 1;
} /* add_event() */

int add_alts( string s1, string s2, int deleting ) {
   string who, result;
   string * alts;

   who = this_player()->expand_nickname( lower_case(s1) );
   alts = explode( lower_case(s2), " " );
   alts = explode( implode( alts, "," ), "," ) - ({ "" }) - ({ 0 });

   if( deleting ) {
      result = PLAYERINFO_HANDLER->delete_alts( this_player(), who, alts );
   } else {
      result = PLAYERINFO_HANDLER->add_alts( this_player(), who, alts );
   }

   add_succeeded_mess( ({ result, "" }) );
   return 1;
} /* add_alts() */

// Return the command pattern list.
mixed *query_patterns() {
   return ({
     "list",
       (: list_events() :),
     "list alerts",
       (: list_alerts(0) :),
     "list alerts online",
       (: list_alerts(1) :),
     "<word'playername'>",
       (: do_report( $4[0], 0, 10, 0 ) :),
     "<word'playername'> verbose",
       (: do_report( $4[0], 0, 0, 0 ) :),
     "<word'playername'> interleaved",
       (: do_report( $4[0], 0, 0, 1 ) :),
     "<word'playername'> <word'event type'> interleaved",
       (: do_report( $4[0], $4[1], 0, 1 ) :),
     "<word'playername'> <word'event type'>",
       (: do_report( $4[0], $4[1], 0, 0 ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "<string'comment'>",
       (: do_acknowledge( $4[0], "misc", $4[1], $4[2] ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "as <word'event type'> <string'comment'>",
       (: do_acknowledge( $4[0], $4[2], $4[1], $4[3] ) :),
     "<word'playername'> add [event] <word'event type'>",
       (: add_event( $4[0], $4[1], 0 ) :),
     "<word'playername'> add [event] <word'event type'> <string'comment'>",
       (: add_event( $4[0], $4[1], $4[2] ) :),
     "<word'playername'> addalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 0 ) :),
     "<word'playername'> delalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 1 ) :),
   });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/playerinfo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/dist_ribution.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/dist_ribution.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626904   Available: 13574258
Inodes: Total: 5242880    Free: 4960132
772 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/dist_ribution.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626904   Available: 13574258
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Gototh 11/04/98

inherit "/cmds/base";

varargs int cmd(string num) {
  object player, *players;
  int division, i, max, slot;
  mapping stuff;

  division = to_int(num);
  if(!division) {
    division = 50;
  }

  stuff = ([ ]);
  players = users();
  max = 0;

  foreach( player in players )  {
    if ( !player->query_creator() )  {
      slot = player->query_level() / division;
      ++stuff[slot];
      if ( slot > max )  max = slot;
    }
    else players -= ({ player });
  }

  write("%^ORANGE%^Player level distribution:%^RESET%^\n");
  for ( i = 0; i < max; i++ )  {
    if ( stuff[i] )  {
      printf( "%5d ..%4d:\t%3d\t%3d%%\n", division * i, division * (i + 1) - 1,
              stuff[i], stuff[i] * 100  / sizeof( players ) );
    }
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/dist_ribution.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/prof.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/prof.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626904   Available: 13574258
Inodes: Total: 5242880    Free: 4960132
1697 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/prof.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626904   Available: 13574258
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <housing.h>

inherit "/cmds/base";

#define MAX 500

int last_got;
mixed *data, *tot;

int total(mapping *info) {
  int ret;
  mapping item;
  
  foreach(item in info)
    ret += item["self"];
  return ret;
}

int cmd(string thing) {
  int i, j;
  mapping stuff;
  object ob;
  mixed foo;
  string ret;

  if(last_got < time() - 900) {
    data = map(objects((: !clonep($1) :)),
               (: ({ $1, function_profile($1) }) :));
    tot = allocate(sizeof(data));
    for(i=0; i<sizeof(data); i++) {
      tot[i] = ({ data[i][0], total(data[i][1]) });
    }
   
    for(i=0; i<24; i++) {
      reset_eval_cost();
      for (j = i; j < sizeof(tot); j++)
        if (tot[i][1] < tot[j][1]) {
          foo = tot[i];
          tot[i] = tot[j];
          tot[j] = foo;
        }
    }
    last_got = time();
  }

  ret = "";

  if(!thing) {
    // We could use sort_array() here, but that's an inefficient way
    // to get the top 10 when there are lots of objects.
    for (i = 0; i < 50 && i<sizeof(tot); i++) {
      if(tot[i][1])
        ret += sprintf("%60-O %i\n", tot[i][0], tot[i][1]);
    }
  } else {
    ob = find_object(thing);
    if(!ob)
      return notify_fail("No such object.\n");
    ret += sprintf("%30-s %10s %10s %10s\n", "function", "calls", "self", "children");
    i = 0;
    for(j=0; j<sizeof(data); j++)
      if(data[j][0] == ob) {
        i = 1;
        break;
      }

    if(!i)
      return notify_fail("No such object in data.\n");
    
    foreach(stuff in data[j][1]) {
      ret += sprintf("%30-s %10d %10d %10d\n", stuff["name"], stuff["calls"],
             stuff["self"], stuff["children"]);
    }
  }

  write("$P$Profile$P$" + ret);
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/prof.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/sqlcmd.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/sqlcmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626903   Available: 13574257
Inodes: Total: 5242880    Free: 4960132
572 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/sqlcmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626903   Available: 13574257
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <db.h>
#include <config.h>

mapping *results;

void set_results( int flag, mapping *res, object who);

int cmd( string db, string query ) {
  DB_HANDLER->make_sql_request( db, CONFIG_DB_USER, "", query, 
  (: set_results( $1, $2, $(this_player()) ) :) );
  return 1;
}

void set_results( int flag, mapping *res, object who ) { 
  tell_creator( who, "flag: %O\n%O\n", flag, res );
  results = res; 
}

mapping *query_results() { return results; }

mixed query_patterns() {
  return ({ 
    "<word'db'> <string:quoted'query'>", 
    (: cmd( $4[0], $4[1] ) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/sqlcmd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/screen.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626903   Available: 13574257
Inodes: Total: 5242880    Free: 4960132
3093 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/screen.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626903   Available: 13574257
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * ScreenWrite Command. 
 * Used to send blocks to text to other creators, in a more
 * readable fashion.
 * Written by Terano, on 14th September, 1998
 */

inherit "/cmds/base";

object target;

int cmd(object player)
{

   target = player;

   if (target == this_player())
      return notify_fail("You start to send text to yourself, "
                         "but think better of it.\n");

/*
   if ( !target->query_creator() && !this_player()->query_lord() ) 
        return notify_fail( "There is really no need to echo text to "
          + target->query_short() +", is there?\n" ); 
*/

   if (target->check_earmuffs("remote-spam")) {
      tell_object(target, sprintf("%s tried to screen some text to you.\n",
                                  this_player()->query_short()));

      return notify_fail(target->query_short() +
                         " currently has " + target->query_possessive() +
                         " screen earmuffs on, ask " +
                         target->query_possessive() + " to turn "
                         "them off.\n");
   }

   tell_object(target, sprintf("Receiving text from %s.\n",
                               this_player()->query_short()));

   tell_object(this_player(),
               sprintf("Sending text to %s. Use ** to stop.\n]",
                       target->query_short()));

   input_to("do_screen");
   return 1;
}

void do_screen(string spam)
{

   if (spam == "**") {
      tell_object(target,
                  sprintf("Stopped receiving text from %s.\n",
                          this_player()->query_short()));

      tell_object(this_player(),
                  sprintf("Stopped sending text to %s.\n",
                          target->query_short()));
      return;
   }

   if (spam) {
      tell_object(target, "] " + spam + "\n");
      write("] ");
   }
   input_to("do_screen");

}

int screen_toggle(string toggle)
{

   if (toggle == "on") {
      if (member_array("remote-spam",
                       this_player()->query_property("earmuffs")) == -1)
         return notify_fail("You aren't earmuffing remote-spam events!\n");

      this_player()->add_property("earmuffs",
                                  (this_player()->query_property("earmuffs") -
                                   ({ "remote-spam" })));
      write("Remote-spam earmuffs off.\n");
      return 1;
   }

   if (toggle == "off") {
      if (member_array("remote-spam",
                       this_player()->query_property("earmuffs")) != -1)
         return
            notify_fail("You are already earmuffing remote-spam events!\n");

      this_player()->add_property("earmuffs",
                                  (this_player()->query_property("earmuffs") +
                                   ({ "remote-spam" })));
      write("Remote-spam earmuffed.\n");
      if (!this_player()->query_earmuffs())
         write("Remeber to \"earmuff on\" to enable them.\n");
      return 1;
   }

}
mixed *query_patterns()
{
   return ({ "<indirect:player>", (: cmd($1[0]) :),
             "{on|off}", (: screen_toggle($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/screen.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/forwards.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/forwards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626902   Available: 13574256
Inodes: Total: 5242880    Free: 4960132
1192 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/forwards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626902   Available: 13574256
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
#include <db.h>

inherit "/cmds/base";

int db;

void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;

   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Forwarder"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
} /* finish_request() */

int cmd(string who){
   string request;

   if(who == "all") {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder is not NULL "
                   "group by Forwarder order by bing desc";
   } else {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder = '" + who + "' "
                   "group by Forwarder order by bing desc";
   }

   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}

mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/creator/forwards.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/autodocrm.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/autodocrm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626901   Available: 13574255
Inodes: Total: 5242880    Free: 4960132
779 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/autodocrm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626901   Available: 13574255
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: auto_doc.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: auto_doc.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#include <autodoc.h>

int cmd(string str) {
   string *files;
   string file;

   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->remove_file(file)) {
         write("Removed file " + file + ".\n");
      } else {
         write("Unable to remove file " + file + ".\n");
      }
   }
   return 1;
} /* cmd() */

mixed *query_patterns() { 
   return ({ "<string>", (: cmd($4[0]) :) });
 } /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/autodocrm.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/dupd_ate.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/dupd_ate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626901   Available: 13574255
Inodes: Total: 5242880    Free: 4960132
1321 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/dupd_ate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626901   Available: 13574255
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dupd_ate.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: dupd_ate.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* dupdate command by wodan */

inherit "/cmds/base";

#include <creator.h>

string other;

int do_it(string str){
  object ob, *obs;
  string *all, *dil, file, fnob /* FileName ob */;

  obs = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(obs))
    return 0;
  foreach(ob in obs){
    fnob = file_name(ob);
    all = inherit_list(ob);
    foreach(file in all){
      if (other){
        dil = deep_inherit_list(find_object(file));
        if (!((member_array(other, dil) != -1) || other == file))
          continue;
      }
      do_it(file);
    }
    ob->dest_me();
    if (ob)
      ob->dwep();
    if (ob)
      destruct(ob);
    ob = load_object(fnob);
    printf("Updated %s.\n", WIZ_PRESENT->desc_f_object(ob));
  }
  return 1;
}

int cmd(string str){
  object *tmp;

  other = 0;
  notify_fail("usage: dupdate <object> [<object>]\n");
  if (!str)
    return 0;
  sscanf(str, "%s %s", str, other);
  if (other){
    tmp = WIZ_PRESENT->wiz_present(other, this_player());
    if (sizeof(tmp)){
      other = file_name(tmp[0]);
      other += ".c";
    } 
    else
      return 0;
  }
  return do_it(str);
}




// --- END [/mnt/home2/grok/lib/cmds/creator/dupd_ate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/rehash.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/rehash.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626900   Available: 13574254
Inodes: Total: 5242880    Free: 4960132
1192 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/rehash.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626900   Available: 13574254
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rehash.c,v 1.3 2002/07/18 02:10:43 pinkfish Exp $
 * $Log: rehash.c,v $
 * Revision 1.3  2002/07/18 02:10:43  pinkfish
 * Make it work with the armoury properly.
 *
 * Revision 1.2  2002/07/18 02:05:01  pinkfish
 * make it handle rehashing the armoury and help files.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* rehash command, trial out by Turrican for a commands daemon. */
#include <armoury.h>

#define CMD_D "/secure/command"

mixed cmd(string str) {
  if (!str)
    return notify_fail("Syntax: rehash <path>\n");
  if (file_size(str) != -2)
    return notify_fail(str+": Path not found.\n");

  if (str[0..4] == "/doc/") {
     "/cmds/player/help"->rehash_specific_dir(str);
     write("Rehashed help dir: " + str + "\n");
     return 1;
  }

  if (str[0..4] == "/obj/" || str[0..2] == "/d/") {
     if (ARMOURY->rehash_specific_dir(str)) {
        write("Rehashed armoury dir: " + str + "\n");
        return 1;
     }
  }

  CMD_D->eventRehash(str);
  write(str+": Rehashed.\n");
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/rehash.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/snoop.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/snoop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626900   Available: 13574254
Inodes: Total: 5242880    Free: 4960132
1173 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/snoop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626900   Available: 13574254
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: snoop.c,v 1.3 2000/04/24 01:57:43 presto Exp $
 * $Log: snoop.c,v $
 * Revision 1.3  2000/04/24 01:57:43  presto
 * Display an approprite message if you try to cancel a snoop and you
 * aren't snooping anyone.
 *
 * Revision 1.2  1998/05/01 15:03:17  pinkfish
 * Changed to use add command.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
 */
/* snoop command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

int do_snoop_cancel() {
  seteuid(geteuid(this_player()));
  if (!query_snooping(this_player()))
    write("You aren't snooping anyone.\n");
  else  {
    snoop(this_player(), 0);
    write("Ok, snoop cancelled.\n");
  }
  return 1;
} /* do_snoop_cancel() */

int do_snoop(object *obs) {
  object targ;

  targ = obs[0];
  if(!snoop(this_player(), targ)) {
    notify_fail("You fail to snoop " + targ->the_short() + ".\n");
    return 0;
  }
  write("Ok, snooping "+targ->the_short()+".\n");
  return 1;
} /* do_snoop() */

mixed *query_patterns() {
  return ({ "<indirect:player>", (: do_snoop($1) :),
            "", (: do_snoop_cancel() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/snoop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/jumps.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/jumps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626899   Available: 13574253
Inodes: Total: 5242880    Free: 4960132
1758 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/jumps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626899   Available: 13574253
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <playtesters.h>

object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }

   return load_object(str);
}

int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;

   from_ob = find_location(from);
   to_ob = find_location(to);

   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }

   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}

int do_path_list() {
   string str;
   string from;
   string* dest;

   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}

int do_remove_jump(string from, string to) {
   string* dests;

   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}

mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/jumps.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/template.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/template.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626899   Available: 13574253
Inodes: Total: 5242880    Free: 4960132
526 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/template.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626899   Available: 13574253
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit "/cmds/base";

int cmd(int size) {
   mixed* data;
   int x;
   int y;
   string line;

   data = TERRAIN_MAP_WORLD_MAP->query_map_template(size);
   line = "";
   for (y = 0; y < sizeof(data); y++) {
      for (x = 0; x < sizeof(data[y]); x++) {
         if (data[x][y]) {
            line += "*";
         } else {
            line += " ";
         }
      }
      line += "\n";
   }
   write(line);
   return 1;
}

mixed* query_patterns() {
   return ({ "<number>", (: cmd($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/template.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/req_uest.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/req_uest.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626898   Available: 13574252
Inodes: Total: 5242880    Free: 4960132
2227 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/req_uest.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626898   Available: 13574252
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <housing.h>

inherit "/cmds/base";

#include <armoury.h>

int request(string item, int condition, string area) {
  object ob;

  ob = ARMOURY->request_item(item, condition, area);
  if(!ob) 
    return notify_fail(item + " not found.\n");

  ob->move(this_player());
  this_player()->add_succeeded_mess(ob, "$N $V $D\n", ({ }));
  log_file ("REQUEST", "%s: %s requested %s.\n",
    ctime (time()), this_player()->query_name(), item);
  return 1;
}

int list(string type, string filter) {
  mapping stuff;

  stuff = ARMOURY->query_items(type, filter);
  if(!sizeof(stuff))
     return this_player()->add_failed_mess(this_object(),
                                           "No such list.\n", ({ }));
  

  printf("Available " + type +" objects are:\n%-*#s\n",
         (int)this_player()->query_cols(),
         implode(keys(stuff), "\n"));
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}

int path(string item, int condition, string area) {
  object ob;
  string res;
  
  ob = ARMOURY->request_item(item, condition, area);
  if(!ob) 
    return notify_fail("");
  
  if (ob->query_property("virtual name")) {
    res = "Virtual file for " + ob->the_short() +
      ":\n   " + ob->query_property("virtual name") + "\n";
  } else {
    res = "Path of " + ob->the_short() + ":\n   " + base_name(ob) + "\n";
  }
  ob->move("/room/rubbish");
  this_player()->add_succeeded_mess(ob, res, ({ }));
  return 1;
}

mixed *query_patterns() {
  return ({ "list <word'" + implode(ARMOURY->query_types(), "|") + "'>",
              (: list($4[0], "") :),
"list <word'" + implode(ARMOURY->query_types(), "|") + "'> <string'filter'>",
              (: list($4[0], $4[1]) :),             
              "<word'area'> <string'item'>", (: request($4[1], 100, $4[0]) :),
              "<word'area'> <string'item'> <number'condition'>", (: request($4
[1], $4[2], $4[0]) :),
              "<string'item'>", (: request($4[0], 100, "") :),
              "<string'item'> <number'condition'>", (: request($4[0], $4
[1], "") :),
              "path <string'item'>", (: path($4[0], 100, "") :),
              "path <word'area'> <string'item'>", (: path($4[1], 100, $4
[0]) :),
        });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/req_uest.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/delalt.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/delalt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626898   Available: 13574252
Inodes: Total: 5242880    Free: 4960132
644 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/delalt.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626898   Available: 13574252
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Delalt - deletes a record about a player's alt character.
 * @author Fiona
 */
#include <creator.h>
#include <playerinfo.h>

inherit "/cmds/base";

// Command entry point
int delete_alt(string s1, string s2) {
  string *alts, alt;

  s1 = this_player()->expand_nickname(lower_case(s1));
  alts =  explode(lower_case(s2)," ") - ({ "" }) - ({ 0 });

  foreach(alt in alts) 
    write(PLAYERINFO_HANDLER->delete_alt(this_player(), s1, alt));

  return 1;
}

// Answer the command patterns
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <string'alt-name alt-name ...'>",
        (: delete_alt($4[0],$4[1]) :)
    });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/delalt.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/comment.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/comment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626897   Available: 13574251
Inodes: Total: 5242880    Free: 4960132
738 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/comment.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626897   Available: 13574251
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: comment.c,v 1.1 2003/04/29 20:45:50 pinkfish Exp $
 * $Log: comment.c,v $
 * Revision 1.1  2003/04/29 20:45:50  pinkfish
 * Initial revision
 *
 * Revision 1.3  1998/04/16 12:52:49  pinkfish
 * Update to use the new report base inhertiable command.
 *
 * Revision 1.2  1998/02/28 02:47:28  presto
 * fixed destination directory for virtual object bugreps
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 *
 */
/**
 * Does this nice bug reporting for the players.  Uses a neato
 * base object whizz bang thing now.
 * @author Pinkfish
 */

inherit "/cmds/report_base";

void create() {
   ::create();
   set_error_type("COMMENT");
   set_use_last_error(1);
} /* create() */
// --- END [/mnt/home2/grok/lib/cmds/creator/comment.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/sar.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/sar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626897   Available: 13574251
Inodes: Total: 5242880    Free: 4960132
1755 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/sar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626897   Available: 13574251
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sar.c,v 1.3 1999/10/24 19:19:22 wodan Exp $
 */
/*
  Nanvaent Industries International
  
  LPC: Search and Replace

  Written by  : Weazel@Nanvaent Nov 92
  Modified by : Bill@Nanvaent Jan 93
  Modified by : Bill@Nanvaent+@Discworld Mar 93
*/
/* sar command, trial out by Turrican for a commands daemon. */

#include <creator.h>

mixed cmd(string str) {
  int i;
  string *files;
  string s1, s2, s3, s4;
  mixed *things;

  seteuid(geteuid(this_player()));
  if ( !str ) {
    notify_fail( "Usage: sar <search_string> <replace_string> <files>\n" );
    return 0;
  }
  s4 = str[ 0 .. 0 ];
  if ( sscanf( str, s4 +"%s"+ s4 +" "+ s4 +"%s"+ s4 +" %s", s1, s2, s3 ) != 3 )
    if ( sscanf( str, "%s %s %s", s1, s2, s3 ) != 3 ) {
      notify_fail( "Usage: sar <search_string> <replace_string> <files>\n" );
      return 0;
    }

  if(strsrch(s3, "*") == -1) {
    if(sizeof(things = WIZ_PRESENT->wiz_present(s3, this_player()))) {
      s3 = file_name(things[0]);
      sscanf(s3, "%s#%*d", s3);
      if (file_size(s3) <= 0)
        s3 += ".c";
    }
  }
  
  files = (string *)this_player()->get_files(s3);
  if(!sizeof(files))
  {
    notify_fail("File(s) " + s3 + " not found.\n");
    return 0;
  }
  s1 = replace( s1, "^M", "\n" );
  s2 = replace( s2, "^M", "\n" );
  for (i=0;i<sizeof(files);i++)
  {
    if (file_size(files[i]) <= 0) continue;
    printf("Looking at %s.\n", files[i]);
    s4 = read_file(files[i]);
    if (s4)
    {
      s4 = replace(s4, s1, s2);
      rm(files[i]);
      write_file(files[i], s4);
    }
    else
      printf("...failed...no file\n");
  }
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/sar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/set.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/set.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626896   Available: 13574250
Inodes: Total: 5242880    Free: 4960132
442 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/set.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626896   Available: 13574250
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: set.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: set.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* set command, trial out by Turrican for a commands daemon. */

#include <creator.h>

mixed cmd(string str) {
  return (int)PEOPLER->set_var(str);
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/set.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/findc_orpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/findc_orpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626896   Available: 13574250
Inodes: Total: 5242880    Free: 4960132
1330 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/findc_orpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626896   Available: 13574250
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- *
 * An attempt to make a command to find player corpses.
 * Goodness only knows how this will turn out.
 * From an exec constructed by young Wonko.
 * Started 19 May 1999
 * Allana
 */

inherit "/cmds/base";

int cmd( string arg ) {

   object *cs, c;
   string r;
  
   r = "player corpse objects\n";
  
   cs = filter( children( "/obj/corpse" ), (: $1 && $1->query_property(
      "player" ) :) );

   if( !arg ) {

      foreach( c in cs ) r += file_name( c ) + " - " + c->query_owner() + 
         " - " + ( environment( c ) ? file_name( environment( c ) ) : 
         "In void" ) + "\n";

   
      tell_object( this_player(), r );

      tell_object( this_player(), sizeof( cs ) + " player corpses.\n" );
 
   } else {

      cs = filter( cs, (: $1 && $1->query_ownership() == $( arg ) :) ); 

      if( sizeof( cs ) ) { 
         r = "Corpse objects of " + arg + ": \n"; 
         foreach( c in cs ) r += file_name( c ) + " in " + (
         environment( c ) ? file_name( environment( c ) ) : "void" ) + "\n";

         tell_object( this_player(), r ); 

      } else { 

         tell_object( this_player(), arg + " has no corpses loaded.\n" );    
      }
   }                
   return 1;
} 

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/findc_orpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/st_at.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/st_at.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626896   Available: 13574250
Inodes: Total: 5242880    Free: 4960132
1472 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/st_at.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626896   Available: 13574250
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: st_at.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: st_at.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <creator.h>

inherit "/cmds/base";

mixed cmd(string str) {
  object *ob, thing;
  mixed *ob1, *thing1;
  string s, bing;
  string long_fields, temp;   /* added by ember to produce long and short fields */
  int long_length;  /* fields are divided into long and short fields by this */

  bing = "";
  str = (string)this_player()->expand_nickname(str);
  ob = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ob)) {
    write("No such object.\n");
    return 1;
  }
  foreach (thing in ob) {
    ob1 = (mixed *)thing->stats();
    if (!pointerp(ob1))
      continue;
    s = "";
    long_fields = "";
    long_length = ( (int)this_player()->query_cols() / 3 ) - 1;
    foreach (thing1 in (pointerp(ob1[0][0])?ob1[0]:ob1)) {
      if (thing1[1]) {
        temp = thing1[0] +": "+ sprintf("%O", thing1[1]) +"\n";
/* this test will incorrectly assess some fields which have line feeds in
 * them as 'long fields', but who really cares? */
        if (strlen(temp) > long_length) {
          long_fields += temp;
        } else {
          s += temp;
        }
      }
    }
    bing += sprintf("%-*#s\n", this_player()->query_cols(), long_fields) +
      sprintf( "%-*#s\n", this_player()->query_cols(), s );
  }
  this_player()->more_string(bing, "Stat");
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/st_at.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/weapons.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/weapons.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626895   Available: 13574249
Inodes: Total: 5242880    Free: 4960132
16419 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/weapons.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626895   Available: 13574249
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <weapon.h>

inherit "/cmds/base";
mapping _weapons;
mapping _items;
mapping _matched;

// Condition modifiers for materials
mapping _conditions = ([ "cloth" : 800, "rubber" : 100, "hide" : 700, "leather" : 600, "wood" : 500, "bone" : 200, "silver" : 300, "copper" : 400, "stone" : 400, "bronze" : 500, "iron" : 700, "steel" : 900, "klatchian steel" : 1100, "octiron" : 1300 ]);

// Damage chance modifiers for materials
mapping _chances = ([ "cloth" : 20, "rubber" : 19, "hide" : 17, "leather" : 15, "wood" : 12, "bone" : 8, "silver" : 15, "copper" : 10, "stone" : 3, "bronze" : 8, "iron" : 6, "steel" : 4, "klatchian steel" : 2, "octiron" : 0 ]);

// Weight modifiers for different materials
mapping _weights = ([ "cloth" : 1, "rubber" : 3, "hide" : 2, "leather" : 2, "wood" : 3, "bone" : 3, "silver" : 6, "copper" : 6, "stone" : 5, "bronze" : 5, "iron" : 5, "steel" : 5, "klatchian steel" : 5, "octiron" : 5 ]);

// Map some weird things to more standard equivalents.
mapping _equivalents = ([ "chocolate" : "rubber",
                          "earthworm" : "octiron" ]);

// The light & heavy weapon specials.
mapping _specials = ([ "bash" : "smash",
                       "hack" : "chop",
                       "stab" : "pierce",
                       "slash" : "slice" ]);
// Standard attack names/types/skills
mapping _types = ([ "strike" : "blunt",
                    "bash" : "blunt",
                    "smash" : "blunt",
                    "hack" : "sharp",
                    "chop" : "sharp",
                    "poke" : "pierce",
                    "stab" : "pierce",
                    "pierce" : "pierce",
                    "cut" : "sharp",
                    "slash" : "sharp",
                    "slice" : "sharp",
                    "spike" : "pierce",
                    "fire" : "any" ]);

nosave string *_attack_types = ({ "blunt", "sharp", "pierce", "fire" });

void create() {
  ::create();
  _weapons = "/obj/handlers/armoury"->make_list("/obj/nweapons/",
                                                ({".c", ".wep"}));
}

string warn(int i) {
  switch(i) {
  case 2:
    return "  %^BOLD%^%^RED%^!%^RESET%^ ";
  case 1:
    return "  %^ORANGE%^o%^RESET%^ ";
  default:
    return "  %^GREEN%^-%^RESET%^ ";
  }
}

int *calc_rating(object weapon) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;

    data = (mixed *)weapon->query_attack_data();
    
    if ( !( size = sizeof( data ) ) )
      return ({ 0, 0 });

    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
    }
    return ({ ave, max });
}

int calc_ave(mixed damage) {
  if(arrayp(damage))
    return damage[F_FIXED] + (damage[F_NUM] * (1 + damage[F_DIE])) / 2;
  
  return damage;
}

int calc_max(mixed damage) {
  if(arrayp(damage))
    return damage[F_FIXED] + (damage[F_NUM] * damage[F_DIE]);
  
  return damage;
}

object *filter(object who) {
  object *tmp;

  if(who->query_creator())
    return ({});
  
  tmp = who->query_weapons();
  switch(sizeof(tmp)) {
  case 2:
    if(tmp[0]->query_property("virtual name")) {
      if(tmp[0]->query_property("virtual name") ==
         tmp[1]->query_property("virtual name"))
        return ({ tmp[0] });
    } else {
      if(base_name(tmp[0]) == base_name(tmp[1]))
        return ({ tmp[0] });
    }
    break;
  default:
  }
  return tmp;
}

int list(string type) {
  mapping weapons;
  object wep;
  mixed *data;
  string *names, *types, str;
  int i;

  weapons = "/obj/handlers/armoury"->query_items("weapons");

  foreach(str in keys(weapons)) {
    if(str == "twoedge" || str == "kring" ||
       strsrch(weapons[str], "ranged") != -1 ||
       strsrch(weapons[str], "misc") != -1)
      continue;
 
    wep = "/obj/handlers/armoury"->request_item(str);
    if(!wep)
      continue;

    types = wep->query_attack_types();
    if(type && types && member_array(type, types) == -1)
      continue;

    data = wep->query_attack_data();
    names = wep->query_attack_names();
    for(i=0; i<sizeof(data); i += W_ARRAY_SIZE) {
      printf("%-30s %8s %3d %3d %3d %6s\n",
             wep->query_short(),
             names[i / W_ARRAY_SIZE],
             data[i + W_CHANCE],
             calc_ave(data[i+W_DAMAGE]),
             calc_max(data[i+W_DAMAGE]),
             data[i+W_SKILL]);
      write_file("/w/ceres/WEAPONS.csv",
                 sprintf("%s,%s,%d,%d,%d,%s\n",
                         wep->query_short(),
                         names[i / W_ARRAY_SIZE],
                         data[i + W_CHANCE],
                         calc_ave(data[i+W_DAMAGE]),
                         calc_max(data[i+W_DAMAGE]),
                         data[i+W_SKILL]));
    }
    wep->dest_me();
  }
  return 1;
}

int sort_weapons(int wep1, int wep2) {
  if(wep1 > wep2)
    return -1;
  if(wep1 < wep2)
    return 1;
  return 0;
}

int players() {
  mapping weapons;
  object wep, *weps;
  mixed *data;
  string str;
  
  data = map(users(), "filter");
  weapons = ([ ]);
  foreach(weps in data) {
    if(weps) {
      foreach(wep in weps) {
        if(wep->query_property("virtual name"))
          str = (clone_object(wep->query_property("virtual name"))->query_short());
        else
          str = base_name(wep)->query_short();
        if(!weapons[str])
          weapons[str] = 1;
        else
          weapons[str] += 1;
      }
    }
  }
  foreach(str in sort_array(keys(weapons),
                            (: sort_weapons($(weapons)[$1],
                                            $(weapons)[$2]) :)))
    if(str && weapons[str])
      printf("%d %s\n", weapons[str], str);
  
  return 1;
}

private string *map_materials(string *materials) {
  string str;
  
  foreach(str in materials) {
    if(_equivalents[str]) {
      materials -= ({ str });
      materials += ({ _equivalents[str] });
    }
  }
  return materials;
}

void total(object pl) {
  write("Total of " + _matched[pl] + " weapons found.\n");
}

void check(int bad_only, string type, string search, string *weapons,
           object pl) {
  string str, *materials, att, ret;
  string *tstr, *anames;
  object wep;
  int cond, dc, ave, max, weight, tmp, bad, count;
  mixed *data;
  float wf;

  count = 0;
  foreach(str in weapons) {
    bad = 0;
    if(wep)
      wep->dest_me();

    // These don't load.
    if(str == "twoedge" || str == "kring")
      continue;

    // exclude the weird stuff if they'd checking for bad/warning weapons.
    if(bad_only && (strsrch(str, "bow") != -1 ||
                    str == "satin knife boots" || str == "knife boots" ||
                    strsrch(_items[pl][str], "ranged") != -1 ||
                    strsrch(_items[pl][str], "misc") != -1))
      continue;

    // Search for specific weapons.
    if(search != "" && strsrch(str, search) == -1 &&
       strsrch(_items[pl][str], search) == -1)
      continue;
    
    wep = clone_object(_items[pl][str]);
    if(!wep || !wep->query_short())
      continue;

    materials = map_materials(wep->query_materials());
    cond = wep->query_max_cond();
    dc = wep->query_damage_chance();

    ret = "";
    if(search)
      ret = sprintf("\n");
    
    ret += sprintf("%s (%s)\n", capitalize(wep->query_short()),
                   _items[pl][str]);

    tstr = ({ });

    if(!sizeof(materials) || sizeof(materials - keys(_conditions)))
      tstr += ({ "materials" });
    else
      ret += warn(0) + sprintf("is made of %s\n",
                               query_multiple_short(materials));

    if(wep->query_length() == 1)
      tstr += ({ "length" });
    if(wep->query_width() == 1)
      tstr += ({ "width" });
    if(!wep->query_weight())
      tstr += ({ "weight" });
    
    if(sizeof(tstr)) {
      if(sizeof(tstr) == 1 && tstr[0] == "width") {
        ret += warn(1);
        //if(bad < 2)
        //bad = 1;
      } else {
        ret += warn(2);
        bad = 2;
      }
      ret += sprintf("has no %s\n", replace(query_multiple_short(tstr),
                                            "and", "or"));

      if(member_array("materials", tstr) != -1) {
        tell_object(pl, ret);
        continue;
      }
    }

    if(wep->query_length() != 1 && wep->query_width() != 1)
      ret += warn(0) + sprintf("is %s%d\" (%dcm) by %s%d\" (%dcm) "
                               "and weighs %.1f%s (%.1fkg)\n",
                               (wep->query_length() / 12) > 0 ?
                               (wep->query_length() / 12) + "'" : "",
                               wep->query_length() % 12,
                               to_int(wep->query_length() * 2.54),
                               (wep->query_width() / 12) > 0 ?
                               (wep->query_width() / 12) + "'" : "",
                               wep->query_width() % 12,
                               to_int(wep->query_width() * 2.54),
                               wep->query_weight() / 9.0,
                               (wep->query_weight() / 9.0) == 1.0 ? "lb" :
                               "lbs",
                               wep->query_weight() / 20.0);

    // Calculate the ratio of length+width+material to weight.
    wf = 0;
    foreach(tstr in materials)
      wf += _weights[tstr];
    wf /= sizeof(materials);
    
    wf = (wep->query_weight() * (wep->query_weight() / 2)) /
      (wep->query_length() * wep->query_width() * wf);

    if(wf < 0.5 || wf > 3.0) {
      ret += warn(1);
      if(bad < 2)
        bad = 1;
    } else
      ret += warn(0);
    
    ret += sprintf("has weight factor of %.1f [0.5/1.0/3.0] "
                   "(%%^ORANGE%%^Experimental%%^RESET%%^)\n", wf);
      
    switch(type) {
    case "weapons":
      weight = 10 + 2 * sqrt(wep->query_weight());
      break;
    case "armours":
      weight = 5 + 2 * sqrt(wep->query_weight());
      break;
    case "clothes":
      weight = 2 * sqrt(wep->query_weight());
      break;
    }

    tmp = 0;
    foreach(tstr in materials)
      tmp += _conditions[tstr];

    tmp /= sizeof(materials);
    tmp *= weight;
    
    if((cond < tmp - tmp/10) || (cond > tmp + tmp/10)) {
      ret += warn(2) + sprintf("has max cond of %d should be [%d/%d/%d]\n",
                               cond, tmp - tmp/10, tmp, tmp + tmp/10);
      tell_object(pl, ret);
      continue;
    } else if(search)
      ret += warn(0) + sprintf("has max cond of %d [%d/%d/%d]\n",
                               cond, tmp - tmp/10, tmp, tmp + tmp/10);


    tmp = 0;
    foreach(tstr in materials)
      tmp += _chances[tstr];
    tmp /= sizeof(materials);

    if(dc < tmp -1 || dc > tmp+1) {
      ret += warn(2) + sprintf("has damage chance of %d should be "
                               "[%d/%d/%d]\n",
                               dc, tmp-1, tmp, tmp+1);
      bad = 2;
    } else if(search)
      ret += warn(0) + sprintf("has damage chance of %d [%d/%d/%d]\n",
                               dc, tmp-1, tmp, tmp+1);

    // Check the common specials
    anames = wep->query_attack_names();
    if(!sizeof(anames)) {
      ret += warn(2) + sprintf("has no attacks.\n");
      tell_object(pl, ret);
      continue;
    }

    foreach(att in anames) {
      if(!_specials[att] && member_array(att, keys(_types)) == -1) {
        ret += warn(1) + sprintf("has non-standard %s attack\n", att);
        if(bad < 2)
          bad = 1;
      } else if(wep->query_weight() < 30 &&
         member_array(att, values(_specials)) != -1) {
        ret += warn(2) + sprintf("has %s but is too light\n", att);
        bad = 2;
      } else if(wep->query_weight() > 50 && _specials[att] && 
                member_array(_specials[att], anames) == -1) {
        ret += warn(1) + sprintf("has %s but not %s\n", att, _specials[att]);
        if(bad < 2)
          bad = 1;
      }
    }
    
    // Check type & skill.
    data = wep->query_attack_data();
    for(tmp=0; tmp < sizeof(data); tmp += W_ARRAY_SIZE) {
      if(member_array(data[tmp+W_TYPE], _attack_types) == -1) {
        ret += warn(2) + sprintf("has unknown attack type %s\n",
                                 data[tmp+W_TYPE]);
        bad = 2;
      }
      if(member_array(data[tmp+W_SKILL], values(_types)) == -1) {
        ret += warn(2) + sprintf("has unknown attack skill %s\n",
                                 data[tmp+W_SKILL]);
        bad = 2;
      }

      if(_types[anames[tmp/W_ARRAY_SIZE]] &&
         _types[anames[tmp/W_ARRAY_SIZE]] != "any" &&
         _types[anames[tmp/W_ARRAY_SIZE]] != data[tmp+W_SKILL]) {
        ret += warn(2) + sprintf("has attack %s with skill of %s\n",
                                 anames[tmp/W_ARRAY_SIZE], data[tmp+W_SKILL]);
        bad = 2;
      }
      if(data[tmp+W_FUNCTION]) {
        ret += warn(1) + sprintf("has attack function %s on %s attack\n",
                                 data[tmp+W_FUNCTION],
                                 anames[tmp/W_ARRAY_SIZE]);
        bad = 1;
      }
    }
    
    // Check the axe attacks.
    if(strsrch(_items[pl][str], "axe") == -1 &&
       strsrch(wep->query_long(), "axe") == -1) {
      if(member_array("chop", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has chop attack but is not an axe.\n");
        if(bad < 2)
          bad = 1;
      }
      if(member_array("hack", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has chop attack but is not an axe.\n");
        if(bad < 2)
          bad = 1;
      }
    } else {
      if(member_array("slash", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has slash attack but is an axe.\n");
        if(bad < 2)
          bad = 1;
      }
      if(member_array("slice", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has slice attack but is an axe.\n");
        if(bad < 2)
          bad = 1;
      }
    }
    
    if(cond) {
      data = calc_rating(wep);
      ave = data[0];
      max = data[1];

      if(ave > 140 || max > 300) {
        ret += warn(2);
        bad = 2;
      } else
        ret += warn(0);
      
      ret += sprintf("has damage of %d/%d max permitted is [140/300]\n",
                     ave, max);

      tmp = (100 * ave * max) / cond; // damage factor
      if(tmp < 75 || tmp > 150) {
        ret += warn(1);
        if(bad < 2)
          bad = 1;
      } else
        ret += warn(0);
      
      ret += sprintf("has damage factor of %d [75/150] "
                     "(%%^ORANGE%%^Experimental%%^RESET%%^)\n",
                     tmp);
    }
    
    if(bad >= bad_only) {
      tell_object(pl, ret);
      count++;
    }
  }
  _matched[pl] += count;
  return;
}

int do_check(int bad_only, string type) {
  string *tmp, search;
  int i;

  if(!_items)
    _items = ([ ]);
  if(!_matched)
    _matched = ([ ]);
  
  if(type == "armours" || type == "clothes") {
    _items[this_player()] = "/obj/handlers/armoury"->query_items(type);
    search = "";
  } else if(type == "weapons") {
    _items[this_player()] = _weapons;
    search = "";
  } else {
    search = type;
    type = "weapons";
    _items[this_player()] = _weapons;
  }

  _matched[this_player()] = 0;
  
  tmp = keys(_items[this_player()]);

  if(!sizeof(tmp))
    return notify_fail("No items matched.\n");

  for(i=0; i<sizeof(tmp); i+= 50) {
    if(i+50 < sizeof(tmp)) {
      call_out("check", 0, bad_only, type, search, tmp[i..i+49],
               this_player());
    } else
      call_out("check", 0, bad_only, type, search, tmp[i..], this_player());
  }
  call_out("total", 1, this_player());
  return 1;
}

mixed *query_patterns() {
  return ({
    //"list", (: list("") :),
              //              "list <string'type'>", (: list($4[0]) :), 
              "players", (: players() :),
              "check", (: do_check(0, "") :),
              "check <string'type'>", (: do_check(0, $4[0]) :),
              "check bad", (: do_check(2, "") :),
                "check bad <string'type'>", (: do_check(2, $4[0]) :),
              "check warn", (: do_check(1, "") :),
              "check warn <string'type'>", (: do_check(1, $4[0]) :)
                });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/weapons.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/sne_tstat.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/sne_tstat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626891   Available: 13574245
Inodes: Total: 5242880    Free: 4960132
817 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/sne_tstat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626891   Available: 13574245
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: sne_tstat.c,v 1.2 1999/10/28 02:35:54 ceres Exp $
 * $Log: sne_tstat.c,v $
 * Revision 1.2  1999/10/28 02:35:54  ceres
 * can't remember
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* goto command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <creator.h>
#include <peopler.h>

mixed cmd(string str) {
   mixed *bing;

   bing = (mixed *)this_player()->query_property("netstat list");
   if (!bing) {
     bing = SN_DEFAULT;
   }
   (int)PEOPLER->do_command( bing, str,
                         (: strcmp(query_ip_number($1), query_ip_number($2)) :) );
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/sne_tstat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/pquests.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/pquests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626890   Available: 13574244
Inodes: Total: 5242880    Free: 4960132
1510 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/pquests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626890   Available: 13574244
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <quest_handler.h>
#include <library.h>

inherit "/cmds/base";

string quest_text(string quest);

int cmd( string player, int sorted ) {
    string *quests, text;
    int i, size;
    
    if ( !player ) {
        quests = QUEST_HANDLER->query_quest_names();
        text = "$P$Quest list$P$\nTotal quests on " + mud_name() + " :-\n\n";
    }
    else {
        quests = LIBRARY->query_quests(player);    
        
        if (!quests) {
            add_failed_mess( "That player has not done any "
                "quests.\n" );
            return 0;
        }
        
    if ( sorted ) 
        quests = sort_array( quests, 1 );

        text = "$P$Quest list$P$\nQuests done for player " + player + " :-\n\n";
    }
    size = sizeof(quests);

    for ( i = 0; i < size; i++ ) {
        text += sprintf("%d. %s (%s) %s\n", i + 1, quests[i], 
            QUEST_HANDLER->query_quest_title (quests[i]), 
            quest_text( quests[i] ) );
    }
    
    tell_object( this_player(), text );
    return 1;
} /* cmd() */

string quest_text(string quest) {
    switch ( QUEST_HANDLER->query_quest_status(quest) ) {
        case 0:
            return "(inactive)";
            
        case 1:
            return "";
        
        default:
            return "(broken)";
    }
} /* quest_text() */

mixed *query_patterns() {
    return ({ "", (: cmd(0, 0) :),
        "<string'player'>", (: cmd($4[0], 0) :),
        "<string'player'> sorted", (: cmd($4[0], 1) :) 
    });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/pquests.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/hours.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/hours.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626890   Available: 13574244
Inodes: Total: 5242880    Free: 4960132
2383 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/hours.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626890   Available: 13574244
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Hours command.
 * <p>
 * This command displays which players have been connected to the MUD for a 
 * certain number of hours.  
 * <p>
 * @author Taffyd
 * @started 27/08/99 3:16AM
 * @finished 27/08/99 3:43AM
 */

inherit "/cmds/base";

/** @ignore yes */
int cmd( int time, string all) {
    mapping people;
    int seconds, num;
    string mess;

    if ( !time ) {
      if(all == "")
        people = unique_mapping( filter( users(), 
            (: interactive( $1 ) && !$1->query_login_ob() &&
             !$1->query_creator() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
      else
        people = unique_mapping( filter( users(), 
            (: interactive( $1 ) && !$1->query_login_ob() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
        
        people = map( people, (: sort_array( $2, (: strcmp( $1->query_name(),
            $2->query_name() ) :) ) :) );

        mess = "";
        
        foreach( num in sort_array( keys( people ), -1 ) ) {
            if ( num > 0 ) {
                mess += "Online for " + query_num( num ) + 
                    ( num == 1 ? " hour: \n" : " hours: \n" ) +
                    query_multiple_short( people[ num ] ) + ".\n\n";
            }
        }
        
        tell_object( this_player(), "$P$Online time$P$" + 
            mess );
    }
    else {
        seconds = time * 60 * 60;
        
        people = allocate_mapping( users(), (: $(time()) -  $1->query_last_log_on() :) );        
        people = filter( people, (: interactive($1) && !$1->query_login_ob() 
            && $2 > $(seconds) :) );
        

        if ( sizeof( people ) ) {
            tell_object( this_player(), "The following people have been "
                "connected for more than " + query_num( time ) + 
                ( time % 3600 < 2 ? " hour: " : " hours: " ) +
                query_multiple_short( keys( people ) ) + ".\n" );
        }
        else {
            tell_object( this_player(), "No one has been connected for that "
                "long.\n" );
        }
    }
        
    return 1;
} /* cmd() */


/** @ignore yes */
mixed *query_patterns() {
  return ({ "<number>", (: cmd($4[0], "") :),
            "<number> all", (: cmd($4[0], "all") :),
            "all", (: cmd(0, "all") :),
            "", (: cmd(0, "") :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/hours.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/eff_ects.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/eff_ects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626889   Available: 13574243
Inodes: Total: 5242880    Free: 4960132
1369 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/eff_ects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626889   Available: 13574243
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * Command to list the effects on a person.
 */
inherit "/cmds/base";

int cmd( object * obs, int brief ) {
   object who;
   int num, * enums;
   mixed arg;

   if( !obs )
      obs = ({ this_player() });

   foreach( who in obs ) {
      write( "%^BOLD%^Effects on " + who->query_short() + ":%^RESET%^\n" );
      enums = who->effects_matching( "" );
      if( !sizeof( enums ) ) {
         write( "No effects.\n" );
         printf( "%s\n",
           "-----------------------------------------------------------" );
         continue;
      }

      foreach( num in enums ) {
         arg = who->arg_of(num);
         if ( brief && ( arrayp(arg) || classp(arg) || mapp(arg) ) ) {
            arg = "COMPLEX";
         }
         if ( !brief ) {
            printf( "%s\n",
              "-----------------------------------------------------------" );
         }
         printf( "[%d]   %s (%O)\n", num,
           find_object( who->eff_of(num) )->query_classification(),
           arg );
      }
      printf( "%s\n",
        "-----------------------------------------------------------" );
   }
   return 1;
}

mixed * query_patterns() {
   return ({
     "<indirect:wiz-present> verbose", (: cmd( $1, 0 ) :),
     "<indirect:wiz-present> [brief]", (: cmd( $1, 1 ) :),
     "[me] verbose", (: cmd( 0, 0 ) :),
     "[me] [brief]", (: cmd( 0, 1 ) :),
   });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/eff_ects.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/addevent.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/addevent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626889   Available: 13574243
Inodes: Total: 5242880    Free: 4960132
2559 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/addevent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626889   Available: 13574243
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Addevent - adds entries to the player info database.
 */
#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>

inherit "/cmds/base";

// Update the database with the data the user has entered
void update_database(string comment, string *data) {
    if (comment == 0) {
       return;
    }

    if (PLAYERINFO_HANDLER->add_entry(this_player(),
                                      data[0],
                                      data[1],
                                      comment+"\n")) {
        write(capitalize(data[0])+"'s dossier updated.  \n");
    } else {
        write("Cannot update "+capitalize(data[0])+"'s dossier.  \n");
    }
} /* update_database() */

// Command entry point
int add_event(string player, string event, string comment) {
    string *events;
    string myself;

    player = this_player()->expand_nickname(lower_case(player));
    event = lower_case(event);

    if (!PLAYER_HANDLER->test_user(player)) {
        add_failed_mess("No such player: " + player + ".\n");
        return 0;
    }

    myself = base_name(this_object());
    events = filter(PLAYERINFO_HANDLER->query_events(),
                (: PLAYERINFO_HANDLER->query_source_ok($1, $(myself)) :));
    if (member_array(event, events) == -1) {
       add_failed_mess("Incorrect event type '" + event +
                       "' it must be one of " +
                       query_multiple_short(events) + ".\n");
       return 0;
    }

    if (comment != 0) {
        update_database(comment, ({ player, event }));
        return 1;
    }
    write("Please enter your comments:\n");
    this_player()->do_edit(0, "update_database", this_object(), 0,
                           ({ player, event }));
    return 1;
} /* add_event() */

// Yet Anothr Command Entry Point (YACEP)
int list_events() {
    string result;
    string myself;
    string *list;

    result = "";
    myself = base_name(this_object());
    list = sort_array(
            filter(PLAYERINFO_HANDLER->query_events(),
                (: PLAYERINFO_HANDLER->query_source_ok($1, $(myself)) :)), 1);


    write("The following events can be added using addevent: " +
          query_multiple_short(list) + ". \n");
    return 1;
} /* list_events() */

// Answer the command patterns
mixed *query_patterns()
{
    return ({
        "list",
        (: list_events() :),
        "<word'player-name'> <word'event'>",
        (: add_event($4[0],$4[1],0) :),
        "<word'player-name'> <word'event'> <string'comment'>",
        (: add_event($4[0],$4[1],$4[2]) :)
    });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/addevent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/malloc.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/malloc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626888   Available: 13574242
Inodes: Total: 5242880    Free: 4960132
437 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/malloc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626888   Available: 13574242
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: malloc.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: malloc.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* malloc command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
  printf("%s", malloc_status());
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/malloc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/hcre.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/hcre.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626887   Available: 13574241
Inodes: Total: 5242880    Free: 4960132
1377 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/hcre.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626887   Available: 13574241
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: hcre.c,v 1.1 2001/01/18 01:49:16 pinkfish Exp $
 * $Log: hcre.c,v $
 * Revision 1.1  2001/01/18 01:49:16  pinkfish
 * Initial revision
 *
 * Revision 1.2  2001/01/18 01:35:17  pinkfish
 * Fix up the code.
 *
 * Revision 1.1   1998/01/06 05:25:41   ceres
 * Initial revision
 * 
*/
/* hcre command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <broadcaster.h>

mixed cmd(string) {
   int i;
   mixed *hist;

   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("cre");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the cre channel.\n");
   }
   write("The creator channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(), 
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0], 
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(), 
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/hcre.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/tell!.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/tell!.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626887   Available: 13574241
Inodes: Total: 5242880    Free: 4960132
6573 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/tell!.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626887   Available: 13574241
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <drinks.h>
#include <language.h>
#include <player.h>

#define TP this_player()

inherit "/cmds/base";
inherit "/cmds/speech";

#ifdef USE_SMILEYS
string *two_smileys = ({":)", ":(", ":P", ":p", ":b", ";)", 
  ";(", ";P", ";p", ";b", "=)", "=("});

string *three_smileys = ({":-)", ":-(", ":-P", ":-p", ":-b",
  ";-)", ";-(", ";-P", ";-p", ";-b", ":o)", ":o(", ":oP", 
  ":op", ":ob", ";o)", ";o(", ";oP", ";op", ";ob", "=-)",
  "=-(", "=o)", "=o("});
#endif

int cmd( string arg, mixed thing, int silent ) {
   string word, lang, words, emotion;
#ifdef USE_SMILEYS
   string smiley, smiley_words;
#endif
   string them_mess, temp;
   string me_mess;
   object *obs;
   object *net_dead;
   object *fail;
   mixed busy;

   emotion = "";
   if (pointerp(thing)) {
      words = arg;
   } else if ( !objectp( thing ) ) {
      if ( !arg || sscanf( arg, "%s %s", word, words ) != 2 )
         return 0;
      word = lower_case( word );
      word = (string)TP->expand_nickname( word );
      thing = find_player( word );
      if ( !thing ) {
         if ( sscanf( word, "%*s@%*s" ) == 2 ) {
            "/net/daemon/out_tell"->do_tell( word+" "+words );
            return 1;
         }
         add_failed_mess( capitalize( word ) +" is not logged in.\n" );
         return 0;
      }
   } else {
      words = arg;
   }

   if (!pointerp(thing)) {
      obs = ({ thing });
   } else {
      obs = thing;
   }

   obs -= ({ this_player() });
   if ( !sizeof(obs) ) {
      add_failed_mess( "Talking to yourself again.  I don't know.\n" );
      return 0;
   }

   if (sizeof(obs) > 20) {
      add_failed_mess("You can only tell up to 20 people a message.\n");
      return 0;
   }

   fail = this_player()->query_ignoring(obs);
   if ( sizeof( fail ) )  {
      write( "You are currently ignoring " +
             query_multiple_short( fail ) + ", so " +
             (sizeof(fail) > 1 ? " they" : fail[0]->query_pronoun()) +
             " couldn't reply anyway.\n" );
      obs -= fail;
      if ( !sizeof( obs ) )  {
         return 1;
      }
   }
   lang = (string)TP->query_current_language();
   if ( !LANGUAGE_HAND->query_language_spoken( lang ) ) {
      return notify_fail( capitalize( lang ) +
            " is not a spoken language.\n" );
   }
   if ( !LANGUAGE_HAND->query_language_distance( lang ) ) {
      return notify_fail( capitalize( lang ) +
            " is not able to be spoken at a distance.\n" );
   }
  // This is so small tells don't error.
#ifdef USE_SMILEYS
  if(sizeof(words) >= 3) {
    if(member_array(words[<3..], three_smileys) != -1) {
      smiley = words[<3..];
    } else if(member_array(words[<2..], two_smileys) != -1) {
      smiley = words[<2..];
    }
  } else if(member_array(words, three_smileys) != -1) {
    smiley = words;
  } else if(member_array(words, two_smileys) != -1) {
    smiley = words;
  }
#endif
  word = query_word_type(words, "");
  if(word != "") {
    word = " "+word+"ing";
  }
#ifdef USE_SMILEYS
  if(smiley) {
    // This is so we don't get errors with people telling each
    // other smileys on their own.
    if(sizeof(words) > 3) {
      smiley_words = words[0..<sizeof(smiley) + 1];
    } else {
      smiley_words = words;
    }
    word = query_word_type(smiley_words, "");
    if(word != "") {
      word = " "+word+"ing";
    }
  }
  switch(smiley) {
    case ":)" :
    case ":-)" :
    case ":o)" :
      emotion = " happily";
      break;
    case ":(" :
    case ":-(" :
    case ":o(" :
      emotion = " sadly";
      break;
    case "=)" :
    case "=-)" :
    case "=o)" :
      emotion = " innocently";
      break;
    case "=(" :
    case "=-(" :
    case "=o(" :
      emotion = " tearfully";
      break;
    case ";(" :
    case ";-(" :
    case ";o(" :
      emotion = " angrilly";
      break;
    case ";)" :
    case ";-)" :
    case ";o)" :
      emotion = " mischieviously";
      break;
    case ":P" :
    case ":-P" :
    case ":oP" :
    case ":p" :
    case ":-p" :
    case ":op" :
    case ":b" :
    case ":-b" :
    case ":ob" :
      emotion = " insanely";
      break;
    case "=P" :
    case "=-P" :
    case "=oP" :
    case "=p" :
    case "=-p" :
    case "=op" :
    case "=b" :
    case "=-b" :
    case "=ob" :
      emotion = " cheekily";
      break;
    case ";P" :
    case ";-P" :
    case ";oP" :
    case ";b" :
    case ";-b" :
    case ";ob" :
    case ";p" :
    case ";-p" :
    case ";op" :
      emotion = " evilly";
      break;
    default :
      emotion = "";
  }
#endif

   if ( word != " asking" ) {
      me_mess = "tell";
   } else {
      me_mess = "ask";
      word = "";
   }

   net_dead = ({ });

   foreach (thing in obs) {
      temp = emotion;
      if(thing->query_earmuffs("emoticon")) {
         emotion = "";
      }
      thing->event_person_tell( TP,
            capitalize( (string)TP->query_name() ) +
            " (creator) "+ me_mess + "s "+
            query_multiple_short(obs - ({ thing }) + ({ "you" })) + emotion +
            word + ": ", words, lang );
      if (!interactive(thing) && userp(thing)) {
         net_dead += ({ thing });
      }
   }
   if ( !silent ) {
      if ( lang != "common" ) {
         word += " in "+ lang;
      }
      if (sizeof(obs)) {
         them_mess =
               TP->convert_message(capitalize( query_multiple_short(obs)));
         emotion = temp;
         if(this_player()->query_earmuffs("emoticon")) {
           emotion = "";
         }
         TP->add_tell_history( "(creator) You " + me_mess + " "+ them_mess +
               word + emotion+ ": ", words );
      }
      if ( sizeof(net_dead)) {
          write("Warning: "+query_multiple_short(
                               map(net_dead, (: $1->query_cap_name() :)))+
                " "+ (sizeof(net_dead)>1?"are":"is")+" net dead.\n" );
      }
      emotion = temp;
      if(this_player()->query_earmuffs("emoticon")) {
        emotion = "";
      }
      busy = this_player()->query_busy();
      if (busy == 1) {
         write("Warning! You have your busy flag on.\n");
      } else if (pointerp(busy) && sizeof(obs - busy)) {
         write("Warning! You are currently set as busy with " + 
                  query_multiple_short(busy) + ".\n");
      }
      my_mess("(creator) You "+me_mess+" "+them_mess+
            emotion + word+": ", words);
   }
   TP->adjust_time_left( -5 );
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "<indirect:player> <string'message'>", (: cmd($4[1], $1, 0) :),
             "<string>", (: cmd($4[0], 0, 0) :) });
} /* query_patterns() */


// --- END [/mnt/home2/grok/lib/cmds/creator/tell!.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/qwho.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/qwho.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626885   Available: 13574239
Inodes: Total: 5242880    Free: 4960132
20519 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/qwho.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626885   Available: 13574239
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Playerdist
 * Shows the geographical distribution of players online
 *
 * @author Dasquian
 * @started 6/10/02
 * @changed 29/04/03 pinkfish
 * Updated to be in the main directory and using 'qwho'.
 **/

#include <top_ten_tables.h>

int cmd(string filter, string arg);

string* determine_location( object person ) {
    mixed *areas, *place;
    
    areas = ({
    
        ({ "/d/liaison/NEWBIE", ({ "Misc", "The newbie area" }) }),
        ({ "/room/air", ({ "Misc", "The air" }) }),
        ({ "/room/void", ({ "Misc", "The void" }) }),
        ({ "/room/rubbish", ({ "Misc", "The rubbish room" }) }),
        ({ "/room/departures", ({ "Misc", "The departures lounge" }) }),
        ({ "/room/jail", ({ "Misc", "Jail" }) }),
        ({ "/w/", ({ "Misc", "/w dirs" }) }),

        ({ "/d/cwc/utils/interview", ({ "CWC", "Interview room" }) }),
        ({ "/d/cwc/common", ({ "CWC", "Commonroom" }) }),
        ({ "/d/cwc/Brown_Islands", ({ "CWC", "Brown Islands" }) }),
        ({ "/d/cwc/Bes_Pelargic/Bad_Poo-Ning/roads/medina",
            ({ "CWC", "Medina" }) }),
        ({ "/d/cwc/Bes_Pelargic/Sum_Bing/roads/snail",
            ({ "CWC", "The Snail" }) }),
        ({ "/d/cwc/Bes_Pelargic", ({ "CWC", "Bes Pelargic" }) }),
        ({ "/d/cwc/Hunghung", ({ "CWC", "HungHung" }) }),
        ({ "/d/cwc/Isle_of_Tonahamen", ({ "CWC", "Isle of Tonahamen" }) }),
        ({ "/d/cwc/families/mcsweeny", ({ "CWC", "McSweeney Estate" }) }),
        ({ "/d/cwc/Maps", ({ "CWC", "Terrains" }) }),
        ({ "/d/cwc", ({ "CWC", "?" }) }),
        ({ "/d/guilds/assassins/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/thieves/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/BesPelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/Hunghung", ({ "CWC", "HH guilds" }) }),
        ({ "/d/guilds/priests/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/wizards/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/witches/bespelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/underworld/moving_shop/rooms/cwc", ({ "CWC", "F-shop" }) }),

        ({ "/d/am/utils/interview", ({ "AM", "Interview room" }) }),
        ({ "/d/am/shades", ({ "AM", "The Shades" }) }),
        ({ "/d/am/common", ({ "AM", "Commonroom" }) }),
        ({ "/d/am", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/special/player_shops", ({ "AM", "Tarnach's" }) }),
        ({ "/d/guilds/merchants", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/guilds/assassins/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/thieves/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/warriors/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/priests/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/wizards/Ankh-Morpork", 
            ({ "AM", "Unseen University" }) }),
        ({ "/d/guilds/witches/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/witches/am", ({ "AM", "AM guilds" }) }),

        ({ "/d/klatch/utils/interview", ({ "Klatch", "Interview room" }) }),
        ({ "/d/klatch/common", ({ "Klatch", "Commonroom" }) }),
        ({ "/d/klatch/djel/city", ({ "Klatch", "KLK" }) }),
        ({ "/d/klatch/djel/necropolis", ({ "Klatch", "Necropolis" }) }),
        ({ "/d/klatch/djel/netherworld", ({ "Klatch", "Netherworld" }) }),
        ({ "/d/klatch/tsort/desert/roads", 
            ({ "Klatch", "Tsort desert road" }) }),
        ({ "/d/klatch/tsort/desert", ({ "Klatch", "Tsort desert" }) }),
        ({ "/d/klatch/tsort", ({ "Klatch", "Tsort" }) }),
        ({ "/d/klatch/Maps", ({ "Klatch", "Terrains" }) }),
        ({ "/d/klatch", ({ "Klatch", "?" }) }),
        ({ "/d/guilds/assassins/Khot-lip-khin", 
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/thieves/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/warriors/Khot-lip-khin", 
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Djelibeybi", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Ephebe", ({ "Klatch", "Ephebe guilds" }) }),
        ({ "/d/guilds/wizards/Tsort", ({ "Klatch", "Tsort guilds" }) }),
        ({ "/d/guilds/witches/klk", ({ "Klatch", "KLK guilds" }) }),

        ({ "/d/ram/utils/interview", ({ "Ram", "Interview room" }) }),
        ({ "/d/ram/common", ({ "Ram", "Commonroom" }) }),
        ({ "/d/ram/Gloomy_Forest", ({ "Ram", "Gloomy forest" }) }),
        ({ "/d/ram/Lancre_Kingdom", ({ "Ram", "Lancre Kingdom" }) }),
        ({ "/d/ram/Listening_Monks", ({ "Ram", "Listening Monks" }) }),
        ({ "/d/ram/Razorback", ({ "Ram", "Razorback" }) }),
        ({ "/d/ram/Slice", ({ "Ram", "Slice" }) }),
        ({ "/d/ram/Sprite_Caverns", ({ "Ram", "Sprite caverns" }) }),
        ({ "/d/ram/Temple_of_Soyin", ({ "Ram", "Temple of Soyin" }) }),
        ({ "/d/ram/Uberwald", ({ "Ram", "Uberwald" }) }),
        ({ "/d/ram/badass", ({ "Ram", "Bad Ass" }) }),
        ({ "/d/ram/madstoat", ({ "Ram", "Mad Stoat" }) }),
        ({ "/d/ram/ohulan", ({ "Ram", "Ohulan-Cutash" }) }),
        ({ "/d/ram/foothills", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/bridge", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/moorland", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/gorge_road", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/Lower_Valleys", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/lancre_town", ({ "Ram", "Lancre Town" }) }),
        ({ "/d/ram/bandit_camp", ({ "Ram", "Bandit camp" }) }),
        ({ "/d/ram/druid_circle", ({ "Ram", "Druid circle" }) }),
        ({ "/d/ram/mountains", ({ "Ram", "Ramtops" }) }),
        ({ "/d/ram", ({ "Ram", "?" }) }),
        ({ "/d/guilds/assassins/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/thieves/Madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/warriors/Lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/priests/Monks-of-Cool", ({ "Ram", "Monks of Cool" }) }),
        ({ "/d/guilds/priests/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/wizards/Creel-Springs",
            ({ "Ram", "Creel Springs guilds" }) }),
        ({ "/d/guilds/witches/badass", ({ "Ram", "Bad Ass guilds" }) }),
        ({ "/d/guilds/witches/lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/witches/madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/witches/razorback", ({ "Ram", "Razorback guilds" }) }),

        ({ "/d/sur/utils/interview", ({ "Sur", "Interview room" }) }),
        ({ "/d/sur/common", ({ "Sur", "Commonroom" }) }),
        ({ "/d/sur/Maps", ({ "Sur", "Terrains" }) }),
        ({ "/d/sur/Dinky", ({ "Sur", "Dinky" }) }),
        ({ "/d/sur/Sto_Helit", ({ "Sur", "Sto Helit" }) }),
        ({ "/d/sur/StoLat", ({ "Sur", "Sto Lat" }) }),
        ({ "/d/sur/Hillshire", ({ "Sur", "Hillshire" }) }),
        ({ "/d/sur/Holywood", ({ "Sur", "Holywood" }) }),
        ({ "/d/sur/Nowhere", ({ "Sur", "Nowhere" }) }),
        ({ "/d/sur/PekanFord", ({ "Sur", "Pekan Ford" }) }),
        ({ "/d/sur/Sheepridge", ({ "Sur", "Sheepridge" }) }),
        ({ "/d/sur/Scrogden", ({ "Sur", "Scrogden" }) }),
        ({ "/d/sur/items/carriage", ({ "Sur", "Carriage" }) }),
        ({ "/d/sur", ({ "Sur", "?" }) }),
        ({ "/d/guilds/assassins/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/assassins/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/assassins/Sheepridge", 
            ({ "Sur", "Sheepridge guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/thieves/Pekan_Ford", ({ "Sur", "PF guilds" }) }),
        ({ "/d/guilds/warriors/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/priests/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/wizards/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/witches/skund", ({ "Sur", "Skund guilds" }) }),
        ({ "/d/guilds/witches/stolat", ({ "Sur", "SL guilds" }) }),

        ({ "/d/forn/utils/interview", ({ "Forn", "Interview room" }) }),
        ({ "/d/forn/common", ({ "Forn", "Commonroom" }) }),
        ({ "/d/forn/genua", ({ "Forn", "Genua" }) }),
        ({ "/d/forn", ({ "Forn", "?" }) }),
        ({ "/d/guilds/assassins/Genua", ({ "Forn", "Genua guilds" }) }),

        ({ "/d/special/utils/interview", ({ "Special", "Interview room" }) }),
        ({ "/d/special/common", ({ "Special", "Commonroom" }) }),
        ({ "/d/special/ctf", ({ "Special", "CTF" }) }),
        ({ "/d/special", ({ "Special", "?" }) }),
        
        ({ "/d/playtesters/utils/interview", ({ "Playtesters", 
            "Interview room" }) }),
        ({ "/d/playtesters/common", ({ "Playtesters", "Commonroom" }) }),
        ({ "/d/playtesters/palace_rooms", ({ "Playtesters", "Palace" }) }),
        ({ "/d/playtesters", ({ "Playtesters", "?" }) }),

        ({ "/d/liaison/utils/interview", ({ "Liaison", "Interview room" }) }),
        ({ "/d/liaison/common", ({ "Liaison", "Commonroom" }) }),
        ({ "/d/liaison", ({ "Liaison", "?" }) }),
        
        ({ "/d/underworld/common", ({ "Underworld", "Commonroom" }) }),
        ({ "/d/underworld/death", ({ "Underworld", "Death's domain" }) }),
        ({ "/d/underworld/lspace", ({ "Underworld", "L-space" }) }),
        ({ "/d/underworld/moving_shop", ({ "Underworld", "T-shop" }) }),
        ({ "/d/underworld", ({ "Underworld", "?" }) }),
        
        ({ "/d/guilds/common", ({ "Guilds", "Commonroom" }) }),
        ({ "/d/guilds/assassins", ({ "Guilds", "Assassins" }) }),
        ({ "/d/guilds/thieves", ({ "Guilds", "Thieves" }) }),
        ({ "/d/guilds/warriors", ({ "Guilds", "Warriors" }) }),
        ({ "/d/guilds/priests/rooms", ({ "Guilds", "Passage rooms" }) }),
        ({ "/d/guilds/priests", ({ "Guilds", "Priests" }) }),
        ({ "/d/guilds/wizards", ({ "Guilds", "Wizards" }) }),
        ({ "/room/magic_circle", ({ "Guilds", "Witches' circle" }) }),
        ({ "/d/guilds/witches", ({ "Guilds", "Witches" }) }),
        ({ "/d/guilds", ({ "Guilds", "?" }) }),
        
        ({ "/d/admin/room/domain_control", ({ "Admin", "Domain control" }) }),
        ({ "/d/admin", ({ "Admin", "?" }) }),

        ({ "/d", ({ "Other", "Unknown /d room" }) }),
   
    });
    
    
    if( !environment(person) ) {
        return ({ "Other", "No environment" });
    }
    
    foreach( place in areas ) {
        if( strsrch( file_name(environment(person)), place[0] ) == 0 ) {
            return place[1];
        }
    }
    
    return ({ "Other", "Unknown environment" });
    
} /* determine_location() */


int get_guild_id(object person) {
    switch(person->query_guild_ob()) {
        case "/std/guilds/warrior":
            return 0;
        case "/std/guilds/assassin":
            return 1;
        case "/std/guilds/thief":
            return 2;
        case "/std/guilds/wizard":
            return 3;
        case "/std/guilds/priest":
            return 4;
        case "/std/guilds/witch":
            return 5;
        default:
            return 6;
    }
} /* get_guild_id() */


mapping get_dist( string filter, string arg ) {
    mapping ps;
    object *people, person;
    string *loc;
    int to_add;
    
    people = filter( users(), (: !$1->query_creator() && 
        $1->query_name() != "logon" :) );
    ps = ([ ]);
    
    foreach( person in people ) {
    
        loc = determine_location(person);
        
        if( !ps[loc[0]] ) {
            if( filter == "average" ) {
                ps[loc[0]] = ({ ([ ]), 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]] = ({ ([ ]), 0, 0 });
            }
        }
        ps[loc[0]][1]++;
        
        if( !ps[loc[0]][0][loc[1]] ) {
            if( filter == "average" ) {
                ps[loc[0]][0][loc[1]] = ({ 0, ({ -1, 0, 0 }) });
            }
            else {    
                ps[loc[0]][0][loc[1]] = ({ 0, 0 });
            }
        }
        ps[loc[0]][0][loc[1]][0]++;
        
        switch(filter) {
            case "verbosity":
                if( person->query_verbose(arg) ) {
                    ps[loc[0]][2]++;
                    ps[loc[0]][0][loc[1]][1]++;
                }
                break;
            
            case "average":
                to_add = 0;
                if( arg == "guild level" ) {
                    to_add = person->query_level();
                }
                if( arg == "rating" ) {
                    to_add = (int)TOP_TEN_HANDLER->calculate_rating(person);
                }
                if( arg == "age" ) {
                    to_add = -person->query_time_on();
                }
                
                if( to_add < ps[loc[0]][2][0] || ps[loc[0]][2][0] == -1 ) {
                    ps[loc[0]][2][0] = to_add;
                }
                ps[loc[0]][2][1] += to_add;
                if( to_add > ps[loc[0]][2][2] ) {
                    ps[loc[0]][2][2] = to_add;
                }
                
                if( to_add < ps[loc[0]][0][loc[1]][1][0] || 
                    ps[loc[0]][0][loc[1]][1][0] == -1 ) {
                    
                    ps[loc[0]][0][loc[1]][1][0] = to_add;
                }
                ps[loc[0]][0][loc[1]][1][1] += to_add;
                if( to_add > ps[loc[0]][0][loc[1]][1][2] ) {
                    ps[loc[0]][0][loc[1]][1][2] = to_add;
                }
                
                break;
            
            case "category":
                if( arg == "guild" ) {
                    if( !ps[loc[0]][2] ) {
                        ps[loc[0]][2] = ({0,0,0,0,0,0,0});
                    }
                    if( !ps[loc[0]][0][loc[1]][1] ) {
                        ps[loc[0]][0][loc[1]][1] = ({0,0,0,0,0,0,0});
                    }
                    to_add = get_guild_id(person);
                    ps[loc[0]][2][to_add]++;
                    ps[loc[0]][0][loc[1]][1][to_add]++;
                }
                break;
            
            default:
        }
    }
    
    return ps;

} /* get_dist() */


int cmd( string filter, string arg, int verbose ) {
    string place, zone, *guilds;
    mapping players, zones;
    int total, i, j;
    string tmp;
    string ret;

    ret = "";
    players = get_dist(filter,arg);
    total = sizeof(filter( users(), (: !$1->query_creator() && 
        $1->query_name() != "logon" :) ));
    
    guilds = ({ "Warriors", "Assassins", "Thieves", "Wizards", "Priests", 
        "Witches", "Adventurers" });
    
    tmp = "\n";
    tmp+= sprintf( "%-27s", "Distribution of players:" );
    
    if( filter == "category" && arg == "guild" ) {
        j = (this_player()->query_cols() - 27) / (sizeof(guilds));
        for( i=0; i<sizeof(guilds); i++ ) {
            tmp += sprintf( "%" + j + ".3s", guilds[i] );
        }
    }
    if( filter == "average" ) {
        if( arg == "age" ) {
            j = (this_player()->query_cols() - 27);
            tmp += sprintf( "%-" + j + "s", "   Average age" );
        }
        else {
            j = (this_player()->query_cols() - 27) / 3;
            tmp += sprintf( "%" + j + "s", "Lowest" );
            tmp += sprintf( "%" + j + "s", "Average" );
            tmp += sprintf( "%" + j + "s", "Highest" );
        }
    }
    
    tmp += "\n\n";
    ret += tmp;

    foreach( place in keys(players) ) {
        
        tmp = "%^YELLOW%^";
        tmp+= sprintf( "%-24.24s", place );
        tmp+= sprintf( "%3.1i", players[place][1] );
        
        switch( filter ) {
            case "verbosity": 
                tmp += players[place][2] + "/" + 
                    players[place][1] + " verbose " + arg;
                break;
            
            case "average":
                if( arg == "age" ) {
                    tmp += sprintf( "%-"+ j +"s", "   " + query_time_string(
                        players[place][2][1] / players[place][1] ) );
                }
                else {
                    tmp += sprintf( "%"+ j +".1i", players[place][2][0] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][1] /             
                        players[place][1] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][2] );
                }
                break;
            
            case "category":
                if( arg == "guild" ) {
                    for( i=0; i<sizeof(guilds); i++ ) {
                        tmp += sprintf( "%" + j + ".1i", 
                            players[place][2][i] );
                    }
                }
                break;
            
            default:
                tmp += "   (";
                tmp += sprintf( "%3s", 
                    ((100 * players[place][1]) / total + "%") );
                tmp += ")";
                break;
   
        } 
        tmp += "%^RESET%^";
        tmp += "\n";
        ret += tmp;

        if (verbose) {
           zones = players[place][0];
           foreach( zone in keys( zones ) ) {
        
               tmp = sprintf( "%-24.24s", ("  - " + zone) );
               tmp+= sprintf( "%3.1i", zones[zone][0] );
               
               switch( filter ) {
                   case "verbosity": 
                       tmp += " (" + zones[zone][1] + "/" + zones[zone][0] + 
                           " verbose " + arg + ")";
                       break;
                   
                   case "average":
                       if( arg == "age" ) {
                           tmp += sprintf( "%-"+ j +"s", "   " + 
                               query_time_string( zones[zone][1][1] /             
                               zones[zone][0] ) );
                       }
                       else {
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][1] /             
                               zones[zone][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][2] );
                       }
                       break;
                   
                   case "category":
                       if( arg == "guild" ) {
                           for( i=0; i<sizeof(guilds); i++ ) {
                               if( !zones[zone][1][i] ) {
                                   tmp += "%^BLACK%^";
                                   tmp += sprintf( "%" + j + ".1i",
                                        zones[zone][1][i] );
                                   tmp += "%^RESET%^";
                               }
                               else {
                                   tmp += sprintf( "%" + j + ".1i",
                                       zones[zone][1][i] );
                               }
                           }
                       }
                       break;
                   
                   default:
                       tmp += "   (";
                       tmp += sprintf( "%3s", 
                           ((100 * zones[zone][0]) / total + "%") );
                       tmp += ")";
                       break;
               }                 
               tmp += "\n";
               ret += tmp;
           }
        }
        if (verbose) {
           ret += "\n";
        }
    }
    
    ret += "Total = " + total + "\n";
    write("$P$Distribution$P$" + ret);
    
    return 1;

} /* cmd() */


mixed *query_patterns() {
    return ({ 
        "by domain", (: cmd(0, 0, 0) :),
        //"by verbose <string'type'>", (: cmd("verbosity", $4[0], 0) :),
        "by guild level",  (: cmd("average", "guild level", 0) :),
        "by rating",  (: cmd("average", "rating", 0) :),
        "by age",  (: cmd("average", "age", 0) :),
        "by guild",  (: cmd("category", "guild", 0) :),
        "verbose by domain", (: cmd(0, 0, 1) :),
        //"verbose by verbose <string'type'>", (: cmd("verbosity", $4[0], 1) :),
        "verbose by guild level",  (: cmd("average", "guild level", 1) :),
        "verbose by rating",  (: cmd("average", "rating", 1) :),
        "verbose by age",  (: cmd("average", "age", 1) :),
        "verbose by guild",  (: cmd("category", "guild", 1) :),
    });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/qwho.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/data.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/data.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626880   Available: 13574234
Inodes: Total: 5242880    Free: 4960132
746 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/data.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626880   Available: 13574234
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
* @ignore
*/
#include <creator.h>

inherit "/cmds/base";


/**
 * This dumps out stuff about the object.
 */
int cmd(object *obs, string var) {
    object ob;

    foreach (ob in obs) {
        if ( userp(ob) && !master()->query_lord( this_player()->query_name() ) ) {
            write("You cannot dump a player object.\n");
            continue;
        }
        else {
            this_player()->more_string( WIZ_PRESENT->desc_object( ob ) + ":\n" +
              debug_info( 2, ob ) + "\n", "Data" );
        }
    }
    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd($1, 0) :) });
         //"<indirect:wiz-present> <string'variable'>", (: cmd($1, $4[1]) :),
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/data.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ftpwho.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ftpwho.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626880   Available: 13574234
Inodes: Total: 5242880    Free: 4960132
826 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ftpwho.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626880   Available: 13574234
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: ftpwho.c,v 1.5 2003/05/21 03:46:41 ceres Exp $
 */

inherit "/cmds/base";

#define FTPD "/secure/ftpd"
#define UNIX_FTPD "/secure/ftp_auth"

mixed cmd(string) {
  mixed *who_unix, *who;
  int i;

  if(!find_object(FTPD)) {
    write("MUD FTP is currently disabled.\n");
  } else {
    who = FTPD->query_connections();
    if ((i = sizeof(who))) {
      write("People currently using MUD FTP :\n");
      while (i--)
        write(" - "+who[i]+"\n");
    } else {
      write("No one is using MUD FTP at the moment.\n");
    }
  }
  who_unix = UNIX_FTPD->query_connections();
  if ((i = sizeof(who_unix))) {
    write("People currently using UNIX FTP :\n");
    while (i--)
      write(" - "+who_unix[i]+"\n");
  } else {
    write("No one is using UNIX FTP at the moment.\n");
  }
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/ftpwho.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/setmin.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/setmin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626879   Available: 13574233
Inodes: Total: 5242880    Free: 4960132
825 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/setmin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626879   Available: 13574233
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: setmin.c,v 1.2 1998/04/14 02:40:30 pinkfish Exp $
 * $Log: setmin.c,v $
 * Revision 1.2  1998/04/14 02:40:30  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if(sizeof(explode("^"+str, "$N")) < 2 ||
       sizeof(explode("^"+str, "$F")) < 2)
      return notify_fail("Must have a $N and a $F in your entry message.\n");
    TP->set_msgin(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
} /* cmd() */

mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/setmin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/twiki.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/twiki.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626879   Available: 13574233
Inodes: Total: 5242880    Free: 4960132
1003 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/twiki.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626879   Available: 13574233
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

#include <cmds/twiki.h>

#define DAY (24 * 60 * 60)

int cmd(int days) {
   string str;

   if (days <= 0) {
      add_failed_mess("The number of days must be higher than 0.\n");
      return 0;
   }
   if (days > 10) {
      add_failed_mess("You are limited to a maximum of ten days of "
        "twiki changes.  Consult the automated commonroom twiki post "
        "for further historical information.\n");
      return 0;
   }
   
   str = TWIKI_HANDLER->find_changes(time() - days * DAY);
   write(str);
   return 1;
} /* cmd() */

int cmd_file(string fname) {
   string str;

   str = TWIKI_HANDLER->query_file(fname);
   if (!str) {
      add_failed_mess("The twiki file " + fname + " does not exist.\n");
      return 0;
   }

   write("$P$" + fname + "$P$" + str);
   return 1;
} /* cmd() */

mixed *query_patterns() {
   return ({ "changes [since] <number'days'>", (: cmd($4[0]) :),
             "view <string'file'>", (: cmd_file($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/twiki.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/dir_s.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/dir_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626878   Available: 13574232
Inodes: Total: 5242880    Free: 4960132
642 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/dir_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626878   Available: 13574232
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: dir_s.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: dir_s.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* dirs command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

#include <peopler.h>
#include <creator.h>

mixed cmd(string str) {
   mixed *stuff;

   stuff = this_player()->query_property("dir list");
   if (!stuff) {
      stuff = D_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/dir_s.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/loc_alcmd.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/loc_alcmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626878   Available: 13574232
Inodes: Total: 5242880    Free: 4960132
2612 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/loc_alcmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626878   Available: 13574232
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: loc_alcmd.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: loc_alcmd.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* localcmd command, trial out by Turrican for a commands daemon. */
/* New localcmd Pinkfish 19/5/93 */

#include <creator.h>

mixed cmd(string str) {
  int flags, i, j, pos;
  mixed flag_types;
  object *obs;
  string *coms, flag;
  mixed *junk;

  if (!str) str = "";
  flag_types = ({ "priority", "star", "function", "object" });
  while (strlen(str) && str[0] == '-') {
    if (sscanf(str, "-%s %s", flag, str) != 2) {
      flag = str[1..100];
      str = "";
    }
    i = member_array(flag, flag_types, 1);
    if (i != -1) {
      flags |= 1 << i;
    }
  }
  if (!flags) {
    if (!strlen(str))
      coms = actions_defined(this_player());
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_player());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
      coms = map(obs, (: actions_defined($1) :));
    }
  } else {
    if (!strlen(str))
      junk = actions_defined(0, 0, flags);
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_object());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
/* I should be able to do this...  
 * Darn didnt work...  sigh...
      junk = actions_defined(obs, 0, flags);
 */
      junk = map(obs, (: actions_defined($1, 0, $(flags)) :));
    }
    coms = ({ });
    for (i=1;i<sizeof(junk);i+=2) {
      pos = 0;
      str = junk[i-1];
      if ((flags&0xc) == 0xc) {
        str = WIZ_PRESENT->desc_f_object(junk[i][0])+"->"+junk[i][1]+":"+str;
        pos += 2;
      } else if (flags&0x8) {
/* First object... */
        str = WIZ_PRESENT->desc_object(junk[i][0])+":"+str;
        pos++;
      } else if (flags&0x4) {
        str = junk[i][0]+"%"+str;
        pos++;
      }
      if (flags&0x2) {
        if (j = junk[i][pos]) {
          if (strlen(junk[i-1]) == j)
            str += "*";
          else {
            j = strlen(str)-junk[i][pos];
            str = str[0..j]+"*"+str[j+1..10000];
          }
        }
        pos++;
      }
      if (flags&1) {
        str += "|"+junk[i][pos];
      }
      coms += ({ str });
    }
  }
  this_player()->more_string( sprintf( "%-#*s\n", 
      (int)this_player()->query_cols(),
      implode( coms, "\n" ) ), "Commands" );
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/loc_alcmd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/mudinfo.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/mudinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626877   Available: 13574231
Inodes: Total: 5242880    Free: 4960132
2572 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/mudinfo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626877   Available: 13574231
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: mudinfo.c,v 1.3 2002/03/24 20:22:44 wodan Exp $
 */
inherit "/cmds/base";
/* Display various information about the mud's status.

   File taken from the VikingMUD lib.  Written by Kniggit 930525

   Hamlet added some stuff, May 1997.
   Hamlet got annoyed and reworked the code, Jul 1997.
*/
 
#ifndef __COMPILER__
#define __COMPILER__     "probably gcc"
#define __OPTIMIZATION__ "bugged driver?"
#endif

#define WIDTH 15

#define PAD(x,y)      sprintf("%-*s: %s\n", WIDTH, x,"" + y)

varargs string pretty_time(int tim, int len);

private nosave int num_obs;

mixed cmd(string str) {
   mapping r;
   float cpu;
   string name, cc, tmp;
   int *ltype; //link type
   
   name = capitalize(mud_name()) + "   (" + query_host_name() + " " + 
          __PORT__ + ")";
   cc = __COMPILER__ + "   (" + __OPTIMIZATION__ + ")";
   r = rusage();
   cpu = ((r["utime"] + r["stime"]) / uptime() / 10.0);
   num_obs = 0;
   objects((: num_obs++ :));
   ltype = implode(users(), (:$1[compressedp($2)]++, $1:), ({0,0}));

   tmp = PAD("Mud name", name) +
         PAD("Driver", __VERSION__) +
         PAD("Architecture", __ARCH__) +
         PAD("Compiler", cc) +
         PAD("Driver uptime", pretty_time(uptime(), 4)) +
         PAD("Avg Cpu usage", sprintf("%4.2f%%",cpu)) +
         PAD("Load Average", query_load_average()) +
         PAD("No of users", sizeof(users())) +
         PAD("Using MCCP", ltype[1]) +
         PAD("Plain telnet", ltype[0]) +
         PAD("Named Livings", sizeof(named_livings())) + 
         PAD("Objects", num_obs) +
         PAD("Call Outs", sizeof(call_out_info()) + " pending.") +
         PAD("Memory usage", memory_info());

   tell_object(this_player(), tmp);
   return 1;
}


/*
   pretty_time() simul efun
   Converts seconds into "2 days, 3 seconds" for example
*/

varargs string pretty_time(int tim, int len) {
   int num;
   string *bits, tmp;

   if(!len)
     len = 99999;

   bits = ({ });
   if(tim >= 60*60*24 && sizeof(bits) < len)
      bits += ({ (num=tim/(60*60*24))+" day"+(num==1?"":"s") });
   if(tim >= 60*60 && tim%(60*60*24) && sizeof(bits) < len)
      bits += ({ (num=(tim/(60*60))%24)+" hour"+(num==1?"":"s") });
   if(tim >= 60 && tim%(60*60) && sizeof(bits) <len)
      bits += ({ (num=(tim/60)%60)+" minute"+(num==1?"":"s") });
   if(tim%60 && sizeof(bits) <len)
      bits += ({ (num=tim%60)+" second"+(num==1?"":"s") });

   for(len =0; len<sizeof(bits); len++)
      if(sscanf(bits[len],"%d %s", num, tmp) == 2 && num == 0)
         bits[len] = 0;

   return implode(bits, ", ");
}
// --- END [/mnt/home2/grok/lib/cmds/creator/mudinfo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/inv.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/inv.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626876   Available: 13574230
Inodes: Total: 5242880    Free: 4960132
790 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/inv.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626876   Available: 13574230
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <creator.h>

inherit "/cmds/base";

protected int cmd( object *obs ) {
    object ob;
    object *inventory;

    foreach( ob in obs ) {
        inventory = filter( all_inventory( ob ),
          (: reference_allowed( $1, $( this_player() ) ) :) );

        tell_object( this_player(), "Inv of " + WIZ_PRESENT->desc_object( ob ) +
          " in " + WIZ_PRESENT->desc_object( 
            environment( ob ) ) + ":\n" );
        tell_object( this_player(), implode( map( inventory,
              (: "  " + WIZ_PRESENT->desc_f_object( $1 ) :) ), "\n" ) + "\n" );

        if ( !sizeof( inventory ) ) {
            continue;
        }
    }
    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "[of] <indirect:wiz-present>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/inv.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/tcheck.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/tcheck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626876   Available: 13574230
Inodes: Total: 5242880    Free: 4960132
1661 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/tcheck.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626876   Available: 13574230
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: tcheck.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: tcheck.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* tcheck command. 
 * It doesn't do nearly all the checks I though it would, but it
 * still finds some.
 */

int cmd( string str ) {
   mixed  err, ret;
   object ob;
   string file, wiz_dir;
   
   if (!this_player()) return 0;
   seteuid(geteuid(this_player()));
   if (!str) {
      notify_fail("Usage: tcheck <file name>\n");
      return 0;
   }   
   wiz_dir = "/w/" + (string)this_player()->query_name();
   if (file_size(wiz_dir)!=-2) {
      notify_fail("Directory: " + wiz_dir + " does not exist.\n");
      return 0;
   }

   if ( str[0..0] != "/" )
     str = (string)this_player()->query_path() + "/" + str;

   if (str[<1..<1]=="0") {
      str=str[0..<2];
   }
   
   if (file_size(str)<0) {
      notify_fail("File: " + str + " does not exist or is a directory.\n");
      return 0;
   }
   file = wiz_dir + "/exec_tmp";
   if (find_object(file)) file->dest_me();
   if (file_size(file+".c")>0) rm(file+".c");
   write_file(file+".c",
              "#pragma strict_types\n" +
              "#pragma save_types\n" +
              "#include \""+ str +"\"\n" +
              "void dest_me_in_exec_temp() { destruct(this_object()); }\n" +
              "\n");
   err = catch(ret = (mixed) file->force_load());
   if (err==0) printf("%s loaded ok.\n", str);
   if (find_object(file)) file->dest_me_in_exec_temp();
   rm(file+".c");
   return 1;
}

void dest_me() {
   destruct(this_object());
}

void clean_up() {
   dest_me();
}

void reset() {
   dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/tcheck.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/tra_ns.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/tra_ns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626875   Available: 13574229
Inodes: Total: 5242880    Free: 4960132
1190 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/tra_ns.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626875   Available: 13574229
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: tra_ns.c,v 1.2 2003/04/11 00:46:24 wodan Exp $
 * $Log: tra_ns.c,v $
 * Revision 1.2  2003/04/11 00:46:24  wodan
 * Forcibly released due to inactivity
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* trans command, trial out by Turrican for a commands daemon. */

#include <creator.h>

mixed cmd(string str) {
  object *obs, ob;

  if (!str || !(sizeof(obs = WIZ_PRESENT->wiz_present(str, this_player())))) {
    write("Transport who ?\n");
    return 1;
  }
  foreach (ob in obs) {
    if (environment(ob) == environment(this_player())) {
      write(WIZ_PRESENT->desc_object(ob)+" is already here.\n");
      continue;
    }
    tell_object( ob, "You are magically transferred somewhere.\n" );
      ob->move_with_look( environment( this_player() ),
            (string)ob->query_mmsgin(), (string)ob->query_mmsgout() );
    log_file("/d/admin/log/trans", "%s transed %s to %s\n", 
             this_player()->query_name(), str, 
             base_name(environment(this_player())));
  }
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/tra_ns.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/delevent.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/delevent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626875   Available: 13574229
Inodes: Total: 5242880    Free: 4960132
914 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/delevent.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626875   Available: 13574229
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Delevent - deletes an entry from the player info database.
 */
#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>

inherit "/cmds/base";

// Command entry point
int delete_event(string s1, string s2, int n)
{
    string  who = lower_case(s1);
    string  event = lower_case(s2);

    if(!PLAYER_HANDLER->test_user(who)) {
        write("No such player: "+who+".  \n");
        return 1;
    }

    if(PLAYERINFO_HANDLER->delete_entry(this_player(),who,event,n))
        write("Entry #" + n + " of " + capitalize(who) +
            "'s dossier deleted.  \n");
    else
        write("Cannot remove entry #" + n + " from " +
            capitalize(who) + "'s dossier.  \n");
    return 1;
}

// Answer the command patterns
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <word'event'> <number'entry-number'>",
        (: delete_event($4[0],$4[1],$4[2]) :)
    });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/delevent.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/perm_it.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/perm_it.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626874   Available: 13574228
Inodes: Total: 5242880    Free: 4960132
13543 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/perm_it.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626874   Available: 13574228
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: perm_it.c,v 1.7 2003/05/13 18:25:01 ceres Exp $
 * $Log: perm_it.c,v $
 * Revision 1.7  2003/05/13 18:25:01  ceres
 * Modified to allow multiple assignments
 *
 * Revision 1.6  2003/04/18 00:14:23  pinkfish
 * Remove the update abilioty.
 *
 * Revision 1.5  2003/04/17 20:56:20  pinkfish
 * Add in some code to update the error assignments.
 *
 * Revision 1.4  2003/03/27 22:14:01  trilogy
 * Was using /secure/login.
 *
 * Revision 1.3  2003/03/21 17:14:48  drakkos
 * Added a filter option for permit assignment summary
 *
 * Revision 1.2  2003/03/05 22:46:28  pinkfish
 * Make it sort the keys correctly and make it pick up details of domain
 * directory assignments.
 *
 * Revision 1.1  2003/03/05 18:57:00  pinkfish
 * Initial revision
 *
 * Revision 1.6  2003/03/04 23:01:49  pinkfish
 * Allow you to remove permissions too.
 *
 * Revision 1.5  2003/03/04 22:29:34  pinkfish
 * Add in directory stuff.
 *
 * Revision 1.4  1999/01/21 18:35:19  ceres
 * Forgot to remove a debug statement.
 *
 * Revision 1.2  1999/01/20 00:54:55  ceres
 * Modified add_command
 *
 * Revision 1.1  1998/12/29 06:03:04  ceres
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <access.h>
#include <player_handler.h>
#include <error_handler.h>

inherit "/cmds/base";

#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8

int help();

mixed cmd(string command, string euid, string path) {
  string* euids;
  string* bing;

  if (this_player() != this_player(1)) {
    return 0;
  }

  seteuid("Root");
  
  notify_fail("Something went wrong.\n");
  path = (string)this_player()->get_path(path);
  
  switch(command) {
  case "assign" :
    // Assign someone to the directory.
    if (file_size(path) != -2) {
       notify_fail("The path " + path + " does not exist.\n");
       return 0;
    }
    euids = explode(replace_string(euid, " ", ""), ",") - ({ "none" });
    bing = filter(euids, (: !PLAYER_HANDLER->test_creator($1) &&
                            $1 != ERROR_ASSIGNED_NO_ONE:));
    if (sizeof(bing)) {
       notify_fail("The people " + query_multiple_short(bing) +
                   " are not creators.\n");
       return 0;
    }
    if ((int)master()->assign_people_to_directory(path, euids)) {
       add_succeeded_mess("Assigned the directory " + path +
                         " to " + query_multiple_short(euids) + ".\n");
       return 1;
    }
    notify_fail("Unable to assign the directory, not creator names?\n");
    return 0;

  case "read":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to add read access.\n");
    return (int)master()->add_read_permission(euid, path);
    break;

  case "write":
      if (!master()->high_programmer(previous_object(-1)) &&
          !master()->valid_grant(this_player(), path, WRITE_MASK))
        return notify_fail("You do not have permission to add write "
                           "access.\n");
      return (int)master()->add_write_permission(euid, path);
      break;

  case "grant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to add grant access.\n");
    return (int)master()->add_grant_permission(euid, path);
    break;

  case "lock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->lock_path(path);

  case "noread":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to remove read "
                         "access.\n");
    return (int)master()->remove_read_permission(euid, path);
  break;

  case "nowrite":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, WRITE_MASK))
      return notify_fail("You do not have permission to remove write "
                         "access.\n");
    return (int)master()->remove_write_permission(euid, path);
    break;

  case "nogrant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to remove grant "
                         "access.\n");
    return (int)master()->remove_grant_permission(euid, path);
    break;

  case "unlock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->unlock_path(path);
    break;

  default:
    return help();
  }
} /* cmd() */

int do_directory_summary(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;

   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }   
   //paths = sort_array( keys( assignments ), "list_before", this_object() );
   paths = sort_array( keys( assignments ), 1 );
   ret = sprintf("%40-s Assigned To\n", "Path");
   foreach (path in paths) {
      ret += sprintf("%-40s %s\n", path, query_multiple_short(assignments[path]));
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}

// This updates the directory assignments
int do_directory_update(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;
   string* bits;

   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }   
   //paths = sort_array( keys( assignments ), "list_before", this_object() );
   paths = sort_array( keys( assignments ), 0 );
   foreach (path in paths) {
      if (sizeof(assignments[path])) {
         bits = explode(path, "/");
         if (bits[0] == "d") {
           ERROR_HANDLER->do_update_directory_assignment(("/d/" + bits[1] + "/master")->query_lord(), assignments[path][0], path, (: 1 :));
         } else {
           ERROR_HANDLER->do_update_directory_assignment("nobody", assignments[path][0], path, (: 1 :));
         }
         write("Updated " + path + " to " + assignments[path][0] + "\n");
      }
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}

int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
   
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!PLAYER_HANDLER->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str; 
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  //paths = sort_array( keys( perms ), "list_before", this_object() );
  paths = sort_array( keys( perms ), 1 );
  if (!sizeof(paths)) {
    ret = "No permissions set.\n";
  } else {
    ret = sprintf("%11-s    Path\n", "Euid");
  }
  for (i=0;i<sizeof(paths);i++) {
    euids = keys(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
} /* do_summary() */

int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;

   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !PLAYER_HANDLER->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
} /* do_tidy() */

int help() {
  write("Available commands:\n"
"  read    <euid> <path>     : add read permison to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n"
"  assign <euid> <path>      : assigns someone to look after a directory.\n"
"  assignment summary        : summary of directory assignments.\n" );
   return 1;
}

mixed *query_patterns() {
  return ({ "summary", (: do_summary(0) :),
              "summary <string>", (: do_summary($4[0]) :),
              "assignment summary", (: do_directory_summary(0) :),
//              "assignment update", (: do_directory_update(0) :),
              "assignment summary <string'filter'>", (: do_directory_summary($4[0]) :),

              "tidy", (: do_tidy() :),
              "help", (: help() :),
              "<word'permission'> <string'euid'> <word'path'>",
              (: cmd($4[0], $4[1], $4[2] ) :)
#ifdef 0
              ,
              "write <string'euid'> <string>", (: cmd("write", $4[0], $4[1]) :),
              "grant <string'euid'> <string>", (: cmd("grant", $4[0], $4[1]) :),
              "lock <string'euid'> <string>", (: cmd("lock", $4[0], $4[1]) :),
              "noread <string'euid'> <string>", (: cmd("noread", $4[0], $4[1]) :),
              "nowrite <string'euid'> <string>", (: cmd("nowrite", $4[0], $4[1]) :),
              "nogrant <string'euid'> <string>", (: cmd("nogrant", $4[0], $4[1]) :),
              "unlock <string'euid'> <string>", (: cmd("unlock", $4[0], $4[1])
                                                 :),
#endif        
              });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/perm_it.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/setmout.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/setmout.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626871   Available: 13574225
Inodes: Total: 5242880    Free: 4960132
829 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/setmout.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626871   Available: 13574225
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: setmout.c,v 1.2 1998/04/14 02:41:29 pinkfish Exp $
 * $Log: setmout.c,v $
 * Revision 1.2  1998/04/14 02:41:29  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(string str) {

  if(TP->query_creator() || TP->query_property("setm")) { 
    str = str + " ";
    if(sizeof(explode("^"+str, "$N")) < 2 ||
       sizeof(explode("^"+str, "$T")) < 2)
      return notify_fail("Must have a $N and a $T in your exit message.\n");
    TP->set_msgout(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
} /* cmd() */

mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/setmout.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/net_stat.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/net_stat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626871   Available: 13574225
Inodes: Total: 5242880    Free: 4960132
621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/net_stat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626871   Available: 13574225
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: taffyd $
 * $Id: ne_tstat.c,v 1.1 1998/01/06 05:25:41 ceres Exp taffyd $
 * $Log: ne_tstat.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
#include <creator.h>
inherit "/cmds/base";

#include <peopler.h>
#include <creator.h>

mixed cmd(string str) {
   mixed *stuff;

   stuff = this_player()->query_property("netstat list");
   if (!stuff) {
      stuff = N_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/net_stat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/fixed.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/fixed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626870   Available: 13574224
Inodes: Total: 5242880    Free: 4960132
1362 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/fixed.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626870   Available: 13574224
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
#include <db.h>

inherit "/cmds/base";

int db;

void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;

   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Fixer"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
} /* finish_request() */

int cmd(string who){
   string request;

   if(who == "all") {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer is not NULL and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   } else {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer = '" + who +
                            "' and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   }

   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}

mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/creator/fixed.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/go_to.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/go_to.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626870   Available: 13574224
Inodes: Total: 5242880    Free: 4960132
3296 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/go_to.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626870   Available: 13574224
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: go_to.c,v 1.4 2002/02/08 18:42:42 pinkfish Exp pinkfish $
 * $Log: go_to.c,v $
 * Revision 1.4  2002/02/08 18:42:42  pinkfish
 * Allow them to handle virtual room stuff more usefully.
 *
 * Revision 1.3  1999/07/03 19:56:52  sin
 * Added support for terrains for gob_ack.c
 *
 * Revision 1.2  1999/07/02 20:41:25  ceres
 * Small changes
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* goto command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
  object dest;
  string *names, nick;
  string tname;

  if (!str)
    return notify_fail("Teleport where?\n");

  nick = (string)this_player()->expand_nickname(str);
  dest = find_living(nick);
  if (!dest && objectp(this_player()->get_obvar(str))) {
    dest = this_player()->get_obvar(str);
    if (dest == environment(this_player()))
      return notify_fail("You look around and realise you are already there.\n");
    this_player()->set_last_location(base_name(environment(this_player())));
    this_player()->move_with_look( dest,
                                   (string)this_player()->query_mmsgin(),
                                   (string)this_player()->query_mmsgout() );
    return 1;
  }
  if (dest) {
    if(dest = environment(dest)) {
      if (dest == environment(this_player()))
        return notify_fail("You look around and realise you are already "
                           "there.\n");

      this_player()->set_last_location(base_name(environment(this_player())));
      this_player()->move_with_look( dest,
            (string)this_player()->query_mmsgin(),
            (string)this_player()->query_mmsgout() );
      return 1;
    } else
      return notify_fail(capitalize(nick) + " is not standing in a location.\n");
  } else {
    names = (string *)this_player()->get_cfiles(str);
    if(sizeof(names)) {
      str = names[0];
    } else {
      // If is had a : try anyway.
      if (strsrch(str, ":") == -1) {
         return notify_fail("No such room.\n");
      }
      if (str[0] != '/') {
         str = this_player()->query_current_path() + "/" + str;
      }
    }
    dest = load_object(str);
    if (!dest) {
      return notify_fail("Failed to load " + str + "\n");
    } else if(!dest->query_property("location")) {
      return notify_fail("Not a room: " + str + "\n");
    } else {
      if (dest == environment(this_player())) {
        notify_fail("You look around and realise you are already there.\n");
        return 0;
      }

      if (environment(this_player())) {
         tname = environment(this_player())->query_property("terrain name");
         if (tname) {
           this_player()->set_last_location(
             ({ tname, environment(this_player())->query_co_ord() })
             );
         } else {
           this_player()->set_last_location(
             base_name(environment(this_player()))
             );
         }
      }
      this_player()->move_with_look( dest,
                                     (string)this_player()->query_mmsgin(),
                                     (string)this_player()->query_mmsgout() );
      return 1;
    }
  }
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/go_to.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/compare2.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/compare2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626869   Available: 13574223
Inodes: Total: 5242880    Free: 4960132
1551 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/compare2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626869   Available: 13574223
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// for WIZ_PRESENT
#include <creator.h>

inherit "/cmds/base";

string format_data( object *items, object victim, object target ) {
    int size;
    string vname, tname;

    vname = victim->the_short();
    tname = target->the_short();

    switch( size = sizeof( items ) ) {
    case 0:
        return "No objects in " + vname + " were cloned by " +
        tname;

    case 1:
        return "One object, " + query_multiple_short( items ) + 
        " in " + vname + "'s inventory was cloned by " + 
        tname;

    default:
        return query_num( size, 100 ) + " objects in " + 
        vname + "'s inventory were cloned by " + tname;		
    }

} /* format_data() */

void describe_objects( object player1, object player2 ) {
    string mess;
    mapping data;

    data = filter( unique_mapping( all_inventory( player1 ), 
        (: $1->query_cloned_by() :) ), 
      (: $1 == $(player2)->query_name() :) );

    if ( !sizeof( data ) ) {
        data[ player1->query_name() ] = ({ });
    }

    mess = implode( values( map( data, 
          (: format_data( $2, $(player1), $(player2) ) :) ) ), "\n" );

    tell_object( this_player(), "$P$compare$P$" + mess + "." );
} /* describe_objects() */

int cmd( object player1, object player2 ) {
    describe_objects( player1, player2 );
    describe_objects( player2, player1 );
    return 1;
} /* cmd() */

mixed *query_patterns() { 
    return ({ "<indirect:wiz-present> {against|with|and} "
      "<indirect:wiz-present>",
      (: cmd( $1[0][0], $1[1][0] ) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/compare2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/upg_rade.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/upg_rade.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626868   Available: 13574222
Inodes: Total: 5242880    Free: 4960132
586 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/upg_rade.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626868   Available: 13574222
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: upg_rade.c,v 1.2 2003/03/21 19:53:29 ceres Exp $
 * $Log: upg_rade.c,v $
 * Revision 1.2  2003/03/21 19:53:29  ceres
 * Modified for new login object
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* upgrade command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
  seteuid(geteuid(this_player()));
  (clone_object("/secure/login"))->do_upgrade(this_player());
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/upg_rade.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/findr_edef.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/findr_edef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626868   Available: 13574222
Inodes: Total: 5242880    Free: 4960132
747 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/findr_edef.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626868   Available: 13574222
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
string *find_stuff(object ob, string varname){
  string *variables = variables(ob);
  string *ret = ({});
  if(member_array(varname, variables) > -1){
    object *inhobs = map(inherit_list(ob), (:find_object:));
    object obj;
    foreach(obj in inhobs){
      ret += find_stuff(obj, varname);
    }
    
    if(ret == ({})){
      ret = ({file_name(ob)});
    }
  }
  return ret;
}

int cmd(object ob, string var){
  string *files = find_stuff(ob, var);
  if(sizeof(files) > 1)
    printf("%s is defined in %s and %s.\n", var, implode(files[0..<2], ", "),
           files[<1]);
  else
    write("No redefinition found.\n");
  return 1;
}

string *query_patterns(){
  return ({"<indirect:wiz-present> <word'global'>", (:cmd($1[0], $4[1]):)});
}
// --- END [/mnt/home2/grok/lib/cmds/creator/findr_edef.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ho_me.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ho_me.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626867   Available: 13574221
Inodes: Total: 5242880    Free: 4960132
452 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ho_me.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626867   Available: 13574221
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ho_me.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: ho_me.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* home command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
  write("Usage : alias home goto <wherever> :)\n");
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/ho_me.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/todo.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/todo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626867   Available: 13574221
Inodes: Total: 5242880    Free: 4960132
12210 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/todo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626867   Available: 13574221
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The todo list handler thingy.  A small command to deal with nice little
 * todo lists.<p>
 *
 * NB: This assumes that the creator has a ~/save directory.
 *
 * @author Pinkfish
 * @started Thu Mar 25 21:15:16 PST 1999
 */
inherit "/cmds/base";

class todo_item {
   string type;
   int id;
   int priority;
   string description;
   int time_added;
   int time_to_finish;
}

#define TODO_PRIVATE 0x8000
#define TODO_PRIORITY_MASK (~TODO_PRIVATE)

private mapping todo_lists;
private mapping changed;
private int save_callout_id;

void create() {
   ::create();
   todo_lists = ([ ]);
   changed = ([ ]);
   seteuid("Root");
} /* create() */

private class todo_item *query_todo_list(string player) {
   string data;
   class todo_item *stuff;
   class todo_item *new_stuff;
   class todo_item item;
   class todo_item new_item;

   if (todo_lists[player]) {
      return todo_lists[player];
   }

   /* Read it from the disk... */
   data = read_file("/w/" + player + "/save/todo_list.o");
   if (!data) {
      return ({ });
   }
   stuff = restore_variable(data);
   if (!stuff) {
      return ({ });
   }

   /* Old type, upgrade it. */
   if (sizeof(stuff) &&
       sizeof(stuff[0]) != 6) {
      new_stuff = ({ });
      foreach (item in stuff) {
         new_item = new(class todo_item);
         new_item->priority = item->priority;
         new_item->type = item->type;
         new_item->description = item->description;
         new_item->id = item->id;
         new_item->time_added = time();
         new_item->time_to_finish = time();
         new_stuff += ({ new_item });
      }
      stuff = new_stuff;
   }
   return stuff;
} /* query_todo_list() */

private void save_todo_lists() {
   int times;
   string player;
   string data;

   save_callout_id = 0;
   foreach (player, times in changed) {
      data = save_variable(todo_lists[player]);
      write_file("/w/" + player + "/save/todo_list.o", data, 1);
   }
   changed = ([ ]);
   todo_lists = ([ ]);
} /* save_todo_lists() */

private void set_todo_list(string player, class todo_item *data) {
   todo_lists[player] = data;
   changed[player] = time();
   if (!save_callout_id) {
      save_callout_id = call_out((: save_todo_lists :), 120);
   }
} /* set_todo_list() */

private int query_next_id(string player) {
   class todo_item *data;
   class todo_item item;
   int id;

   data = query_todo_list(player);
   id = 1;
   foreach (item in data) {
      if (item->id >= id) {
         id = item->id + 1;
      }
   }
   return id;
} /* query_next_id() */

string query_priority_name(int priority) {
   string extra;

   extra = " ";
   if (priority & TODO_PRIVATE) {
      extra = "P";
   }
   switch (priority & TODO_PRIORITY_MASK) {
      case 0 :
         return "VL" + extra;
      case 1 :
         return " L" + extra;
      case 2 :
         return " H" + extra;
      case 3 :
         return "VH" + extra;
      case 4 :
         return " U" + extra;
      default :
         return " F" + extra;
   }
} /* query_priority_name() */

int query_priority_number(string priority) {
   int mask;

   priority = lower_case(priority);
   mask = 0;
   if (priority[<1] == 'p') {
      mask = TODO_PRIVATE;
      priority = priority[0..<2];
   }
   switch (priority) {
      case "vl" :
         return 0 | mask;
      case "l" :
         return 1 | mask;
      case "h" :
         return 2 | mask;
      case "vh" :
         return 3 | mask;
      case "u" :
         return 4 | mask;
   }
   return -1;
} /* query_priority_number() */

string query_todo_line(class todo_item item, int brief, int cols) {
  if(brief) {
  return sprintf("%s%-=*s\n",
                  query_priority_name(item->priority),
                  cols - 3, 
                  item->description);
  }
  
  return sprintf("#%3d %s (%s) Added at %s\n    %-=*s\n",
                  item->id,
                  query_priority_name(item->priority),
                  item->type,
                  ctime(item->time_added),
                  cols - 4, 
                  item->description);
} /* query_todo_line() */

int sort_function(class todo_item bing,
                  class todo_item bing2) {
   if ((bing->priority & TODO_PRIORITY_MASK) == (bing2->priority & TODO_PRIORITY_MASK)) {
      if (bing->type == bing2->type) {
         return bing->id - bing2->id;
      }
      return strcmp(bing->type, bing2->type);
   }
   return (bing2->priority & TODO_PRIORITY_MASK) - (bing->priority & TODO_PRIORITY_MASK);
} /* sort_function() */

/**
 * Sort it in priority order, then in order of type, then id.
 */
class todo_item *sort_todo_list(class todo_item *data) {
   return sort_array(data, (: sort_function :));
} /* sort_list() */

string query_todo_list_string(class todo_item *items, int brief) {
   class todo_item bing;
   string data;

   data = "";
   if (sizeof(items)) {
      foreach (bing in items) {
         data += query_todo_line(bing, brief, this_player()->query_cols());
      }
   }
   return data;
} /* query_todo_list_string() */

private int list_todo(int brief) {
   class todo_item* items;
   string data;

   items = query_todo_list(this_player()->query_name());
   if (sizeof(items)) {
     data = query_todo_list_string(items, brief);
   } else {
      data = "No items in your todo list.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
} /* list_todo() */

private int list_todo_creator(string player) {
   class todo_item* items;
   string data;

   items = query_todo_list(player);
   if (sizeof(items)) {
      items = filter(items, (: !($1->priority & TODO_PRIVATE) :));
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in " + capitalize(player) + "'s todo list.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
} /* list_todo() */

private int list_todo_priority(int priority) {
   class todo_item *items;
   string data;

   items = query_todo_list(this_player()->query_name());
   items = filter(items, (: ($1->priority & TODO_PRIORITY_MASK) == $(priority) :) );
   if (sizeof(items)) {
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in your todo list with the specified priority.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
} /* list_todo_priority() */

private int list_todo_type(string type) {
   class todo_item *items;
   string data;

   type = lower_case(type);
   items = query_todo_list(this_player()->query_name());
   items = filter(items, (: $1->type == $(type) :) );
   if (sizeof(items)) {
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in your todo list with a type of " + type + ".\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
} /* list_todo_type() */

private int add_item(string priority, string type, string description) {
   int priority_num;
   class todo_item frog;
   class todo_item *data;

   priority_num = query_priority_number(priority);
   if (priority_num == -1) {
      add_failed_mess("Unknown priority '" + priority +
                      "', only VL, L, H, VH and U allowed.\n");
      return 0;
   }

   if (strlen(type) > 10) {
      add_failed_mess("The type cannot be more than 10 characters long.\n");
      return 0;
   }

   /* Check to make sure the directories exist and stuff */
   if (file_size("/w/" + this_player()->query_name() + "/save") != -2) {
      add_failed_mess("There is no save directory in your home directory.  "
                      "This is needed for operation of this command.\n");
      return 0;
   }

   frog = new(class todo_item);
   frog->priority = priority_num;
   frog->description = description;
   frog->type = lower_case(type);
   frog->id = query_next_id(this_player()->query_name());
   frog->time_added = time();
   // default to 1 week finish time.
   frog->time_to_finish = time() + (60 * 60 * 24) * 7;

   data = query_todo_list(this_player()->query_name());
   data += ({ frog });
   data = sort_todo_list(data);
   set_todo_list(this_player()->query_name(), data);
   add_succeeded_mess(({ "You added a new item #" + frog->id +
                         " to your todo list.\n", "" }));
   return 1;
} /* add_item() */

private void confirm_complete_item(string response, int id) {
   class todo_item *data;
   class todo_item item;

   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Ok, canceling the completion of the item.\n");
      return ;
   }
   data = query_todo_list(this_player()->query_name());
   foreach (item in data) {
      if (item->id == id) {
         data -= ({ item });
         set_todo_list(this_player()->query_name(), data);
         write("Ok, completed list id #" + id + ".\n");
         return ;
      }
   }
   write("Unable to find the item.  Someone must have run off with it!\n");
   return ;
} /* confirm_complete_list() */

class todo_item find_todo_id(class todo_item *data, int id) {
   class todo_item item;

   foreach (item in data) {
      if (item->id == id) {
         return item;
      }
   }
   return 0;
} /* find_todo_id() */

private int complete_item(int id) {
   class todo_item *data;
   class todo_item item;

   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      write(query_todo_line(item, 0, this_player()->query_cols()) +
            "Are you sure you wish to complete this todo list item? ");
      input_to((: confirm_complete_item :), 0, id);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id + " to complete.\n");
   return 0;
} /* complete_item() */

private int change_priority(int id, string new_priority) {
   class todo_item *data;
   class todo_item item;
   int priority_num;

   priority_num = query_priority_number(new_priority);
   if (priority_num == -1) {
      add_failed_mess("Unknown priority '" + new_priority +
                      "', only VL, L, H, VH and U allowed.\n");
      return 0;
   }

   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      item->priority = priority_num;
      add_succeeded_mess(({ "Change the priority of #" + id +
                            " to " + new_priority + ".\n", "" }));
      set_todo_list(this_player()->query_name(), data);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id +
                   " to change the priority of.\n");
   return 0;
} /* change_priority() */

private int change_description(int id, string new_description) {
   class todo_item *data;
   class todo_item item;

   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      item->description = new_description;
      set_todo_list(this_player()->query_name(), data);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id +
                   " to change the description of.\n");
   return 0;
} /* change_description() */

mixed *query_patterns() {
   return ({
             "", (: list_todo(1) :),
             "list", (: list_todo(0) :),
             "list type <string'type'>", (: list_todo_type($4[0]) :),
             "list urgent", (: list_todo_priority(4) :),
             "list very high", (: list_todo_priority(3) :),
             "list high", (: list_todo_priority(2) :),
             "list low", (: list_todo_priority(1) :),
             "list very low", (: list_todo_priority(0) :),
               "list brief", (: list_todo(1) :), 
             "creator <string'name'>", (: list_todo_creator($4[0]) :),
             "add <word'priority'> <word'type'> <string'description'>",
                   (: add_item($4[0], $4[1], $4[2]) :),
             "complete <number'todo id'>", (: complete_item($4[0]) :),
             "change priority <number'todo it'> <word'priority'>",
                   (: change_priority($4[0], $4[1]) :),
             "change description <number'todo id'> <string'description'>",
                   (: change_description($4[0], $4[1]) :),
           });
} /* query_patterns() */

void dest_me() {
   save_todo_lists();
   ::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/cmds/creator/todo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/compare.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/compare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626864   Available: 13574218
Inodes: Total: 5242880    Free: 4960132
1609 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/compare.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626864   Available: 13574218
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// for WIZ_PRESENT
#include <creator.h>

inherit "/cmds/base";

int cmd( string words ) {
  string *name = allocate(2);
  string *mess = allocate(2);
  object *person = allocate(2);
  object *tmp;
  object thing;
  mixed *inv = allocate(2);
  mixed *matching = allocate(2);
  int i;
  
  sscanf( words, "%s with %s", name[0], name[1] );
  for( i=0; i<2; i++)
    name[i] = this_player()->expand_nickname( name[i] );
    
  for( i=0; i<2; i++) {
    if( !(person[i] = find_player( name[i] )) )
         return notify_fail("No such player - " + name[i] + ".\n");
    inv[i] = all_inventory( person[i] );
    tmp = ({ });
    foreach( thing in inv[i] )
      if( thing->query_cloned_by() == name[!i] ) tmp += ({ thing });
    if(tmp) {
      switch( arrayp(tmp) ) {
        case 1:  matching[i] = tmp; break;
        default: matching[1] = ({ tmp });
      }
    }
    switch( sizeof(matching[i]) ) {
      case 0:
        mess[i] = "No items in " + name[i] + " were cloned by " + name[!i] + ".\n";
        break;
      case 1:
        mess[i] = "One item in " + name[i] + " was cloned by " + name[!i] + ".\n";
        mess[i] += "  " + WIZ_PRESENT->desc_f_object(matching[i][0]) + "\n";
        break;
      default:
        mess[i] = sizeof(matching[i]) + " items in " + name[i] + 
                                       " were cloned by " + name[!i] + ".\n";
        foreach( thing in matching[i] )
          mess[i] += "  " + WIZ_PRESENT->desc_f_object(thing) + "\n";
    }
  }
  write(mess[1] + "\n" + mess[0]);
  //tell_creator("mansarde", "\nwords: %s\nmatching: %O\n", words, matching );
  
  return 1;
}// --- END [/mnt/home2/grok/lib/cmds/creator/compare.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/stats.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/stats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626863   Available: 13574217
Inodes: Total: 5242880    Free: 4960132
6552 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/stats.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626863   Available: 13574217
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

#define TP this_player()
#define STATS ({"con", "dex", "int", "str", "wis"})

#define GUILDS ({"assassin", "priest", "thief", "warrior", "witch", "wizard"})
#define TREES ({"covert", "crafts", "faith", "fighting", "magic", "other" })

string get_stat(string s) {
  switch(s) {
  case "S": return "str";
  case "I": return "int";
  case "W": return "wis";
  case "D": return "dex";
  case "C": return "con";
  }
}

int cmd() {
  object user;
  string guild_ob, stat, str;
  mapping stats;
  int val, m, i;
  mapping tmp;
  mapping mode;
  
  stats = ([ ]);
  
  foreach(user in users()) {
    if(user->query_creator() || user->query_known_command("rearrange"))
      continue;
    
    tmp = ([]);
    guild_ob = user->query_guild_ob();

    if(guild_ob)
      guild_ob = guild_ob->query_name();
    
    if(stats[guild_ob])
      tmp = stats[guild_ob];
    else {
      foreach(stat in STATS) {
        tmp[stat] = ({ 0, 0, 0, 0 });
      }
    }

    if(!mode)
      mode = ([ ]);
    if(!mode[guild_ob])
      mode[guild_ob] = ([ ]);

    foreach(stat in STATS) {
      val = call_other(user, "query_real_" + stat);
      tmp[stat][0] += 1;
      tmp[stat][1] += val;
      if(tmp[stat][2] > val || !tmp[stat][2]) {
        tmp[stat][2] = val;
      }
      if(tmp[stat][3] < val) {
        tmp[stat][3] = val;
      }
      
      if(!mode[guild_ob][stat])
        mode[guild_ob][stat] = ([ val : 1 ]);
      else if(!mode[guild_ob][stat][val])
        mode[guild_ob][stat][val] = 1;
      else
        mode[guild_ob][stat][val] += 1;
    } 
    stats[guild_ob] = tmp;
  }

  write("stat: min max mode ave\n");
  foreach(guild_ob in keys(stats)) {
    if(!guild_ob)
      continue;

    printf("\n%s:\n", guild_ob);
    str = "";
    foreach(stat in STATS) {

      // Find the mode.
      m = 0;
      foreach(i in keys(mode[guild_ob][stat]))
        if(mode[guild_ob][stat][i] > m) {
          val = i;
          m = mode[guild_ob][stat][i];
        }

      str += sprintf("  %s: %2d %2d %2d %2d\n",
                     stat,
                     stats[guild_ob][stat][2], stats[guild_ob][stat][3],
                     val, stats[guild_ob][stat][1] / stats[guild_ob][stat][0]);
    }
    printf("%-#*s", this_player()->query_cols(), str);
  }

  printf("\n");
  return 1;
}

int guild(string gstr) {
  string user, stat, gob, tstr, guild;
  mapping count, total;
  int val, i;

  foreach(guild in GUILDS) {
    if(gstr && gstr != guild && gstr != guild+"s" &&
       gstr != guild+"es")
      continue;

    gob = "/std/guilds/" + guild;
    count = ([ ]);
    total = ([ ]);
    foreach(user in users()) {
      if(user->query_guild_ob() != gob || user->query_creator() ||
         user->query_known_command("rearrange"))
        continue;
      
      foreach(stat in STATS) {
        total[stat] += 1;
        val = call_other(user, "query_real_" + stat);
        if(!count[stat])
          count[stat] = ([ val : 1 ]);
        if(!count[stat][val])
          count[stat][val] = 1;
        else
          count[stat][val] += 1;
      }
    }
    
    if(!sizeof(count))
      return notify_fail("No players in that guild.\n");
    
    write("\nStats for " + guild + "\n");
    
    foreach(stat in STATS)
      printf("%-13s", "   " + capitalize(stat));
    write("\n");
    
    for(val = 8; val <= 23; val++) {
      foreach(stat in STATS) {
        tstr = "";
        for(i=0; i<((count[stat][val] * 10) / total[stat]); i++)
          tstr += "#";
        printf("%2d %-10s", val, tstr);
      }
      write("\n");
    }
  }
  return 1;
}

int stats(string sstr) {
  string user, guild, tstr, st;
  mapping count, total;
  int val, i;

  foreach(st in STATS) {
    
    if(sstr && st[0] != sstr[0])
      continue;
    count = ([ ]);
    total = ([ ]);
    
    foreach(user in users()) {
      if(user->query_creator() || user->query_known_command("rearrange"))
        continue;
      
      guild = replace(user->query_guild_ob(), "/std/guilds/", "");
      if(!guild)
        continue;
      
      val = call_other(user, "query_real_" + st);
      if(!count[guild])
        count[guild] = ([ val : 1 ]);
      else
        count[guild][val] += 1;
      total[guild] += 1;
    }
    
    if(!sizeof(count))
      return notify_fail("No players in that guild.\n");
  
    write("\nValues for " + capitalize(st) + "\n");
    foreach(guild in GUILDS)
      printf("%-13s", "   " + capitalize(guild));
    write("\n");
    
    for(val = 8; val <= 23; val++) {
      foreach(guild in GUILDS) {
        tstr = "";
        for(i=0; i<((count[guild][val] * 10) / total[guild]); i++) {
          tstr += "#";
        }
        printf("%2d %-10s", val, tstr);
      }
      write("\n");
    }
  }
  
  return 1;
}

int primaries() {
  string guild, skill, st, stats;
  mapping count;
  int i, total;
  string str;

  write("Guild Primaries\n");
  
  foreach(guild in GUILDS) {
    write(guild + "\n");
    count = ([ ]);
    total = 0;
    str = "";
    
    foreach(skill in ("/std/guilds/" + guild)->query_skills()) {
      stats = "/std/skills"->query_skill_stat(skill);
      total += sizeof(stats);
      for(i=0; i<sizeof(stats); i++) {
        st = get_stat(stats[i..i]);
        count[st] += 1;
      }
    }
    foreach(st in STATS) {
      str += sprintf("  %s: %2d%%\n",
                     capitalize(st), (count[st] * 100) / total);
    }
    printf("%-#*s", this_player()->query_cols(), str);
    write("\n");
  }

  return 1;
}

int skills() {
  string tree, skill, st, stats;
  mapping count;
  int i, total;
  string str;

  write("Guild Primaries\n");
  
  foreach(tree in TREES) {
    write(tree + "\n");
    count = ([ ]);
    total = 0;
    str = "";
    foreach(skill in ("/std/skills")->query_all_children(tree)) {
      stats = "/std/skills"->query_skill_stat(skill);
      total += sizeof(stats);
      for(i=0; i<sizeof(stats); i++) {
        st = get_stat(stats[i..i]);
        count[st] = 1;
      }
    }
    foreach(st in STATS) {
      str += sprintf("  %s: %2d%%\n",
                     capitalize(st), (count[st] * 100) / total);
    }
    printf("%-#*s", this_player()->query_cols(), str);
    write("\n");
  }
  
  return 1;
}

mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "guild", (: guild(0) :),
             "guild <word'guild'>", (: guild($4[0]) :),
             "stat", (: stats(0) :),
             "stat <word'guild'>", (: stats($4[0]) :),
             "primaries", (: primaries() :),
             "skills", (: skills() :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/stats.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/gna_.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/gna_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626862   Available: 13574216
Inodes: Total: 5242880    Free: 4960132
1390 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/gna_.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626862   Available: 13574216
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Mighty Gnaaaah command. 
 * @author Taffyd.
 */ 

inherit "/cmds/base";

// #define USE_WIZ_PRESENT 1

protected int cmd( string pattern, object *obs ) {
    string gn; 
    object ob;
    string verb = query_verb();

    if ( sizeof( explode( verb, "" ) - ({ "g", "n", "a", "h" }) ) ) {
        return 0;
    }

    gn = "gn" + implode( allocate( sizeof( pattern ) - 2, "a" ), "" ) + "h!";

    if ( arrayp( obs ) ) {
        obs = filter( obs, (: !$1->check_earmuffs( "remote-soul" ) :) );
        obs -= ({ this_player() });
        
         if ( sizeof( obs ) ) {
            tell_object( this_player(), "You go '$C$" + gn + "' at " + 
                query_multiple_short( obs ) + ".\n" ); 
                
            foreach (ob in obs) {
                tell_object(ob, this_player()->the_short() + " goes '$C$" +
                    gn + "' at you.\n" );
            }
        
            return 1;    
        }
    }
    
    write( capitalize( gn ) + "\n" );
    return 1;
} /* cmd() */

mixed *query_patterns() {
    mixed *pat = ({ "", (: cmd($6, 0) :) });

    if ( previous_object(1)->query_lord() ) {
        pat += ({ " <indirect:wiz-present>", (: cmd($6, $1) :) });
    }
    else {
        pat += ({ " <indirect:any-living>", (: cmd($6, $1) :),
                  " <indirect:object>", (: cmd($6, $1) :) });
    }
    
    return pat;
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/gna_.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/playerskills.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/playerskills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626861   Available: 13574215
Inodes: Total: 5242880    Free: 4960132
4991 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/playerskills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626861   Available: 13574215
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: playerskills.c,v 1.5 2001/06/07 06:15:15 shrike Exp $
 * $Log: playerskills.c,v $
 * Revision 1.5  2001/06/07 06:15:15  shrike
 * Changed it so it only prompts you for confirmation if there are players in the indirect_obs array.
 *
 * Revision 1.4  2000/07/27 05:35:08  taffyd
 * Added a confirmation prompt.
 *
 * Revision 1.3  2000/03/31 01:24:56  taffyd
 * Made to use wiz-present. :)
 *
 * Revision 1.2  1998/04/14 02:36:20  presto
 * Modified to always show creator's name, regardless of invisibility.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 *
*/
#include <skills.h>

private string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;

   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)pl->query_skill_bonus( tp ) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
} /* rec_list() */

private int real_cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;

/* Only do the first player */
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );
      this_player()->more_string( result, "Skills" );
/*
      this_player()->add_succeeded(players[0]);
      this_player()->add_succeeded_mess(this_object(), ({ "",
                         this_player()->query_name() +
                         " delves skillfully into the internals of $I.\n" }),
                         players[0..0]);
*/

    tell_object( pl, this_player()->query_cap_name() + " is checking "
        "your skills.\n" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
   this_player()->more_string( result, "Skills" );
/*
   this_player()->add_succeeded(players[0]);
   this_player()->add_succeeded_mess(this_object(), ({ "",
                       this_player()->query_name() +
                       " delves skillfully into the internals of $I.\n" }),
                       players[0..0]);
*/
   tell_object( pl, this_player()->query_cap_name() + " is checking your "
       "skills.\n" );
   return 1;
} /* real_cmd() */


private void check_response( string txt, object *indirect_obs, string skill ) {

    int result;

    if ( upper_case( txt ) == "Y" ) {
        result = real_cmd( indirect_obs, skill );
        return;
    }

    tell_object( this_player(), "Not viewing skills.\n" );
} /* check_response() */

private int cmd( object *indirect_obs, string skill ) {
   if ( !sizeof( filter( indirect_obs, (: userp :) ) ) ) {
      check_response( "Y", indirect_obs, skill );
      return 1;
   }

   tell_object( this_player(), "Are you sure you wish to view " +
      query_multiple_short( indirect_obs ) + "'s skills?  You should ask "
      "$V$0=" + indirect_obs[0]->query_possessive() + ",their$V$ "
   "permission first.\n" );

   tell_object( this_player(), "Enter 'Y' to view " +
      query_multiple_short( indirect_obs ) + "'s skill tree.\n" );

   input_to( (: check_response :), 0, indirect_obs, skill );
   return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "<indirect:wiz-present> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:wiz-present>",
            (: cmd($1, 0) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/creator/playerskills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/fetch.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/fetch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626860   Available: 13574214
Inodes: Total: 5242880    Free: 4960132
1693 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/fetch.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626860   Available: 13574214
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Fetch command to retrieve objects from the broken room for players.
 * @author Taffyd
 * @started 29/01/0 2:43AM
 */
#include <move_failures.h>
#include <playerinfo.h>

#define BROKEN_ROOM "/room/broken"

inherit "/cmds/base";

int cmd( mixed *indirect_obs ) {
    object *broken_items, *failed, *success;
    object player;
    
    if ( sizeof( indirect_obs ) != 2 ) {
        return 0;    
    }
    
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You cannot $V an object for more than one "
            "player at once.\n" );
        return 0;
    }
    player = indirect_obs[ 1 ][ 0 ];    
    
    broken_items = indirect_obs[ 0 ];
    
    failed = filter( broken_items,
        (: $1->move( $(player), "$N appear$s in your inventory." ) != MOVE_OK :) );
    
    success = broken_items - failed;
    
    if ( sizeof( failed ) ) {
        tell_object( this_player(), "Warning-- could not move " + 
            query_multiple_short( failed ) + " to " + 
            player->the_short() + ".\n" );
    }
    
    if ( sizeof( success ) ) {
        PLAYERINFO_HANDLER->add_entry(
            this_player(), player->query_name(), "replace", 
            "Fetched " + implode( success->short(), "," ) + " from /room/broken.");
        
        add_succeeded_mess( "$N $V $I for " + player->the_short() + " from "
            "the broken room.\n", success );
        return 1;
    }

    add_failed_mess( "No objects could be retrieved for $I.\n", 
        ({ player }) );
    return -1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "<indirect:object:" + BROKEN_ROOM + "> [for] <indirect:player>", 
        (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/fetch.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/nslookup.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/nslookup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626859   Available: 13574213
Inodes: Total: 5242880    Free: 4960132
92 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/nslookup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626859   Available: 13574213
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/** 
 * nslookup command.
 * Links to the host command.
 */

inherit "/cmds/creator/host";

// --- END [/mnt/home2/grok/lib/cmds/creator/nslookup.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/guildl_ist.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/guildl_ist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626859   Available: 13574213
Inodes: Total: 5242880    Free: 4960132
690 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/guildl_ist.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626859   Available: 13574213
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: guildl_ist.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: guildl_ist.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

int cmd(string arg) {
  object ob;
  mapping guilds;
  string guild, *fields;

  guilds = ([ ]);
  
  foreach(ob in users()) {
    if(ob->query_creator())
      continue;
    
    if(!ob->query_guild_ob()) {
      guilds["none"]++;
    } else {
      fields = explode((string)ob->query_guild_ob(), "/");
      guilds[fields[2]]++;
    }
  }

  write("Guild memberships:\n");
  foreach(guild in keys(guilds))
    printf("  %s: %d\n", guild, guilds[guild]);
  
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/guildl_ist.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/spell.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/spell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626858   Available: 13574212
Inodes: Total: 5242880    Free: 4960132
885 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/spell.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626858   Available: 13574212
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <network.h>

void finish_lookup(object player, string word, int result, mixed* results) {
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "Matches for " + word + ": None.\n");
      } else {
         tell_object(player, "Matches for " + word + ": " +
                             query_multiple_short(map(results, (: $1[1] :))) +
                             "\n");
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
} /* finish_lookup() */

int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->spell_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   add_succeeded_mess("$N look$s up a word.\n");
   return 1;
} /* cmd() */

mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/spell.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/clubs.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626858   Available: 13574212
Inodes: Total: 5242880    Free: 4960132
3099 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626858   Available: 13574212
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: clubs.c,v 1.3 2002/03/01 22:42:50 ceres Exp $
 * 
*/

#include <runtime_config.h>
#include <clubs.h>
#include <mail.h>
#include <money.h>

inherit "/cmds/base";

#define CONTROL_ROOM "/std/room/club_control_room"

// Length of a list entry
#define ELEN 20

private void do_list(string extra, int width);
private void do_invalid(string extra, int width);

mixed cmd(string command, string extra, string rest) {

  if (this_player() != this_player(1))
    return 0;

  switch(command) {
  case "list":
    do_list(extra, this_player()->query_cols());
    break;
  case "invalid":
    do_invalid(extra, this_player()->query_cols());
    break;
  }
  return 1;
} /* cmd() */

private string club_line(string club, int width, int verbose) {
  string tmp, tmp2, member;
  int clubtype, i;

  clubtype = CLUB_HANDLER->query_club_type(club);
  
  tmp = sprintf("%%^BOLD%%^%%^RED%%^%-9s%%^RESET%%^ %-15s\n", 
                CLUB_ARRAY[clubtype]+":", club);

  if(verbose) {
        tmp+= sprintf(" %%^BOLD%%^Club Name:%%^RESET%%^ %s\n",
                  CLUB_HANDLER->query_club_name(club));
    tmp += sprintf(" %%^BOLD%%^Founder:%%^RESET%%^ %s\n"
                   " %%^BOLD%%^Members:%%^RESET%%^\n",
                   CLUB_HANDLER->query_founder(club));
    i = 0;
    tmp2 = "";
    foreach(member in CLUB_HANDLER->query_members(club)) {
      tmp2 += sprintf("%-15s ", member);
      if((i-1 * ELEN) % (width/ELEN) == 0  && tmp2 != "") {
        tmp += this_player()->fix_string("   " + tmp2 + "\n", width, 10);
        tmp2 = "";
      }
      i++;
    }
  }
  return tmp;
}

private void do_list(string extra, int width) {
  string club, tmp, t2, *clubs;

  tmp = "";
  clubs = sort_array(CLUB_HANDLER->query_clubs(),
                     (: strcmp($1, $2 ) :) );

  foreach(club in clubs) {
    if(extra == "" || extra == "brief" || extra == "verbose" ||
       strsrch(club, extra) != -1) {
      t2 = club_line(club, width, (extra != "brief"));
      if(strlen(tmp) + strlen(t2) < 200000)
        tmp += t2;
      else
        break;
    }
}

  if(tmp == "")
    write("No clubs matching " + extra + ".\n");
  else
    this_player()->more_string(tmp, "Clubs", 1);
} /* do_list() */

private int do_balance(string club_name) {
   int balance;
   string place;

   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("There is no club called '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   }
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   balance = CLUB_HANDLER->query_balance(club_name);
   write("The balance of the club '" +
         CLUB_HANDLER->query_club_name(club_name) + "' is " +
         MONEY_HAND->money_value_string(balance, place) + ".\n");
   return 1;
} /* do_balance() */

mixed *query_patterns() {
  return ({ "list", (: cmd("list", "", "") :),
            "list <string'club name'>", (: cmd("list", $4[0], "") :),
            "balance <string'club name'>", (: do_balance($4[0]) :)
        });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/clubs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/lpc_info.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/lpc_info.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626857   Available: 13574211
Inodes: Total: 5242880    Free: 4960132
437 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/lpc_info.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626857   Available: 13574211
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: lpc_info.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: lpc_info.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* lpcinfo command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
  printf("%s", lpc_info());
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/lpc_info.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/shutdown.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/shutdown.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626857   Available: 13574211
Inodes: Total: 5242880    Free: 4960132
1341 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/shutdown.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626857   Available: 13574211
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: shutdown.c,v 1.3 1999/10/28 02:35:46 ceres Exp pinkfish $
 * $Log: shutdown.c,v $
 * Revision 1.3  1999/10/28 02:35:46  ceres
 * can't remembe
 *
 * Revision 1.2  1999/03/08 10:31:35  pinkfish
 * Make it less error prone.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* shutdown command. */
inherit "/cmds/base";

//#define GAME_LOG

mixed cmd(int tim, string reason, int force) {
  string str;

  seteuid(geteuid(this_player()));
  str = (string)this_player()->query_name()+" at "+ctime(time());

#ifdef GAME_LOG  
  log_file("GAME_LOG", "Game shutdown by ");
  log_file("GAME_LOG", str);
/*
  log_file("GAME_LOG", ctime(time()));
 */
  log_file("GAME_LOG", " for\n");
  log_file("GAME_LOG", num + " " + reason);
  log_file("GAME_LOG", "\n\n");
#endif  
  write("Ok... shutting down game... \n");

  if (tim < 10 && (!master()->query_lord(geteuid(this_object())) && !force)) {
    tim = 10;
  }
  if (!tim) {
    "/obj/shut"->end_it_all(reason);
  } else {
    "/obj/shut"->shut(tim, reason);
  }
  return 1;
} /* cmd() */

mixed *query_patterns() {
  return ({ "<number'number of minutes'> <string'reason'>",
              (: cmd($4[0], $4[1], 0) :),
              "now <string'reason'>", (: cmd(0, $4[0], 1) :),
              });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/shutdown.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/status.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/status.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626856   Available: 13574210
Inodes: Total: 5242880    Free: 4960132
662 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/status.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626856   Available: 13574210
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: status.c,v 1.2 2000/11/08 20:08:54 pinkfish Exp $
 * $Log: status.c,v $
 * Revision 1.2  2000/11/08 20:08:54  pinkfish
 * Fix up the status command to use add_command.
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* status command, trial out by Turrican for a commands daemon. */
inherit "/cmds/base";

mixed cmd(string str) {
  if (str)
    this_player()->more_string(mud_status(1), "Status info");
  else
    printf("%s", mud_status());
  return 1;
}

mixed* query_patterns() {
   return ({ "", (: cmd(0) :),
             "detailed", (: cmd("detailed") :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/status.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/dump.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/dump.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626856   Available: 13574210
Inodes: Total: 5242880    Free: 4960132
383 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/dump.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626856   Available: 13574210
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

#include <creator.h>
 
/**
 * This dumps out stuff about the object.
 */
int cmd(object *obs) {
   object ob;
   

   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(0, ob) + "\n");
   }
   return 1;
} /* cmd() */
 
mixed *query_patterns() {
   return ({ "<indirect:wiz-present>", (: cmd($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/dump.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/cloner.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/cloner.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626856   Available: 13574210
Inodes: Total: 5242880    Free: 4960132
2433 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/cloner.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626856   Available: 13574210
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: cloner.c,v 1.4 2001/08/17 00:32:27 ceres Exp $
 */
inherit "/cmds/base";

#define CLONER "/global/cloner"
#define LIFE_TIME 7257600

int do_list(string file) {
  string *files, change;
  mapping changes;
  string ret;
  
  if(file && file != "") {
    files = this_player()->get_files(file);
  }
  
  changes = CLONER->query_changes();
  ret = "";
  foreach(change in keys(changes)) {
    if(files && member_array(change, files) == -1 &&
       strsrch(change, file) == -1) {
      continue;
    }
    
    ret += sprintf("%s:\n  %s until %s\n", change, changes[change][0],
           ctime(changes[change][1] + LIFE_TIME));
  }
  this_player()->more_string( ret, "Cloner list", 1 );
  return 1;
}

int do_move(string source, string dest) {
  string *sources, *tmp, destp, rcs;
  
  seteuid(geteuid(this_player()));

  sources = this_player()->get_files(source);
  if(!sizeof(sources))
    return notify_fail("No source files found.\n");

  destp = this_player()->get_path(dest);
  if(file_size(destp) != -2 && !mkdir(dest))
    return notify_fail("Destination must be a directory.\n");

  foreach(source in sources) {
    if(file_size(source) == -2 || file_size(source) == -1) {
      if(source[<4..] == "/RCS") {
        if(rename(source, source+".tmp"))
          return notify_fail("Error moving RCS directory to temp location.\n");
        else
          rcs = source+".tmp";
      } else
        write("Not moving directory: " + source + "\n");
    } else {
      tmp = explode(source, "/");
      dest = destp + "/" + tmp[sizeof(tmp)-1];
    
      if(rename(source, dest))
        return notify_fail("Error renaming [" + source + "] to [" + dest +
                           "]\n");
      CLONER->add_mapping(source, dest);
    }
  }

  if(rcs && rename(rcs, destp + "/RCS"))
    return notify_fail("Error moving RCS directory.\n");
    
  return 1;
}

int do_add(string source, string dest) {
  CLONER->add_mapping(source, dest);
  return 1;
}

int do_remove(string source) {
  CLONER->remove_mapping(source);
  return 1;
}

mixed *query_patterns() {
  return ({ "list", (: do_list(0) :),
            "list <word'file'>", (: do_list($4[0]) :),
            "move <word'source'> <word'dest'>", (: do_move($4[0], $4[1]) :),
            "add <word'source'> <word'dest'>", (: do_add($4[0], $4[1]) :),
            "remove <word'source'>", (: do_remove($4[0]) :), 
              });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/cloner.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/mobs.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/mobs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626855   Available: 13574209
Inodes: Total: 5242880    Free: 4960132
1546 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/mobs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626855   Available: 13574209
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <creator.h>
#define COUNT 10

int cmd(string arg){
  mapping m = ([]);
  string *obs, ob, ret = "";

  if(!master()->query_senior(this_player()->query_name()))
    return 0;

  switch(arg){
  case "all":
    objects((:$(m)[base_name($1)]++,reset_eval_cost():)); 
    break;

  case "inside":
    objects((:environment($1) && $(m)[base_name($1)]++:));
    break;

  default:
    objects((:environment($1) && living($1) && 
       $(m)[base_name($1)]++:));
  }

  obs = keys(filter(m, (:$2 > COUNT:)));

  foreach(ob in obs){
    object *things, thing;
    
    m = ([]);
    
    reset_eval_cost();

    if(arg != "all")
      things = filter(children(ob), (:environment($1):));
    else
      things = children(ob);
    
    foreach(thing in things)
      m[environment(thing)]++;
    
    m = filter(m, (:$2 > COUNT:));
    if(sizeof(m)){
      object *rooms = keys(m);
      
      foreach(thing in rooms){
        ret += sprintf("%3d %s in %s\n", m[thing], 
                       WIZ_PRESENT->desc_f_object(find_object(ob)),
                       WIZ_PRESENT->desc_f_object(thing));
      }
    }
  }
  

  ob = sprintf("/w/%s/mobs", this_player()->query_name());
  printf("Saving to %s.\n", ob);
  //this_player()->more_string(ret);
  seteuid(geteuid(this_player()));
  unguarded((:rm($(ob)),write_file($(ob), $(ret)):));
  return 1;
}

mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
      "{all|inside}", (: cmd($4[0]) :) });
}

string help() {
  return "Shows groups of NPCs of one kind that are in the same room.";
}


// --- END [/mnt/home2/grok/lib/cmds/creator/mobs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/hous_ing.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/hous_ing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626854   Available: 13574208
Inodes: Total: 5242880    Free: 4960132
6916 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/hous_ing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626854   Available: 13574208
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: hous_ing.c,v 1.9 2002/08/08 02:07:48 ceres Exp $
 * 
 */

#include <housing.h>
#include <login_handler.h>
#include <money.h>

inherit "/cmds/base";

private string get_file(string fname) {
  string *tmp;
  
  tmp = this_player()->get_files(fname);
  if(sizeof(tmp) != 1) {
    tmp = this_player()->get_files(fname + ".c");
    if(sizeof(tmp) != 1)
      return "";
  }
  return tmp[0][0..<3];
}

int do_remove(string house) {
  house = get_file(house);
  
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");
  
  HOUSING->remove_house(house);
  write("House removed.\n");
  return 1;
}

int do_add(string house, string region, int rented, string address) {
  object ob;

  house = get_file(house);
  
  if(house == "")
    return notify_fail("House does not exist.\n");
  
  load_object(house);
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The file " + house + " is not a player house.\n");
     return 0;
  }

  HOUSING->add_house(house, ({ }), address, region, rented);
  write("House added.\n");
  return 1;
}

int do_modify(string house, string region, int rented, string address) {
  string *rooms;
  
  house = get_file(house);
  if(house == "")
    return notify_fail("House does not exist.\n");
  if(!HOUSING->query_house(house))
    return notify_fail("That house is not registered.\n");

  rooms = HOUSING->query_rooms(house) - ({ house });
  HOUSING->modify_house(house, rooms, address, region, rented);
  write("House modified.\n");
  return 1;
}

int add_room(string house, string room) {
  string *files, file;
  object ob;
  int added;
  
  house = get_file(house);
  if(!HOUSING->query_house(house)) {
    return notify_fail("No such house.\n");
  }
  
  files = this_player()->get_files(room);

  if(!sizeof(files)) {
    return notify_fail("That room doesn't exist.\n");
  }
 
  house->force_load();
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The start point is not a player house!\n");
     return 0;
  }

  added = 0; 
  foreach(file in files) {
    room = file[0..<3];
    if(room == house) {
      continue;
    }
    
    if(!HOUSING->add_rooms(house, ({ room }))) {
      write("Error adding room " + room + ".\n");
    } else {
      write("Room added [" + room + "]\n");
    }
  }

  return 1;
}

int remove_room(string house, string room) {
  house = get_file(house);
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");

  if(!HOUSING->remove_rooms(house, ({ room })))
    return notify_fail("Error removing room.\n");

  write("Room removed.\n");
  return 1;
}

int do_owner(string house, string owner) {
  if(owner == "none")
    owner = "For Sale";
  
  if(owner != "For Sale" && owner != "Under Offer" &&
     !PLAYER_HANDLER->test_user(owner))
    return notify_fail("No such user " + owner + ".\n");

  house = get_file(house);

  if(!HOUSING->set_owner(house, owner))
     return notify_fail("Error changing owner.\n");

  write("Owner set to " + owner + ".\n");
  return 1;
}

int do_list(string search) {
  string house;
  string str;
  string tmp;
  int num, negative;

  debug_printf("search: %s", search);
  
  if(search) {
    house = get_file(search);
    if(HOUSING->query_house(house)) {
      printf("House: %s\n  Owner: %s\n  Address: %s\n  Region: %s\n  "
             "Type: %s\n  Value: %d\n  Rooms: %s\n",
             house,
             HOUSING->query_owner(house),
             HOUSING->query_address(house),
             HOUSING->query_region(house),
             (HOUSING->query_type(house) ? "Rented" : "Owned"),
             HOUSING->query_value(house),
             implode(HOUSING->query_rooms(house), ", "));
      return 1;
    }
  }

  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }
  
  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s: %s. %d rooms (%s).\n",
                  house,
                  (HOUSING->query_type(house) ? "Renter" + 
                   (HOUSING->query_value(house) ? " (" +
                    MONEY_HAND->money_value_string(HOUSING->query_value(house), "Ankh-Morpork") + ")" : "")
                   : "Owner"),
                  HOUSING->query_owner(house),
                  sizeof(HOUSING->query_rooms(house)),
                  (stringp(HOUSING->query_region(house))?HOUSING->query_region(house):"Bad region"));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }

  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}

int do_sell(string house) {
   house = get_file(house);
   if (!HOUSING->set_for_sale(house)) {
      add_failed_mess("Unable to set the house " + house + " up for sale.\n");
      return 0;
   }
   write("Set the house up for sale.\n");
   return 1;
}

int do_list_address(string search) {
  string house;
  string str;
  string tmp;
  int num;
  int negative;
  
  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }

  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s (%s).\n",
                  house,
                  HOUSING->query_address(house),
                  HOUSING->query_region(house));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }

  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}

mixed *query_patterns() {
  return ({ "list", (: do_list(0) :),
              "list <string'search'>", (: do_list($4[0]) :), 
              "list address", (: do_list_address(0) :), 
              "list address <string'search'>", (: do_list_address($4[0]) :), 
              "sell <word'house'>", (: do_sell($4[0]) :),
              "add <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_add($4[0], $4[1], $4[2], $4[3]) :),
              "modify <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_modify($4[0], $4[1], $4[2], $4[3]) :),
              "add room <word'house'> <string'room'>",
              (: add_room($4[0], $4[1]) :),
              "remove room <word'house'> <string'room'>",
              (: remove_room($4[0], $4[1]) :),
              "owner <word'house'> <string'owner'>",
              (: do_owner($4[0], $4[1]) :),
              "remove <word'house'>", (: do_remove($4[0]) :),
              });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/hous_ing.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/testchar.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/testchar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626852   Available: 13574206
Inodes: Total: 5242880    Free: 4960132
1185 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/testchar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626852   Available: 13574206
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * testchar command.  Adds a few useful properties to test characters.
 * @author Taffyd
 */

inherit "/cmds/base";

private mapping properties = ([ "no score" : 1, 
    "no delete" : 1, 
    "test character" : (: $1->query_name() :), 
    "authorised player" : 1 ]);

int cmd( object player, string status ) {
    foreach( string property, mixed value in properties ) {
        if ( status == "on" ) {

            if ( functionp( value ) ) {
                player->add_property( property, evaluate( value, 
                    this_player() ) );
            }
            else { 
                player->add_property( property, value );
            }
        }
        else {
            player->remove_property( property );
        }
    }

    if ( status == "on" ) {
        player->save_me();
        add_succeeded_mess( ({ "$I is now a test character.\n", "" }),
            ({ player }) );
    }
    else {
        add_succeeded_mess( ({ "$I is no longer a test character.\n", "" }),
            ({ player }) );
    }

    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "<indirect:player> {on|off}", (: cmd($1[0], $4[1]) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/testchar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/netdups.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/netdups.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626852   Available: 13574206
Inodes: Total: 5242880    Free: 4960132
591 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/netdups.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626852   Available: 13574206
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: netdups.c,v 1.5 2001/08/27 18:55:48 pinkfish Exp $
 */

#include <creator.h>
#include <peopler.h>

int cmd(string str) {
   mixed *bing;

   bing = this_player()->query_property("netdups list");
   if (!bing) {
      bing = ND_DEFAULT;
   }
   return PEOPLER->do_command(bing, str,
      (: query_ip_number($1) == 0 || query_ip_number($2) == 0 ||
         strcmp(query_ip_number($1), query_ip_number($2)) :),
      1);
} /* cmd() */

mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/netdups.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/which.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/which.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626851   Available: 13574205
Inodes: Total: 5242880    Free: 4960132
2846 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/which.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626851   Available: 13574205
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* $Id: which.c,v 1.3 2001/10/23 17:57:56 taffyd Exp $ */

#include <command.h>
#include <soul.h>
#include <user_parser.h>

inherit "/cmds/base";

int cmd(string str) {
  int i;
  mixed *junk, *coms;
  class command cmd;
  string file, *files;

  files = ({ });
  junk = actions_defined(this_player(), 0, 12);
  for (i = 0; i < sizeof(junk); i += 2) {
    if (junk[i] == str) {
      file = function_exists((string)junk[i+1][1], (object)junk[i+1][0]);
      if (!file) {
        file = base_name((object)junk[i+1][0]);
      }
      files += ({ file });
    }
  }
  cmd = new(class command, verb : str);
  if (CMD_D->HandleStars(cmd) &&
      sizeof((coms = (mixed *)CMD_D->GetPaths(cmd->verb) &
              (mixed *)this_player()->GetSearchPath()))) {
    files += map(coms, (: $1 + "/" + $(cmd->verb) :));
  }

  coms = this_player()->query_parse_command_objects(str);
  if (sizeof(coms)) {
    files += map(coms, (: base_name($1) :));
  }
  if ((coms = SOUL_OBJECT->query_soul_command(str))) {
    files += ({ SOUL_OBJECT });
  }
  if (!sizeof(files)) {
    return notify_fail("Command " + str + " not found.\n");
  }

  printf("List of files defining '%s', in search order:\n%s", str,
         implode(files, (: $1 + "    " + $2 + "\n" :), ""));
  return 1;
} /* cmd() */ 

int command_list() {
    mapping objects;
    mapping data = ([ ]); 
    string *dkeys;
    string command;
    int maxlen = 8; 
    int width = 0;
    string txt;
    
    // Get a list of all the objects defined on the player.
    objects = this_player()->query_p_objects(); 

    // Data is in the following format:
    //
    // "verb" : ({ objects }),
    //
    // So combine them together.        

    foreach( object ob, string *commands in objects ) {
        foreach( command in commands ) { 
            if ( data[ command ] ) { 
                data[ command ] += ({ ob }); 
            }
            else {
                data[ command ] = ({ ob });
            }

            if ( strlen( command ) > maxlen ) {
                maxlen = strlen( command );
            }
        }
    }

    width = this_player()->query_cols() - maxlen;
    
    // Get the keys, and start building the text. 

    dkeys = sort_array( keys( data ), 1 ); 
   
    txt = sprintf( "$P$Command list$P$%*-s %*-=s\n", maxlen, "Command", 
        width, "Defined On" );

    foreach( command in dkeys ) { 
        // #define LIST_FORMAT "   %12-s %*-=s\n"

        txt += sprintf( "%*-s %*-=s\n", maxlen, 
            command, width, 
            implode( map( data[ command ], (: file_name :) ), ", " ) );
    }

    // Finally display the text. 

    tell_object( this_player(), txt );
    
    return 1;
} /* command_list() */ 

mixed *query_patterns() {
  return ({ 
      "", (: command_list :), 
      "<word'command'>", (: cmd($4[0]) :) });
} /* query_patterns() */ 
// --- END [/mnt/home2/grok/lib/cmds/creator/which.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/sockets.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/sockets.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626851   Available: 13574205
Inodes: Total: 5242880    Free: 4960132
209 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/sockets.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626851   Available: 13574205
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Id: sockets.c,v 1.2 2000/02/18 14:25:09 turrican Exp $
 */

inherit "/cmds/base";

mixed cmd(string /* unused */) {
  this_player()->more_string(dump_socket_status());
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/sockets.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/scorepl_ayer.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/scorepl_ayer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626850   Available: 13574204
Inodes: Total: 5242880    Free: 4960132
969 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/scorepl_ayer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626850   Available: 13574204
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

#define SCORE_CMD "/cmds/player/score"

int score_quests(object *obs) {
   object play;

   foreach(play in obs) {
      write("Quests score for " + play->the_short() + ":\n");
      SCORE_CMD->score_quests(play);
   }
   return 1;
} /* score_quests() */

int score_stats(object *obs) {
   object play;
 
   foreach(play in obs) {
      write("Stats score for " + play->the_short() + ":\n");
      SCORE_CMD->score_stats(play, "verbose");
   }
   return 1;
} /* score_stats() */

int score_normal(object *obs) {
   object play;
 
   foreach(play in obs) {
      write("Score for " + play->the_short() + ":\n");
      SCORE_CMD->score_normal(play, "verbose");
   }
   return 1;
} /* score_normal() */

mixed *query_patterns() {
   return ({ "quests <indirect:player>", (: score_quests($1) :), 
             "stats <indirect:player>", (: score_stats($1) :),
             "<indirect:any-living>", (: score_normal($1) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/scorepl_ayer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/errors.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/errors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626850   Available: 13574204
Inodes: Total: 5242880    Free: 4960132
31857 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/errors.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626850   Available: 13574204
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the new errors command to deal with the new error handler
 * code.
 * @author Pinkfish
 * @started Mon Apr 28 12:01:45 PDT 2003
 */
inherit "/cmds/base";
#include <error_handler.h>
#include <db.h>
#include <nroff.h>
#include <player_handler.h>

class user_data {
   class error_query query;
   class error_summary* errors;
   int pos;
   int last_touched;
   string direction;
   string report;
}

private mapping _user_query;

void create() {
   _user_query = ([ ]);
}

int find_index(object person, int id) {
   int i;
   class error_summary* errors;

   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   errors = _user_query[person->query_name()]->errors;
   for (i = 0; i < sizeof(errors); i++) {
      if (id == errors[i]->id) {
         return i;
      }
   }
   return 0;
}

int max_index(object person) {
   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   return sizeof(_user_query[person->query_name()]->errors);
}

int id_at(object person, int index) {
   if (!_user_query[person->query_name()] || index < 0 ||
       index >= sizeof(_user_query[person->query_name()]->errors)) {
      return 0;
   }

   _user_query[person->query_name()]->last_touched = time();
   return _user_query[person->query_name()]->errors[index]->id;
}

string menu_line(object person) {
   string ret;

   // Figure out the nice little menu line.
   ret = "[" + (_user_query[person->query_name()]->pos + 1) + " of " +
          sizeof(_user_query[person->query_name()]->errors) + "] "
         "STFCOLHA-+PNGQ : ";
   return ret;
}

void finish_details(object person, int verbose,
                    int type, mixed data) {
   string ret;
   class error_details details;
   class error_complete complete;
   class error_comment comment;
   class error_forward forward;
   class error_replies reply;
   class user_data user_data;

   if (type != DB_SUCCESS) {
      tell_object(person, "%^BOLD%^%^RED%^Error: " + data + "%^RESET%^\n");
      return ;
   }

   user_data = _user_query[person->query_name()];

   complete = data[0];
   details = complete->details;
   ret = "%^BOLD%^%^CYAN%^Bug #" + details->summary->id + "%^RESET%^ " +
         details->summary->status + " " + details->summary->type + " " +
         details->summary->category + "\n";

   ret += "%^BOLD%^Date Reported%^RESET%^     : " +
             ctime(details->summary->entry_date) + "\n";
   ret += "%^BOLD%^Assigned To%^RESET%^       : " +
          details->summary->assigned_to + "\n";
   ret += "%^BOLD%^Reporter%^RESET%^          : " + details->summary->reporter + "\n";
   ret += "%^BOLD%^File name%^RESET%^         : " + details->summary->filename + "\n";
   if (verbose) {
      ret += "%^BOLD%^Directory%^RESET%^         : " + details->summary->directory + "\n";
   }

   if (details->summary->status == "FIXED" ||
       details->summary->status == "DENIED") {
      ret += "%^BOLD%^Fixed By%^RESET%^          : " + details->fixer +
             " (" + ctime(details->fix_date) + ")\n";
   }

   if (verbose) {
      if (sizeof(complete->forwards)) {
         ret += "%^BOLD%^Forwards%^RESET%^          :\n";
         // Print out the forwards.
         foreach (forward in complete->forwards) {
            ret += "$I$5=     " + forward->forwarder + " from " +
                   forward->old_directory + " at " +
                   ctime(forward->date)[4..15] + "\n";
         }
      }
   }

   ret += "$I$0=" + details->report;
   if (verbose) {
      ret += details->runtime;
   } else if (details->runtime && details->runtime != "") {
      ret += "[Runtime Available]\n";
   }

   user_data->report = details->report;

   if (verbose) {
      ret += "$I$3=   ";
      // Show the error replies before the comments.
      foreach (reply in complete->replies) {
         ret += "%^BOLD%^Date Sent%^RESET%^   : " + ctime(reply->senddate)[4..15] +
                "\n%^BOLD%^From%^RESET%^        : " + reply->sender +
                "\n%^BOLD%^To%^RESET%^          : " + reply->recipient +
                "\n%^BOLD%^Subject%^RESET%^     : " + reply->subject + "<br>" +
                reply->message + "\n";
      }
      if (sizeof(complete->replies) && sizeof(complete->comments)) {
         ret += "$I$0=-------------------------------------------------------------\n$I$3=   ";
      }
      foreach (comment in complete->comments) {
         ret += "%^BOLD%^Comment by " + comment->commenter + " at " +
                ctime(comment->date)[4..15] + "%^RESET%^\n" +
                comment->comment + "\n";
      }
   } else {
      if (sizeof(complete->replies) > 0) {
         ret += sizeof(complete->replies) + " error replies.\n";
      }
      if (sizeof(complete->comments) > 0) {
         ret += sizeof(complete->comments) + " comments.\n";
      }
   }
   person->set_finish_func("finish_more_details", this_object());
   tell_object(person, "$P$Bug #" + details->summary->id + "$P$" + ret);
}

int finish_more_details() {
   object ob;

   ob = this_player();
   write(menu_line(ob));
   input_to("menu_response");
}

int finish_forward(object person, int pos, string new_dir, int type, mixed mess) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Unable to forward bug #" +
                          data->errors[data->pos]->id +
                          " to " + new_dir + " (" + mess + ")");
   } else {
      tell_object(person, "Forwarded bug #" +
                          data->errors[data->pos]->id +
                          " from " + data->errors[data->pos]->directory +
                          " to " + new_dir);
      data->errors[data->pos]->directory = new_dir;
   }
}

void finish_change_status(object person, string status, int command,
                          string subject, int no_reply, int type, mixed mess) {
   class user_data data;


   data = _user_query[person->query_name()];

   if (type != DB_SUCCESS) {
      tell_object(person, "Database error: " + mess);
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }

   tell_object(person, "Updated status of bug #" + data->errors[data->pos]->id +
               " to " + status + (no_reply ?  " (no reply) " : "") +"\n");
   if (!command) {
      data = _user_query[person->query_name()];
      tell_object(person, menu_line(person));
      data->errors[data->pos]->status = status;
   }
}

void finish_status_message(object person, string status, int command,
                           string subject, string mess) {
   class user_data data;
   int pos;

   data = _user_query[person->query_name()];
   if (!mess) {
      tell_object(person, "Message aborted.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }

   if (status == "THANKS" || status == "TEMPORARY") {
      status = "FIXED";
   }
   if (status == "NOTREPRODUCIBLE" || status == "NOINFO" ||
       status == "NOTPOSSIBLE") {
      status = "DENIED";
   }

   pos = strsrch("$report$", mess);
   if (pos == -1) {
      mess += "\n\n" + data->report;
   } else {
      mess = replace_string(mess, "$report$", data->report);
   }

   if (!command) {
      input_to("menu_response");
   }
   // Do it.
   if (!ERROR_HANDLER->do_change_status(data->errors[data->pos]->id,
                        status, subject == 0, subject, person->query_name(),
                        mess,
                        (: finish_change_status, person, status, command, 
                                          subject, subject == 0 :))) {
      tell_object(person, "Unhappily an error occured.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
   }
}

string query_subject_from_type(string type, class error_summary error) {
   switch (type) {
   case "THANKS" :
      return "Thanks for " + error->category + " " + error->type;
   case "NOTPOSSIBLE" :
      return "Not possible to fix " + error->category + " " + error->type;
   case "NOTREPRODUCIBLE" :
      return "Not able to reproduce " + error->category + " " + error->type;
   case "FIXED" :
      return "Fixed bug #" + error->id;
   case "DENIED" :
      return "Denied bug #" + error->id;
   default :
      return "Change status of bug #" + error->id + " to " +
             type;
   }
}

string query_message_from_type(object person, string type,
                               class error_summary error) {
   switch (upper_case(type)) {
   case "THANKS" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "TEMPORARY" :
      return "Your " + lower_case(error->type) +
             " report was a temporary problem in the system and has "
             "since been resolved.  Thanks for reporting it."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTENOUGHINFORMATION" :
      return "Your " + lower_case(error->type) +
             " report did not contain enough information for this " +
             lower_case(error->type) + " to be resolved.  Please report "
             "again with more detailed information."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTREPRODUCIBLE" :
      return "Unable to reproduce your " + lower_case(error->type) +
             " report.  If you can track down exactly the circumstances "
             "which generate this error, please report it again."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTPOSSIBLE" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is not possible to fix, because of code restrictions."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXED" :
   case "DENIED" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " has now been " + lower_case(type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being fixed.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CONSIDERING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being considered for future fixing.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CUSTOM" :
      return "custom";
   case "NONE" :
      return "none";
   case "OPEN" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   }
}

void finish_change_type(object person, string new_type, int type, mixed mess) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }

   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new type of " + new_type + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_type;
}

void finish_change_category(object person, string new_category, int type, mixed mess) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }

   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new category of " + new_category + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_category;
}

void finish_assign_bug(object person, string assigner, int type, mixed mess) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }

   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " is assigned to " + assigner + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->assigned_to = assigner;
}

void finish_adding_comment(object person, int type, mixed mess) {
   if (type != DB_SUCCESS) {
      tell_object(person, "SQL Error: " + mess);
      tell_object(person, menu_line(person));
   }

   tell_object(person, "Added a comment to the bug.\n");
   tell_object(person, menu_line(person));
}

void finish_comment(object person, int id, string comment) {
   if (!comment) {
      write("Aborted adding the comment.\n");
      write(menu_line(person));
      input_to("menu_response");
      return ;
   }
   input_to("menu_response");
   if (!ERROR_HANDLER->do_comment(id, person->query_name(), comment,
                             (: finish_adding_comment, person :))) {
      write("Big bad error.\n");
      write(menu_line(person));
   }
}

int do_bug_details(object person, int id, int verbose) {
   if (!ERROR_HANDLER->do_query_bug_details(id, (: finish_details, person,
                                                   verbose :))) {
      tell_object(person, "Error doing stuff.");
   }
   return 1;
}

int do_forward(object person, string new_dir) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_forward(data->errors[data->pos]->id,
                person->query_name(), new_dir,
                    (: finish_forward, person, data->pos, new_dir :))) {
      write("A horrible error occured.\n");
      return 0;
   }
   return 1;
}

int do_change_status(object person, string status, int command, string subject,
                     string mess) {
   if (mess == "custom") {
      tell_object(person, "User $report$ to place the error report in the "
                  "mail.  If $report$ is not included, the report will be "
                  "added onto the end.\n");
      person->do_edit("", (: finish_status_message, person, status, command,
                                                    subject :));
   } else if (mess == "none") {
      finish_status_message(person, status, command, 0, "");
   } else {
      finish_status_message(person, status, command, subject, mess);
   }
}

int do_change_type(object person, string type) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_type(data->errors[data->pos]->id, type,
       (: finish_change_type, person, type :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}

int do_change_category(object person, string category) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_category(data->errors[data->pos]->id, category,
       (: finish_change_category, person, category :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}

int do_assign_bug(object person, string assigner) {
   class user_data data;

   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_assign_bug_to(data->errors[data->pos]->id, assigner,
       (: finish_assign_bug, person, assigner :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}

int do_comment(object person) {
   class user_data data;

   data = _user_query[person->query_name()];
   this_player()->do_edit("", (: finish_comment, person, 
                                   data->errors[data->pos]->id :));
}

int do_help(object player) {
   string str;

   str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   if (!str) {
      NROFF_HAND->create_nroff("/doc/creator/commands/errors", "/doc/creatornr/errors");
      str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   }
   player->set_finish_func("finish_more_details", this_object());
   tell_object(player, "$P$Error help$P$" + str);
}

int do_list_errors() {
   class user_data data;
   class error_summary error;
   string str;
   int i;

   data = _user_query[this_player()->query_name()];
   str = "";
   i = 1;
   str += sprintf("ndx: #<num> %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                  "Status", "Cat", "Type", "Reporter", "Filename", "Directory");
   foreach (error in data->errors) {
      str += sprintf("$I$3=%3d: #%d %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                     i++, error->id, error->status[0..4], error->category[0..3],
                     error->type, error->reporter, error->filename[<15..],
                     error->directory[<15..]);
   }
   this_player()->set_finish_func("finish_more_details", this_object());
   write("$P$Error list$P$" + str);
}

int show_current_bug(object player, int verbose) {
   class user_data data;

   data = _user_query[player->query_name()];
   if (verbose == -1) {
      verbose = player->query_verbose("errors");
   }
   return do_bug_details(player, data->errors[data->pos]->id, verbose);
}

string expand_short_type(string name) {
   string str;

   str = upper_case(name);
   switch (str) {
   case "F" :
      return ERROR_STATUS_FIXED;
   case "D" :
      return ERROR_STATUS_DENIED;
   case "I" :
      return ERROR_STATUS_FIXING;
   case "C" :
      return ERROR_STATUS_CONSIDERING;
   case "O" :
      return ERROR_STATUS_OPEN;
   case "U" :
      return "CUSTOM";
   case "R" :
      return "NOTREPRODUCIBLE";
   case "R" :
      return "NOTPOSSIBLE";
   case "N" :
      return "NONE";
   case "T" :
      return "THANKS";
   case "M" :
      return "NOTENOUGHINFORMATION";
   case "E" :
      return "TEMPORARY";
   default :
      return str;
   }
}

void finish_change_status_command(object player, int id, string status,
                        string messtype, int type, mixed data) {
   string mess;
   string subject;
   class error_summary error;

   if (type != DB_SUCCESS) {
      tell_object(player, "SQL error: " + data + "\n");
      return ;
   }

   if (!sizeof(data)) {
      tell_object(player, "No bug found with an id of #" + id + "\n");
      return ;
   }

   error = data[0];

   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;

   status = expand_short_type(status);
   // Now lets see if they asked for a standard reply or not.
   if (messtype) {
      messtype = expand_short_type(messtype);
      mess = query_message_from_type(player, messtype, error);
      subject = query_subject_from_type(messtype, error);
      if (!mess) {
         tell_object(player, "The reply type " + messtype + " was not valid.\n");
      } else {
         if (member_array(status, ERROR_TYPE) != -1) {
            tell_object(player, "The error type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
         } else {
            // Allow the person to enter their own message.
            do_change_status(player, status, 1, subject, mess);
            return ;
         }
      }
   } else {
      mess = query_message_from_type(player, status, error);
      subject = query_subject_from_type(status, error);
      // Change the status.
      if (mess) {
         do_change_status(player, status, 1, subject, mess);
         return ;
      }
   }
   tell_object(player, "Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
   tell_object(player, "The default message is based on the type it is changed to.\n");
   tell_object(player, "The type has some short forms: o -> open, f -> fixed, d ->denied\n");
   tell_object(player, "   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
   tell_object(player, "   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
   tell_object(player, "   t ->temporary.\n");
}

/**
 * This function does most of the work.  It handles the response from the
 * creator and does what it needs to with the error.
 */
void menu_response(string str) {
   string* bits;
   class user_data data;
   int print_menu_line;
   class error_summary error;
   string mess;
   string subject;
   int id;

   bits = explode(str, " ");
   if (!sizeof(bits)) {
/*
      write("You need to specify something to do.\n");
      write(menu_line(this_player()));
      input_to("menu_response");
      return ;
 */
      bits = ({ "n" });
   }

   data = _user_query[this_player()->query_name()];
   switch(lower_case(bits[0])) {
   case "v" :
      if (sizeof(bits) > 1) {
         show_current_bug(this_player(), bits[1] == "verbose");
      } else {
         show_current_bug(this_player(), -1);
      }
      break;
   case "+" :
   case "n" :
      // next bug.
      if (data->pos < sizeof(data->errors) - 1) {
         data->pos++;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No next bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "-" :
   case "p" :
      // previous bug.
      if (data->pos > 0) {
         data->pos--;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No previous bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "f" :
      // Forward the bug somewhere.
      if (sizeof(bits) == 2) {
         if (do_forward(this_player(), bits[1])) {
            input_to("menu_response");
         } else {
            print_menu_line = 1;
         }
      } else {
         write("Need to specify the destination directory (and nothing else)\n");
         print_menu_line = 1;
      }
      break;
   case "s" :
      // Change the status of the bug
      if (sizeof(bits) > 1) {
         bits[1] = expand_short_type(bits[1]);
         // Now lets see if they asked for a standard reply or not.
         error = data->errors[data->pos];
         if (sizeof(bits) > 2) {
            bits[2] = expand_short_type(bits[2]);
            mess = query_message_from_type(this_player(), bits[2], error);
            subject = query_subject_from_type(bits[1], error);
            if (!mess) {
               write("The reply type " + bits[2] + " was not valid.\n");
               print_menu_line = 1;
            } else {
               if (member_array(bits[1], ERROR_TYPE) != -1) {
                  write("The error type must be one of " +
                        query_multiple_short(ERROR_TYPE) + ".\n");
                  print_menu_line = 1;
               } else {
                  // Allow the person to enter their own message.
                  do_change_status(this_player(), bits[1], 0, subject, mess);
                  input_to("menu_response");
               }
            }
         } else {
            mess = query_message_from_type(this_player(), bits[1], error);
            subject = query_subject_from_type(bits[1], error);
            // Change the status.
            if (mess) {
               do_change_status(this_player(), bits[1], 0, subject, mess);
               input_to("menu_response");
            }
         }
         if (!mess) {
            write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
            write("The default message is based on the type it is changed to.\n");
            write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
            write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
            write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
            write("   t ->temporary.\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
         write("The default message is based on the type it is changed to.\n");
         write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
         write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
         write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
         write("   t ->temporary.\n");
         print_menu_line = 1;
      }
      break;
   case "t" :
      // Change the type of the bug.
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_TYPE) != -1) {
            do_change_type(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {TYPO|BUG|IDEA}\n");
         print_menu_line = 1;
      }
      break;
   case "o" :
      // Change the category of the bug.
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_CATEGORIES) != -1) {
            do_change_category(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_CATEGORIES) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {ROOM|OBJECT|COMMAND|HELP|RITUAL|SPELL|GENERAL}\n");
         print_menu_line = 1;
      }
      break;
   case "g" :
      // goto a specific bug.
      if (sizeof(bits) > 0) {
         id = to_int(bits[1]);
         if (id <= sizeof(data->errors)) {
            data->pos = id - 1;
            show_current_bug(this_player(), -1);
         } else {
            // See if we can find it.
            id = find_index(this_player(), id);
            if (id == -1) {
               write("Unable to find the bug #" + id + "\n");
               print_menu_line = 1;
            }
         }
      } else {
         write("Syntax: g <num>\nNum can either be the index number or the "
               "bug id.\n");
         print_menu_line = 1;
      }
      break;
   case "c" :
      // comment on the bug.
      do_comment(this_player());
      break;
   case "i" :
   case "l" :
      do_list_errors();
      break;
   case "q" :
      write("Bye bye.\n");
      return ;
   case "a" :
      if (sizeof(bits) > 1) {
         if (!PLAYER_HANDLER->test_creator(bits[1])) {
            write("You can only assign a bug to a creator.\n");
            print_menu_line = 1;
         } else {
            do_assign_bug(this_player(), bits[1]);
            input_to("menu_response");
         }
      } else {
         write("You need to specify someone to assign the error to.\n");
         print_menu_line = 1;
      }
      break;
   case "h" :
      do_help(this_player());
      break;
   default :
      write("Bad command.\n");
      print_menu_line = 1;
      break;
   }
   if (print_menu_line) {
      write(menu_line(this_player()));
      input_to("menu_response");
   }
}

void finish_query(object player, int type, mixed data) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error: " + data + "\n");
      return ;
   }

   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;
   if (!sizeof(data)) {
      tell_object(player, "No bugs with that query.\n");
      return ;
   }
   show_current_bug(player, -1);
}

int setup_query(object player, class error_query query) {
   if (!ERROR_HANDLER->do_query_bug_summary(query, (: finish_query, player :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   return 1;
}

int errors_change_status(int id, string status, string messtype) {
   class error_query query;

   query = new (class error_query);
   query->id = id;
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                     (: finish_change_status_command, this_player(), id, status,
                        messtype :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   write("Looking up bug #" + id + " to fix.\n");
   return 1;
}

int errors_this_dir(int recursive) {
   class error_query query;

   query = new (class error_query);
   query->dir = this_player()->query_path();
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}

int errors_by_person(string person) {
   class error_query query;

   query = new (class error_query);
   query->reporter = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}

int errors_assigned_to_person(string person) {
   class error_query query;

   query = new (class error_query);
   query->assigned_to = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}

int errors_assigned_to_me() {
   return errors_assigned_to_person(this_player()->query_name());
}

int errors_in_dir(string str, int recursive) {
   class error_query query;
   string path;

   path = this_player()->get_path(str);
   query = new (class error_query);
   query->dir = path;
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}

int errors_with_id(int id) {
   class error_query query;

   query = new (class error_query);
   query->id = id;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}

int errors_for_file(string file) {
   class error_query query;

   query = new (class error_query);
   query->file_name = file;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}

int errors_in_this_room() {
   class error_query query;

   query = new (class error_query);
   query->file_name = file_name(environment(this_player()));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}

mixed* query_patterns() {
   return ({ "", (: errors_this_dir(0) :),
             "status <number'bug id'> <word'status'>",
                   (: errors_change_status($4[0], $4[1], 0) :),
             "status <number'bug id'> <word'status'> <word'reply'>",
                   (: errors_change_status($4[0], $4[1], $4[2]) :),
             "recursive", (: errors_this_dir(1) :),
             "mine", (: errors_assigned_to_me :),
             "here", (: errors_in_this_room :),
             "assigned <string'person'>", (: errors_assigned_to_person($4[0]) :),
             "by <string'person'>", (: errors_by_person($4[0]) :),
             "id <number'bug id'>", (: errors_with_id($4[0]) :),
             "file <string'file'>", (: errors_for_file($4[0]) :),
             "dir <string'dir'>", (: errors_in_dir($4[0], 0) :),
             "dir recursive <string'dir'>", (: errors_in_dir($4[0], 1) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/errors.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/mv.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/mv.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626842   Available: 13574196
Inodes: Total: 5242880    Free: 4960132
2133 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/mv.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626842   Available: 13574196
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mv.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: mv.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* mv command, trial out by Turrican for a commands daemon. */

mixed cmd(string str) {
  int loop, fs, pos, multi;
  string *filenames, dest, *fnames, trash1, trash2, trash3, trash4;
  string path, *temp, start, end;

  seteuid(geteuid(this_player()));

  if ((!str) || (sscanf(str, "%s %s", trash1, trash2) != 2))
    return notify_fail("Usage : mv file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2], " "));
  if(!sizeof(filenames))
    return notify_fail("Usage : mv file [file|dir...]\n");
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if (!dest) {
    write("No destination\n");
    return 1;
  }
  if (sscanf(str, "%s*%s %s*%s", trash1, trash2, trash3, trash4) == 4) {
    multi = 1;
    temp = explode(dest, "/");
    path = implode(temp[0..sizeof(temp) - 2], "/") + "/";
    sscanf(temp[sizeof(temp)-1], "%s*%s", start, end);
    temp = explode(implode(fnames[0..sizeof(fnames) -2], " "), "/");
    sscanf(temp[sizeof(temp)-1], "%s*%s", trash1, trash2);
    pos = strlen(trash1);
  } 
  for (loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(file_size(str) == -1) {
      write("No such file : " + str + "\n");
      continue;
    }
    if(multi) {
      temp = explode(str, "/");
      trash1 = temp[sizeof(temp)-1];
      fs  = strlen(trash1) - strlen(trash2) - 1;
      dest = path + start + trash1[pos..fs] + end;
      fs = file_size(dest);
    }
    else {
      fs = file_size(dest);
      if(fs == -2) {
        string *names;

        names = explode(str, "/");
        fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      }
    }
    if(fs != -1) {
      write("File exists : " + dest + "\n");
      continue;
    }
    rename(str, dest);
  }
  write("Ok.\n");
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/mv.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/setmmin.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/setmmin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626841   Available: 13574195
Inodes: Total: 5242880    Free: 4960132
786 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/setmmin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626841   Available: 13574195
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: setmmin.c,v 1.2 1998/04/14 02:42:56 pinkfish Exp $
 * $Log: setmmin.c,v $
 * Revision 1.2  1998/04/14 02:42:56  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(string str) {

  if(TP->query_creator() || TP->query_property("setm")) { 
    str = str + " ";
    if (sizeof(explode("^"+str, "$N")) < 2)
      return notify_fail("Must have a $N in your teleport entry message.\n");
    TP->set_mmsgin(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
} /* cmd() */

mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/setmmin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/terrain_s.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/terrain_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626841   Available: 13574195
Inodes: Total: 5242880    Free: 4960132
7525 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/terrain_s.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626841   Available: 13574195
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <terrain_map.h>

/**
 * Useful command to find out information about the terrain.
 * Contains a bunch of small useful commands.
 */

/**
 * This one maps the area around the creator.
 */
int do_map() {
   string map;
   object hand;
   int* coords;
   int x;
   int y;

   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   coords = environment(this_player())->query_terrain_coords();
   x = coords[0];
   y = coords[1];
   map = hand->query_debug_map(x, y, 13, x, y);
   write(map);
   add_succeeded_mess("");
   return 1;
}

/**
 * This one maps the whole terrain.
 */
int do_map_terrain() {
   string map;
   object hand;
   string* map_data;
   int i;

   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   map_data = hand->query_area_map();
   map = "";
   for (i = sizeof(map_data) - 1; i >= 0; i--) {
      map += map_data[i] + "\n";
   }
   write("$P$Map$P$" + map);
   add_succeeded_mess("");
   return 1;
}

/**
 * This method shows the features associated with this terrain.
 */
int do_features_distant() {
   object hand;
   string title;
   mixed tmp;
   string fluff;
   string ret;
   int* coords;
   int x;
   int y;
   int z;
   string* features;

   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];

   features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   if (!sizeof(features)) {
      add_failed_mess("No distant features to list.\n");
      return 0;
   }

   // Find the distant features.
   ret = "List of distant features:\n";
   foreach (title in features) {
      tmp = title->query_feature_desc_from(x, y, z);
      if (tmp && tmp != "") {
         if (stringp(tmp)) {
            ret += "$I$3=%^BOLD%^" + title + "%^RESET%^: " + tmp + "\n";
         } else if (pointerp(tmp)) {
            foreach (fluff in tmp) {
               ret += "$I$3=%^BOLD%^" + title + "%^RESET%^: " + fluff + "\n";
            }
         }
      }
   }

   write("$P$Distant Features$P$" + ret);
   return 1;
}

/**
 * This method lists all the local features in this room.
 */
int do_features_local() {
   mapping features;
   string ret;
   object hand;
   mapping hand_features;
   string name;
   mixed stuff;

   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   hand_features = hand->query_features();
   features = environment(this_player())->query_features();
   if (!features) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   if (!sizeof(features)) {
      add_failed_mess("No local features.\n");
      return 0;
   }

   ret = "List of features:\n";
   foreach (name, stuff in hand_features) {
      ret += "$I$3=%^BOLD%^" + name + "%^RESET%^ (" + 
             file_name(hand->query_feature_region(name)) + ")";
      if (features[name]) {
         ret += " " + features[hand] + "\n";
      } else {
         ret += " Not visible here.\n";
      }
   }
   write("$P$Features$P$" + ret);
   return 1;
}

/**
 * This method maps a specific local feature showing the range that it covers
 * in the terrain.
 */
int do_feature_local_map(string feature) {
   object hand;
   mapping hand_features;
   string ret;

   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   hand_features = hand->query_features();

   if (!hand_features[feature]) {
      add_failed_mess("There is no feature called " + feature + ".\n");
      return 0;
   }

   ret = hand->query_debug_map_feature(feature);

   write("$P$" + feature + "$P$" + ret);
   return 1;
}

/**
 * This method maps a specific local feature showing the range that it covers
 * in the terrain.
 */
int do_feature_distant_map(string feature) {
   object hand;
   string* dist_features;
   string ret;
   int* coords;
   int x;
   int y;
   int z;

   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   dist_features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);

   if (member_array(feature, dist_features) == -1) {
      add_failed_mess("There is no distant feature " + feature + ".\n");
      return 0;
   }

   ret = hand->query_debug_map_feature_distant(feature);

   write("$P$" + feature + "$P$" + ret);
   return 1;
}

/**
 * This prints the status of the terrain.  The x,y real co-ordinates, size,
 * features and distant features.
 */
int do_terrain_status() {
   string ret;
   object hand;
   mixed* coords;
   mapping features;
   string name;
   int x;
   int y;
   int z;
   string* dist_features;
   mapping terrs;

   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }

   ret = "%^BOLD%^" + file_name(hand) + ":%^RESET%^\n";
   ret += "Size: " + hand->query_dimensions()[0] + ", " + hand->query_dimensions()[1] + "\n";
   coords = hand->query_real_coords();
   if (coords) {
      ret += "Real: " + coords[0][0] + ", " + coords[0][1] + " -- " +
             coords[1][0] + ", " + coords[1][1] + "\n";
   }

   features = hand->query_features();
   foreach (name in keys(features)) {
      ret += name + ": " + file_name(hand->query_feature_ob(name)) + "\n";
   }

   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   dist_features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   foreach (name in dist_features) {
      ret += name + " (distant feature)\n";
   }


   hand->find_all_adjacent_terrains();
   terrs = hand->query_adjacent_terrains();
   if (terrs["-1:-1"]) {
      ret += "Southwest: " + terrs["-1:-1"] + "\n";
   }
   if (terrs["0:-1"]) {
      ret += "South: " + terrs["0:-1"] + "\n";
   }
   if (terrs["40:-1"]) {
      ret += "Southeast: " + terrs["40:-1"] + "\n";
   }
   if (terrs["40:0"]) {
      ret += "East: " + terrs["40:0"] + "\n";
   }
   if (terrs["40:40"]) {
      ret += "NorthEast: " + terrs["40:40"] + "\n";
   }
   if (terrs["0:40"]) {
      ret += "North: " + terrs["0:40"] + "\n";
   }
   if (terrs["-1:40"]) {
      ret += "Northwest: " + terrs["-1:40"] + "\n";
   }
   if (terrs["-1:0"]) {
      ret += "West: " + terrs["-1:0"] + "\n";
   }
   write("$P$Status$P$" + ret);
   return 1;
}

mixed* query_patterns() {
   return ({ "map", (: do_map() :),
             "map terrain", (: do_map_terrain :),
             "features local", (: do_features_local :),
             "features distant", (: do_features_distant :),
             "status", (: do_terrain_status :),
             "features local <string'feature to map'>",
                  (: do_feature_local_map($4[0]) :),
             "features distant <string'feature to map'>",
                  (: do_feature_distant_map($4[0]) :) });
}
// --- END [/mnt/home2/grok/lib/cmds/creator/terrain_s.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ptobj_ect.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ptobj_ect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626839   Available: 13574193
Inodes: Total: 5242880    Free: 4960132
2078 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ptobj_ect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626839   Available: 13574193
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/*
** Creator Interface to the Playtesters' Palace Armoury, where PTs can request
** items which are in playtesting.
**
** @author Arienne
*/

inherit "/cmds/base";

#define PT_ARMOURY "/d/playtesters/palace_rooms/armoury"

mixed *query_patterns() {
    return ({ "info",
                  (: PT_ARMOURY->do_info() :),

              "help",
                  (: PT_ARMOURY->do_info() :),

              "list",
                  (: PT_ARMOURY->do_list_all() :),

              "list commands",
                  (: PT_ARMOURY->do_list_commands() :),

              "list objects",
                  (: PT_ARMOURY->do_list_commands() :),

              "control",
                  (: PT_ARMOURY->do_list_control_all() :),

              "control commands",
                  (: PT_ARMOURY->do_list_control_commands() :),

              "control objects",
                  (: PT_ARMOURY->do_list_control_commands() :),

              "request <string:'item'>",
                  (: PT_ARMOURY->do_request_object( lower_case( $4[ 0 ] ) ) :),
                  
              "add object <word:'path of object'> as <string:'item name'>",
                  (: PT_ARMOURY->do_add_object( $4[ 0 ],
                                                lower_case( $4[ 1 ] ) ) :),

              "remove object <string:'item name'>",
                  (: PT_ARMOURY->do_remove_object( $4[ 0 ] ) :),
                  
              "allow <word:'guilds'> to use object <string:'item name'>",
                  (: PT_ARMOURY->do_allow_object( $4[ 0 ],
                                                  lower_case( $4[ 1 ] ) ) :),
    
              "add command <string:'command name'>",
                  (: PT_ARMOURY->do_add_command( $4[ 0 ] ) :),

              "remove command <string:'command name'>",
                  (: PT_ARMOURY->do_remove_command( $4[ 0 ] ) :),

              "allow <word:'guilds'> to use command <string:'command name'>",
                  (: PT_ARMOURY->do_allow_command( $4[ 0 ], $4[ 1 ] ) :)
                  
              });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/ptobj_ect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/fry.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/fry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626838   Available: 13574192
Inodes: Total: 5242880    Free: 4960132
6514 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/fry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626838   Available: 13574192
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// $Id: fry.c,v 1.2 2000/05/13 00:36:36 taffyd Exp $
// Lightning zap - based on meteor code
// Wrytten by Rue and Drakkos
// 15/04/2000

#include <playerinfo.h>
#define LIGHTNING "%^WHITE%^BOLD%^lightning%^RESET%^"
#define THUNDER "%^RED%^BOLD%^thunder%^RESET%^"

inherit "/cmds/base";

mapping banned = ([
    "macchirton"    :   "it's tradition.",
    "que"           :   "you're an arse.",
    ]);
    
mixed cmd(string words) {
  string player, reason;
  object ob;

    add_failed_mess("At Pinkfish's request this command has been disabled.\n" );
    return 0;

  if(member_array (this_player()->query_name(), keys(banned)) != -1)
  {
    return notify_fail("You cannot use 'fry', because " + 
        banned[this_player()->query_name()] + "\n");
  }
   
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: fry <player> <reason>\n");
  }
  
  if (!"/secure/master"->query_senior(this_player()->query_name()))
  {
    return notify_fail ("Only Senior Creators and above may smite players "
        "with Righteous Vengeance!\n");
  }

  ob = find_player(this_player()->expand_nickname(player));
  
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y/n): ");
 

  input_to("are_sure", ob, reason);
  
  return 1;
} /* cmd() */

void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("There's a good "+gender+"!  Now you go play nice with little "
        + ob->one_short() + "!\n");
    return;
  }
  
  write("Would you like the whole Disc to be aware of the reason "
    "for your ire? (y/n): ");
    
  input_to("positive", ob, reason);  
}

void positive (string str, object ob, string reason) {
    
  str = lower_case(str);
  if(str[0] != 'y') {
    write ("Okay, we'll keep it between you and me.\n");
    call_out("fry2", 5+random (3), ob);
  }
  else
  {
    write ("Bwah-ha-ha-ha!\n");
    call_out("fry2", 5+random (3), ob, reason);
  }
  
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("SMITE", "%s: %s smote %s: %s\n", ctime(time()), 
    this_player()->query_short(), ob->query_short(), reason);

  shout("The sky grows dark.  Thick black clouds roll in.\n");
  shout("A loud peal of " + THUNDER + " rumbles, shaking the ground, "
    "and bolts of " + LIGHTNING + " flash through the sky!\n");
  write("Smiting "+capitalize (ob->query_name()) +" with Righteous Vengeance!\n");
} /* are_sure() */

varargs void fry2(object ob, string reason) {
    
     
    string *shout_mess = ({
        "A bolt of ferocious " + LIGHTNING + " rips the sky in two!  ",
        "A peal of deafening " + THUNDER + " rumbles o'er the land!  ",
        "The clouds gather, spitting forth bolts of vicious " + LIGHTNING + 
            " from their folds!  ",
        "The clouds gather into great dark masses, spitting " + LIGHTNING +
            " at the cowering Disc below!  "
        });

    string *player_mess = ({
        "A bolt of shimmering " + LIGHTNING + " spears the ground in front "
            "of you!\n",
        "A bolt of " + LIGHTNING + " pierces the air above you, melting "
            "your eyebrows.\n",
        "A bolt of " + LIGHTNING + " flares before your face, causing "
            "little blobs of light to dance over your retinas.\n"
            });

        
    shout (shout_mess[random(sizeof(shout_mess))] + "It appears one "
        "of the " + mud_name() + "'s creators is unhappy...\n");        
                    
    tell_object(ob, player_mess[random(sizeof(player_mess))]);
    call_out("fry3", 8 + random (10), ob, reason);
} /* nuke2() */

varargs void fry3(object ob, string reason) 
{
    
    string name;
    
    string *TMs = ({
        "You feel more able to spear players with bolts of lightning!\n",
        "You feel more confident about your aim when trying to hit small "
            "scurrying figures from Cori Celesti!\n",
        "You manage to grasp one of the principles of creator justice "
            "more firmly!\n",
        });
        
    string *shout_mess = ({
        "Another spear of " + LIGHTNING + " lances through the clouds, "
            "followed closely by a deafening peal of " + THUNDER + "!\n",
        "A deafening roll of " + THUNDER + " followed by a bolt of brilliant "
        + LIGHTNING + " rolls over the " + mud_list() + ".\n",
        "The clouds spit out another violent bolt of " + LIGHTNING + " as "
        + THUNDER + " shatters the relative peace of the " + mud_list() + ".\n"
        });
  
    string *player_mess = ({
        "A bolt of " + LIGHTNING + " strikes you and sends you into the "
            "%^RED%^oblivion%^RESET%^ of the real world!\n",
        "A bolt of " + LIGHTNING + " pierces the skies and strikes you!  "
        "%^RED%^Zzzzzot!%^RESET%^\n",
        "A bolt of " + LIGHTNING + " spears down from the sky and %^RED%^"
            "smites%^RESET%^ you!\n",
        });
  
  /*
        No point actually putting this through the tasker since it's only
        supposed to be a joke anyway.  :-P
  */
          
  if (random (100) > 80)
  {
        tell_object (this_player(), "The " + LIGHTNING + " blasts " + ob->short() +
            " into oblivion!\n");
        tell_object (this_player(), "%^YELLOW%^%^BOLD%^" + TMs[random(sizeof(TMs))]
            + "%^RESET%^");
        this_player()->add_skill_level ("fighting.combat.range.thrown", 1);
  }
                  
                  
  shout(shout_mess[random(sizeof(shout_mess))]);
  
  if (this_player()->query_invis())
  {
        name = "Someone";
  }
  else
  {
        name = this_player()->short();
  }
    
    
  if (reason)
  {
      shout(name + " shouts from the clouds:  This is " + reason + 
      ", " + ob->short() +"!\n");
  }
  else
  {
      shout(name + " cackles in the distance.\n");
  }
   
    
  tell_object(ob, player_mess[random(sizeof(player_mess))]);
  ob->save();
  ob->quit();
  shout(ob->query_cap_name()+" was smote by " + name + "'s "
    "lightning.\n"+ capitalize(ob->query_pronoun())+" is no more.\n");
  shout ("The clouds roll back across the sky.");

} /* fry3() */

// --- END [/mnt/home2/grok/lib/cmds/creator/fry.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/path_of.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/path_of.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626836   Available: 13574190
Inodes: Total: 5242880    Free: 4960132
1071 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/path_of.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626836   Available: 13574190
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: path_of.c,v 1.3 2003/02/25 17:19:40 trilogy Exp $
 * $Log: path_of.c,v $
 * Revision 1.3  2003/02/25 17:19:40  trilogy
 * Got rid of some tabs.
 *
 * Revision 1.2  2001/06/01 20:56:52  ceres
 * Fixed long eval stuff
 *
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* pathof command, trial out by Turrican for a commands daemon. */

#include <creator.h>

mixed cmd(string str) {
  object *ov, ob;

  if(strsrch(str, "in everyone") != -1)
    return notify_fail("Please don't do that.  You've been asked not to "
      "and it causes lag.\n");

  notify_fail("Pathof what?\n");
  ov = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ov)) return 0;

  foreach (ob in ov) {
    if (!objectp(ob)) continue;
    write("Path of " + WIZ_PRESENT->desc_object(ob) + " in " +
        WIZ_PRESENT->desc_object(environment(ob)) + ":\n");
    write(file_name(ob)+ "\n");
  }
  return 1;
}

void dest_me() {
  destruct(this_object());
}

void clean_up() {
  dest_me();
}

void reset() {
  dest_me();
}
// --- END [/mnt/home2/grok/lib/cmds/creator/path_of.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/bugreps.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/bugreps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626836   Available: 13574190
Inodes: Total: 5242880    Free: 4960132
1174 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/bugreps.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626836   Available: 13574190
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
#include <db.h>

inherit "/cmds/base";

int db;

void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;

   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Reporter"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
} /* finish_request() */

int cmd(string who){
   string request;

   if(who == "all") {
      request = "select Reporter, count(*) as bing from errors "
		   //"where Status = 'OPEN' "
                   "group by Reporter order by bing desc";
   } else {
      request = "select Reporter, count(*) as bing from errors "
		   "where Reporter = '" + who + "'" // and Status = 'OPEN' "
                   "group by Reporter order by bing desc";
   }

   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}

mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
} /* query_pattern() */
// --- END [/mnt/home2/grok/lib/cmds/creator/bugreps.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/unsuspend.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/unsuspend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626835   Available: 13574189
Inodes: Total: 5242880    Free: 4960132
1023 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/unsuspend.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626835   Available: 13574189
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: unsuspend.c,v 1.1 2001/03/12 05:08:14 ceres Exp $
 * $Log: unsuspend.c,v $
 * Revision 1.1  2001/03/12 05:08:14  ceres
 * Initial revision
 *
 * Revision 1.1  1998/12/29 06:03:35  ceres
 * Initial revision
 *
 * Revision 1.1  1998/01/06 05:29:21  ceres
 * Initial revision
 * 
*/
#include <parser.h>
#include <access.h>

inherit "/cmds/base";

mixed cmd(string str) {
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object())))
    return notify_fail("You must be a lord or liaison deputy to unsuspend "
		       "someone.");

  notify_fail("We failed!\n");
  if (!"/secure/bastards"->unsuspend_person(str))
    return 0;
  write(str+" unsuspended.\n");
  return 1;
} /* cmd() */

int help() {
  return notify_fail("Syntax: unsuspend <name>.\n");
}

mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/unsuspend.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/pstat.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/pstat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626835   Available: 13574189
Inodes: Total: 5242880    Free: 4960132
635 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/pstat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626835   Available: 13574189
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

int cmd( object *indirect_obs ) {
    object ob;
    mapping prop;
    string *sorted, property;
    string txt;

    txt = "$P$Properties$P$";

    foreach( ob in indirect_obs ) {
        prop = filter( ob->query_properties(), (: $2 :) );
        sorted = sort_array( keys( prop ), 1 );
        foreach( property in sorted ) {
            txt += sprintf( "$I$0,5=(%s): %O$I$0,-5=\n", property, prop[ property ] );
        }
    }

    tell_object( this_player(), txt );
    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd( $1 ) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/pstat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/rm.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/rm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626835   Available: 13574189
Inodes: Total: 5242880    Free: 4960132
1116 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/rm.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626835   Available: 13574189
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: rm.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: rm.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
/* rm command, trial out by Turrican for a commands daemon. */

inherit "/cmds/base";

mixed cmd(string str) {
  int fsize, loop;
  string *filenames;
 
  seteuid(geteuid(this_player()));

  if (!str) {
    notify_fail("Usage: rm file [file ...]\n");
    return 0;
  }
  filenames = this_player()->get_files(str);
  if (!sizeof(filenames)) {
    notify_fail("No such file : "+ str+"\n");
    return 0;
  }
  for (loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    fsize = file_size(str);
    if (str[<2..] == "/." || str[<3..] == "/..")
      continue;
    if (fsize == -1) {
      notify_fail("No such file or directory.\n");
      return 0;
    }
    if (fsize == -2) {
      if (!rmdir(str)) {
        notify_fail("Couldn't rm directory: " + str + "\n");
        return 0;
      }
    } else if (!rm(str)) {
      notify_fail("Can't remove file.\n");
      return 0;
    }
  }
  write("Ok.\n");
  return 1;
}
// --- END [/mnt/home2/grok/lib/cmds/creator/rm.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/auto_doc.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/auto_doc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626834   Available: 13574188
Inodes: Total: 5242880    Free: 4960132
821 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/auto_doc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626834   Available: 13574188
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: auto_doc.c,v 1.1 1998/01/06 05:25:41 ceres Exp $
 * $Log: auto_doc.c,v $
 * Revision 1.1  1998/01/06 05:25:41  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#include <autodoc.h>

int cmd(string str) {
   string *files;
   string file;

   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->recreate_documentation(file)) {
         write("Recreating documentation for " + file + ".\n");
      } else {
         write("Unable to recreate documentation for " + file + ".\n");
      }
   }
   return 1;
} /* cmd() */

mixed *query_patterns() { 
   return ({ "<string>", (: cmd($4[0]) :) });
 } /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/auto_doc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/define.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/define.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626834   Available: 13574188
Inodes: Total: 5242880    Free: 4960132
937 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/define.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626834   Available: 13574188
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
#include <network.h>

void finish_lookup(object player, string word, int result, mixed* results) {
   string ret;
   string* bing;

   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "No definitions for " + word + ".\n");
      } else {
         ret = "";
         foreach (bing in results) {
            ret += bing[1] + "\n" + bing[2] + "\n\n";
         }
         tell_object(player, "Definitions for " + word + ":\n" + ret);
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
} /* finish_lookup() */

int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->define_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   add_succeeded_mess("$N look$s up a word.\n");
   return 1;
} /* cmd() */

mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/define.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/iemote.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/iemote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626833   Available: 13574187
Inodes: Total: 5242880    Free: 4960132
656 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/iemote.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626833   Available: 13574187
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <network.h>

inherit "/cmds/base";

int cmd(string person, string text) {
    string target, mud;
 
    if (sscanf(person, "%s@%s", target, mud) != 2) {
        return 0;
    }

    if ( !strlen( target ) || !strlen( mud ) ) {
        return 0;
    }
    SERVICES_D->eventSendEmote(target, mud, text);
    add_succeeded_mess( ({ sprintf("You emote to %s@%s: %s@%s %s\n",
        capitalize(target), mud, this_player()->query_cap_name(),
        mud_name(), text), "" }) );
    return 1;
} /* cmd() */

mixed *query_patterns() {
    return ({ "<string'person'> <string'message'>",
              (: cmd($4[0], $4[1]) :) });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/iemote.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/on_line.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/on_line.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626833   Available: 13574187
Inodes: Total: 5242880    Free: 4960132
3218 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/on_line.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626833   Available: 13574187
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";

string idle_time(object person) {
  int hours, mins, secs;
  string s, m, h;

  secs = query_idle(person);
  mins = secs / 60;
  secs %= 60;
  hours = mins / 60;
  mins %= 60;
  s = ("0"+secs)[<2..<1];
  m = ("0"+mins)[<2..<1];
  if ( !hours )  {
    return " (idle: "+m+":"+s+")";
  }
  h = ("0"+hours)[<2..<1];
  return " (idle: "+h+":"+m+":"+s+")";
} /* idle_time() */

int cmd( int show_idle ) {
  object *people, person;
  string *cre, *invis, *director, *trustee, bing, obtyp;

  cre = ({ });
  invis = ({ });
  director = ({ });
  trustee = ({ });

  people = filter_array( users(), (: $1->query_creator() :) );
  people = people - this_player()->query_ignoring( people );
  people = sort_array( people,
    (: strcmp( $1->query_name(), $2->query_name() ) :) );

  foreach( person in people )  {
    bing = person->query_cap_name();
    if ( show_idle && query_idle( person ) > 120 )  {
      bing += idle_time( person );
    }
    if (!this_player()->query_property("nod")) {
      obtyp = person->query_object_type();
        switch(obtyp) {
        case "X":
           break;
        case " ":
           break;
        case "C":
           bing += "(%^CYAN%^C%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
              bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "S":
           bing += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "T":
           bing += "(%^BOLD%^%^RED%^T%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "D":
           bing += "(%^RED%^D%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        default:
           break;
      }
    }

    switch( person->query_invis()  )  {
      case 0:
        cre += ({ bing });
        break;
      case 1:
        invis += ({ bing });
        break;
      case 2:
        director += ({ bing });
        break;
      default:
        trustee += ({ bing });
        break;
    }
  }

  if(sizeof(cre)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^GREEN%^"
      "Visible%^RESET%^: "+query_multiple_short(cre)+".\n"));
  }
  if(sizeof(invis)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^CYAN%^"
      "Invisible%^RESET%^: "+query_multiple_short(invis)+".\n"));
  }
  if(sizeof(director)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^YELLOW%^Director "
      "Invisible%^RESET%^: "+query_multiple_short(director)+".\n"));
  }
  if(sizeof(trustee)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^RED%^Trustee "
      "Invisible%^RESET%^: "+query_multiple_short(trustee)+".\n"));
  }
  return 1;
} /* cmd() */

mixed *query_patterns() { 
    return ({ "", (: cmd(1) :),
              "noidle", (: cmd(0) :) });
} /* query_patterns() */ 
// --- END [/mnt/home2/grok/lib/cmds/creator/on_line.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/setmmout.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/setmmout.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626832   Available: 13574186
Inodes: Total: 5242880    Free: 4960132
791 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/setmmout.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626832   Available: 13574186
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: setmmout.c,v 1.2 1998/04/14 02:42:56 pinkfish Exp $
 * $Log: setmmout.c,v $
 * Revision 1.2  1998/04/14 02:42:56  pinkfish
 * Changed to use add_command.
 *
 * Revision 1.1  1998/01/06 05:29:43  ceres
 * Initial revision
 * 
*/
inherit "/cmds/base";

#define TP this_player()

mixed cmd(string str) {

  if(TP->query_creator() || TP->query_property("setm")) { 
    str = str + " ";
    if (sizeof(explode("^"+str, "$N")) < 2)
      return notify_fail("Must have a $N in your teleport exit message.\n");
    TP->set_mmsgout(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");

} /* cmd() */
 
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/setmmout.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/ban.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/ban.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626832   Available: 13574186
Inodes: Total: 5242880    Free: 4960132
1139 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/ban.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626832   Available: 13574186
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:43.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ban.c,v 1.4 2001/06/01 20:56:23 ceres Exp $
 * 
 */
#include <parser.h>
#include <access.h>

inherit "/cmds/base";

/*
 * This will ban a site
 */
mixed cmd(string ip, string reason) {
  seteuid("Root");
  
  if (this_player() != this_player(1))
    return 0;

  if(!"/secure/master"->query_lord(geteuid(previous_object())) &&
     !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) 
    return notify_fail("Only lords or liaison deputies can do that.\n");

  if(strsrch(ip, "*") != -1)
    return notify_fail("This command does not take wildcards.\n");
  
  if (!"/secure/bastards"->change_access(ip, 2, reason,
                                         time() + (60*60*2))) {
    write("Error changing permissions.\n");
    return 0;
  }

  write("Site banned.\n");
  return 1;
} /* cmd() */

int help() {
  return notify_fail(
    "Syntax: ban <ip number> <reason>\n");
}
mixed *query_patterns() {
  return ({ "<word'address'> <string'reason'>",
              (: cmd($4[0], implode($4[1..], "")) :),
              "help", (: help() :)
              });
} /* query_patterns() */
// --- END [/mnt/home2/grok/lib/cmds/creator/ban.c] ---
// --- BEGIN [/mnt/home2/grok/lib/cmds/creator/pw_d.c] ---
// Size:   File: "/mnt/home2/grok/lib/cmds/creator/pw_d.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626831   Available: 13574185
Inodes: Total: 5242880    Free: 4960132
194 bytes, Last Modified:   File: "/mnt/home2/grok/lib/cmds/creator/pw_d.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626831   Available: 13574185
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:44.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/cmds/base";
 
int cmd() {
   write(this_player()->query_path() + "\n");
   return 1;
} /* cmd() */
 
mixed *query_patterns() {
   return ({ "", (: cmd :) });
} /* query_patterns() */

// --- END [/mnt/home2/grok/lib/cmds/creator/pw_d.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/external/java/telnet/tools/mrelayd.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/external/java/telnet/tools/mrelayd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626831   Available: 13574185
Inodes: Total: 5242880    Free: 4960132
15201 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/external/java/telnet/tools/mrelayd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626831   Available: 13574185
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:05.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * mrelayd.c -- a relay daemon
 * --
 * $Id: mrelayd.c,v 1.10 1998/02/09 13:57:42 marcus Exp $
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * "The Java Telnet Applet" is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/* mrelayd.c (c) 1996,1997 Marcus Meissner <marcus@mud.de> */

/* Compile with: cc -o relayd relayd.c
 *           or: gcc -o relayd relayd.c
 * Solaris: (g)cc -o relayd relayd.c -lsocket -lnsl
 */

/* this program expects the string:
 * "relay <hostname> <port>" or "relay <hostname>"
 * after connecting. It will then try to connect to the specified host
 * if failures occur, it will terminate the connection.
 */

/* adjust this to a reasonable limit */
#define MAXUSERS  120

/* message printed if all slots are used ... */
#define FAILMESSAGE "Sorry, all slots are full.\r\n"

/* string printed before connection */
#define RELAYHEADER "Relayd $Revision: 1.10 $ (c) Marcus Meissner\r\n"

/* the tcp port this demons is listening on ... */
#define LISTENPORT  31415

/* default connect port (telnet) */
#define DEFAULTPORT 23

/* default buffersize */
#define DEFAULTSIZE	2000

#include <stdio.h>
#ifdef _WIN32
#include <winsock.h>
#include <signal.h>
#define ioctl ioctlsocket
#define read(a,b,c) recv(a,b,c,0)
#define write(a,b,c) send(a,b,c,0)
#define close _lclose
#define EINTR WSAEINTR
#define perror xperror
void xperror(char *s) {
	fprintf(stderr,"%s: %d\n",s,GetLastError());
}
#else
#include <sys/time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/errno.h>
#include <sys/signal.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#endif
#include <memory.h>
#include <malloc.h>
#include <string.h>
#include <sys/types.h>

#if defined(sun) && defined(__GNUC__)
int socket(int,int,int);
int shutdown(int,int);
int close(int);
int bind(int,struct sockaddr*,int);
int listen(int,int);
void bzero(char*,int);
int select(int,fd_set *,fd_set*,fd_set*,struct timeval*);
int accept(int,struct sockaddr*,int*);
int connect(int,struct sockaddr*,int);
int recvfrom(int,char*,int,int,struct sockaddr*,int*);
/*void perror(char*); SLOWLARIS HASS*/
/*int sendto(int,char*,int,int,struct sockaddr*,int); SLOWLARIS HASS*/
#endif

#ifdef hpux
/* redefinition... to avoid prototype in <time.h> */
#define FD_CAST int
#endif

#ifdef sgi
void bzero(void*,int);
#endif

#ifndef FD_CAST
#define FD_CAST fd_set
#endif

extern int errno;

struct relay {
	char	*inbuf,*outbuf;
	int	infd,outfd,incur,outcur,insize,outsize;
	struct	sockaddr_in	inaddr,outaddr;
	int	state;
#define STATE_ACCEPTED		0
#define STATE_OK		1
	int	flags;
#define FLAG_EOF_USER		1
#define FLAG_EOF_TARGET		2
#define FLAG_CLOSED_TARGET	4
#define FLAG_CLOSED_USER	8
} *relays = NULL;
int nrofrelays = 0;

void*
xmalloc(int size) {
	void*x;

	x=malloc(size);
	if (!x && size) {
		fprintf(stderr,"Out of memory, exiting.\n");
		exit(1);
	}
	return x;
}

void*
xrealloc(void *y,int size) {
	void*x;

	x=realloc(y,size);
	if (!x && size) {
		fprintf(stderr,"Out of memory, exiting.\n");
		exit(1);
	}
	return x;
}

static int
fd_make_nonblocking(int fd) {
  int     isnonblock=0;

#ifdef FIONBIO
  if (!isnonblock) {
    int     b;
    b=1;
    if (-1==ioctl(fd,FIONBIO,&b)) {
      perror("ioctl FIONBIO");
    } else
      isnonblock=1;
  }
#endif
#ifdef O_NDELAY
  if (!isnonblock) {
    int     flags;

    if (-1==(flags=fcntl(fd,F_GETFL))) {
      perror("fcntl F_GETFL");
    } else {
      flags|=O_NDELAY;
      if (-1==fcntl(fd,F_SETFL,flags)) {
        perror("fcntl F_SETFL  O_NDELAY");
      } else
        isnonblock=1;
    }
  }
#endif
#ifdef O_NONBLOCK
  if (!isnonblock) {
    int     flags;

    if (-1==(flags=fcntl(fd,F_GETFL))) {
      perror("fcntl F_GETFL");
    } else {
      flags|=O_NONBLOCK;
      if (-1==fcntl(fd,F_SETFL,flags)) {
        perror("fcntl F_SETFL  O_NONBLOCK");
      } else
        isnonblock=1;
    }
  }
#endif
  return isnonblock;
}

void
clean_connection(struct relay *relay) {
  if (!relay) return;
  if (relay->outfd>=0) {
    if (-1==close(relay->outfd))
      perror("close");
    relay->outfd=-1;
  }
  if (relay->infd>=0) {
    if (-1==close(relay->infd))
      perror("close");
    relay->infd=-1;
  }
  free(relay->outbuf);free(relay->inbuf);
  memcpy(relay,relay+1,sizeof(struct relay)*(nrofrelays-(relay-relays)-1));
  relays = xrealloc(relays,sizeof(struct relay)*(--nrofrelays));
}

void
main(argc,argv)
int argc;
char  **argv;
{
  int i,j,res;
  int acfd;
  struct  sockaddr_in acsa;
  char	readbuf[1000],relaystring[1000];
  struct  in_addr targetaddr;
#ifdef _WIN32 
  {
	WSADATA wsad;
	
	WSAStartup(0x0101,&wsad);
  }
#else
  close(0);
  close(1);
#endif
#ifdef SIGPIPE
  signal(SIGPIPE,SIG_IGN);
#endif
#ifdef SIGHUP
  signal(SIGHUP,SIG_IGN); /* don't terminate on session detach */
#endif
  strcpy(relaystring,FAILMESSAGE);
  if (-1==(acfd=socket(PF_INET,SOCK_STREAM,0))) {
    perror("socket(accept_socket)");
    exit(1);
  }

  acsa.sin_family=AF_INET;
  acsa.sin_port=htons(LISTENPORT);
  acsa.sin_addr.s_addr=INADDR_ANY;
#ifdef SO_REUSEADDR
  {
    int reuseit=1;
    if (-1==setsockopt(acfd,SOL_SOCKET,SO_REUSEADDR,(char*)&reuseit,sizeof(reuseit)))
	perror("setsockopt SOL_SOCKET SO_REUSEADDR");
  }
#endif
  if (-1==bind(acfd,(struct sockaddr*)&acsa,sizeof(struct sockaddr_in))) {
    perror("bind");
    exit(1);
  }
  /* 5 is usual the maximum anyway */
  if (-1==listen(acfd,5)) {
    perror("listen");
    exit(1);
  }
  while (1) {
    fd_set  readfds,writefds;
    int width;

    width=3;
    if (acfd>=width)
      width=acfd+1;
restart_select:
    FD_ZERO(&readfds);FD_ZERO(&writefds);
    FD_SET(acfd,&readfds);
    for (i=nrofrelays;i--;) {
      struct relay *relay = relays+i;

      /* both sides closed? -> clean */
      if ((relay->flags & (FLAG_CLOSED_TARGET|FLAG_CLOSED_USER)) ==
      	(FLAG_CLOSED_TARGET|FLAG_CLOSED_USER)
      ) {
      	clean_connection(relay);
	continue;
      }
      /* transmitted all stuff left to user? -> close */
      if ((relay->flags&(FLAG_CLOSED_TARGET|FLAG_EOF_TARGET))&&(!relay->outcur)) {
	clean_connection(relay);
	continue;
      }
      /* transmitted all stuff left to target? -> close */
      if ((relay->flags&(FLAG_CLOSED_USER|FLAG_EOF_USER))&&(!relay->incur)) {
	clean_connection(relay);
	continue;
      }

      if (relay->outfd>=0) {
        /*need to do that... else it will cause load 1*/
        if (relay->incur)
          FD_SET(relay->outfd,&writefds);
	if (!(relay->flags & FLAG_EOF_TARGET))
	    FD_SET(relay->outfd,&readfds);
        if (relay->outfd>=width)
          width=relay->outfd+1;
      }
      if (relay->infd>=0) {
        /*need to do that... else it will cause load 1*/
        if (relay->outcur)
          FD_SET(relay->infd,&writefds);
	if (!(relay->flags & FLAG_EOF_USER))
          FD_SET(relay->infd,&readfds);
        if (relay->infd>=width)
          width=relay->infd+1;
      }
    }
    if (-1==select(   width,
          (FD_CAST*)&readfds,
          (FD_CAST*)&writefds,
          NULL,/*no exceptfds.*/
          0)
    ) {
      if (errno!=EINTR)
        perror("select");
      else
        goto  restart_select;
    }
    if (FD_ISSET(acfd,&readfds)) {
      int afd;
      int aclen;
      struct  sockaddr_in conaddr;
      struct relay *relay = NULL;

      aclen=sizeof(struct sockaddr_in);
      if (-1==(afd=accept(acfd,(struct sockaddr*)&conaddr,&aclen)))
        perror("accept");
      if (relays)
	  relays=(struct relay*)xrealloc(relays,sizeof(struct relay)*(nrofrelays+1));
      else
	  relays=(struct relay*)xmalloc(sizeof(struct relay));
      nrofrelays++;
      relay = relays+(nrofrelays-1);
      relay->inbuf	= xmalloc(DEFAULTSIZE);
      relay->outbuf	= xmalloc(DEFAULTSIZE);
      relay->insize	= DEFAULTSIZE;
      relay->outsize	= DEFAULTSIZE;
      relay->flags	= 0;
      relay->incur	= 0;
      relay->outcur	= 0;
      relay->infd	= afd;
      relay->outfd	= -1;
      relay->state	= STATE_ACCEPTED;
      memcpy(&relay->inaddr,&conaddr,sizeof(struct sockaddr_in));
      if (nrofrelays>=MAXUSERS) {
        strcpy(relay->outbuf,relaystring);
	relay->outcur = strlen(relaystring)+1;
	relay->state = STATE_OK;
	relay->flags = FLAG_CLOSED_TARGET;
      }
#ifdef SO_LINGER
      {
	struct linger sol;
	sol.l_linger = 5;
	sol.l_onoff = 1;
	if (-1==setsockopt(acfd,SOL_SOCKET,SO_LINGER,(char*)&sol,sizeof(sol)))
	    perror("setsockopt SOL_SOCKET SO_LINGER");
      }
#endif
    }
    for (i=nrofrelays;i--;) {
      struct relay *relay = relays+i;

      if ((relay->infd>=0) && FD_ISSET(relay->infd,&readfds)) {
        do {
          if (-1==(res=read(relay->infd,readbuf,1000))) {
            if (errno==EINTR)
              break;
            /* user side has broken the connection */
	    close(relay->infd);relay->infd=-1;
	    relay->flags |= FLAG_CLOSED_USER;
            break;
          }
          break;
        } while (1);
        if (res==0) {
	  /* we read the End Of File marker. but we still have to write 
	   * the rest of the text
	   */
	  relay->flags |= FLAG_EOF_USER;
        }
        if (res>0) {
          readbuf[res]='\0';
          while (relay->incur+res>=relay->insize) {
            relay->inbuf=xrealloc(relay->inbuf,relay->insize*2);
            relay->insize*=2;
          }
          memcpy(relay->inbuf+relay->incur,readbuf,res+1);
          relay->incur+=res;
        }
        if (	(relay->outfd==-1) &&
		(relay->state==STATE_ACCEPTED) &&
		memchr(relay->inbuf,'\n',relay->incur)
        ) {
          char  sendbuf[200];
          struct  hostent *hp;
          char  *s,*nextchar,*tmp;
          int port;

          s = memchr(relay->inbuf,'\n',relay->incur);
          if (!s)
            continue;
          *s='\0';
          nextchar=s+1;
          if ((s=memchr(relay->inbuf,'\r',(s-relay->inbuf))))
            *s='\0';


	  relay->state = STATE_OK;

          tmp = (char*)xmalloc(strlen(relay->inbuf));
          if (2!=sscanf(relay->inbuf,"relay %s %d",
            tmp,&port
          )) {
            if (!sscanf(relay->inbuf,"relay %s",tmp)) {

              free(tmp);
              /* we avoid telling potential hackers how to use this relay */
	      sprintf(relay->outbuf,"550 Bad syntax. Go away.\n",tmp);
	      relay->outcur = strlen(relay->outbuf);
	      relay->flags = FLAG_CLOSED_TARGET;
              continue;
            } else
              port = DEFAULTPORT;
          }
          hp=gethostbyname(tmp);
          if (!hp) {/* not found */
	    sprintf(relay->outbuf,"No hostentry for '%s'!\n",tmp);
            free(tmp);
	    relay->outcur = strlen(relay->outbuf);
	    relay->flags = FLAG_CLOSED_TARGET;
            continue;
          }
          memcpy(&targetaddr,hp->h_addr_list[0],sizeof(struct in_addr));
          relay->outaddr.sin_family=AF_INET;
          relay->outaddr.sin_port=htons(port);
          memcpy(&(relay->outaddr.sin_addr),&targetaddr,4);
          strcpy(sendbuf,RELAYHEADER);
          relay->outcur=strlen(sendbuf);
          memcpy(relay->outbuf,sendbuf,strlen(sendbuf)+1);
          if (-1==(relay->outfd=socket(PF_INET,SOCK_STREAM,0)))
            perror("socket(connect_socket)");
#ifndef _WIN32
          (void)fd_make_nonblocking(relay->outfd);
#endif
          if (  (-1==connect( relay->outfd,
              (struct sockaddr*)&(relay->outaddr),
              sizeof(struct sockaddr_in))
#ifdef _WIN32
				) && (WSAGetLastError()!=WSAEINPROGRESS)
#else
				) && (errno!=EINPROGRESS)
#endif
          ) {
            sprintf(readbuf,"Connect to %s failed: %s\n",tmp,strerror(errno));
            perror("connect");
	    close(relay->outfd);relay->outfd=-1;
	    relay->state = STATE_OK;
	    relay->flags |= FLAG_CLOSED_TARGET;
	    strcpy(relay->outbuf,readbuf);
	    relay->outsize = strlen(readbuf)+1;
            free(tmp);
            continue;
          }
          free(tmp);
#ifdef SEND_REMOTEIP
          /* only useful if you want to tell the
           * remotemud the _real_ host the caller
           * is calling from
           */
          tmphp=gethostbyaddr(
            (char*)(&(conaddr.sin_addr)),
            sizeof(struct in_addr),
            AF_INET
          );
          if (!tmphp) {
            sprintf(sendbuf,"remoteip %s %s\n",
              inet_ntoa(conaddr.sin_addr),
              inet_ntoa(conaddr.sin_addr)
            );
          } else {
            sprintf(sendbuf,"remoteip %s %s\n",
              inet_ntoa(conaddr.sin_addr),
              tmphp->h_name
            );
          }
          memcpy(relay->inbuf,sendbuf,strlen(sendbuf)+1);
          relay->incur=strlen(sendbuf);
#else
          relay->inbuf[0]='\0';
          relay->incur=0;
#endif
        }
      }
      if ((relay->outfd>=0) && FD_ISSET(relay->outfd,&readfds)) {
        do {
          if (-1==(res=read(relay->outfd,readbuf,1000))) {
            if (errno==EINTR)
              continue;
            /* the mudside has broken the
             * connection. we still have
             * to transmit the rest of
             * the text
             */
            close(relay->outfd);relay->outfd=-1;
	    relay->flags |= FLAG_CLOSED_TARGET;
            break;
          }
          break;
        } while (1);
        if (res==0) {
	  /* we read the End Of File marker. but we still have to write 
	   * the rest of the text
	   */
	  relay->flags |= FLAG_EOF_TARGET;
	}
        if (res>0) {
          /* 0 is not automagically appended. */
          readbuf[res]='\0';
          while (relay->outcur+res>=relay->outsize) {
            relay->outbuf=xrealloc(relay->outbuf,relay->outsize*2);
            relay->outsize*=2;
          }
          memcpy(relay->outbuf+relay->outcur,readbuf,res+1);
          relay->outcur+=res;
        }
      }
      if ((relay->infd>=0) && FD_ISSET(relay->infd,&writefds)) {
        j=relay->outcur;
        if (-1==(res=write(relay->infd,relay->outbuf,j))) {
          if (errno!=EINTR) {
	    close(relay->infd);relay->infd=-1;
	    relay->flags |= FLAG_CLOSED_USER;
          }
        }
        if (res>0) {
          memcpy(relay->outbuf,relay->outbuf+res,relay->outcur-res);
          relay->outcur-=res;
        }
      }
      if ((relay->outfd>=0) && FD_ISSET(relay->outfd,&writefds)) {
        j=relay->incur;
        if (-1==(res=write(relay->outfd,relay->inbuf,j))) {
          if (errno!=EINTR) {
            close(relay->outfd);relay->outfd=-1;
	    relay->flags |= FLAG_CLOSED_TARGET;
          }
        }
        if (res>0) {
          memcpy(relay->inbuf,relay->inbuf+res,relay->incur-res);
          relay->incur-=res;
        }
      }
    }
  }
}
// --- END [/mnt/home2/grok/lib/www/external/java/telnet/tools/mrelayd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/external/java/telnet/tools/relayd.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/external/java/telnet/tools/relayd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626827   Available: 13574181
Inodes: Total: 5242880    Free: 4960132
11092 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/external/java/telnet/tools/relayd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626827   Available: 13574181
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:05.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * relayd.c -- a relay daemon (using one targethost/port)
 * --
 * $Id: relayd.c,v 1.4 1998/02/06 16:30:21 marcus Exp $
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * "The Java Telnet Applet" is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/* relayd.c (c) 1996,1997 Marcus Meissner <marcus@mud.de> */

/* Compile with: cc -o relayd relayd.c
 *           or: gcc -o relayd relayd.c
 * Solaris: (g)cc -o relayd relayd.c -lsocket -lnsl
 */

/* this program expects the string:
 * "relay <hostname> <port>" or "relay <hostname>"
 * after connecting. It will then try to connect to the specified host
 * if failures occur, it will terminate the connection.
 */

/* adjust this to a reasonable limit */
#define MAXUSERS  120

/* message printed if all slots are used ... */
#define FAILMESSAGE "Sorry, all slots are full.\r\n"

/* string printed before connection */
#define RELAYHEADER "Relayd (c) Marcus Meissner\r\n"

#include <stdio.h>
#ifdef _WIN32
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <winsock.h>
#include <io.h>
#define ioctl ioctlsocket
#define write(h,buf,size) send(h,buf,size,0)
#define read(a,b,c) recv(a,b,c,0)
#define close _lclose
#define EINPROGRESS WSAEWOULDBLOCK
#else
#include <unistd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/signal.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#endif
#include <memory.h>
#include <malloc.h>
#include <string.h>
#include <sys/types.h>



#if defined(sun) && defined(__GNUC__)
int socket(int,int,int);
int shutdown(int,int);
int close(int);
int bind(int,struct sockaddr*,int);
int listen(int,int);
void bzero(char*,int);
int select(int,fd_set *,fd_set*,fd_set*,struct timeval*);
int accept(int,struct sockaddr*,int*);
int connect(int,struct sockaddr*,int);
int recvfrom(int,char*,int,int,struct sockaddr*,int*);
/*void perror(char*); SLOWLARIS HASS*/
/*int sendto(int,char*,int,int,struct sockaddr*,int); SLOWLARIS HASS*/
#endif

/* extern char *sys_errlist[]; */

#ifdef hpux
/* redefinition... to avoid prototype in <time.h> */
#define FD_CAST int
#endif

#ifdef sgi
void bzero(void*,int);
#endif

#ifndef FD_CAST
#define FD_CAST fd_set
#endif

extern int errno;

char  *inbuf[MAXUSERS],*outbuf[MAXUSERS];
int insize[MAXUSERS],outsize[MAXUSERS];
int incur[MAXUSERS],outcur[MAXUSERS];
int outfd[MAXUSERS],infd[MAXUSERS];
struct  sockaddr_in inaddr[MAXUSERS],outaddr[MAXUSERS];

#ifdef _WIN32
#define perror xperror
void xperror(char *str) {
	fprintf(stderr,"%s: %d\n",str,GetLastError());
}
#endif

static int
fd_make_nonblocking(int fd) {
  int     isnonblock=0;

#ifdef FIONBIO
  if (!isnonblock) {
    int     b;
    b=1;
    if (-1==ioctl(fd,FIONBIO,&b)) {
      perror("ioctl FIONBIO");
    } else
      isnonblock=1;
  }
#endif
#ifdef O_NDELAY
  if (!isnonblock) {
    int     flags;

    if (-1==(flags=fcntl(fd,F_GETFL))) {
      perror("fcntl F_GETFL");
    } else {
      flags|=O_NDELAY;
      if (-1==fcntl(fd,F_SETFL,flags)) {
        perror("fcntl F_SETFL  O_NDELAY");
      } else
        isnonblock=1;
    }
  }
#endif
#ifdef O_NONBLOCK
  if (!isnonblock) {
    int     flags;

    if (-1==(flags=fcntl(fd,F_GETFL))) {
      perror("fcntl F_GETFL");
    } else {
      flags|=O_NONBLOCK;
      if (-1==fcntl(fd,F_SETFL,flags)) {
        perror("fcntl F_SETFL  O_NONBLOCK");
      } else
        isnonblock=1;
    }
  }
#endif
  return isnonblock;
}

void
clean_connection(i)
int i;
{
  if (outfd[i]>=0) {
    if (-1==close(outfd[i]))
      perror("close");
    outfd[i]=-1;
  }
  if (infd[i]>=0) {
    if (-1==close(infd[i]))
      perror("close");
    infd[i]=-1;
  }
  incur[i]=outcur[i]=0;
  outbuf[i][0]=inbuf[i][0]='\0';
}

void
usage() {
   fprintf(stderr,"Usage: relayd <listenport> <targethost> [<targetport>]\n");
}

void
main(argc,argv)
int argc;
char  **argv;
{
  int i,j,res;
  int acfd;
  struct  sockaddr_in acsa;
  char  readbuf[1000],relaystring[1000];
  struct  in_addr targetaddr;
  struct  hostent *hp;
  char *targethost;
  int  port,targetport;
  
#ifdef _WIN32 
  {
	WSADATA wsad;
	
	WSAStartup(0x0101,&wsad);
  }
#else
  close(0);
  close(1);
#endif

#ifdef SIGPIPE
  signal(SIGPIPE,SIG_IGN);
#endif  
  switch (argc) {
  default:
  case 1:
  case 2:
    usage();
    exit(1);
  case 3:
    if (!sscanf(argv[1],"%d",&port)) {
      usage();
      exit(1);
    }
    targethost = argv[2];
    targetport = 23;
    break;
  case 4:
    if (!sscanf(argv[1],"%d",&port)) {
      usage();exit(1);
    }
    if (!sscanf(argv[3],"%d",&targetport)) {
      usage();exit(1);
    }
    targethost=argv[2];
    break;
  }
  strcpy(relaystring,FAILMESSAGE);
  if (-1==(acfd=socket(PF_INET,SOCK_STREAM,0))) {
    perror("socket(accept_socket)");
    exit(1);
  }
  for (i=MAXUSERS;i--;) {
    inbuf[i]=malloc(10000*sizeof(char));
    outbuf[i]=malloc(10000*sizeof(char));
    inbuf[i][0]='\0';outbuf[i][0]='\0';

    insize[i]=10000;incur[i]=0;

    outsize[i]=10000;outcur[i]=0;
    outfd[i]=infd[i]=-1;
  }

  acsa.sin_family=AF_INET;
  acsa.sin_port=htons(port);
  acsa.sin_addr.s_addr=INADDR_ANY;
  if (-1==bind(acfd,(struct sockaddr*)&acsa,sizeof(struct sockaddr_in))) {
    perror("bind");
    exit(1);
  }
  /* 5 is usual the maximum anyway */
  if (-1==listen(acfd,5)) {
    perror("listen");
    exit(1);
  }
  while (1) {
    fd_set  readfds,writefds;
    int width;

    width=3;
    if (acfd>=width)
      width=acfd+1;
restart_select:
    FD_ZERO(&readfds);FD_ZERO(&writefds);
    FD_SET(acfd,&readfds);
    for (i=MAXUSERS;i--;) {
      if (outfd[i]>=0) {
        /*need to do that... else it will cause load 1*/
        if (incur[i])
          FD_SET(outfd[i],&writefds);
        FD_SET(outfd[i],&readfds);
        if (outfd[i]>=width)
          width=outfd[i]+1;
      }
      if (infd[i]>=0) {
        /*need to do that... else it will cause load 1*/
        if (outcur[i])
          FD_SET(infd[i],&writefds);
        FD_SET(infd[i],&readfds);
        if (infd[i]>=width)
          width=infd[i]+1;
      }
    }
    if (-1==select(   width,
          (FD_CAST*)&readfds,
          (FD_CAST*)&writefds,
          NULL,/*no exceptfds.*/
          0)
    ) {
      if (errno!=EINTR)
        perror("select");
      else
        goto  restart_select;
    }
    if (FD_ISSET(acfd,&readfds)) {
      int afd;
      int aclen;
      struct  sockaddr_in conaddr;

      aclen=sizeof(struct sockaddr_in);
      if (-1==(afd=accept(acfd,(struct sockaddr*)&conaddr,&aclen)))
        perror("accept");
      for (i=MAXUSERS;i--;)
        if ((infd[i]==-1) && (outfd[i]==-1))
          break;
      if (i==-1) {
        write(afd,relaystring,strlen(relaystring));
        close(afd);
      } else {
        char  sendbuf[200];
        infd[i]=afd;
        memcpy(&inaddr[i],&conaddr,sizeof(struct sockaddr_in));
        /* outfd setting delayed until we get
         * to the first line
         */
        hp=gethostbyname(targethost);
        if (!hp) {/* not found */
          clean_connection(i);
          continue;
        }
        memcpy(&targetaddr,hp->h_addr_list[0],sizeof(struct in_addr));
        outaddr[i].sin_family=AF_INET;
        outaddr[i].sin_port=htons(targetport);
        memcpy(&(outaddr[i].sin_addr),&targetaddr,4);
        strcpy(sendbuf,RELAYHEADER);
        outcur[i]=strlen(sendbuf);
        memcpy(outbuf[i],sendbuf,strlen(sendbuf)+1);
        if (-1==(outfd[i]=socket(PF_INET,SOCK_STREAM,0)))
          perror("socket(connect_socket)");
#ifndef _WIN32
        (void)fd_make_nonblocking(outfd[i]);
#endif        
		if (  (-1==connect( outfd[i],
            (struct sockaddr*)&outaddr[i],
            sizeof(struct sockaddr_in))
#ifdef _WIN32
        ) && (WSAGetLastError()!=WSAEWOULDBLOCK)
#else  
        ) && (errno!=EINPROGRESS)
#endif
        ) {
#ifdef _WIN32
			sprintf(readbuf,"Connect to %s failed: %d\n",targethost,GetLastError());
#else
          sprintf(readbuf,"Connect to %s failed: %s\n",targethost,sys_errlist[errno]);
#endif
          perror("connect");
          if (-1==write(infd[i],readbuf,strlen(readbuf)))
            perror("write");
          clean_connection(i);
          continue;
        }
        inbuf[i][0]='\0';
        incur[i]=0;
      }
    }
    for (i=MAXUSERS;i--;) {
      if ((infd[i]>=0) && FD_ISSET(infd[i],&readfds)) {
        do {
          if (-1==(res=read(infd[i],readbuf,1000))) {
            if (errno==EINTR)
              continue;
            /* user side has broken the connection */
            clean_connection(i);
            break;
          }
          break;
        } while (1);
        if (res==0) /* EOF */
          clean_connection(i);
        if (res>0) {
          readbuf[res]='\0';
          while (incur[i]+res>=insize[i]) {
            inbuf[i]=realloc(inbuf[i],insize[i]*2);
            insize[i]*=2;
          }
          memcpy(inbuf[i]+incur[i],readbuf,res+1);
          incur[i]+=res;
        }
      }
      if ((outfd[i]>=0) && FD_ISSET(outfd[i],&readfds)) {
        do {
          if (-1==(res=read(outfd[i],readbuf,1000))) {
            if (errno==EINTR)
              continue;
            /* the mudside has broken the
             * connection. we still have
             * to transmit the rest of
             * the text
             */
            outfd[i]=-1;
            break;
          }
          break;
        } while (1);
        if (res==0)
          clean_connection(i);
        if (res>0) {
          /* 0 is not automagically appended. */
          readbuf[res]='\0';
          while (outcur[i]+res>=outsize[i]) {
            outbuf[i]=realloc(outbuf[i],outsize[i]*2);
            outsize[i]*=2;
          }
          memcpy(outbuf[i]+outcur[i],readbuf,res+1);
          outcur[i]+=res;
        }
      }
      if ((infd[i]>=0) && FD_ISSET(infd[i],&writefds)) {
        j=outcur[i];
        if (-1==(res=write(infd[i],outbuf[i],j))) {
          if (errno!=EINTR) {
            clean_connection(i);
          }
        }
        if (res>0) {
          memcpy(outbuf[i],outbuf[i]+res,outcur[i]-res);
          outcur[i]-=res;
        }
      }
      if ((outfd[i]>=0) && FD_ISSET(outfd[i],&writefds)) {
        j=incur[i];
        if (-1==(res=write(outfd[i],inbuf[i],j))) {
          if (errno!=EINTR) {
            outfd[i]=-1;
            /*clean_connection(i);*/
          }
        }
        if (res>0) {
          memcpy(inbuf[i],inbuf[i]+res,incur[i]-res);
          incur[i]-=res;
        }
      }
    }
  }
}
// --- END [/mnt/home2/grok/lib/www/external/java/telnet/tools/relayd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/errors_new.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/errors_new.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626824   Available: 13574178
Inodes: Total: 5242880    Free: 4960132
27891 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/errors_new.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626824   Available: 13574178
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the new bug database html error handler.  It uses the new
 * error handler to do the bug database lookups and avoids using the
 * blocking database calls.
 * @author Pinkfish
 * @started Fri Feb  7 12:31:59 PST 2003
 */
#include <error_handler.h>
#include <player_handler.h>
#include <http.h>
#include <db.h>

#undef SAVE_FILE
#define SAVE_FILE "/save/www/errors"

#define TIMEOUT_PERIOD (30 * 60)

class user_data {
   class error_query query;
   class error_summary* errors;
   int last_touched;
   string direction;
}

private mapping _user_query;

void load_me();

void create() {
   _user_query = ([ ]);
   call_out("flush_old", TIMEOUT_PERIOD);
   load_me();
}

void flush_old() {
   string name;
   class user_data data;

   call_out("flush_old", TIMEOUT_PERIOD);
   foreach (name, data in _user_query) {
      if (time() - data->last_touched > TIMEOUT_PERIOD) {
         map_delete(_user_query, name);
      }
   }
}

void load_me() {
   unguarded( (: restore_object(SAVE_FILE) :) );
}

void save_me() {
   unguarded( (: save_object(SAVE_FILE, 2) :) );
}

private varargs string create_header(class http_request req, string title,
                                     int no_timeout) {
  return "<HTML>\n<HEAD>\n"
    "<TITLE>" + title + "</TITLE>\n"
    "<META http-equiv=\"Refresh\" content=\"" + TIMEOUT_PERIOD +
        ";URL=http://" + req->hostname +
        "/secure/errors_new.c?action=timeout\">"
    "</HEAD>\n<BODY bgcolor=\"#ffffff\" text=\"#000030\" link=\"#4a529c\" "
    "vlink=\"#b57339\">\n<FONT face=\"arial,helvetica\">\n"
    //"<i>(Imagine a pretty picture here to save space)</i>\n<H2>Errors</H2>\n"
    //"<H3><I>When cabbages are just not enough.</I></H3>\n<BR clear=\"left\">\n"
    "<BR>\n";
} /* create_header() */

private string create_footer(class http_request req) {
  return ("/www/footer"->www_function("footer", ([ ]), req))+"</BODY>\n</HTML>\n";
}

private string htmlify_no_address(string str) {
  return replace(str, ({
    "&", "&amp;",
      "<", "&lt;",
      ">", "&gt;",
      "\n", "<BR>\n",
      /* " ", "&nbsp;", */
      }) );
}

/*
 * Makes all the '<' turn into $gt; and the '>' the same.  Turn
 * http addresses into real addresses...
 */
string htmlify(string  str) {
   string *bits;
   string start;
   string end;
   string extra;
   int i;

   str =  htmlify_no_address(str);
   if (strsrch(str, "http:") > 0) {
      bits = explode("#" + str, "http:");
      bits[0] = bits[0][1..];
      for (i = 1; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%s&nbsp;%s", start, end) == 2) {
            end = "&nbsp;" + end;
            if (sscanf(start, "%s<BR>%s", start, extra) == 2) {
                end = "<BR>" + extra + end;
            }
         } else if (sscanf(bits[i], "%s<BR>%s", start, end) == 2) {
            end = "<BR>" + end;
         } else {
            start = bits[i];
            end = "";
         }
         if (start[<1] == '.') {
            start = start[0..<2];
            end = "." + end;
         }
         bits[i] = "<A href=\"http:" + start + "\">http:" + start + "</A>" +
                     end;
      }
      str = implode(bits, "");
   }

   return str;
}

string html_error(class http_request req, string error) {
   return create_header(req, error) +
          "<h2>" + error + "</h2>" +
          create_footer(req);
}

int find_index(class http_request req, int id) {
   int i;
   class error_summary* errors;

   if (!_user_query[req->user]) {
      return 0;
   }
   _user_query[req->user]->last_touched = time();
   errors = _user_query[req->user]->errors;
   for (i = 0; i < sizeof(errors); i++) {
      if (id == errors[i]->id) {
         return i;
      }
   }
   return 0;
}

int max_index(class http_request req) {
   if (!_user_query[req->user]) {
      return 0;
   }
   _user_query[req->user]->last_touched = time();
   return sizeof(_user_query[req->user]->errors);
}

int id_at(class http_request req, int index) {
   if (!_user_query[req->user] || index < 0 ||
       index >= sizeof(_user_query[req->user]->errors)) {
      return 0;
   }

   _user_query[req->user]->last_touched = time();
   return _user_query[req->user]->errors[index]->id;
}

void finish_query(function callback,
                  class http_request req,
                  int type, mixed data, string query) {
   class error_summary summary;
   string ret;
   string fname;
   string line;

   if (type != DB_SUCCESS) {
      evaluate(callback, html_error(req, "Error: " + data));
      return ;
   }

   ret = create_header(req, "Error list");
   _user_query[req->user]->errors = data;
   save_me();
   if (!sizeof(data)) {
      ret += sprintf("No bugs found.");
   } else {
      line = "";
      if (sizeof(data) == 150) {
         line += "[ <a href=\"error_query.html\">Query</a> | "
                "<a href=\"errors_new.c?action=newoffset&offset=" +
                (_user_query[req->user]->query->bug_offset + 150) + "\">Next 150 bugs</a> ";
      } else {
         line += "[ <a href=\"error_query.html\">Query</a> ";
      }
      if (_user_query[req->user]->query->bug_offset != 0) {
         line += "| <a href=\"errors_new.c?action=newoffset&offset=" +
                (_user_query[req->user]->query->bug_offset - 150) +
                "\">Previous 150 bugs</a> ";
      }
      line += "]";
      ret += "<b>Offset #" + _user_query[req->user]->query->bug_offset +
             "</b> " + line + "<br>";
      ret += "<table width=100%><tr><th>Id</th>"
             "<th>File Name</th>"
             "<th>Status</th>"
             "<th>Date Reported</th><th>Reporter</th>"
             "<th>Assigned to</th>"
             "<th>Category</th><th>Type</th>"
             "<th>Directory</th></tr>";
      foreach (summary in data) {
         fname = explode(summary->filename, "/")[<1];
         ret += "<tr><td>" + 
                 "<a href=\"errors_new.c?action=bug&id=" + summary->id + "\">" +
                  summary->id + "</a></td><td>" +
                 fname + "</td><td>" +
                summary->status + "</td><td>" +
                 ctime(summary->entry_date)[4..15] + "</td><td>" +
                 summary->reporter + "</td><td>" +
                 summary->assigned_to + "</td><td>" +
                summary->category + "</td><td>" + summary->type + "</td><td>" +
                 summary->directory + "</td></tr>";
      }
      ret += "</table>";
      ret += line + "<br>";
   }
   ret += create_footer(req);
   evaluate(callback, ret);
}

int compare_query(class error_query q1, class error_query q2) {
   if (!q1 || !q2) {
      return 0;
   }

   if (q1->dir != q2->dir) {
      return 0;
   }

   if (q1->reporter != q2->reporter) {
      return 0;
   }

   if (q1->fixer != q2->fixer) {
      return 0;
   }

   if (q1->file_name != q2->file_name) {
      return 0;
   }

   if (q1->recursive != q2->recursive) {
      return 0;
   }

   if (q1->assigned_to != q2->assigned_to) {
      return 0;
   }

   if (sizeof(q1->status) != sizeof(q2->status) ||
       sizeof(q1->status - q2->status)) {
      return 0;
   }

   if (sizeof(q1->type) != sizeof(q2->type) ||
       sizeof(q1->type - q2->type)) {
      return 0;
   }

   if (sizeof(q1->category) != sizeof(q2->category) ||
       sizeof(q1->category - q2->category)) {
      return 0;
   }
   return 1;
}

mixed do_query(function callback, mapping args, class http_request req) {
   class error_query query;
   string bing;

   if (args["dir"] == "" && args["filename"] == "" &&
       args["reporter"] == "" && args["assigned"] == "") {
      evaluate(callback, html_error(req, "One of 'dir', 'filename' or 'reporter' must be not blank."));
      return 1;
   }

   query = new(class error_query);
   if (args["dir"] != "") {
      query->dir = args["dir"];
   }

   if (args["recurse"]) {
      query->recursive = 1;
   }

   // Check each of the statuses to see if they were set.
   query->status = ({ });
   foreach (bing in ({ "fixing", "considering", "open", "fixed", "denied" })) {
      if (args[bing]) {
         query->status += ({ upper_case(bing) });
      }
   }

   query->type = ({ });
   foreach (bing in ({ "bug", "typo", "idea", "comment" })) {
      if (args[bing]) {
         query->type += ({ upper_case(bing) });
      }
   }

   query->category = ({ });
   foreach (bing in ({ "room", "help", "object", "command", "general", "ritual", "spell" })) {
      if (args[bing]) {
         query->category += ({ upper_case(bing) });
      }
   }

   if (args["reporter"] != "") {
      query->reporter = args["reporter"];
   }

   if (args["fixer"] != "") {
      query->fixer = args["fixer"];
   }

   if (args["filename"] != "") {
      query->file_name = args["filename"];
   }

   if (args["assigned"] != "") {
      query->assigned_to = args["assigned"];
   }

   if (args["bug_offset"] != "") {
      query->bug_offset = to_int(args["bug_offset"]);
   }

   query->order_by = args["order_by"];

   if (!_user_query[req->user]) {
      _user_query[req->user] = new(class user_data);
   }

   _user_query[req->user]->direction = "next";
   _user_query[req->user]->last_touched = time();
   // Redo the query each time.
   //if (!compare_query(_user_query[req->user]->query, query)) {

      _user_query[req->user]->query = query;
      if (!ERROR_HANDLER->do_query_bug_summary(query, (: finish_query, callback, req :))) {
         evaluate(callback, html_error(req, "Error doing stuff."));
      }
   //} else {
      //finish_query(callback, req, DB_SUCCESS,
                   //_user_query[req->user]->errors, "some select thing");
   //}
   return 1;
}

int do_new_offset(function callback, int offset, class http_request req) {
   class error_query query;

   query = _user_query[req->user]->query;
   if (query->bug_offset == offset) {
      finish_query(callback, req, DB_SUCCESS, _user_query[req->user]->errors, "");
   } else {
      query->bug_offset = offset;
      if (!ERROR_HANDLER->do_query_bug_summary(query, (: finish_query, callback, req :))) {
         evaluate(callback, html_error(req, "Error doing stuff."));
      }
   }
   return 1;
}

void finish_details(function callback, class http_request req,
                    int type, mixed data) {
   string ret;
   string bing;
   class error_details details;
   class error_complete complete;
   class error_comment comment;
   class error_forward forward;
   class error_replies reply;
   int index;
   int max;

   if (type != DB_SUCCESS) {
      evaluate(callback, html_error(req, "Error: " + data));
      return ;
   }

   complete = data[0];
   details = complete->details;
   ret = create_header(req, "Bug #" + details->summary->id);

   ret += "<table width=100%>";
   ret += "<tr><td><b>Date Reported</b>:</td><td>" + ctime(details->summary->entry_date) + "</td></tr>";
   ret += "<tr><td><b>Assigned To</b>:</td><td>" +
          "<table border=0 width=100%><tr><td>" +
          details->summary->assigned_to + "</td><td align=right>"
          "<form action=\"errors_new.c?action=assign&id=" +
          details->summary->id +
          "\" method=get><input type=text size=12 name=\"assigned\">"
          "<input type=hidden name=id value=" + details->summary->id + ">"
          "<input type=hidden name=action value=assign>"
          "<input type=submit name=rabbit value=assign></form>"
          "</td></tr></table>";
   ret += "<tr><td><b>Reporter</b>:</td><td>" + details->summary->reporter + "</td></tr>";
   ret += "<tr><td><b>Directory</b>:</td><td>" + details->summary->directory + "</td></tr>";
   ret += "<tr><td><b>File name</b>:</td><td>" + details->summary->filename + "</td></tr>";
   ret += "<tr><td><b>Category</b>:</td><td>"
          "<table border=0 width=100%><tr><td>" +
          details->summary->category +
          "</td><td align=right><font size=-2>Change to:";
   foreach (bing in ERROR_CATEGORIES) {
      if (bing != details->summary->category) {
         ret += "<a href=\"errors_new.c?action=changecategory&id=" +
                details->summary->id +
                "&category=" + bing +
                "\">" + bing + "</a> ";
      }
   }
   ret += "</i></font></td></tr></table></td></tr>";
   ret += "<tr><td><b>Type</b>:</td><td>"
          "<table border=0 width=100%><tr><td>" +
          details->summary->type +
          "</td><td align=right><font size=-2>Change to:";
   foreach (bing in ERROR_TYPE) {
      if (bing != details->summary->type) {
         ret += "<a href=\"errors_new.c?action=changetype&id=" +
                details->summary->id +
                "&type=" + bing +
                "\">" + bing + "</a> ";
      }
   }
   ret += "</i></font></td></tr></table></td></tr>";
   ret += "<tr><td><b>Status</b>:</td><td>"
          "<table border=0 width=100%><tr><td>" +
          details->summary->status +
          "</td><td align=right><font size=-2>Change to:";
   foreach (bing in ERROR_STATUS) {
      ret += "<a href=\"errors_new.c?action=changestatus&id=" +
             details->summary->id +
             "&status=" + bing +
             "\">" + bing + "</a> ";
   }
   ret += "<br><a href=\"errors_new.c?action=changestatus&id=" +
          details->summary->id +
          "&status=THANKS\">Thanks</a> ";
   ret += "<a href=\"errors_new.c?action=changestatus&id=" +
          details->summary->id +
          "&status=NOTREPRO\">Not reproducable</a> ";
   ret += "<a href=\"errors_new.c?action=changestatus&id=" +
          details->summary->id +
          "&status=NOTPOSSIBLE\">Not possible to fix</a> ";
   ret += "<a href=\"errors_new.c?action=changestatus&id=" +
          details->summary->id +
          "&status=NOINFO\">Not enough Information</a> ";
   ret += "<a href=\"errors_new.c?action=changestatus&id=" +
          details->summary->id +
          "&status=TEMPORARY\">Temporary</a> ";
   ret += "</i></font></td></tr></table></td></tr>";

   if (details->summary->status == "FIXED" ||
       details->summary->status == "DENIED") {
      ret += "<tr><td><b>Fixed By</b></td><td>" + details->fixer +
             " (" + ctime(details->fix_date) + ")</td></tr>";
   }

   if (sizeof(complete->forwards)) {
      ret += "<tr><td><b>Forwards</b>:</td><td>";
      // Print out the forwards.
      foreach (forward in complete->forwards) {
         ret += forward->forwarder + " from " +
                forward->old_directory + " at " +
                ctime(forward->date)[4..15] + "<br>";
      }
      ret += "</td></tr>";
   }

   ret += "</table>";

   ret += "<div align=right><form action=\"errors_new.c?action=forward&id=" +
           details->summary->id + "\" method=get>";
   index = find_index(req, details->summary->id);
   if (index != -1) {
      // Update the summary details, just in case they changed.
      _user_query[req->user]->errors[index] = details->summary;
   }
   max = max_index(req);
   ret += (index + 1) + " of " + max + " ";
   ret += "<b>[ <a href=\"errors_new.c?action=index\">Index</a> | ";
   if (index + 1 < max) {
      ret += "<a href=\"errors_new.c?action=next&id=" + id_at(req, index + 1) + "\">Next</a> | ";
   }
   if (index > 0) {
      ret += "<a href=\"errors_new.c?action=prev&id=" + id_at(req, index - 1) + "\">Prev</a> | ";
   }
   ret += "<a href=\"errors_new.c?action=comment&id=" + details->summary->id + "\">Add Comment</a> | ";
   ret += "<a href=\"error_query.html\">Query</a> ]</b><br>";
   ret += "\n<input type=text size=30 name=\"forward\">"
          "<input type=hidden name=id value=" + details->summary->id + ">"
          "<input type=hidden name=action value=forward>"
          "<input type=submit name=rabbit value=forward></form></div>\n";
   ret += htmlify(details->report);
   ret += htmlify(details->runtime);

   ret += "<blockquote>";
   // Show the error replies before the comments.
   foreach (reply in complete->replies) {
      ret += "<p><b>Date Sent:</b> " + ctime(reply->senddate)[4..15] + 
             "<br><b>From:</b> " + reply->sender +
             "<br><b>To:</b> " + reply->recipient +
             "<br><b>Subject:</b> " + reply->subject + "<br>" +
             htmlify(reply->message);
   }
   if (sizeof(complete->replies) && sizeof(complete->comments)) {
      ret += "<hr width=30%>";
   }
   foreach (comment in complete->comments) {
      ret += "<p><b>Comment by " + comment->commenter + " at " +
             ctime(comment->date)[4..15] + "</b><br>" +
             htmlify(comment->comment);
   }
   ret += "</blockquote>";
   ret += create_footer(req);
   evaluate(callback, ret);
}

int do_bug_details(function callback, mapping args, class http_request req,
                   int update_position) {
   int index;
   int max;
   int val;

   if (update_position) {
      index = find_index(req, to_int(args["id"]));
      max = max_index(req);
      val = to_int(args["id"]);
      switch (_user_query[req->user]->direction) {
      case "prev" :
         if (index - 1 >= 0) {
            val = id_at(req, index - 1);
         }
      case "next" :
      default :
         if (index + 1 < max) {
            val = id_at(req, index + 1);
         }
         break;
      }
tell_creator("pinkfish", "%O %O %O\n", args["id"], index, max);
      args["id"] = val + "";
   }

   if (!ERROR_HANDLER->do_query_bug_details(to_int(args["id"]), (: finish_details, callback, req :))) {
      evaluate(callback, html_error(req, "Error doing stuff."));
   }
   return 1;
}

int do_change_type(function callback, mapping args, class http_request req) {
   if (!ERROR_HANDLER->do_change_type(to_int(args["id"]), args["type"],
                (: do_bug_details($(callback), $(args), $(req), 0) :))) {
      evaluate(callback, html_error(req, "Error doing stuff."));
   }
   return 1;
}

int do_change_category(function callback, mapping args, class http_request req) {
   if (!ERROR_HANDLER->do_change_category(to_int(args["id"]), args["category"],
                (: do_bug_details($(callback), $(args), $(req), 0) :))) {
      evaluate(callback, html_error(req, "Error doing stuff."));
   }
   return 1;
}

int do_forward(function callback, mapping args, class http_request req) {
   if (!ERROR_HANDLER->do_forward(to_int(args["id"]), req->user,
                args["forward"],
                (: do_bug_details($(callback), $(args), $(req), 1) :))) {
      evaluate(callback, html_error(req, "Cannot forward to a non-existant "
                                   "directory or to '/'"));
   }
   return 1;
}

int do_assign(function callback, mapping args, class http_request req) {
   if (!ERROR_HANDLER->do_assign_bug_to(to_int(args["id"]),
                args["assigned"],
                (: do_bug_details($(callback), $(args), $(req), 1) :))) {
      evaluate(callback, html_error(req, "Error doing stuff."));
   }
   return 1;
}

void finish_change_status_details(function callback, mapping args,
                                  class http_request req,
                                  int type, mixed data) {
   class error_complete complete;
   class error_details details;
   string str;
   string internal_status;

   if (type != DB_SUCCESS) {
      evaluate(callback, html_error(req, "Error: " + data));
      return ;
   }

   complete = data[0];
   details = complete->details;

   internal_status = args["status"];
   if (internal_status == "TEMPORARY") {
      internal_status = "FIXED";
   }
   if (internal_status == "NOTREPRO" || internal_status == "NOINFO" ||
       internal_status == "NOTPOSSIBLE" || internal_status == "THANKS") {
      internal_status = "DENIED";
   }

   str = create_header(req, "Change status of #" + details->summary->id);
   str += "New status: " + internal_status;
   str += "<form action=\"errors_new.c?action=changestatusmessage\" method=post>\n";
   switch (args["status"]) {
   case "TEMPORARY" :
      str += "<input type=text size=60 name=subject value=\"" +
             lower_case(details->summary->category) + " " +
             lower_case(details->summary->type) +
             " bug #" + args["id"] + " was a temporary bug\"><br>";
      break;
   case "NOINFO" :
      str += "<input type=text size=60 name=subject value=\"Not enough " +
             "information on " +
             lower_case(details->summary->category) + " " +
             lower_case(details->summary->type) +
             " bug #" + args["id"] + "\"><br>";
      break;
   case "NOTPOSSIBLE" :
      str += "<input type=text size=60 name=subject value=\"" +
             lower_case(details->summary->category) + " " +
             lower_case(details->summary->type) +
             " bug #" + args["id"] + " was not possible to fix\"><br>";
      break;
   case "NOTREPRO" :
      str += "<input type=text size=60 name=subject value=\"" +
             lower_case(details->summary->category) + " " +
             lower_case(details->summary->type) +
             " bug #" + args["id"] + " was not reproducable\"><br>";
      break;
   case "THANKS" :
      str += "<input type=text size=60 name=subject value=\"Thanks for " +
             lower_case(details->summary->category) + " " +
             lower_case(details->summary->type) +
             " bug #" + args["id"] + "\"><br>";
      break;
   default :
      str += "<input type=text size=60 name=subject value=\"Change status of " +
             lower_case(details->summary->category) + " " +
             lower_case(details->summary->type) +
             " bug #" + args["id"] + " to " +
             lower_case(args["status"]) + "\"><br>";
   }
   str += "<textarea name=message cols=80 rows=20>";
   switch (args["status"]) {
   case "FIXED" :
      str += "Thank you for your " + lower_case(complete->details->summary->type) +
             " report, this " + lower_case(complete->details->summary->type) +
             " has now been fixed.\n\nGood luck!\n" +
             capitalize(req->user) + "\n";
      break;
   case "DENIED" :
      str += "Thank you for your " + lower_case(complete->details->summary->type) +
             " report."
             "\n\nThanks!\n" +
             capitalize(req->user) + "\n\n";
      break;
   case "THANKS" :
      str += "Thank you for your " + lower_case(complete->details->summary->type) +
             " report.\n\nThanks!\n" +
             capitalize(req->user) + "\n\n";
      break;
   case "NOTREPRO" :
      str += "The " + lower_case(complete->details->summary->type) +
             " report was unable to be reproduced.  Please submit a new bug "
             "report with more specific details if it happens again.\n\n"
             "Thanks!\n" +
             capitalize(req->user) + "\n\n";
      break;
   case "NOINFO" :
      str += "The " + lower_case(complete->details->summary->type) +
             " report did not contain enough information to fix the bug.  "
             "Please make a new report with more details.\n\n"
             "Good luck!\n" +
             capitalize(req->user) + "\n\n";
      break;
   case "NOTPOSSIBLE" :
      str += "Sadly, this " + lower_case(complete->details->summary->type) +
             " is cannot be fixed due to coding "
             "constraints.\n\n"
             "Good luck!\n" +
             capitalize(req->user) + "\n\n";
      break;
   case "TEMPORARY" :
      str += "The " + lower_case(complete->details->summary->type) +
             " in question was a temporary problem in the game and has now "
             "been solved.  Please report this if it happens again.\n\n"
             "Good luck!\n" +
             capitalize(req->user) + "\n\n";
      break;
   }
   str += "> Bug #" + details->summary->id + " reported at " +
          ctime(details->summary->entry_date)[4..15] + "\n>\n";
   str += "> " + replace_string(htmlify_no_address(sprintf("%79-=s", details->report)), "<BR>\n", "\n> ");
   str += "</textarea>";
   str += "<br>";
   str += "<input type=hidden name=status value=\"" + internal_status + "\">";
   str += "<input type=hidden name=id value=\"" + details->summary->id + "\">";
   str += "<input type=submit name=submit value=\"Change Status\">";
   str += "<input type=checkbox name=nomail value=yes> Don't send mail<br>";
   str += "</form>";
   str += create_footer(req);
   evaluate(callback, str);
}

int do_change_status(function callback, mapping args, class http_request req) {
   if (!ERROR_HANDLER->do_query_bug_details(to_int(args["id"]), (: finish_change_status_details, callback, args, req :))) {
      evaluate(callback, html_error(req, "Error doing stuff."));
   }
   return 1;
}

int do_change_status_message(function callback, mapping args, class http_request req) {
   int nomail;

   args = req->body->data;
   if (args["nomail"] == "yes") {
      nomail = 1;
   }

   args["message"] = replace_string(args["message"], "\r\n", "\n");

   if (!ERROR_HANDLER->do_change_status(to_int(args["id"]), args["status"],
                                  nomail, args["subject"],
                                  req->user, args["message"],
                (: do_bug_details($(callback), $(args), $(req), 1) :))) {
      evaluate(callback, html_error(req, "Error doing stuff."));
   }

   return 1;
}

string do_comment(mapping args, class http_request req) {
   string str;

   str = create_header(req, "Comment on #" + args["id"]);
   str += "<h2>Comment to add to #" + args["id"] + "</h2>"
          "<form action=\"errors_new.c?action=commentmessage&id=" + args["id"] +
         "\" method=post>";
   str += "<textarea name=message cols=80 rows=20>"
          "</textarea><br>"
          "<input type=submit name=\"Add Comment\" value=\"Add Comment\">"
          "</form>";
   str += create_footer(req);
   return str;
}

int do_comment_message(function callback, mapping args, class http_request req) {
   string mess;

   mess = replace_string(req->body->data["message"], "\r\n", "\n");
   if (!ERROR_HANDLER->do_comment(to_int(args["id"]), req->user,
                                  req->body->data["message"],
                (: do_bug_details($(callback), $(args), $(req), 0) :))) {
      evaluate(callback, html_error(req, "Error doing stuff."));
   }
   return 1;
}

mixed www_delayed(function callback, string str, mapping args,
    class http_request req ) {
   if (!PLAYER_HANDLER->test_creator(req->user)) {
      return 0;
   }
   switch (args["action"]) {
   case "query" :
      return do_query(callback, args, req);
   case "next" :
   case "prev" :
      _user_query[req->user]->direction = args["action"];
   case "bug" :
      return do_bug_details(callback, args, req, 0);
   case "index" :
      finish_query(callback, req, DB_SUCCESS,
                   _user_query[req->user]->errors, "some select thing");
      return 1;
   case "changetype" :
      return do_change_type(callback, args, req);
   case "changecategory" :
      return do_change_category(callback, args, req);
   case "changestatus" :
      return do_change_status(callback, args, req);
   case "changestatusmessage" :
      return do_change_status_message(callback, args, req);
   case "forward" :
      return do_forward(callback, args, req);
   case "assign" :
      return do_assign(callback, args, req);
   case "commentmessage" :
      return do_comment_message(callback, args, req);
   case "newoffset" :
      return do_new_offset(callback, to_int(args["offset"]), req);
   }
   return 0;
}

mixed www_request(string str, mapping args, class http_request req) {
   if (!PLAYER_HANDLER->test_creator(req->user)) {
      return 0;
   }
   switch (args["action"]) {
   case "timeout" :
      map_delete(_user_query, req->user);
      str = create_header(req, "Session timed out.", 1);
      str += "<h2>Your session timed out</h2>"
             "<a href=\"error_query.html\">Query page</a>";
      return str + create_footer(req);
   case "comment" :
      return do_comment(args, req);
   }
}

mapping query_dynamic_auto_load() {
   return _user_query;
}

void init_dynamic_arg(mapping details) {
   if (mapp(details)) {
      _user_query = details;
   }
}
// --- END [/mnt/home2/grok/lib/www/secure/errors_new.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/newspaper.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/newspaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626817   Available: 13574171
Inodes: Total: 5242880    Free: 4960132
13056 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/newspaper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626817   Available: 13574171
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <room/newspaper.h>
#include <http.h>
#include <player_handler.h>

mapping _allowed_editions;
mapping _colours;

void create() {
   _allowed_editions = ([ ]);
   _colours = ([ ]);
   _colours["red"] = "#AF0A28";
   _colours["magenta"] = "#550064";
} /* create() */

void reset() {
   _allowed_editions = ([ ]);
} /* reset() */

/**
 * This method returns the path of the logo.
 */
string find_logo_url(string paper) {
   if (stringp(paper)) {
      paper = lower_case(paper);
      paper = replace_string(paper, " ", "_");
      if (file_size("/www/" + NEWSPAPER_WWW_LOGO_BASE + paper + ".gif") > 0) {
         return "http://discworld.imaginary.com/" + NEWSPAPER_WWW_LOGO_BASE +
                 paper + ".gif";
      }
      if (file_size("/www/" + NEWSPAPER_WWW_LOGO_BASE + paper + ".jpg") > 0) {
         return "http://discworld.imaginary.com/" + NEWSPAPER_WWW_LOGO_BASE +
                 paper + ".jpg";
      }
   }
   return "http://discworld.imaginary.com/external/pics/dw5.gif";
} /* find_logo_url() */

int is_allowed_to_read(int edition, string paper, string person) {
   string office;

   if (!person) {
      return 0;
   }

  if (PLAYER_HANDLER->test_creator (person)) {
    return 1;
  }
   if(!_allowed_editions[person])
     _allowed_editions[person] = ([ ]);

   if(!_allowed_editions[person][paper]) {
     _allowed_editions[person][paper] = PLAYER_HANDLER->test_property(person, "Paper " + paper);
     if(!_allowed_editions[person][paper]) {
       _allowed_editions[person][paper] = ({ });
     }
   } else if (find_player(person)) {
     _allowed_editions[person][paper] = find_player(person)->query_property("Paper " + paper);
   }

   if(!_allowed_editions[person][paper])
     _allowed_editions[person][paper] = ({ });
   
   if(member_array(edition, _allowed_editions[person][paper]) != -1) {
     return 1;
   }

   office = NEWSPAPER_HANDLER->query_paper_office(paper);
   if (office) {
      if (office->is_editor(person)) {
         return 1;
      }
   }
   return 0;
} /* is_allowed_to_read() */

/*
 * Makes all the '<' turn into $gt; and the '>' the same.
 */
string htmlify(string  str) {
  return replace(str, ({ "<", "&lt;", ">", "&gt;", "\n", "<br>",
                         "&", "&amp;" }));
} /* htmlify() */

string make_header(string title, string paper) {
   return "<html<head><title>" + title + "</title></head>\n"
          "<body bgcolor=#ffffff TEXT=#000030 LINK=#4a529c VLINK=#b57339>\n"
          "<font face=\"arial, helvetica\">\n"
          "<img align=left src=\"" + find_logo_url(paper) + "\">\n"
          "<h2>Discworld MUD</h2>\n"
          "<br clear=both>";
} /* make_header() */

string show_article(string paper, string edition, string article, class http_request req) {
   class advert* ads;
   class advert ad;
   class article* arts;
   int edt;
   int art_no;
   string ret;
   string* bottom;
   mixed* stuff;

   sscanf(edition, "%d", edt);
   sscanf(article, "%d", art_no);
   // Check the edition stuff now.
   if (!is_allowed_to_read(edt, paper, req->user)) {
      ret = make_header("Unable to read article", paper);
      ret += "<h3>You need to buy this issue in the game before you can read it "
             "on the web.</h3>\n";
      return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
   }

   arts =  NEWSPAPER_HANDLER->query_edition_articles(paper, edt);
   ret = make_header(arts[art_no]->title, paper);
   if (arts[art_no]->type == NEWSPAPER_ARTICLE_TYPE_ADVERTS) {
      ads = NEWSPAPER_HANDLER->query_edition_adverts(paper, edt);
      if (ads) {
         stuff = unique_array(ads, (: $1->category :));
         foreach (ads in stuff) {
            ret += "<center><h1>" + ads[0]->category + "</h1></center>\n";
            //ret += "<dl>\n";
            foreach (ad in ads) {
               ret += "<div align=right><h4><i>" + ad->author +
                      "</i></h4></div><p>\n</font><pre>\n" +
                      sprintf("%-=*s\n", 75, ad->text) +
                      "</pre><font face=\"helvetica,arial\">\n";
               ret += "<hr width=10%>\n";
            }
            //ret += "</dl>\n";
         }
      }
   } else {
      ret += "<h3>" + arts[art_no]->title + "</h3>";
      if (!(arts[art_no]->type & NEWSPAPER_ARTICLE_ANONYMOUS_FLAG)) {
         ret += "by " + arts[art_no]->shown_name + "<p>";
      }
      ret += replace(NEWSPAPER_HANDLER->query_article_text_html(arts[art_no]),
                     ({ "<pre>", "</font><pre>",
                        "</pre>", "</pre><font face=helvetica,arial>" }));
   }
   NEWSPAPER_HANDLER->add_edition_web_hit(paper, edt);
   ret += "<hr width=50%>\n";
   bottom = ({ });
   if (art_no > 0) {
      bottom += ({ "<a href=\"http://discworld.imaginary.com:5678/secure/newspaper.c?type=article&paper=" +
             replace_string(paper, " ", "+") + "&edition=" + edition +
             "&article=" + (art_no - 1) + "\">Previous Page</a>" });
   }
   if (art_no + 1 < sizeof(arts)) {
      bottom += ({ "<a href=\"http://discworld.imaginary.com:5678/secure/newspaper.c?type=article&paper=" +
             replace_string(paper, " ", "+") + "&edition=" + edition +
             "&article=" + (art_no + 1) + "\">Next Page</a>" });
   }
   bottom += ({ "<a href=\"http://discworld.imaginary.com:5678/secure/newspaper.c?type=edition&paper=" +
             replace_string(paper, " ", "+") + "&edition=" + edition +
             "\">Contents</a>" });
   ret += "<center><b>[ " + implode(bottom, " | ") + " ]</b></center>\n";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_article() */

string show_edition(string paper, string edition, class http_request req) {
   class article* arts;
   int edt;
   int i;
   string ret;
   string office;
   string* editors;
   string* bottom;
   string owner;

   ret = make_header("Edition " + edition + " of " + paper, paper);
   sscanf(edition, "%d", edt);
   ret += "<h3>" + NEWSPAPER_HANDLER->query_paper_headline(paper, edt) + "</h3>\n";
   ret += "<b><i>Edition " + edition + " of " + paper + "</b></i>\n\n";
   ret += "<ul>\n";
   arts =  NEWSPAPER_HANDLER->query_edition_articles(paper, edt);
   for (i = 0; i < sizeof(arts); i++) {
      if (arts[i]->colour) {
         if (_colours[lower_case(arts[i]->colour)]) {
            ret += "<font color=" + _colours[lower_case(arts[i]->colour)] + ">";
         } else {
            ret += "<font color=" + lower_case(arts[i]->colour) + ">";
         }
      }
      switch (arts[i]->type) {
      case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
         ret += "<h4>";
         ret += "<a href=\"http://discworld.imaginary.com:5678"
               "/secure/newspaper.c?type=article&paper=" +
                replace_string(paper, " ", "+") + "&edition=" + edition +
                "&article=" + i + "\">Adverts</a></h4>\n";
         break;
      case NEWSPAPER_ARTICLE_TYPE_SECTION :
         ret += "<h4>" + arts[i]->title + "</h4>\n";
         break;
      case NEWSPAPER_ARTICLE_TYPE_PLAIN :
      case NEWSPAPER_ARTICLE_TYPE_HTML :
         ret += "<li><a href=\"http://discworld.imaginary.com:5678/secure/newspaper.c?type=article&paper=" +
                replace_string(paper, " ", "+") + "&edition=" + edition +
                "&article=" + i + "\">" + arts[i]->title + "</a>";
         if (!(arts[i]->type & NEWSPAPER_ARTICLE_ANONYMOUS_FLAG)) {
            ret += " by " + arts[i]->shown_name + "\n";
         }
         break;
      }
      if (arts[i]->colour) {
         ret += "</font>";
      }
   }
   ret += "</ul>\n";
   office = NEWSPAPER_HANDLER->query_paper_office(paper);
   if (office) {
      owner = office->query_owner();
      editors = sort_array( uniq_array( office->query_all_editors() ), 1 );
      ret += "<p><i>The current owner is " + 
            "<a href=\"finger.c?player=" + owner + "\">" + owner + "</a>"
            " and the editors are " +
             query_multiple_short(map(editors,
                            (: "<a href=\"finger.c?player=" + $1 + "\">" +
                               $1 + "</a>" :)));
      if (office->query_address()) {
         ret += " and is located at " + office->query_address();
      }
      ret += "</i>\n";
   }
   bottom = ({ });
   bottom += ({ "<a href=\"newspaper.c?type=paper&paper=" +
             replace_string(paper, " ", "+") +
             "\">Editions</a>" });
   if (!req->user) {
      bottom += ({ "<a href=\"http://discworld.imaginary.com:5678/secure/newspaper.c?type=edition&paper=" +
                   replace_string(paper, " ", "+") +
                   "&edition=" + edt + "\">Login</a>" });
   }
   ret += "<hr width=50%>\n"
          "<center><b>[ " + implode(bottom, " | ") + " ]</b></center>\n";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_edition() */

string show_paper(string paper, class http_request req) {
   int i;
   int top;
   string ret;
   string bing;
   string office;
   string* editors;
   string* bottom;
   string owner;

   ret = make_header(paper, paper);
   ret += "<h3>" + paper + "</h3>\n";
   top = NEWSPAPER_HANDLER->query_current_edition_num(paper);
   if (NEWSPAPER_HANDLER->query_paper_description(paper)) {
      ret += NEWSPAPER_HANDLER->query_paper_description(paper);
   }

   if (top > 1) {
      ret += "<p><center>Current Issue:<br><b>";
      for (i = top - 1; i >= 1; i--) {
         bing = ctime(NEWSPAPER_HANDLER->query_edition_date(paper, i));
         if (i <= top - 2) {
            if (i == top - 2) {
               ret += "</b></center><hr width=25%><ul>\n";
            }
            ret += "<li>\n";
         }
         ret += "<a href=\"newspaper.c?type=edition&paper=" +
                replace_string(paper, " ", "+") +
                "&edition=" + i + "\">Edition " + i + "</a> <b>" +
                NEWSPAPER_HANDLER->query_paper_headline(paper, i) +
                "</b> <i>" +
                bing[0..10] + bing[20..] +
                "</i>\n";
         if (is_allowed_to_read(i, paper, req->user)) {
            ret += "</b><font size=-2>(bought)</font>\n";
         }
      }
      if (top > 2) {
         ret += "</ul>\n";
      } else {
         ret += "</b></center>\n";
      }
   } else {
      ret += "No editions yet.\n";
   }
   office = NEWSPAPER_HANDLER->query_paper_office(paper);
   if (office) {
      editors = sort_array( uniq_array( office->query_all_editors() ), 1 );
      owner = office->query_owner();
      ret += "<p><i>The current owner is " + 
            "<a href=\"finger.c?player=" + owner + "\">" + owner + "</a>"
            " and the editors are " +
             query_multiple_short(map(editors,
                            (: "<a href=\"finger.c?player=" + $1 + "\">" +
                               $1 + "</a>" :)));
      if (office->query_address()) {
         ret += " and is located at " + office->query_address();
      }
      ret += "</i>\n";
   }
   bottom = ({ });
   bottom += ({ "<a href=\"newspaper.c\">Papers</a>" });
   if (!req->user) {
      bottom += ({ "<a href=\"http://discworld.imaginary.com:5678/secure/newspaper.c?type=paper&paper=" +
                   replace_string(paper, " ", "+") +
                   "\">Login</a>" });
   }
   ret += "<hr width=50%>\n"
          "<center><b>[ " + implode(bottom, " | ") + " ]</b></center>\n";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_paper() */

string show_all_papers(class http_request req) {
   string ret;
   string paper;
   int last;
   string bing;

   ret = make_header("All The Discworld Papers", "empty set");
   ret += "<h3>Where papers are seasonal</h3>\n";
   ret += "<ul>\n";
   foreach (paper in NEWSPAPER_HANDLER->query_all_papers()) {
      ret += "<li><a href=\"newspaper.c?type=paper&paper=" +
             replace_string(paper, " ", "+") + "\">" + paper + "</a>\n";
      last = NEWSPAPER_HANDLER->query_last_edition_num(paper);
      if (last) {
          bing = ctime(NEWSPAPER_HANDLER->query_edition_date(paper, last));
          ret += "<i>last edition released at " + bing[0..10] + bing[20..] +
             " (<b>" +
             NEWSPAPER_HANDLER->query_paper_headline(paper, last) +
             "</b>)</i>.\n";
      } else {
         ret += "<i>no editions released yet</i>.\n";
      }
   }
   ret += "</ul>\n";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_all_papers() */

// this is the function which the webserver calls
string www_request(string str, mapping args, class http_request req) {
   switch (args["type"]) {
   case "article" :
      return show_article(args["paper"], args["edition"], args["article"], req);
   case "edition" :
      return show_edition(args["paper"], args["edition"], req);
   case "paper" :
      return show_paper(args["paper"], req);
   default :
      return show_all_papers(req);
   }
}

mapping query_allowed_editions() {
   return _allowed_editions;
} /* query_allowed_editions() */
// --- END [/mnt/home2/grok/lib/www/secure/newspaper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/bug_replies.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/bug_replies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626814   Available: 13574168
Inodes: Total: 5242880    Free: 4960132
10505 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/bug_replies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626814   Available: 13574168
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This lists all the replies to bugs and lets you go through and delete/read
 * them.
 * @author Pinkfish
 * @started Mon Feb 17 14:56:20 PST 2003
 */
#include <http.h>
#include <error_handler.h>
#include <player_handler.h>
#include <db.h>

#define TIMEOUT_PERIOD (6 * 60 * 60)

private mapping _replies;

void create() {
   _replies = ([ ]);
}

private varargs string create_header(class http_request req, string title,
                                     int no_timeout) {
  return "<HTML>\n<HEAD>\n"
    "<TITLE>" + title + "</TITLE>\n"
    "<META http-equiv=\"Refresh\" content=\"" + TIMEOUT_PERIOD +
        ";URL=http://" + req->hostname +
        "/secure/errors_new.c?action=timeout\">"
    "</HEAD>\n<BODY bgcolor=\"#ffffff\" text=\"#000030\" link=\"#4a529c\" "
    "vlink=\"#b57339\">\n<FONT face=\"arial,helvetica\">\n"
    //"<i>(Imagine a pretty picture here to save space)</i>\n<H2>Errors</H2>\n"
    //"<H3><I>When cabbages are just not enough.</I></H3>\n<BR clear=\"left\">\n"
    "<BR>\n";
} /* create_header() */

private string create_footer(class http_request req) {
  return ("/www/footer"->www_function("footer", ([ ]), req))+"</BODY>\n</HTML>\n";
}

string html_error(class http_request req, string error) {
   return create_header(req, error) +
          "<h2>" + error + "</h2>" +
          create_footer(req);
}

private string htmlify(string str) {
  return replace(str, ({
    "&", "&amp;",
      "<", "&lt;",
      ">", "&gt;",
      "\n", "<BR>\n",
      /* " ", "&nbsp;", */
      }) );
}

string list_replies(string user) {
   class error_replies reply;
   string ret;

   if (!sizeof(_replies[user])) {
      ret = "<font size=-1>[ <b><a href=\"bug_replies.c\">Refresh</a></b> ]<p>";
      return ret + "No bug replies.<br>";
   }

   ret = "<ol>";
   foreach (reply in _replies[user]) {
      ret += "<li>" + ctime(reply->senddate)[4..15] + " " +
             (reply->status != "READ" ? "<B>" + reply->status + "</b> " : "") +
             capitalize(reply->sender) +
             " '<a href=\"bug_replies.c?action=read&id=" + reply->id + "\">" +
             reply->subject + "</a>'";
      if (PLAYER_HANDLER->test_creator(user)) {
         ret += "<font size=-2>(bug <a href=\"errors_new.c?action=bug&id=" +
                reply->bug_id + "\">#" + reply->bug_id + "</a>)</font>";
      }
   }
   ret += "</ol>";
   ret += "<font size=-1>[ <b><a href=\"bug_replies.c\">Refresh</a></b> | " +
          "<b><a href=\"bug_replies.c?action=deleteread\">Delete all "
          "read</a></b> ]<p>";
   return ret;
}

string reply_details(class error_replies reply, class http_request req) {
   string ret;
   int i;

   ret = "<table>" +
         (PLAYER_HANDLER->test_creator(req->user)?
          "<tr><td><b>Bug #</b></td><td>"
             "<a href=\"errors_new.c?action=bug&id=" +
             reply->bug_id + "\">#" + reply->bug_id + "</a>"
         "</td></tr>":"") +
         "<tr><td><b>Date Sent:</b></td><td>" +
         ctime(reply->senddate) + "</td></tr>"
         "<tr><td><b>Status:</b></td><td>" +
         reply->status + "</td></tr>"
         "<tr><td><b>From:</b></td><td>" +
         reply->sender + "</td></tr>"
         "<tr><td><b>To:</b></td><td>" +
         reply->recipient + "</td></tr>"
         "<tr><td><b>Subject:</b></td><td>" +
         reply->subject + "</td></tr>"
         "</td></tr></table>";
   ret += "<p><div align=right><font size=-1>";
   if (reply->status != "DELETED") {
      ret += "<p><b>[ <a href=\"bug_replies.c?action=reply&id=" + reply->id +
                  "\">Reply</a> | "
                  "<a href=\"bug_replies.c?action=list\">List</a> | "
                  "<a href=\"bug_replies.c?action=delete&id=" + reply->id +
                  "\">Delete</a> ";
   } else {
      ret += "<p><b>[ <a href=\"bug_replies.c?action=reply&id=" + reply->id +
                  "\">Reply</a> | "
                  "<a href=\"bug_replies.c?action=list\">List</a> | "
                  "<a href=\"bug_replies.c?action=undelete&id=" + reply->id +
                  "\">Undelete</a>";
   }
   for (i = 0; i < sizeof(_replies[req->user]); i++) {
      if (((class error_replies)_replies[req->user][i])->id == reply->id) {
         if (i > 0) {
            ret += "| <a href=\"bug_replies.c?action=read&id=" +
      ((class error_replies)_replies[req->user][i - 1])->id + "\">Previous</a>";
         }
         if (i < sizeof(_replies[req->user]) - 1) {
            ret += "| <a href=\"bug_replies.c?action=read&id=" +
         ((class error_replies)_replies[req->user][i + 1])->id + "\">Next</a>";
         }
      }
   }
   ret += " ]</b></font></div><p>" + htmlify(reply->message);
   if (reply->status == "NEW") {
      ERROR_HANDLER->do_status_error_reply(reply->id, "READ", (: 1 :));
   }
   return ret;
}

void finish_replies_list(function callback, class http_request req,
                         int type, class error_replies* data) {
   if (type != DB_SUCCESS) {
      evaluate(callback, html_error(req, "Unable to get bug replies.\n"));
   } else {
      _replies[req->user] = data;
      evaluate(callback, create_header(req, "Bug Reply List") +
                         "<h2>Your bug reply list</h2>" +
                         list_replies(req->user) +
                         create_footer(req));
   }
}

string get_reply_details(int id, class http_request req) {
   class error_replies reply;

   foreach (reply in _replies[req->user]) {
      if (reply->id == id) {
         return create_header(req, "Bug reply #" + reply->id) +
                reply_details(reply, req) +
                create_footer(req);
      }
   }
   return html_error(req, "Unable to find the bug reply.\n");
}

string delete_bug_reply(int id, class http_request req) {
   class error_replies reply;

   foreach (reply in _replies[req->user]) {
      if (reply->id == id) {
         reply->status = "DELETED";
         ERROR_HANDLER->do_status_error_reply(reply->id, "DELETED", (: 1 :));
         return create_header(req, "Deleted bug reply #" + reply->id) +
                reply_details(reply, req) +
                create_footer(req);
      }
   }
   return html_error(req, "Unable to find the bug reply.\n");
}

string undelete_bug_reply(int id, class http_request req) {
   class error_replies reply;

   foreach (reply in _replies[req->user]) {
      if (reply->id == id) {
         reply->status = "READ";
         ERROR_HANDLER->do_status_error_reply(reply->id, "READ", (: 1 :));
         return create_header(req, "Deleted bug reply #" + reply->id) +
                reply_details(reply, req) +
                create_footer(req);
      }
   }
   return html_error(req, "Unable to find the bug reply.\n");
}

string reply_to_bug_reply(int id, class http_request req) {
   string ret;
   class error_replies reply;

   foreach (reply in _replies[req->user]) {
      if (reply->id == id) {
         ret = create_header(req, "Deleted bug reply #" + reply->id);
         ret = "<form action=\"bug_replies.c?action=replymessage&id=" + reply->id +
               "\" method=post>"
                "Subject: <input name=subject type=text size=60 value=\"Re: " +
                htmlify(reply->subject) + "\">\n"
                "<textarea name=message rows=15 cols=80>" +
                "> " + htmlify(implode(map(explode(reply->message, "\n"),
                                   (: "> " + $1 :)), "\n")) +
                "</textarea>"
                "<br><input type=submit name=rabbit value=\"Send Message\">" +
                create_footer(req);
         return ret;
      }
   }
   return html_error(req, "Unable to find the bug reply.\n");
}

string reply_message_bug_reply(int id, class http_request req) {
   class error_replies reply;

   foreach (reply in _replies[req->user]) {
      if (reply->id == id) {
         reply->status = "READ";
         ERROR_HANDLER->do_add_error_reply(reply->bug_id, req->user,
                     reply->sender, req->body->data["subject"],
                     req->body->data["message"]);
         return create_header(req, "Deleted bug reply #" + reply->id) +
                "<h2>Reply sent</h2>" +
                reply_details(reply, req) +
                create_footer(req);
      }
   }
   return html_error(req, "Unable to find the bug reply.\n");
}

string delete_all_read(class http_request req) {
   string str;

   str = create_header(req, "Delete all read.");
   str += "<b>Are you sure you want to delete all the read replies?</b><p>";
   str += "<a href=\"bug_replies.c?action=deleteallreadconfirm\">Yes</a> "
          "<a href=\"bug_replies.c\">No</a>";
   return str + create_footer(req);
}

string delete_all_confirmed(class http_request req) {
   class error_replies reply;

   foreach (reply in _replies[req->user]) {
      if (reply->status == "READ") {
         // Do the delete.
         reply->status = "DELETED";
         ERROR_HANDLER->do_status_error_reply(reply->id, "DELETED", (: 1 :));
      }
   }
   return create_header(req, "Deleted all read") +
                         list_replies(req->user) +
                         create_footer(req);
}

mixed www_delayed(function callback, string str, mapping args,
    class http_request req ) {
   if (!args["action"]) {
      // List the current replies.
      ERROR_HANDLER->do_error_replies(req->user, 0,
                      (: finish_replies_list($(callback), $(req),
                                    $1, $2) :));
      return 1;
   }
}

string www_request(string str, mapping args, class http_request req) {
   switch (args["action"]) {
   case "delete" :
      return delete_bug_reply(to_int(args["id"]), req);
   case "undelete" :
      return undelete_bug_reply(to_int(args["id"]), req);
   case "read" :
      return get_reply_details(to_int(args["id"]), req);
   case "reply" :
      return reply_to_bug_reply(to_int(args["id"]), req);
   case "replymessage" :
      return reply_message_bug_reply(to_int(args["id"]), req);
   case "deleteallread" :
      return delete_all_read(req);
   case "deleteallreadconfirm" :
      return delete_all_confirmed(req);
   case "list" :
      return create_header(req, "Bug Reply List") +
                         list_replies(req->user) +
                         create_footer(req);
   default :
      return html_error(req, "Unknown action.\n");
   }
}

mapping query_dynamic_auto_load() {
   return ([ "replies" : _replies ]);
}

void init_dynamic_arg(mapping map) {
   _replies = map["replies"];
   if (!_replies) {
      _replies = ([ ]);
   }
}
// --- END [/mnt/home2/grok/lib/www/secure/bug_replies.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/creator_stuff.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/creator_stuff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626811   Available: 13574165
Inodes: Total: 5242880    Free: 4960132
1694 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/creator_stuff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626811   Available: 13574165
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>
#include <playtesters.h>
#include <player_handler.h>

string www_function(string arg, mapping fields, class http_request req) {
   string ret;
   int start;

   ret = "";

   if (PLAYTESTER_HAND->query_playtester(req->user) ||
       PLAYER_HANDLER->test_creator(req->user)) {
      ret += "<td valign=\"top\">\n<font face=\"arial,helvetica\">\n";
      ret += "<h3>Playtesters</h3>\n<ul>\n";
      ret += "<li><a href=\"http://discworld.imaginary.com/twiki/pt/bin/view/Playtesters/WebHome\">Playtesters Wiki</a>\n";
      ret += "<li><a href=\"http://discworld.imaginary.com:5678/~Playtesters/\">Playtesters Webpage</a>\n";
      ret += "<li><a href=\"http://discworld.imaginary.com:5678/~Playtesters/secure/idea.c\">Feedback Centre</a>\n";
      ret += "</ul>\n";
      start = 1;
   }
   if (PLAYER_HANDLER->test_creator(req->user)) {
      if (!start) {
         ret += "<td valign=\"top\">\n<font face=\"arial,helvetica\">\n";
      }
      ret += "<h3>Creator</h3>\n<ul>\n";
      ret += "<li><a href=\"creator/bugs\">Bug statistics</a>\n";
      ret += "<li><a href=\"source_browser.c\">Source browser</a>\n";
      ret += "<li><a href=\"error_query.html\">Error handler</a>\n";
      ret += "<li><a href=\"http://discworld.imaginary.com/cgi-bin/fom_creator\">Creator FAQ</a>\n";
      ret += "<li><a href=\"../lpc_for_dummies/index.htm\">LPC for Dummies</a>\n";
      ret += "<li><a href=\"creator/project.c\">Project Tracker</a>\n";
      ret += "<li><a href=\"http://discworld.imaginary.com/twiki/bin/view/Main/WebHome\">Wiki Project Information</a>\n";
      ret += "</ul>\n";
   }
   if (start) {
      ret += "</td>\n";
   }
   return ret;
} /* www_function() */
// --- END [/mnt/home2/grok/lib/www/secure/creator_stuff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/source_browser.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/source_browser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626810   Available: 13574164
Inodes: Total: 5242880    Free: 4960132
10842 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/source_browser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626810   Available: 13574164
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
//Source browser by Wodan
#include <http.h>
#include <nroff.h>
#include <assert.h>
#include <player_handler.h>

string this_file;
string *simuls;
string *defs;
mixed *funcs;
string last_file;
object file_ob;
int use_defs = 0;

string function_tag(string file, string exp, string match, object ob);

void create(){
  simuls = functions((find_object("/secure/simul_efun")));
  this_file = __FILE__[strsrch(__FILE__, "/", - 1) + 1..];
}

string get_inc_path(string file){
  string ret;
  while(file[0] == ' ')
    file = file[1..];
  
  if(file[0] == '<'){
    ret = "/include/";
    file = file[1..];
  } else if(file[0] == '"'){
    if(file[1] == '/')
      ret = "";
    else 
      ret = "/" + implode(explode(last_file, "/")[0..<2], "/") + "/";
    file = file[1..];
  } else error(file);

  while(file[<1] == ' ')
    file = file[0..<2];
  file = file[0..<2];
  if(file_size(ret + file) < 0)
    return get_inc_path(sprintf("<%s>", file));
  return ret + file;
}

string expand_macros(string ins){
  int i, changed;
  int *allowed = ({' ','\t','+','-',',','(','\"','['});
  do{
    changed = 0;
    for(i=0; i<sizeof(defs); i+=2){
      int off;
      if((off = strsrch(ins, defs[i])) != -1){
        if(!off || member_array(ins[off-1], allowed) >= 0){
          ins = replace_string(ins, defs[i], defs[i+1]);
          changed = 1;
        }
      }
    }
  } while(changed);
  return ins;
}

string strip_junk(string stuff){
  stuff = replace(stuff, ({" ", "", "+", ""}));
  return replace_string(stuff, "\"\"", "");
}

void defines(){
  string *lines = ({"#include <all_inc.h>"}) + regexp(explode(read_file(last_file), "\n"),
                         "^#[ ]*(include|define)");
  string line;
  string infile = last_file;

  if(defs)
    lines = lines[1..];

  foreach(line in lines){
    int off;
    string tmp, tmp2;
    if(off = strsrch(line, "include") != -1){
      string file;
      tmp = line[off+7..];
      file = get_inc_path(tmp);
      last_file = file;
      defines();
      last_file = infile;
    } else {
      int i = 0, j, nest = 0, macro = 0;
      off = strsrch(line, "define");
      tmp = line[off+6..];
      while(tmp[0] == ' ')
        tmp = tmp[1..];
      while((tmp[++i] != ' ' || nest) && i <= (sizeof(tmp) - 1)){
        if(tmp[i] == '('){
          nest++;
          macro = 1;
        } else if(tmp[i] == ')')
          nest--;
      }
      j = i;
      if(j != (sizeof(tmp))){
        while(tmp[++j] == ' ' && j <= (sizeof(tmp) - 1));
      }

      tmp2 = tmp[j..];
      tmp = tmp[0..i-1];

      if(!macro)
        tmp2 = strip_junk(expand_macros(tmp2));
      
      defs += ({tmp, tmp2});
    }
  }
}

string get_function(string func){
  mixed tmp;
  int i=0, j=0;

  tmp = reg_assoc(read_file(last_file),
                  ({"\n[a-z_ \t]*[\\* ][ \t]*" + func +
                     "[ \t]*\\([a-zA-Z0-9, _\\*\n\t]*(...)?[ \t]*\\)[ \t\n]*{"
                      , "\n}"})
                  , ({1, 2}));

  j = member_array(1, tmp[1]) + 1;

  assert(j);

  while(tmp[0][j][i] != '\n'){
    if(tmp[0][j][i] == '}')
      return sprintf("%s%s", tmp[0][j - 1], tmp[0][j][0..i]);
    i++;
  }
  return sprintf("%s%s%s", tmp[0][j - 1], tmp[0][j], tmp[0][j + 1]);
}

string function_tag(string file, string exp, string match, object ob){
  string html, infile, func;

  assert(stringp(file));
  assert(stringp(exp));
  assert(stringp(match));
  assert(objectp(ob));

  func = match[0..<2];

  if(member_array(func, simuls) >= 0){
    file = "/secure/simul_efun";
    ob = find_object(file);
    exp = "";
  }
  
  if((infile = (function_exists(func, ob, 1) + ".c")) == file){
    html = sprintf("<B><A HREF=\"%s?file=%s&funcs=%s/%s#%s\">%s</A></B>",
                   this_file, file, exp, func, func, func);
  } else {
    html = (infile == "0.c")?func:
      (sprintf("<B><A HREF=\"%s?file=%s&funcs=%s#%s\">%s</A></B>",
                   this_file, infile, func, func, func));
  }
  return sprintf("%s(", html);
}

string inherited_function_tag(string file, string match, object ob){
  string html, infile, func, filep;

  assert(stringp(file));
  assert(stringp(match));
  assert(objectp(ob));

  sscanf(match[0..<2], "%s::%s", filep, func);

  if(sizeof(filep))
    filep +=".c";
  foreach(file in inherit_list(ob)){
    string tmp = function_exists(func, (ob = load_object(file)), 1);
    if(tmp && file[<sizeof(filep)..] == filep)
      break;
  }
  
  infile = (function_exists(func, ob, 1) + ".c");

  html = (infile == "0.c")?match[0..<2]:
    (sprintf("<B><A HREF=\"%s?file=%s&funcs=%s#%s\">%s</A></B>",
             this_file, infile, func, func, match[0..<2]));
  return sprintf("%s(", html);
}

string parse_function(string funct, string *expand){
  string ret;
  int i;
  mixed *tmp; 

  if(!sizeof(defs)){
    defs = ({});
    if(use_defs)
      defines();
  }

  ret = funct;

  if(use_defs)
    while(ret != (funct = expand_macros(funct)))
      ret = funct;
          
  tmp = reg_assoc(funct, ({"[a-zA-Z_0-9][a-zA-Z_0-9]*\\(",
                           "[a-z_]*::[a-zA-Z_0-9][a-zA-Z_0-9]*\\("}),
                  ({(:function_tag($(last_file), $(implode(expand, "/")), $1,
                                   $(file_ob)):),
                    (:inherited_function_tag($(last_file), $1, $(file_ob)):)}),
                  (:HTTPD->escape_html($1):));

  ret = "";
  for(i = 0; i < sizeof(tmp[1]); i++){
    ret += evaluate(tmp[1][i], tmp[0][i]);
  }
  return ret;
}

string make_func(string *expand, int can_read, string done, mixed *func){
  string tmp;
  reset_eval_cost();
  done += "<a name=\"" + func[0] + "\"><a>";
  
  if(member_array(func[0], expand) == -1){
    string proto = func[2] + func[0];
    return done + sprintf("<B><A HREF=\"%s?file=%s&funcs=%s/%s#%s\""
                          ">%s(%s);</A></B><br>", 
                          this_file, last_file, implode(expand, "/"), func[0],
                          func[0],  proto, implode(func[3..], ","));
  }

  if(tmp = "/obj/handlers/autodoc/autodoc_handler"->query_help_on(last_file,
                                                                  func[0])){
    string help;
    if (tmp[<3..] == ".o") {
      help = NROFF_HAND->html_file(tmp);
    } else {
      help = read_file(tmp, 0, 2);
      if (help[0] == '.') {
        NROFF_HAND->create_nroff(tmp, "/tmp/00000bing");
        help = NROFF_HAND->html_file("/tmp/00000bing", tmp);
        rm("/tmp/00000bing");
      }
    }
    done += help;
  }
  if(can_read) return done + sprintf("<pre>%s</pre><br>",
           parse_function(get_function(func[0]), expand));
  return done + sprintf("<br>Can't read function: %s, no read permission to: %s<br>",
                 func[0], last_file);
}

string *inherits_list(string ob){
  mixed *tmp;

  tmp = objects((:!clonep($1) && inherits($(ob), $1) &&
                 (member_array($(ob), inherit_list($1)) != -1):));
  tmp = map(tmp, (:file_name($1) + ".c":));
  tmp = filter(tmp, (: $1[0..1] != "/w" :));

  if(sizeof(tmp) > 10){
    tmp = sort_array(tmp, (: reset_eval_cost(), $1[0..1] == "/d"? 1 : -1 :));
    return tmp[0..9];
  }
  return tmp;
}

string make_inherit_list(string done, string file){
  return sprintf("%s<B><A HREF=\"%s?file=%s\">%s</A></B><br> ", done,
                 this_file, file, file);
}

mixed *filter_funcs(mixed *ret, mixed *item){
  mixed *present = map(ret, (:$1[0]:));

  if(member_array(item[0], present) == -1)
    return ret + ({item});

  return ret;
}

string www_request(string, mapping args, class http_request req){
  string *expand;
  string ret;
  
  if(!args["funcs"])
    args["funcs"] = "";
  expand = explode(args["funcs"], "/");
  
  use_defs = args["defs"]?1:0;
  
  if(sizeof(args["file"])>2){
    if(args["file"][<2..] != ".c")
      args["file"] += ".c";
    if(file_size(args["file"]) > 0){
      catch{
        int can_read;
        
        if(last_file != args["file"] || !file_ob){
          last_file = args["file"];
          file_ob = 0;
          file_ob = load_object(args["file"]);
          funcs = 0;
          defs = 0;
        }
        
        if(!req->user) {
          ret = "Try help coffee_table";
          throw("no user");
        }
        
        if(!PLAYER_HANDLER->test_creator(req->user)){
          ret = "You are not a creator!";
          throw("not a cre");
        }
        
        can_read = unguarded((: master()->valid_read($(last_file), 
                                                     $(req->user), "cat"):));
        if(!funcs){
          funcs = filter(functions(file_ob, 1),
                         (:(function_exists($1[0], $(file_ob), 1) + ".c") ==
                          $(last_file):));
          
          funcs = implode(funcs, (:filter_funcs:), ({}));
          
          funcs = sort_array(funcs, 1);
        }

        if(args["funcs"] == "all")
          expand = map(funcs, (:$1[0]:));

        ret = sprintf(@END
<html>
<head>
<title> Browsing %s</title>
</head>
<body bgcolor="#ffffff" TEXT="#000030" LINK="#4a529c" VLINK="#b57339">
<font face="arial,helvetica">
<IMG ALIGN=LEFT SRC="/pics/dw3.gif"><h2>Source Browser</h2><h3><i>Froginess for all.</I></h3><BR clear=left><HR>
<h3>File: %s</h3>
<dl>
<dt><strong>Inherits:</strong>
<dd>%s<BR>
<dt><strong>Inherited by:</strong>
<dd>%s<BR>
<dt><strong>Functions:</strong><b><a href="%s?file=%s">Fold all</a></b>
    <b><a href="%s?file=%s&funcs=all">Expand all</a></b>
    <b><a href="%s?file=%s&funcs=%s&defs=1">Expand defines</a></b><BR><BR>

END
        , last_file, last_file
        , implode(inherit_list(file_ob), (:make_inherit_list:), "<br>")
        , implode(inherits_list(last_file), (:make_inherit_list:), "<br>")
        , this_file, last_file, this_file, last_file, this_file, last_file
        , args["funcs"]) +
          unguarded((: implode($(funcs), (:make_func, $(expand), 
                                 $(can_read):), ""):)) + "<BR>" + sprintf(@END
</dl>
<hr><form action="%s" METHOD=GET>
<b>File:</b> <input type="text" name="file" size=62><p>
<p>
<input type="submit" value="Get file">
<input type="reset" value="Reset">
</form>
<hr>
%s<br>
<i><a href="mailto:wodan.discworld@wodan.net">wodan.discworld@wodan.net</font></a></i><br>
</body>
</html>
END
        , this_file
        , "/www/footer"->www_function("footer", ([ ]), req, 0, 1));

      };
    }
  }
  if(ret)
    return ret;
  return sprintf("No such (loadable) file, or no file selected."
    "<hr><form action=\"%s\" METHOD=GET>"
    "<b>File:</b> <input type=\"text\" name=\"file\" size=62><p>"
    "<p>"
    "<input type=\"submit\" value=\"Get file\">"
    "<input type=\"reset\" value=\"Reset\">"
    "</form><br><b><a HREF=\"file_browser.c?"
    "action=/secure/%s,check_file,"
    "%s,file\">Browse</a>", allocate(3, this_file) ...);
}

int check_file(string file){
  if(sizeof(file) < 3)
    return 0;
  return file[<2..] == ".c";
}

// --- END [/mnt/home2/grok/lib/www/secure/source_browser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/club_info.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/club_info.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626807   Available: 13574161
Inodes: Total: 5242880    Free: 4960132
1475 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/club_info.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626807   Available: 13574161
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This will print out information about a specific club.
 * @author Pinkfish
 * @started Tue Nov  3 18:14:12 PST 1998
 */
#include <clubs.h>
inherit "/std/basic/club_listing";
#include <http.h>

private string create_header(string title) {
  return "<html><head>"
      "<title>" + title + "</title>"+
      "</head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" "
      "VLINK=\"#b57339\"><font face=\"arial,helvetica\">\n";
} /* create_header() */

string www_request(string str, mapping args, class http_request req) {
   string ret;

   if (args["club_name"] &&
       CLUB_HANDLER->is_club(args["club_name"])) {
         if (CLUB_HANDLER->is_family(args["club_name"])) {
            ret = create_header("Discworld family: " + args["club_name"]);
            ret += www_family_info_string(args["club_name"], req->user);
         } else {
            ret = create_header("Discworld club: " + args["club_name"]);
            ret += www_club_info_string(args["club_name"], 1, req->user);
         }
   } else {
      if (args["club name"]) {
         ret = create_header("Discworld club: "  + args["club_name"]);
         ret += "<h2>The club " + args["club_name"] +
                " is non-existant.</h2>\n";
      } else {
         ret = create_header("Discworld club: Unknown");
         ret += "<h2>Bad argument to the club listing.</h2>";
      }
   }
   ret += "/www/footer"->www_function("footer", ([ ]), req);
   return ret;
} /* www_request() */
// --- END [/mnt/home2/grok/lib/www/secure/club_info.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/file_browser.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/file_browser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626807   Available: 13574161
Inodes: Total: 5242880    Free: 4960132
2395 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/file_browser.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626807   Available: 13574161
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: file_browser.c,v 1.4 2003/03/21 04:50:28 ceres Exp $
 *
 *
 */

//Source browser by Wodan
#include <http.h>
#include <assert.h>
#include <player_handler.h>

string this_file;
string *action_info, action;

void create(){
  this_file = __FILE__[strsrch(__FILE__, "/", - 1) + 1..];
}

int done_dirs;

string make_dir_list(string done, mixed *file_info){
  int size;
  string file = file_info[1];
  if((size = file_info[0]) == -1)
    return done;
  if(size == 0)
    return sprintf("%s<B><A HREF=\"%s?path=%s/&action=%s\">%s/</A></B><br> ", done,
                 this_file, file, action, file);

  if(!done_dirs){
    done += "<br>";
    done_dirs = 1;
  }

  if(!call_other(action_info[0], action_info[1], file))
    return done;
  
  return sprintf("%s<B><A HREF=\"%s?%s=%s\"><strong>%s</strong></A></B><br> ", done,
                 action_info[2], action_info[3], file, file);

}

mixed *get_full_dir(string path){
  mixed *ret = map(get_dir(path, -1), (:({$1[1] >= 0, $(path) + $1[0]}):));
  ret = sort_array(ret, function(mixed *a, mixed *b){
    if(a[0] < b[0])
      return -1;
    if(a[0] > b[0])
      return 1;
    if(a[1] < b[1])
      return -1;
    if(a[1] > b[1])
      return 1;
    return 0;
  });
  return ret;
}

string www_request(string, mapping args, class http_request req){
  string ret;

  if(!args["path"])
    args["path"] = "/";
  
  if(!(req->user && args["action"]))
    return "Something bad is wrong.";

  action_info = explode(args["action"], ",");
  action_info[0] = "/www" + action_info[0];
  action = args["action"];

  if(!PLAYER_HANDLER->test_creator(req->user))
    return "You are not a creator!";
  
  done_dirs = 0;

  if(!unguarded((:master()->valid_read($(args["path"]), $(req->user), "cat"):)))
    return sprintf("You don't have read permission for %s", args["path"]);

  ret = sprintf(@END
<html><head><title> Browsing %s</title></head>
<body bgcolor="#ffffff" TEXT="#000030" LINK="#4a529c" VLINK="#b57339">
<strong>Path:</strong> %s<BR><BR>
%s<BR>
%s<br>
<i><a
  href="mailto:wodan.discworld@discworld.imaginary.com">wodan.discworld@discworld.imaginary.com</font></a></i><br>
</body>
</html>

END
  , args["path"], args["path"]
  , unguarded((: implode(get_full_dir($(args["path"])), 
       (:make_dir_list:), "<br>"):))
  , "/www/footer"->www_function("footer", ([ ]), req, 0, 1));
  return ret;
}



// --- END [/mnt/home2/grok/lib/www/secure/file_browser.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/survey.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/survey.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626806   Available: 13574160
Inodes: Total: 5242880    Free: 4960132
15186 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/survey.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626806   Available: 13574160
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */

#define WWW_SURVEY_HANDLER "survey.c"

#include <http.h>
#include <log.h>
#include <player_handler.h>

#define MAX_IDLE_TIME 60*60 // 1 hour

#define DEMOTEXT "<Font color=red> Demo only </font>"

#define GV_LAST_USE(user)        (globvars[(user)])[0]
#define GV_STATUS(user)          (globvars[(user)])[1]

private nosave mapping globvars;

/* should be in globvars */

private nosave int nq;


protected string startup(mapping args, string user);
protected string menu(string user);

protected mixed playerq = ({
  ({ "Now, in an average block of playing,"
       "which activity absorbs most of your time?", 
       ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Now, in an average block of playing,"
         "which activity do you devote the least time to?", 
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Before Quest XP was removed, in an average block of playing,"
         "which activity absorbed most of your time?", 
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Before Quest XP was removed, in an average block of playing,"
         "which activity did you devote the least time to?", 
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "If the mud was expanded, so that you could spend as much time as you "
         "liked playing in any of the following ways, "
         "how would spend your time? ",
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Rank the following for how much they contribute to your fun as a player "
         "on the mud "
         "(eg. put 1 beside your favourite item, 2 beside your second  favourite "
         "item, etc...)",
         ({ "Social interaction with other players (eg. talker, chatting)",
              "In-character interaction with other players (roleplaying)",
              "Getting new/higher skills", "New commands", "New spells", 
              "New items (eg. Quest items, T-shop items, unusual items)",
              "Completing Quests", "Exploring new areas", 
              "New NPCs for killing", "New NPCs to interact with",
              "PK fights/stealing" }), "number" }),
    ({ "What was your main way to advance skills when Quests all gave XP?",
         ({ "Idle XP", "Quest XP", "Guild command XP", "Killing XP", "TM's" }) }),
    ({ "If all ways to get XP (except idle) gave it at the same rate, "
         "what way would you prefer to get XP?",
         ({ "Quest XP", "Guild command XP", "Killing XP" }) }),
    ({ "Has the removal of XP, quest items and rewards changed your "
         "interest in doing Quests?  Choose the response that most reflects your "
         "opinion: ",
         ({ "I no longer have any interest in Quests",
              "I have decreased interest in Quests",
              "I still have the same interest in Quests",
              "I have increased interest in Quests" }) }),
    ({ "Would you like XP for all Quests?",
         ({ "Yes","No","Don't Care" }) }),
    ({ "Is Quest XP important enough for you, that you would accept "
         "inconvenience and limitations on your play to get it back?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "Would it be a good thing to limit the rate at which people "
         "can do Quests for XP?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "If you had to choose to do Quests for XP or Kill for XP and you "
         "were only allowed to switch every hour or so, would that "
         "be better than no Quest XP?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "If you had to choose to do Quests for XP or Kill for XP, and you "
         "were only allowed to switch every hour or so, and Killing always "
         "gave more XP would you still do quests?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "Do you think special commands (eg. ambush, impale) "
         "should be limited to a single guild, "
         "or a small subset of the guilds?",
         ({ "Yes, even more than now", "Yes, the same as now","Less than now","Not at all" }) }),
    ({ "How many alternate characters do you currently have "
         "(ie. not counting any that deleted)?",
         ({ "None", "1", "2", "3", "4", "5 or more", "10 or more" }) }),
    ({ "How many alternate characters do you currently have, "
         "that you play at least once a month?",
         ({ "None", "1", "2", "3", "4", "5 or more", "10 or more" }) }),
    ({ "Do you have any comments you would like to make?<BR>"
         "Please keep it brief: the survey is mainly intended as multiple choice",
         ({ "Did you respond ``Other'' to any questions above? "
              "Please give details here:", " General comments:" }), "text" })
    });

protected mixed creatorq = ({
  ({ "How long ago did you last actively play on Discworld? (not testing)",
       ({ "< 1 Day", "< 1 Week", "< 1 Month", "< 1 Year" }) }),
    ({ "What fraction of time do you currently spend as a player, "
         "rather than your creator alt?",
    ({ "Less than a tenth", "Up to a quarter", "Around half", "More than half"
         }) }),
  ({ "Do you think players will do Quests for no reward (eg. XP, items)?",
       ({ "Absolutely", "Probably, Yes","Probably Not","No" }) }),
    ({ "Are you disappointed that Quests you make or have made may not "
         "qualify for XP?",
         ({ "Absolutely", "Yes, somewhat","Not that much","No" }) }),
    ({ "Do you think many players will consider Hack and Slash "
         "the main remaining option with no/limited Quest XP?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No" }) }),
    ({ "If there are players who strongly prefer to do Quests for XP, "
         "what should we do about it?",
         ({ "Leave them with Hack and Slash XP, work on other stuff",
              "Assume they will switch to some new non-Hack and Slash XP, work "
              "on that", 
              "Permanently leave easy-if-you-know-it Quests without XP but "
              "work on new higher effort Quests for XP",
              "Work on Quest XP rate limits or Quest mode so that Quest XP can be "
              "restored pretty much across the board" }), "long" }),
    ({ "... what should we do about Quest XP right away?",
         ({ "Nothing", "Restore Quest XP but limit the rate (eg. 1 qp per hour)", 
              "Restore Quest XP but apply rate "
              "limits and some sort of Quest mode" }), "long" }),
    });

protected void create() {
  seteuid(getuid());
  globvars = ([]);
}

private varargs string create_header(string title, string host) {
  return "<HTML>\n<HEAD>\n"
    "<TITLE>" + title + "</TITLE>\n" +
    (host ? "<META http-equiv=\"Refresh\" content=\"3600;URL=http://" + host +
     "/secure/"+WWW_SURVEY_HANDLER+"?type=timeout\">" : "") +
    "</HEAD>\n<BODY bgcolor=\"#ffffff\" text=\"#000030\" link=\"#4a529c\" "
    "vlink=\"#b57339\">\n<FONT face=\"arial,helvetica\">\n"
    "<IMG align=\"left\" src=\"/pics/dw6.gif\"></A>\n<H2 color=\"#00AADD\">"
    "Playing Styles Survey "+DEMOTEXT+"</H2>"
    "\n<H3><I>When the frogs come home to roost.</I></H3>\n<BR clear=\"left\">\n"
    "<BR>\n";
} /* create_header() */

private string create_footer(class http_request req) {
  return ("/www/footer"->www_function("footer", ([ ]), req))+"</BODY>\n</HTML>\n";
}

private string remove_control_chars(string str) {
  int i;
  
  for (i = 0; i < strlen(str); i++) {
    /* This will also change the hard space back tyo a space. */
    if ((str[i] < ' '  && str[i] != '\n' && str[i] != '\r') ||
        str[i] == 160 ) {
      str[i] = ' ';
    }
  }
  return str;
} /* remove_control_chars() */

string htmlify_no_address(string str) {
  return replace(str, ({
    "&", "&amp;",
      "<", "&lt;",
      ">", "&gt;",
      "\n", "<BR>\n",
      /* " ", "&nbsp;", */
      }) );
}

/*
 * Makes all the '<' turn into $gt; and the '>' the same.  Turn
 * http addresses into real addresses...
 */
string htmlify(string  str) {
   string *bits;
   string start;
   string end;
   string extra;
   int i;

   str =  htmlify_no_address(str);
   if (strsrch(str, "http:") > 0) {
      bits = explode("#" + str, "http:");
      bits[0] = bits[0][1..];
      for (i = 1; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%s&nbsp;%s", start, end) == 2) {
            end = "&nbsp;" + end;
            if (sscanf(start, "%s<BR>%s", start, extra) == 2) {
                end = "<BR>" + extra + end;
            }
         } else if (sscanf(bits[i], "%s<BR>%s", start, end) == 2) {
            end = "<BR>" + end;
         } else {
            start = bits[i];
            end = "";
         }
         if (start[<1] == '.') {
            start = start[0..<2];
            end = "." + end;
         }
         bits[i] = "<A href=\"http:" + start + "\">http:" + start + "</A>" +
                     end;
      }
      str = implode(bits, "");
   }

   return str;
}

protected string process_questions(mixed qs, mapping args, int nq) {
  string ret;
  mixed q,r;
  int nr;

  ret = "";
  foreach (q in qs) {
    nq++;

    if (sizeof(q) == 2 || q[2]=="long") {
      if (args["q"+nq]) ret+="\n\nQuestion: q"+nq+",  Response: "
                          +args["q"+nq]+"<BR>";
    }
    else if (q[2]=="number"){
      nr=0;
      foreach (r in q[1]) {
        nr++;
      if (to_int(args["q"+nq+"r"+nr])) ret+="\n\nQuestion: q"+nq+"r"+nr+",  Response: "
                          +args["q"+nq+"r"+nr]+"<BR>";
      }
    }
    else if (q[2]=="text"){
      nr=0;
      foreach (r in q[1]) {
        nr++;
        if (sizeof(args["q"+nq+"r"+nr])) ret+="\n\nQuestion: q"+nq+"r"+nr+",  Response: "
                          +args["q"+nq+"r"+nr]+"<BR>";
      }
    }

  }

  return ret;
}


string www_request(string, mapping args, class http_request req) {
  string ret, user;
  int iwrite;
  
  if(!req->user)
    return "Error!";

  user = req->user;

  if(!master()->valid_seteuid(this_object(), user))
    return create_header("Playing Style Survey") + "Can't set euid!" +
      create_footer(req);

  seteuid(user);
  
  if(!globvars[user] || args["command"]=="reset" || GV_STATUS(user)) {
    if (!globvars[user]) globvars[user] = ({ time(), 0 });
    if (GV_STATUS(user) == 2) {
      ret = "You have already completed the survey.<BR>"; 
    }
    else ret = "";
    ret += startup(args, user);
    if(ret) {
      return create_header("Playing Style Survey") + ret + create_footer(req);
    }
  }

  GV_LAST_USE(user) = time();

  if (args["command"]=="done") {
    //    if (GV_STATUS(user)!=2) {
      ret = process_questions( playerq, args, 0 );
      if(PLAYER_HANDLER->test_creator(user)) {
        ret += process_questions( creatorq, args, sizeof(playerq) );
      }

      /* Be sure to include the date for each response, in case questions
         change */
      seteuid("shaggy");
      iwrite = unguarded((: write_file, "/www/secure/survey_results/"+user, ret, 1 :));
      seteuid(user);
      ret += "Write success? "+iwrite+"\n<BR>";
      //    }
  //    else ret = "";
      
    ret += DEMOTEXT+" Thank you!<BR>";
    
    GV_STATUS(user) = 2;
    return create_header("Playing Style Survey") + ret + create_footer(req);
  }
   
  ret = "Don't know what that was.\n\n";
  GV_STATUS(user) = 1;

  return create_header("Error handler", req->hostname) + ret + menu(user) + create_footer(req);
}

protected string menu(string user) {
  string ret;

  ret = "<HR>\n<FORM action=\""+WWW_SURVEY_HANDLER+"\" method=\"GET\">\n"
    "<TABLE>\n";

  return ret;
}

protected string add_questions(mixed qs, int nq) {
  string ret, sep;
  mixed q,r;
  int nr;

  ret = "";
  foreach (q in qs) {
    nq++;
    ret +=
      "<TR>\n"
      "<TD width=20> "+nq+".</TD>"
      "<TD> "+q[0]+
      "<TR>\n"
      "<TD> &nbsp; </TD>"
      "<TD>";
    nr=0;
    sep = "";
    if (sizeof(q) == 2) {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep +"<INPUT type=\"radio\" name=\"q"+nq+"\" value=\" "+nr+" \"> "+r+"\n";
        sep = ", &nbsp; ";
      }
    }
    else if (q[2] == "long") {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep +"<INPUT type=\"radio\" name=\"q"+nq+"\" value=\" "+nr+" \"> "+r+"\n";
        sep = "<TR><TD> &nbsp; </TD><TD>";
      }
    }
    else if (q[2] == "number") {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep +"<INPUT type=\"text\" name=\"q"+nq+"r"+nr+"\" size=2> "+r+"\n";
        sep = "<TR><TD> &nbsp; </TD><TD>";
      }
    }
    else if (q[2] == "text") {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep + r+ "<BR>\n"
          "<TEXTAREA name=\"q"+nq+"r"+nr+"\" wrap=\"virtual\" rows=5 "
          " cols=60 >"
          " \n</TEXTAREA> \n";
        sep = "<TR><TD> &nbsp; </TD><TD> ";
      }
    }
    ret +=
      ". </TD>";
  }

  return ret;
}

protected string startup(mapping args, string user) {
  string ret;

  ret = "<FORM method=\"GET\" action=\""+WWW_SURVEY_HANDLER+"\">\n"
    "<TABLE>\n"
    "<TR>\n"
    "<TH align=\"left\" colspan=2>Hi "+capitalize(user)+
    ",  please set your responses below:</TH>\n"
    "<TR>\n"
    "<TD BGCOLOR=\"#DDDDDD\" colspan=2> <font color=blue> Disclaimer:</font> "
    "This survey is not official: "
    "the results will not necessarily constrain the development of discworld. "
    "The discworld administration and creators take many factors into account "
    "when making big development decisions.  The purpose of this survey is to "
    "collect useful information about playing styles."
    "<TR>\n"
    "<TD  BGCOLOR=\"#00DDDD\" colspan=2> <font color=blue> Please do this survey as your "
    "main character only.</font><BR>"
    "If you have a creator alt, do the "
    "survey as that character. "
    "You will probably have to restart your browser to change character.<BR> "
    "The survey is anonymous: your name will not be associated with your responses.</TD>";
  
  if(PLAYER_HANDLER->test_creator(user)) 
    ret += "<TR>\n"
      "<TH align=\"left\" colspan=2> Player Questions:";

  ret += add_questions( playerq, 0 );

  if(PLAYER_HANDLER->test_creator(user)) {
  ret +=
    "<TR>\n"
    "<TH align=\"left\" colspan=2> Creator Questions:"
     + add_questions( creatorq, sizeof(playerq) );
  }
  

  ret +=
    "<TR>\n"
    "<TH align=\"left\" colspan=2> Click here when you are "
    "<INPUT type=\"submit\" name=\"command\" value=\"done\">\n"
    "( or <INPUT type=\"submit\" name=\"command\" value=\"reset\"> )</TH>\n"
    "</TABLE>\n"
    "</FORM>\n";

  return ret;
}

void dest_me() {
  string user;

  if (sizeof(globvars)) {
    seteuid(getuid());
    foreach (user in keys(globvars)) {
      //      finish_errors(user);
    }
  }
  destruct(this_object());
}

int clean_up(int) {
  if (sizeof(globvars)) {
    return 1;
  }
  dest_me();
}

mixed *stats() {
  return ({
    ({ "users", sizeof(globvars) ? implode(keys(globvars), ", ") : "nobody" })
  });
}
// --- END [/mnt/home2/grok/lib/www/secure/survey.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/quests.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/quests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626802   Available: 13574156
Inodes: Total: 5242880    Free: 4960132
16108 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/quests.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626802   Available: 13574156
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This will print out a list of all the current quests
 * @author Ceres
 */
#include <http.h>
#include <quest_handler.h>
#include <library.h>
#include <player_handler.h>
#undef SAVE_FILE
#define SAVE_FILE "/save/www/quests"

#define TEXTS_DIR "/save/quests/"
#define NUM_COLS 4

// Minimum number of times the quest must be done before it is shown here.
#define MIN_TIMES 100
// How long the player must be on to timeout seen hints.
#define TIMEOUT (3600 * 24)
// Delay between successive hints (in player age).
#define HINT_DELAY (3600 * level)

#define MAX_LIST 20
#define MAX_HINTS ({ 10, 5, 2 })

// When sorting the list how much weight to give to a quests level as
// opposed to how many times it's been done.
#define WEIGHTING 500

mapping seen_quests;

nosave string *ql, *qt;

class seen_info {
  string which;
  int time;
  int level;
}

int sort_list(string first, string second) {
  int lfirst, lsecond;

  // sort by level
  lfirst = ( 15 - QUEST_HANDLER->query_quest_level(first)) * WEIGHTING +
    QUEST_HANDLER->query_quest_times(first);
  lsecond = (QUEST_HANDLER->query_quest_level(second) * WEIGHTING) +
    QUEST_HANDLER->query_quest_times(second);

  if(lfirst > lsecond)
    return -1;
  if(lsecond < lfirst)
    return 1;

  return 0;
}

void create() {
  int i;
  
  seteuid("Room");
  unguarded( (: restore_object(SAVE_FILE) :) );
  if (!seen_quests) {
      seen_quests = ([ ]);
   }
   ql = QUEST_HANDLER->query_quest_names();
   ql = sort_array(ql, (: sort_list($1, $2) :));
   qt = allocate(sizeof(ql));
   for(i=0; i<sizeof(ql); i++)
     qt[i] = QUEST_HANDLER->query_quest_title(ql[i]);
}

private string create_header(string title) {
  return "<HTML>\n<HEAD>\n"
    "<TITLE>" + title + "</TITLE>\n"
    "</HEAD>\n<BODY bgcolor=\"#ffffff\" text=\"#000030\" link=\"#4a529c\" "
    "vlink=\"#b57339\">\n<FONT face=\"arial,helvetica\">\n"
    "<IMG align=left src=\"/pics/dw6.gif\"></A>\n"
    "<H2>Discworld Quest Page</H2>\n"
    "<H3><I>For what it's worth.</I></H3>\n<BR clear=\"left\">\n"
    "<BR>\n";
} /* create_header() */

private string create_footer(class http_request req) {
  return ("/www/footer"->www_function("footer", ([ ]), req))+"</BODY>\n</HTML>\n";
}

private string htmlify(string str) {
   return replace(str, ({
                         "&", "&amp;",
                         "<", "&lt;",
                         ">", "&gt;",
                         "\n", "<br>\n",
                         }) );
}

private string calc_filename(string qname) {
  string fname;

  fname = lower_case(qname);
  fname = replace(fname, ({ " ", "_", "'", "" })) + ".txt";
  return fname;
}

private string get_file(string fname) {
  string tmp;
  tmp = unguarded( (: read_file, TEXTS_DIR + fname :) );
  if(tmp)
    tmp = htmlify(tmp);
  return tmp;
}

private string get_plain_file(string fname) {
  string tmp;
  tmp = unguarded( (: read_file, TEXTS_DIR + fname :) );
  return tmp;
}

private void save_file() {
  unguarded( (: save_object(SAVE_FILE) :) );
}

int can_see_hint(string name, string which, int level) {
  class seen_info tmp;
  int hints, i, age;
  
  if ("/secure/bastards"->query_suspended(name))
    return 0;

  if(!PLAYER_HANDLER->test_active(name))
    return 0;

  if(LIBRARY->query_quest_done(name, which))
    return 0;

  age = - (PLAYER_HANDLER->test_age(name));

  for(i=0; i<sizeof(seen_quests[name]); i++) {
    tmp = seen_quests[name][i];
    // remove quests which they've done or which have timedout.
    if(LIBRARY->query_quest_done(name, tmp->which) ||
       tmp->time < age - TIMEOUT) {
      seen_quests[name] = seen_quests[name][0..i-1] +
         seen_quests[name][i+1..];
       save_file();
    } else if(tmp->which == which) { // Ok, this quest is on the list.

      // they've seen this level or higher so let them see it again.
      if(tmp->level >= level)
        return 1;

      // they saw the last level too recently so tell them so.
      if(tmp->time > (age - HINT_DELAY))
        return -1;

      return 1;
    } else if(tmp->level == level) {
      hints++;
    }
  }
  return (hints < (MAX_HINTS[level-1]));
}

void add_seen(string name, string which, int level) {
  class seen_info seen, tmp;
  int i;
  
  if(LIBRARY->query_quest_done(name, which))
    return;
  
  seen = new(class seen_info,
             which : which,
             time : - (PLAYER_HANDLER->test_age(name)),
             level : level);

  if(seen_quests[name]) {
    for(i = 0; i < sizeof(seen_quests[name]); i++) {
      if(seen_quests[name][i]->which == which) {
        tmp = (class seen_info)seen_quests[name][i];
        if(level > tmp->level)
          tmp->level = level;
        seen_quests[name][i] = tmp;
        save_file();
        return;
      }
    }
    seen_quests[name] += ({ seen });
  } else
    seen_quests[name] = ({ seen });
  save_file();
}

string www_request(string str, mapping args, class http_request req) {
   string ret, user, fname, tmp;
   int i, j, k;

   user = req->user;

   if(!PLAYER_HANDLER->test_creator(user))
     return create_header("Quest Hints") + "You are not a creator!" +
       create_footer(req);
#ifdef 0
   if(!"/secure/master"->query_leader(user) &&
      user != "valentijn") {
     return create_header("Quest Hints") + "This page is currently only "
       "available to lords.\n" + create_footer(req);
   }
#endif   
   ret = create_header("Quest List");

   ret += "";

   if(args["param"])
     sscanf(args["param"], "%d", i);
   
   switch(args["op"]) {
   case "write":

     if(req->body->data["hint"] != "0") {
       fname = "hints/" + calc_filename(ql[i]);
       ret += "Writing hint to: " + TEXTS_DIR + fname + "<br>";
       ret += "[" + req->body->data["hint"] + "]<br>";
       unguarded((: write_file, TEXTS_DIR + fname,
                  req->body->data["hint"] + "\n", 1 :));
     }

     if(req->body->data["second_hint"] != "0") {
       fname = "second_hints/" + calc_filename(ql[i]);
       ret += "Writing second hint to: " + TEXTS_DIR + fname + "<br>";
       ret += "[" + req->body->data["second_hint"] + "]<br>";
       unguarded((: write_file, TEXTS_DIR + fname,
                  req->body->data["second_hint"] + "\n", 1 :));
     }

     if(req->body->data["final_hint"] != "0") {
       fname = "final_hints/" + calc_filename(ql[i]);
       ret += "Writing final hint to: " + TEXTS_DIR + fname + "<br>";
       ret += "[" + req->body->data["final_hint"] + "]<br>";
       unguarded((: write_file, TEXTS_DIR + fname,
                  req->body->data["final_hint"] + "\n", 1 :));
     }

     ret += "\n<p><a href=\"quests.c\">Return to main list.</a></p>\n";
     break;
   case "add":
     ret += "<p><b>Title</b>: " + QUEST_HANDLER->query_quest_title(ql[i]) +
       "<br>";
     ret += "<b>Story</b>: " + QUEST_HANDLER->query_quest_story(ql[i])+
       "</p>";
     fname = calc_filename(ql[i]);
     ret += "\n<form action=\"quests.c?op=write&param="+i+"\" "
       "method=\"post\">\n"
       "<br>First Hint:<br>\n"
       "<textarea name=\"hint\" cols=75 rows=10>" +
       get_plain_file("hints/"+fname) +
       "</textarea>\n"
       "<br>Second Hint:<br>\n"
       "<textarea name=\"second_hint\" cols=75 rows=10>" +
       get_plain_file("second_hints/"+fname) +
       "</textarea>\n"
       "<br>Final Hint: <br>\n"
       "<textarea name=\"final_hint\" cols=75 rows=10>" +
       get_plain_file("final_hints/"+fname) +
       "</textarea>\n"
       "<br><input type=\"submit\">\n"
       "</form>\n";
     break;
   case "hint":
     ret += "<h3>Quest Hint</h3>\n";
     ret += "<p><b>Title</b>: " + QUEST_HANDLER->query_quest_title(ql[i]) +
       "<br>";

     if(!can_see_hint(user, ql[i], 1)) {
       ret += "<p>Sorry, you have seen all the hints you're allowed for the "
         "moment. Why not go and complete some of those quests you've "
         "been shown then more will be available.</p>\n";
     } else {
       add_seen(user, ql[i], 1);
       
       fname = "hints/" + calc_filename(ql[i]);
       ret +=  "<p><b>First Hint</b>:<br> " + get_file(fname) + "</p>";

       fname = "second_hints/" + calc_filename(ql[i]);
       if(file_size(TEXTS_DIR + fname) > 0) {
         ret += "<b>Second Hint</b>: "
           "<a href=\"quests.c?op=second_hint&param="+i+"\">Available</a><br>";
       } else {
         ret += "<b>No second hint available</b><br>\n";

         if(file_size(TEXTS_DIR + fname) > 0)

         ret += "<b>Final Hint</b>: <a href=\"quests.c?op=final_hint&param="+i+"\">"
           "Available</a><br>";
       else
         ret += "<b>No final hint available</b><br>\n";
       }
     }
     break;
     
   case "second_hint":
     ret += "<h3>Quest Hint</h3>\n";
     ret += "<p><b>Title</b>: " + QUEST_HANDLER->query_quest_title(ql[i]) +
       "<br>";

     switch(can_see_hint(user, ql[i], 2)) {
     case 0:
       ret += "<p>Sorry, you have seen all the second hints you're allowed "
         "for the moment. Why not go and complete some of those quests you've "
         "been shown then more will be available.</p>\n";
       break;
     case -1:
       ret += "<p>You've only just seen the first hint. Why not try solving "
         "the quest before seeing the next hint.</p>\n";
       break;
     default:
       add_seen(user, ql[i], 2);
       
       fname = "second_hints/" + calc_filename(ql[i]);
       ret +=  "<p><b>Second Hint</b>:<br> " + get_file(fname) + "</p>";
       
       if(file_size(TEXTS_DIR + fname) > 0)
         ret += "<b>Final Hint</b>: "
           "<a href=\"quests.c?op=final_hint&param="+i+"\">Available</a><br>";
       else
         ret += "<b>No final hint available</b><br>\n";
     }
     
     break;

   case "final_hint":
     ret += "<h3>Final Hint</h3>\n";
     ret += "<p><b>Title</b>: " + QUEST_HANDLER->query_quest_title(ql[i]) +
       "<br>";

     switch(can_see_hint(user, ql[i], 3)) {
     case 0:
       ret += "<p>Sorry, you have seen all the final hints you're allowed for "
         "the moment. Why not go and complete some of those quests you've "
         "been shown then more will be available.</p>\n";
       break;
     case -1:
       ret += "<p>You've only just seen the second hint. Why not try solving "
         "the quest before seeing the final hint.</p>\n";
       break;
     default:
       add_seen(user, ql[i], 3);
       fname = "final_hints/" + calc_filename(ql[i]);
       ret +=  "<p><b>Final Hint</b>:<br> "+ get_file(fname) + "</p>";
     }
     break;
#ifdef 0     
   case "search":
     ret += "<h3>Search Results</h3>\n";

     tmp = "<ul>\n";
     for(i=0, j=0; i<sizeof(ql); i++) {
       if(strsrch(lower_case(ql[i]), lower_case(args["search"])) != -1 ||
          strsrch(lower_case(qt[i]), lower_case(args["search"])) != -1) {
         tmp += "<li><a href=\"quests.c?op=basic&param="+i+"\">" +
           lower_case(ql[i]) + "</a>\n";
         j++;
       }
     }

     if(!j)
       ret += "<p>No matches.</p>"
         "<form action=\"quests.c\" method=\"get\">\n"
         "<input type=\"hidden\" name=\"op\" value=\"search\">\n"
         "Search: <input type=\"text\" name=\"search\">\n"
         "</form>\n";
     else if(j > 5)
       ret += "<p>Too many matches, please refine your search.</p>"
         "<form action=\"quests.c\" method=\"get\">\n"
         "<input type=\"hidden\" name=\"op\" value=\"search\">\n"
         "Search: <input type=\"text\" name=\"search\">\n"
         "</form>\n";
     else
       ret += tmp + "</ul>\n";
     break;
#endif     
   case "basic":
     ret += "<h3>Quest Information</h3>\n";
     ret += "<p><b>Title</b>: " + QUEST_HANDLER->query_quest_title(ql[i]) +
       "<br>\n";
     ret += "<b>Story</b>: " + QUEST_HANDLER->query_quest_story(ql[i])+
       "</p>\n";

     if(PLAYER_HANDLER->test_creator(user)) {
       ret += "<p>Level: " + QUEST_HANDLER->query_quest_level(ql[i]) +
         "<br>\n";
       ret += "Times done: " + QUEST_HANDLER->query_quest_times(ql[i]) +
         "</p>\n";
       ret += "<br>Rating: " + (( 16 - QUEST_HANDLER->query_quest_level(ql[i])) *WEIGHTING +  QUEST_HANDLER->query_quest_times(ql[i])) + "\n";

     }

     fname = calc_filename(ql[i]);
     if(file_size(TEXTS_DIR + "hints/" + fname) > 0)
       ret += "<p><b>First Hint</b>: <a href=\"quests.c?op=hint&param="+i+"\">"
         "Available</a></p>";
     else {
       ret += "<p><b>No first hint available</b></p>\n";

     
       if(file_size(TEXTS_DIR + "final_hints/" + fname) > 0)
         ret += "<p><b>Final Hint</b>: <a href=\"quests.c?op=final_hint&param="+i+
           "\">Available</a></p>";
       else
         ret += "<p><b>No final hint available</b></p>\n";
     }
     break;

   case "list":
   default:
     ret += "<h3>Recommended Quests</h3>\n";
     ret += "<p>The following quests are recommended for you.</p>\n";
     ret += "<table><tr>\n<td>\n";
     for(i=0, j=0, k=0; i<sizeof(ql) && j < MAX_LIST; i++) {

       // Dont show them quests they've done already.
       if(LIBRARY->query_quest_done(user, ql[i]))
         continue;

       // Dont show inactive quests
       if(!QUEST_HANDLER->query_quest_status(ql[i]))
         continue;

       if(QUEST_HANDLER->query_quest_times(ql[i]) < MIN_TIMES)
         continue;

       // columnise the output
       if(!(k++ % (MAX_LIST / NUM_COLS)))
         ret += "</td>\n<td valign=\"top\" nowrap>\n";

       // link the quest info page.
       ret += "<li><a href=\"quests.c?op=basic&param="+i+"\">" +
         lower_case(ql[i]) + "</a>";

       j++;

     }
     ret += "</tr></table>\n";

     ret += "<form action=\"quests.c\" method=\"get\">\n"
       "<p>If you need to find assistance with a specific quest you can use "
       "the search tool to find it.</p>\n"
       "<input type=\"hidden\" name=\"op\" value=\"search\">\n"
       "Search: <input type=\"text\" name=\"search\">\n"
       "</form>\n";

     /*
      * This piece is for creators only and provides a full list of quests
      * and indicates which ones are missing hints.
      */
     if("/secure/master"->query_administrator(user) ||
        "/secure/master"->query_leader(user) ||
        user == "valentijn") {
       ret += "<hr>";
       ret += "<h3>Full quest list (for lords+ only).</h3>";
       ret += "<p>As a creator you can use this to update the hints "
         "for quests to make sure they are complete and "
         "accurate.</p>";
       
       ret += "<table><tr>\n<td>\n";
       for(i=0; i<sizeof(ql); i++) {
         // columnise the output
         if(!(i % ((sizeof(ql) + (NUM_COLS/2)) / NUM_COLS)))
           ret += "</td>\n<td valign=\"top\" nowrap>\n";
         
         // link the quest info page.
         ret += "<br><a href=\"quests.c?op=basic&param="+i+"\">" +
           lower_case(ql[i]) + "</a>";
         ret += "<br>" + qt[i] + "<br>";
         ret += "Level " + QUEST_HANDLER->query_quest_level(ql[i]) + "<br>";
         ret += "Done " + QUEST_HANDLER->query_quest_times(ql[i]) +
           " times<br>";

         ret += "Status: " + 
           (QUEST_HANDLER->query_quest_status(ql[i]) ? "Active" : "Inactive")+ 
           "<br>\n";
         
         fname = calc_filename(ql[i]);
           
         if(file_size(TEXTS_DIR + "hints/" + fname) == -1)
           ret += "<b>No</b> <a href=\"quests.c?op=add&param="+i+"\">First Hint</a>"
             "<br>";
         else
           ret += "<a href=\"quests.c?op=add&param="+i+"\">First Hint</a><br>";
         
         if(file_size(TEXTS_DIR + "second_hints/" + fname) == -1)
           ret += "<b>No</b> <a href=\"quests.c?op=add&param="+i+"\">"
             "Second Hint</a><br>";
         else
           ret += "<a href=\"quests.c?op=add&param="+i+"\">Second Hint</a>"
             "<br>";

         if(file_size(TEXTS_DIR + "final_hints/" + fname) == -1)
           ret += "<b>No</b> <a href=\"quests.c?op=add&param="+i+"\">"
             "Final hint</a><br>";
         else
           ret += "<a href=\"quests.c?op=add&param="+i+"\">Final Hint</a>"
             "<br>";
       }
       ret += "</tr></table>\n";
     }
   }
   ret += create_footer(req);
   return ret;
} /* www_request() */

// --- END [/mnt/home2/grok/lib/www/secure/quests.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/editors/editor.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/editors/editor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626798   Available: 13574152
Inodes: Total: 5242880    Free: 4960132
12002 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/editors/editor.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626798   Available: 13574152
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <room/newspaper.h>
#include <http.h>

/*
 * Makes all the '<' turn into $gt; and the '>' the same.
 */
string htmlify(string  str) {
  return replace(str, ({ "<", "&lt;", ">", "&gt;", "\n", "<br>",
                         "&", "&amp;" }));
} /* htmlify() */

string make_header(string title, string paper) {
   return "<html><head><title>" + title + "</title></head>\n"
          "<body bgcolor=#ffffff TEXT=#000030 LINK=#4a529c VLINK=#b57339>\n"
          "<font face=\"arial, helvetica\">\n"
          "<img align=left src=\"" +
                  ("/www/secure/newspaper"->find_logo_url(paper)) + "\">\n"
          "<h2>Discworld MUD</h2>\n"
          "<br clear=both>";
} /* make_header() */

string update_article(string paper, string article, class http_request req) {
   class article* arts;
   string ret;
   string* bottom;
   string office;
   string body;
   string bits;
   int i;

   office = NEWSPAPER_HANDLER->query_paper_office(paper);
   ret = make_header("Broken", paper);
   if (office) {
      // Check and make sure they are an editor first.
      arts = office->query_all_articles();


      if (!office->is_editor(req->user) &&
          !office->is_setter(req->user)) {
         // You can only editor your own articles.
         arts = filter(arts, (: lower_case(((class article)$1)->author) == $2 :), req->user);
      }
      for (i = 0; i < sizeof(arts); i++) {
         if (arts[i]->file_name == article) {
            // Update it onto the main file.
            if (arts[i]->title != req->body->data["title"]) {
               office->set_article_title_by_file(arts[i]->file_name, req->body->data["title"]);
            }
            body = replace_string(req->body->data["body"], "\r\n", "\n");
            office->save_article_text_by_file(arts[i]->file_name, body);
            ret = make_header(arts[i]->title, paper);
            bits = office->load_article_text_by_file(arts[i]->file_name);
            // Show the fluffer in an editable way.
            ret += "<form method=post action=\"editor.c?type=update&paper=" +
                      replace_string(paper, " ", "+") + "&article=" + 
                      arts[i]->file_name + "\">" +
                   "Subject: <input name=title type=text size=60 value=\"" +
                   arts[i]->title + "\"><br>\n"
                   "Shown name: <input name=name type=text size=60 value=\"" +
                   arts[i]->shown_name + "\"><br>\n"
                   "<textarea name=\"body\" rows=20 cols=75>\n" +
                   office->load_article_text_by_file(arts[i]->file_name) +
                   "</textarea><br>\n"
                   "<input type=submit value=\"Update\">\n"
                   "</form>\n";
            if (arts[i]->type == NEWSPAPER_ARTICLE_TYPE_PLAIN) {
               bits = replace_string(bits, "\n\n", "<p>");
               bits = replace_string(bits, "\n", "<br>");
            } else {
               bits = replace_string(bits, "<pre>", "</font><pre>");
            }
         }
      }
   }
   ret += "<hr width=75%>\n";
   ret += "<center><h1>Preview</h1></center>\n" + bits;
   ret += "<hr width=50%>\n";
   bottom = ({ });
   bottom += ({ "<a href=\"editor.c?type=paper&paper=" +
             replace_string(paper, " ", "+") + "\">Contents</a>" });
   ret += "<center><b>[ " + implode(bottom, " | ") + " ]</b></center>\n";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* update_article() */

string show_article(string paper, string article, class http_request req) {
   class article* arts;
   string ret;
   string* bottom;
   string office;
   int i;
   string bits;
   string old_bits;
   string art_type;

   office = NEWSPAPER_HANDLER->query_paper_office(paper);
   ret = make_header("Broken", paper);
   if (office) {
      // Check and make sure they are an editor first.
      arts = office->query_all_articles();
      if (!office->is_editor(req->user) &&
          !office->is_setter(req->user)) {
         // You can only edit your own articles.
         arts = filter(arts, (: lower_case(((class article)$1)->author) == $2 :), req->user);
      }
      for (i = 0; i < sizeof(arts); i++) {
         if (arts[i]->file_name == article) {
            ret = make_header(arts[i]->title, paper);
            bits = office->load_article_text_by_file(arts[i]->file_name);
//tell_creator("pinkfish", "%O %O\n", arts[i]->title, arts[i]->file_name);
            old_bits = bits;
            bits = replace_string(bits, "<", "&lt;");
            bits = replace_string(bits, ">", "&gt;");
            if (!office->is_locked(arts[i])) {
               // Show the fluffer in an editable way.
               ret += "<form method=post action=\"editor.c?type=update&paper=" +
                         replace_string(paper, " ", "+") + "&article=" + 
                         arts[i]->file_name + "\">" +
                   "Subject: <input name=title type=text size=60 value=\"" +
                   arts[i]->title + "\"><br>\n"
                   "Shown name: <input name=name type=text size=60 value=\"" +
                   arts[i]->shown_name + "\"><br>\n"
                   "<textarea name=\"body\" rows=20 cols=75 wrap=hard>\n" +
                   bits +
                   //office->load_article_text_by_file(arts[i]->file_name) +
                   "</textarea><br>\n"
                   "<input type=submit value=\"Update\">\n"
                   "</form>\n";
            } else {
                ret += "Locked and uneditable.\n";
            }
            if (arts[i]->type == NEWSPAPER_ARTICLE_TYPE_PLAIN) {
               old_bits = replace_string(old_bits, "\n\n", "<p>");
               old_bits = replace_string(old_bits, "\n", "<br>");
               art_type = "plain";
            } else {
               art_type = "html";
               old_bits = replace_string(old_bits, "<pre>", "</font><pre>");
               old_bits = replace_string(old_bits, "</pre>",
                                     "</pre>\n<font face=\"helvetica,arial\">");
            }
         }
      }
   }
   ret += "<hr width=75%>\n";
   ret += "<center><h1>Preview (" + art_type + ")</h1></center>\n" + old_bits;
   ret += "<hr width=50%>\n";
   bottom = ({ });
   bottom += ({ "<a href=\"editor.c?type=paper&paper=" +
             replace_string(paper, " ", "+") + "\">Contents</a>" });
   ret += "<center><b>[ " + implode(bottom, " | ") + " ]</b></center>\n";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_article() */

string show_paper(string paper, class http_request req) {
   int i;
   string ret;
   string office;
   string up_down;
   class article* arts;
   int editor;
   int setter;

   ret = make_header(paper, paper);
   ret += "<h3>" + paper + "</h3>\n";

   office = NEWSPAPER_HANDLER->query_paper_office(paper);
   if (office) {
      if (office->is_editor(req->user)) {
         ret += "<a href=\"logo_upload.c?paper=" +
                replace_string(paper, " ", "+") + "\">Upload logo</a>";
         editor = 1;
      }
      // Check and make sure they are an editor first.
      arts = office->query_all_articles();
//tell_creator("pinkfish", "%O\n", implode(map(arts, (: $1->file_name :)), ", "));
      if (!office->is_editor(req->user) &&
          !office->is_setter(req->user)) {
         // You can only editor your own articles.
         arts = filter(arts, (: lower_case(((class article)$1)->author) == $2 :), req->user);
      } else {
         setter = 1;
      }
      if (!sizeof(arts)) {
         ret += "No articles for you to edit.\n";
      } else {
         ret += "<ul>\n";
         for (i = 0; i < sizeof(arts); i++) {
            if (arts[i]->colour) {
               ret += "<font color=" + lower_case(arts[i]->colour) + ">";
            }
            if (setter) {
               up_down = "<font size=-5>[ <a href=\"editor.c?type=move_up&paper=" +
                      replace_string(paper, " ", "+") + "&article=" + 
                      arts[i]->file_name + "\">" + "Up</a> | " +
                      "<a href=\"editor.c?type=move_down&paper=" +
                      replace_string(paper, " ", "+") + "&article=" + 
                      arts[i]->file_name + "\">" + "Down</a> ]</font>";
            } else {
               up_down = "";
            }
            switch (arts[i]->type) {
            case NEWSPAPER_ARTICLE_TYPE_SECTION :
               ret += "<center><h4>" + up_down + arts[i]->title + "</h4></center>\n";
               break;
            case NEWSPAPER_ARTICLE_TYPE_HTML :
            case NEWSPAPER_ARTICLE_TYPE_PLAIN :
               ret += "<li>" + up_down + "<a href=\"editor.c?type=article&paper=" +
                      replace_string(paper, " ", "+") + "&article=" + 
                      arts[i]->file_name + "\">" +
                      arts[i]->title + "</a>" +
                      (editor?" by " + arts[i]->author : "") +
                      " shown " + arts[i]->shown_name;
               if (office->is_postponed(arts[i])) {
                  ret += " (postponed)";
               }
               if (office->is_locked(arts[i])) {
                  ret += " (locked)";
               }
               ret += ".\n";
               break;
            }
            if (arts[i]->colour) {
               ret += "</font>";
            }
         }
         ret += "</ul>\n";
      }
   } else {
      ret += "Unable to find the office for the paper.\n";
   }
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_paper() */

string move_article(string paper, string article, class http_request req, string dir) {
   class article* arts;
   string ret;
   string office;
   int i;

   office = NEWSPAPER_HANDLER->query_paper_office(paper);
   ret = make_header("Broken", paper);
   if (office) {
      // Check and make sure they are an editor first.
      arts = office->query_all_articles();

      if (office->is_editor(req->user)) {
         for (i = 0; i < sizeof(arts); i++) {
            if (arts[i]->file_name == article) {
               office->move_article(i, dir);
            }
         }
      }
   }

   return show_paper(paper, req);
} /* update_article() */

// this is the function which the webserver calls
string www_request(string str, mapping args, class http_request req) {
   string office;
   string ret;

   if (args["paper"]) {
      office = NEWSPAPER_HANDLER->query_paper_office(args["paper"]);
      if (office) {
         // Check and make sure they are an editor first.
         if (!office->is_editor(req->user) &&
             !office->is_setter(req->user)) {
            ret = make_header(args["paper"], args["paper"]);
            ret += "<h1>You must be an editor to edit the paper</h1>\n";
            return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
                    "</body></html>";
         }
      } else {
         ret = make_header(args["paper"], args["paper"]);
         ret += "<h1>You must be an editor to edit the paper</h1>\n";
         return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
                    "</body></html>";
      }
   }

   switch (args["type"]) {
   case "move_up" :
      return move_article(args["paper"], args["article"], req, "up");
   case "move_down" :
      return move_article(args["paper"], args["article"], req, "down");
   case "update" :
      return update_article(args["paper"], args["article"], req);
   case "article" :
      return show_article(args["paper"], args["article"], req);
   case "paper" :
      return show_paper(args["paper"], req);
   default :
      return make_header("Papers", args["paper"]) +
             query_multiple_short(map(NEWSPAPER_HANDLER->query_all_papers(),
                           (: "<a href=\"editor.c?type=paper&paper=" +
                              replace_string($1, " ", "+") +
                              "\">" + $1 + "</a>" :) ));
   }
}
// --- END [/mnt/home2/grok/lib/www/secure/editors/editor.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/editors/logo_upload.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/editors/logo_upload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626795   Available: 13574149
Inodes: Total: 5242880    Free: 4960132
2928 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/editors/logo_upload.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626795   Available: 13574149
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <room/newspaper.h>
#include <http.h>

private mapping _hash;

void create() {
   _hash = ([ ]);
   seteuid(getuid());
}

string make_header(string title, string paper) {
   return "<html><head><title>" + title + "</title></head>\n"
          "<body bgcolor=#ffffff TEXT=#000030 LINK=#4a529c VLINK=#b57339>\n"
          "<font face=\"arial, helvetica\">\n"
          "<img align=left src=\"" + 
                  ("/www/secure/newspaper"->find_logo_url(paper)) + "\">\n"
          "<h2>Discworld MUD</h2>\n"
          "<br clear=both>";
} /* make_header() */

// this is the function which the webserver calls
string www_request(string str, mapping args, class http_request req) {
   string paper;
   string office;

   office = NEWSPAPER_HANDLER->query_paper_office(args["paper"]);
   if (!office || !office->is_editor(req->user)) {
      return make_header("Papers", args["paper"]) +
             "<h1>You are not allowed to update the logo</h1></body></html>";
   }

   switch (args["type"]) {
   case "downloaded" :
      if (_hash[req->user] != args["hash"]) {
          return make_header("Papers", args["paper"]) +
                "<h1>Failure! (" + _hash[req->user] + " -- " + args["hash"] + "</h1></body></html>";
      }
      if (sscanf(_hash[req->user], "%*s====%s", paper) != 0) {
         paper = lower_case(paper);
         paper = replace_string(paper, " ", "_");
         tell_creator("pinkfish", "Uploaded logo ( " + geteuid(this_object()) + " " + paper + ").\n");
         // Figure out the paper from other things.
         unguarded( (: rm("/www/external/newspaper/logos/logo" + $(paper) + ".jpg") :));
         unguarded( (: rm("/www/external/newspaper/logos/logo" + $(paper) + ".gif") :));
         unguarded( (: rename("/www/secure/editors/logo_new" + $(args["ext"]),
                "/www/external/newspaper/logos/logo" + $(paper) + $(args["ext"]) ) :));
         return make_header("Papers", args["paper"]) +
                "<h1>Uploaded the logo</h1>" +
                "<a href=\"/secure/editors/editor.c?type=paper&paper=" +
                args["paper"] + "\">Return the paper listing</a></body></html>";
      }
      break;
   default :
      _hash[req->user] = random(100000) + "====" + args["paper"];
      if (!write_file("/net/save/newspaper_logo_hash_value", "" + _hash[req->user], 1)) {
          return make_header("Papers", args["paper"]) +
                "<h1>Failure!</h1></body></html>";
      }
      return make_header("Papers", args["paper"]) +
             "<form method=post enctype=\"multipart/form-data\" action=\"http://discworld.imaginary.com/cgi-bin/newspaper/cgiupload.py\">\n" +
             "<input name=file type=file>\n"
             "<input name=hash type=hidden value=\"" + _hash[req->user] + "\">\n"
             "<input name=paper type=hidden value=\"" + args["paper"] + "\">\n"
             "<input name=igloo type=submit>\n</form></body></html>";
   }
}
// --- END [/mnt/home2/grok/lib/www/secure/editors/logo_upload.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/nomic_rules.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/nomic_rules.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626794   Available: 13574148
Inodes: Total: 5242880    Free: 4960132
16990 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/nomic_rules.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626794   Available: 13574148
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <nomic_system.h>
#include <http.h>
#include <player_handler.h>

/*
 * Makes all the '<' turn into $gt; and the '>' the same.
 */
string htmlify(string  str) {
  return replace(str, ({ "<", "&lt;", ">", "&gt;", "\n", "<br>",
                         "&", "&amp;", " ", "%20" }));
} /* htmlify() */

string make_header(string title) {
   return "<html<head><title>" + title + "</title></head>\n"
          "<body bgcolor=#ffffff TEXT=#000030 LINK=#4a529c VLINK=#b57339>\n"
          "<font face=\"arial, helvetica\">\n"
          "<h2>Discworld MUD</h2>\n"
          "<h4><i>Where players grow and multiply</i></h4>\n"
          "<br clear=both>";
} /* make_header() */

string show_motions(string area, class http_request req) {
   class nomic_motion* motions;
   class nomic_motion motion;
   string ret;

   ret = make_header(area);

   if (NOMIC_HANDLER->is_citizen_of(area, req->user)) {
      motions = NOMIC_HANDLER->query_all_motions(area);
      if (!NOMIC_HANDLER->is_magistrate_of(area, req->user)) {
         motions = filter(motions, (: ((class nomic_motion)$1)->state == NOMIC_STATE_CITIZEN_VOTE :));
      }
      if (sizeof(motions)) {
         ret += "<h3>Voting</h3>\n<blockquote>\n";
         foreach (motion in motions) {
            ret += NOMIC_HANDLER->motion_as_html(area, motion);

            if (motion->state != NOMIC_STATE_CITIZEN_VOTE &&
                motion->state != NOMIC_STATE_COUNCIL_VOTE) {
               ret += "<h4>Not in a voting state</h4>";
            } else if (!NOMIC_HANDLER->has_voted_for_motion(area,
                                                     motion->identifier,
                                                     req->user)) {
               ret += "<h4>Vote <a href=\"nomic_rules.c?type=vote&area=" +
                      htmlify(area) + "&vote=yes&id=" + motion->identifier +
                      "\">Yes</a> | ";
               ret += "<a href=\"nomic_rules.c?type=vote&area=" +
                      htmlify(area) + "&vote=no&id=" + motion->identifier +
                      "\">No</a> | ";
               ret += "<a href=\"nomic_rules.c?type=vote&area=" +
                      htmlify(area) + "&vote=abstain&id=" + motion->identifier +
                      "\">Abstain</a></h4>";
            } else {
               ret += "<h4>Already voted</h4>";
            }
         }
         ret += "</blockquote>\n";
      }
   } else {
      ret += "You are not a citizen of " + area + ".\n";
   }
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
}

string show_area(string area, class http_request req) {
   string ret;
   class nomic_rule* rules;
   int cur_type;
   class nomic_rule rule;
   string *magistrates;

   ret = make_header(area);

   magistrates = NOMIC_HANDLER->query_magistrates(area);
    
   ret += "<br>\n";

   if (sizeof(magistrates)) { 
      ret += "<b>Magistrates:</b> " + 
         query_multiple_short(map(magistrates,
         (: "<a href=\"finger.c?player=" + $1 + "\">" +
         $1 + "</a>\n" :) )) + "\n";
   }
   else {
       ret += "<b>There are no elected magistrates in " + area + ".</b>\n";
   }

   ret += "<br>\n";

   // First figure out if there is anything to vote for.
   if (NOMIC_HANDLER->is_citizen_of(area, req->user)) {
      if (NOMIC_HANDLER->query_citizen_board(area)) {
         ret += "<b>Boards:</b> <a href=\"boards.c?type=subject&board=" +
                htmlify(NOMIC_HANDLER->query_citizen_board(area)) +                             "\">Citizen board</a>";
         if (NOMIC_HANDLER->is_magistrate_of(area, req->user) &&
             NOMIC_HANDLER->query_magistrate_board(area)) {
            ret += ", <a href=\"boards.c?type=subject&board=" +
                   htmlify(NOMIC_HANDLER->query_magistrate_board(area)) +
                   "\">Magistrate board</a>";
         }
         ret += "<p>";
      }
      

      if (NOMIC_HANDLER->is_election_phase(area)) {
         ret += "There is currently an election on, you can "
                "<a href=\"nomic_rules.c?type=voting&area=" + htmlify(area) +
                "\">vote here</a>.<p>";
      }
   }

   rules = NOMIC_HANDLER->query_all_nomic_rules(area);
   rules = sort_array(rules, (: ((class nomic_rule)$1)->id -
                                ((class nomic_rule)$2)->id :) );
   cur_type = -1;
   foreach (rule in rules) {
      if (rule->type != cur_type) {
         switch (rule->type) {
         case NOMIC_TYPE_IMMUTABLE :
            ret += "<h3>Immutable rules</h3>\n"
                   "<blockquote><font color=brown>These are the unchangeable default set of rules for "
                   "the council.</font></blockquote><p>";
            break;
         case NOMIC_TYPE_CITIZEN   :
            ret += "<h3>Citizen rules</h3>\n"
                   "<blockquote><font color=brown>These are the rules that only effect the citizens of "
                   "the council.</font></blockquote><p>";
            break;
         case NOMIC_TYPE_GENERAL   :
            ret += "<h3>General rules</h3>\n"
                   "<blockquote><font color=brown>These are the rules that effect everyone in the "
                   "jurisdiction of the council.</font></blockquote><p>";
            break;
         }
         cur_type = rule->type;
      }
      ret += "<li>" + NOMIC_HANDLER->rule_as_html(rule);
      ret += "<p>\n";
   }
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_area() */

string query_main_vote_page(string area, mapping people) {
   string person;
   string ret;

   ret = "<form method=post action=\"nomic_rules.c?area=" +
          htmlify(area) + "&type=mainvote\">\n";
   foreach (person in NOMIC_HANDLER->query_can_vote_for(area)) {
      ret += "<input type=checkbox name=\"vote_" + person +
           "\" value=1";
      if (people["vote_" + person]) {
         ret += " checked";
      }
      ret += "> " + person + "<br>\n";
   }
   ret += "<input  type=hidden name=type value=mainvote>\n";
   ret += "<input  type=hidden name=area value=\"" + area + "\">\n";
   ret += "<input type=submit name=\"Vote!\">\n";
   ret += "</form>";
   return ret;
}

string show_main_vote(string area, class http_request req) {
   string ret;

   ret = make_header(area);
   ret += "<b>Current Magistrates:</b> " + 
          query_multiple_short(map(NOMIC_HANDLER->query_magistrates(area),
                                   (: "<a href=\"finger.c?player=" + $1 + "\">" +
                                      $1 + "</a>\n" :) )) + "\n";
   ret += "<br>\n";

   // First figure out if there is anything to vote for.
   if (NOMIC_HANDLER->is_citizen_of(area, req->user)) {
      if (NOMIC_HANDLER->is_election_phase(area)) {
         if (NOMIC_HANDLER->has_voted(area, req->user)) {
            ret += "You have already voted in this election.<p>\n";
         } else {
            ret += query_main_vote_page(area, ([ ]));
         }
      } else {
         ret += "Not in the election phase.\n";
      }
   }

   ret += "Show the main <a href=\"nomic_rules.c?type=area&area=" +
          htmlify(area) + "\">" + area + "</a> page.\n<p>";

   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_main_vote() */

string citizen_vote(string area, class http_request req) {
   string ret;
   string person;
   int num;

   ret = make_header(area);
   ret += "<b>Current Magistrates:</b> " + 
          query_multiple_short(map(NOMIC_HANDLER->query_magistrates(area),
                                   (: "<a href=\"finger.c?player=" + $1 + "\">" +
                                      $1 + "</a>\n" :) )) + "\n";
   if (NOMIC_HANDLER->is_citizen_of(area, req->user)) {
      if (NOMIC_HANDLER->is_election_phase(area)) {
         if (NOMIC_HANDLER->has_voted(area, req->user)) {
            ret += "You have already voted in this election.<p>\n";
         } else {
            ret += "<p>You have decided to vote for:\n";
            ret += "<form method=post action=\"nomic_rules.c?area=" +
                   htmlify(area) + "&type=mainvoteconfirm\">\n";
            ret += "<ul>";
            foreach (person in NOMIC_HANDLER->query_can_vote_for(area)) {
               if (req->body->data["vote_" + person]) {
                  ret += "<li><input type=hidden name=\"vote_" + person +
                          "\" value=1>" + person + "<br>";
                  num++;
               }
            }
            ret += "</ul>";
            ret += "<input  type=hidden name=type value=mainvote>\n";
            ret += "<input  type=hidden name=area value=\"" + area + "\">\n";
            if (num > NOMIC_HANDLER->query_number_of_magistrates(area)) {
               ret += "You have voted for too many magistrates.<p></form>";
               // put the voting form in here.
               ret += query_main_vote_page(area, req->body->data);
            } else {
               if (num < NOMIC_HANDLER->query_number_of_magistrates(area)) {
                  ret += "You are voting for " + query_num(num) +
                         " magistrates out of " +
                         query_num(NOMIC_HANDLER->query_number_of_magistrates(area)) +
                         ".<p>";
               }
               ret += "<input type=submit value=\"Confirm\" name=\"Confirm\">\n";
               ret += "</form>";
            }
         }
      } else {
         ret += "Not in the election phase.\n";
      }
   }
   //ret += replace(sprintf("%O", req->body->data), ({ " ", "&nbsp;", "\n", "<br>" }));

   ret += "Show the main <a href=\"nomic_rules.c?type=area&area=" +
          htmlify(area) + "\">" + area + "</a> page.\n<p>";

   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* citizen_vote() */

string citizen_vote_confirm(string area, class http_request req) {
   string ret;
   string person;
   string* voted;

   ret = make_header(area);
   ret += "<b>Current Magistrates:</b> " + 
          query_multiple_short(map(NOMIC_HANDLER->query_magistrates(area),
                                   (: "<a href=\"finger.c?player=" + $1 + "\">" +
                                      $1 + "</a>\n" :) )) + "\n";
   if (NOMIC_HANDLER->is_citizen_of(area, req->user)) {
      if (NOMIC_HANDLER->is_election_phase(area)) {
         if (NOMIC_HANDLER->has_voted(area, req->user)) {
            ret += "You have already voted in this election.<p>\n";
         } else {
            ret += "<p>You have decided to vote for:\n";
            ret += "<ul>";
            voted = ({ });
            foreach (person in NOMIC_HANDLER->query_can_vote_for(area)) {
               if (req->body->data["vote_" + person]) {
                  ret += "<li>" + person;
                  voted += ({ person });
               }
            }
            ret += "</ul>";
            if (sizeof(voted) > NOMIC_HANDLER->query_number_of_magistrates(area)) {
               ret += "You are trying to vote for too many magistrates.\n";
               // put the voting form in here.
               ret += query_main_vote_page(area, req->body->data);
            } else {
               if (NOMIC_HANDLER->vote_for_people(area, voted, req->user)) {
                  ret += "You have voted for " + query_num(sizeof(voted)) +
                         " magistrates out of " +
                         query_num(NOMIC_HANDLER->query_number_of_magistrates(area)) +
                         ".<p>";
               } else {
                  ret += "There was an error trying to vote.<p>";
               }
            }
         }
      } else {
         ret += "Not in the election phase.\n";
      }
   }

   ret += "Show the main <a href=\"nomic_rules.c?type=area&area=" +
          htmlify(area) + "\">" + area + "</a> page.\n<p>";

   //ret += replace(sprintf("%O", req->body->data), ({ " ", "&nbsp;", "\n", "<br>" }));
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* citizen_vote() */

string do_vote(string area, string vote, string id, class http_request req) {
   int vote_id;
   int int_id;
   int bad;
   class nomic_motion motion;
   string ret;

   ret = make_header(area);
   switch (vote) {
   case "yes" :
      vote_id = NOMIC_VOTE_YES;
      break;
   case "no" :
      vote_id = NOMIC_VOTE_NO;
      break;
   case "abstain" :
      vote_id = NOMIC_VOTE_ABSTAIN;
      break;
   default:
      bad = 1;
      break;
   }

   if (sscanf(id, "%d", int_id) != 1 || bad) {
      ret += "<h1>Could not find the thing to vote for " + id + "</h1>";
   } else {
      if (!NOMIC_HANDLER->has_voted_for_motion(area, int_id, 
                        req->user)) {
         // Ok, find the motion.
         motion = NOMIC_HANDLER->query_motion(area, int_id);
         if (!motion) {
            ret += "<h1>Could not find the thing to vote for " + id + "</h1>";
         } else {
            ret += NOMIC_HANDLER->motion_as_html(area, motion);
            if (NOMIC_HANDLER->vote_for_motion(area, int_id,
                     vote_id, req->user)) {
               ret += "<h4>Voted " + vote + " for the above motion.</h4>\n";
            } else {
               ret += "<h4>Failed to vote " + vote +
                      " for the above motion.</h4>\n";
            }
         }
      } else {
         ret += "<h1>Already voted for the motion " + id + "</h1>" +
                NOMIC_HANDLER->motion_as_html(area, motion);
      }
   }
   ret += "<a href=\"nomic_rules.c?type=area&area=" + htmlify(area) +
          "\">Return to " + area + "</a>";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* do_vote() */

string show_all_areas(class http_request req) {
   string ret;
   string area;
   class nomic_motion* motions;

   ret = make_header("Council Areas");
   ret += "<ul>\n";
   foreach (area in NOMIC_HANDLER->query_citizenship_areas()) {
      ret += "<li>" + capitalize(area) + "\n";
      ret += "<font size=-1>[<i><a href=\"nomic_rules.c?type=area&area=" +
                htmlify(area) +
                "\">Rules</a></i>]";
      if (NOMIC_HANDLER->is_citizen_of(area, req->user) &&
          NOMIC_HANDLER->query_citizen_board(area)) {
         if (NOMIC_HANDLER->is_election_phase(area) &&
             !NOMIC_HANDLER->has_voted(area, req->user)) {
            ret += " | <i><a href=\"nomic_rules.c?type=voting&area=" +
                   htmlify(area) + "\">Magistrate Vote</a>";
         }
         motions = NOMIC_HANDLER->query_all_motions(area);
         if (!NOMIC_HANDLER->is_magistrate_of(area, req->user)) {
            motions = filter(motions, (: ((class nomic_motion)$1)->state == NOMIC_STATE_CITIZEN_VOTE :));
         }
         if (sizeof(motions)) {
            ret += " | <i><a href=\"nomic_rules.c?type=motions&area=" +
                   htmlify(area) + "\">Motions</a>";
         }
         ret += " | <i><a href=\"boards.c?type=subject&board=" +
                htmlify(NOMIC_HANDLER->query_citizen_board(area)) +
                "\">Citizen board</a>";
         if (NOMIC_HANDLER->is_magistrate_of(area, req->user) &&
             NOMIC_HANDLER->query_magistrate_board(area)) {
            ret += " | <a href=\"boards.c?type=subject&board=" +
                   htmlify(NOMIC_HANDLER->query_magistrate_board(area)) +
                   "\">Magistrate board</a>";
         }
         ret += "</i>]";
      }

      ret += "</font>";
   }
   ret += "</ul>\n";
   ret += "<h3>Help files relating to the council</h3>\n";
   ret += "<ul>\n";
   ret += "<li><a href=\"http://discworld.imaginary.com:5678/documentation.c?path=/concepts/citizenship\">Citizenship</a> - what citizenship means to you.\n";
   ret += "<li><a href=\"http://discworld.imaginary.com:5678/documentation.c?path=/room/chambers\">Council Chambers</a> - where you vote on new rules.\n";
   ret += "<li><a href=\"http://discworld.imaginary.com:5678/documentation.c?path=/room/citizenship\">Council Citizenship Room</a> - become a citizen today.\n";
   ret += "<li><a href=\"http://discworld.imaginary.com:5678/documentation.c?path=/room/cases\">Courts</a> - where you make a case and see judgements.\n";
   ret += "</ul>\n";
   return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
} /* show_all_areas() */

// this is the function which the webserver calls
string www_request(string str, mapping args, class http_request req) {
   switch (args["type"]) {
   case "vote" :
      return do_vote(args["area"], args["vote"], args["id"], req);
   case "mainvote" :
      return citizen_vote(args["area"], req);
   case "mainvoteconfirm" :
      return citizen_vote_confirm(args["area"], req);
   case "voting" :
      return show_main_vote(args["area"], req);
   case "area" :
      return show_area(args["area"], req);
   case "motions" :
      return show_motions(args["area"], req);
   default :
      return show_all_areas(req);
   }
}
// --- END [/mnt/home2/grok/lib/www/secure/nomic_rules.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/surveydemo.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/surveydemo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626790   Available: 13574144
Inodes: Total: 5242880    Free: 4960132
14195 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/surveydemo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626790   Available: 13574144
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */

#define WWW_SURVEY_HANDLER "survey.c"

#include <http.h>
#include <log.h>
#include <player_handler.h>

#define MAX_IDLE_TIME 60*60 // 1 hour

#define DEMOTEXT "<Font color=red> Demo only </font>"

private nosave mapping globvars;

/* should be in globvars */
#define LAST_USE (globvars[user])[0]

private nosave int nq;


protected string startup(mapping args, string user);
protected string menu(string user);

protected mixed playerq = ({
  ({ "Now, in an average block of playing,"
       "which activity absorbs most of your time?", 
       ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Now, in an average block of playing,"
         "which activity do you devote the least time to?", 
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Before Quest XP was removed, in an average block of playing,"
         "which activity absorbed most of your time?", 
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Before Quest XP was removed, in an average block of playing,"
         "which activity did you devote the least time to?", 
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "How would you prefer to be able to spend your time, "
         "if the opportunities for each of the following were unlimited?",
         ({ "Hack and Slash", "Socialization", "Doing Quests", "Exploring", "Other" }) }),
    ({ "Rank the following for how much they contribute to your fun as a player "
         "on the mud "
         "(eg. put 1 beside your favourite item, 2 beside your second  favourite "
         "item, etc...)",
         ({ "Social interaction with other players (eg. talker, chatting)",
              "In-character interaction with other players (roleplaying)",
              "Getting new/higher skills", "New commands", "New spells", 
              "New items (eg. Quest items, T-shop items, unusual items)",
              "Completing Quests", "Exploring new areas", 
              "New NPCs for killing", "New NPCs to interact with",
              "PK fights/stealing" }), "number" }),
    ({ "What was your main way to advance skills when Quests all gave XP?",
         ({ "Idle XP", "Quest XP", "Guild command XP", "Killing XP", "TM's" }) }),
    ({ "If all ways to get XP (except idle) gave it at the same rate, "
         "what way would you prefer to get XP?",
         ({ "Quest XP", "Guild command XP", "Killing XP" }) }),
    ({ "Has the removal of XP, quest items and rewards changed your "
         "interest in doing Quests?  Choose the response that most reflects your "
         "opinion: ",
         ({ "I no longer have any interest in Quests",
              "I have decreased interest in Quests",
              "I still have the same interest in Quests",
              "I have increased interest in Quests" }) }),
    ({ "Would you like XP for all Quests?",
         ({ "Yes","No","Don't Care" }) }),
    ({ "Is Quest XP important enough for you, that you would accept "
         "inconvenience and limitations on your play to get it back?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "Would it be a good thing to limit the rate at which people "
         "can do Quests for XP?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "If you had to choose to do Quests for XP or Kill for XP and you "
         "were only allowed to switch every hour or so, would that "
         "be better than no Quest XP?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "If you had to choose to do Quests for XP or Kill for XP, and you "
         "were only allowed to switch every hour or so, and Killing always "
         "gave more XP would you still do quests?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No way" }) }),
    ({ "Do you think special commands (eg. ambush, impale) "
         "should be limited to a single guild, "
         "or a small subset of the guilds?",
         ({ "Yes, even more than now", "Yes","Less than now","Not at all" }) }),
    ({ "How many alternate characters do you currently have "
         "(ie. not counting any that deleted)?",
         ({ "None", "1", "2", "3", "4", "5 or more", "10 or more" }) }),
    ({ "How many alternate characters do you currently have, "
         "that you play at least once a month?",
         ({ "None", "1", "2", "3", "4", "5 or more", "10 or more" }) })
    });

protected mixed creatorq = ({
  ({ "How long ago did you last actively play on Discworld? (not testing)",
       ({ "< 1 Day", "< 1 Week", "< 1 Month", "< 1 Year" }) }),
    ({ "What fraction of time do you currently spend as a player, "
         "rather than your creator alt?",
    ({ "Less than a tenth", "Up to a quarter", "Around half", "More than half"
         }) }),
  ({ "Do you think players will do Quests for no reward (eg. XP, items)?",
       ({ "Absolutely", "Probably, Yes","Probably Not","No" }) }),
    ({ "Are you disappointed that Quests you make or have made may not "
         "qualify for XP?",
         ({ "Absolutely", "Yes, somewhat","Not that much","No" }) }),
    ({ "Do you think many players will consider Hack and Slash "
         "the main remaining option with no/limited Quest XP?",
         ({ "Absolutely", "Probably, Yes","Probably Not","No" }) }),
    ({ "If there are players who strongly prefer to do Quests for XP, "
         "what should we do about it?",
         ({ "Leave them with Hack and Slash XP, work on other stuff",
              "Assume they will switch to some new non-Hack and Slash XP, work "
              "on that", 
              "Permanently leave easy-if-you-know-it Quests without XP but "
              "work on new higher effort Quests for XP",
              "Work on Quest XP rate limits or Quest mode so that Quest XP can be "
              "restored pretty much across the board" }), "long" }),
    ({ "... what should we do about Quest XP right away?",
         ({ "Nothing", "Restore Quest XP but limit the rate (eg. 1 qp per hour)", 
              "Restore Quest XP but apply rate "
              "limits and some sort of Quest mode" }), "long" }),
    });

protected void create() {
  seteuid(getuid());
  globvars = ([]);
}

private varargs string create_header(string title, string host) {
  return "<HTML>\n<HEAD>\n"
    "<TITLE>" + title + "</TITLE>\n" +
    (host ? "<META http-equiv=\"Refresh\" content=\"3600;URL=http://" + host +
     "/secure/"+WWW_SURVEY_HANDLER+"?type=timeout\">" : "") +
    "</HEAD>\n<BODY bgcolor=\"#ffffff\" text=\"#000030\" link=\"#4a529c\" "
    "vlink=\"#b57339\">\n<FONT face=\"arial,helvetica\">\n"
    "<IMG align=\"left\" src=\"/pics/dw6.gif\"></A>\n<H2 color=\"#00AADD\">"
    "Playing Styles Survey "+DEMOTEXT+"</H2>"
    "\n<H3><I>When the frogs come home to roost.</I></H3>\n<BR clear=\"left\">\n"
    "<BR>\n";
} /* create_header() */

private string create_footer(class http_request req) {
  return ("/www/footer"->www_function("footer", ([ ]), req))+"</BODY>\n</HTML>\n";
}

private string remove_control_chars(string str) {
  int i;
  
  for (i = 0; i < strlen(str); i++) {
    /* This will also change the hard space back tyo a space. */
    if ((str[i] < ' '  && str[i] != '\n' && str[i] != '\r') ||
        str[i] == 160 ) {
      str[i] = ' ';
    }
  }
  return str;
} /* remove_control_chars() */

string htmlify_no_address(string str) {
  return replace(str, ({
    "&", "&amp;",
      "<", "&lt;",
      ">", "&gt;",
      "\n", "<BR>\n",
      /* " ", "&nbsp;", */
      }) );
}

/*
 * Makes all the '<' turn into $gt; and the '>' the same.  Turn
 * http addresses into real addresses...
 */
string htmlify(string  str) {
   string *bits;
   string start;
   string end;
   string extra;
   int i;

   str =  htmlify_no_address(str);
   if (strsrch(str, "http:") > 0) {
      bits = explode("#" + str, "http:");
      bits[0] = bits[0][1..];
      for (i = 1; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%s&nbsp;%s", start, end) == 2) {
            end = "&nbsp;" + end;
            if (sscanf(start, "%s<BR>%s", start, extra) == 2) {
                end = "<BR>" + extra + end;
            }
         } else if (sscanf(bits[i], "%s<BR>%s", start, end) == 2) {
            end = "<BR>" + end;
         } else {
            start = bits[i];
            end = "";
         }
         if (start[<1] == '.') {
            start = start[0..<2];
            end = "." + end;
         }
         bits[i] = "<A href=\"http:" + start + "\">http:" + start + "</A>" +
                     end;
      }
      str = implode(bits, "");
   }

   return str;
}

protected string process_questions(mixed qs, mapping args, int nq) {
  string ret;
  mixed q,r;
  int nr;

  ret = "";
  foreach (q in qs) {
    nq++;

    if (sizeof(q) == 2 || q[2]=="long") {
      if (args["q"+nq]) ret+="\n\nQuestion: q"+nq+",  Response: "
                          +args["q"+nq]+"<BR>";
    }
    else if (q[2]=="number"){
      nr=0;
      foreach (r in q[1]) {
        nr++;
      if (to_int(args["q"+nq+"r"+nr])) ret+="\n\nQuestion: q"+nq+"r"+nr+",  Response: "
                          +args["q"+nq+"r"+nr]+"<BR>";
      }
    }
    else if (q[2]=="text"){
      nr=0;
      foreach (r in q[1]) {
        nr++;
      if (sizeof(args["q"+nq+"r"+nr])) ret+="\n\nQuestion: q"+nq+"r"+nr+",  Response: "
                          +args["q"+nq+"r"+nr]+"<BR>";
      }
    }

  }

  return ret;
}


string www_request(string, mapping args, class http_request req) {
  string ret, user;
  
  if(!req->user)
    return "Error!";

  user = req->user;

  if(!master()->valid_seteuid(this_object(), user))
    return create_header("Playing Style Survey") + "Can't set euid!" +
      create_footer(req);

  seteuid(user);
  
  if(!globvars[user]) {
    globvars[user] = ({ time(), 0, 0 });
    ret = startup(args, user);
    if(ret) {
      return create_header("Playing Style Survey") + ret + create_footer(req);
    }
  }

  LAST_USE = time();
  
  ret = process_questions( playerq, args, 0 );
  if(PLAYER_HANDLER->test_creator(user)) {
    ret += process_questions( creatorq, args, sizeof(playerq) );
  }

  ret += DEMOTEXT+" Thank you!<BR>";
  globvars[user] = 0;

  return create_header("Playing Style Survey") + ret + create_footer(req);
  
  switch(args["type"]) {
  case "mail":
    ret = "mail";
    break;
  case "comment":
    ret = "comment";
    break;
  default:
    switch(args["command"]) {
    case "Forward":
      ret = "Forward";
      break;
    default:
      ret = "Default command";
    }
  }
  return create_header("Error handler", req->hostname) + ret + menu(user) + create_footer(req);
}

protected string menu(string user) {
  string ret;

  ret = "<HR>\n<FORM action=\""+WWW_SURVEY_HANDLER+"\" method=\"GET\">\n"
    "<TABLE>\n";

  return ret;
}

protected string add_questions(mixed qs, int nq) {
  string ret, sep;
  mixed q,r;
  int nr;

  ret = "";
  foreach (q in qs) {
    nq++;
    ret +=
      "<TR>\n"
      "<TD width=20> "+nq+".</TD>"
      "<TD> "+q[0]+
      "<TR>\n"
      "<TD> &nbsp; </TD>"
      "<TD>";
    nr=0;
    sep = "";
    if (sizeof(q) == 2) {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep +"<INPUT type=\"radio\" name=\"q"+nq+"\" value=\" "+nr+" \"> "+r+"\n";
        sep = ", &nbsp; ";
      }
    }
    else if (q[2] == "long") {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep +"<INPUT type=\"radio\" name=\"q"+nq+"\" value=\" "+nr+" \"> "+r+"\n";
        sep = "<TR><TD> &nbsp; </TD><TD>";
      }
    }
    else if (q[2] == "number") {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep +"<INPUT type=\"text\" name=\"q"+nq+"r"+nr+"\" size=2> "+r+"\n";
        sep = "<TR><TD> &nbsp; </TD><TD>";
      }
    }
    else if (q[2] == "text") {
      foreach (r in q[1]) {
        nr++;
        ret +=
          sep +"<INPUT type=\"text\" name=\" q"+nq+"r"+nr+"\" size=20> "+r+"\n";
        sep = "<TR><TD> &nbsp; </TD><TD> ";
      }
    }
    ret +=
      ". </TD>";
  }

  return ret;
}

protected string startup(mapping args, string user) {
  string ret;

  ret = "<FORM method=\"GET\" action=\""+WWW_SURVEY_HANDLER+"\">\n"
    "<TABLE>\n"
    "<TR>\n"
    "<TH align=\"left\" colspan=2>Hi "+capitalize(user)+
    ",  please set your responses below:</TH>\n"
    "<TR>\n"
    "<TD BGCOLOR=\"#DDDDDD\" colspan=2> <font color=blue> Disclaimer:</font> "
    "This survey is not official: "
    "the results will not necessarily constrain the development of discworld. "
    "The discworld administration and creators take many factors into account "
    "when making big development decisions.  The purpose of this survey is to "
    "collect useful information about playing styles."
    "<TR>\n"
    "<TD  BGCOLOR=\"#00DDDD\" colspan=2> <font color=blue> Please do this survey as your "
    "main character only.</font><BR>"
    "If you have a creator alt, do the "
    "survey as that character. "
    "You will probably have to restart your browser to change character.<BR> "
    "The survey is anonymous: your name will not be associated with your responses.</TD>";
  
  if(PLAYER_HANDLER->test_creator(user)) 
    ret += "<TR>\n"
      "<TH align=\"left\" colspan=2> Player Questions:";

  ret += add_questions( playerq, 0 );

  if(PLAYER_HANDLER->test_creator(user)) {
  ret +=
    "<TR>\n"
    "<TH align=\"left\" colspan=2> Creator Questions:"
     + add_questions( creatorq, sizeof(playerq) );
  }
  

  ret +=
    "<TR>\n"
    "<TH align=\"left\" colspan=2> Click here when you are done: "
    "<INPUT type=\"submit\" value=\"Submit\"></TH>\n"
    "</TABLE>\n"
    "</FORM>\n";

  return ret;
}

void dest_me() {
  string user;

  if (sizeof(globvars)) {
    seteuid(getuid());
    foreach (user in keys(globvars)) {
      //      finish_errors(user);
    }
  }
  destruct(this_object());
}

int clean_up(int) {
  if (sizeof(globvars)) {
    return 1;
  }
  dest_me();
}

mixed *stats() {
  return ({
    ({ "users", sizeof(globvars) ? implode(keys(globvars), ", ") : "nobody" })
  });
}
// --- END [/mnt/home2/grok/lib/www/secure/surveydemo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/clubs.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626786   Available: 13574140
Inodes: Total: 5242880    Free: 4960132
4824 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/clubs.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626786   Available: 13574140
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This will print out a list of all the current clubs or families.
 * @author Pinkfish
 * @started Tue Nov  3 18:14:12 PST 1998
 */
inherit "/std/basic/club_listing";
#include <http.h>
#include <top_ten_tables.h>
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>

private string _family_string;
private string _club_string;

private string create_header(string title) {
  return "<html><head>"
      "<title>" + title + "</title>"+
      "</head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" "
      "VLINK=\"#b57339\"><font face=\"arial,helvetica\">";
} /* create_header() */

private string club_wrap(string name) {
   if (name) {
      return "<a href=\"club_info.c?club_name=" + name + "\">" + 
             CLUB_HANDLER->query_club_name(name) + "</a>";
   } else {
      return "Unknown";
   }
} /* club_info_wrap() */

private string top_families() {
  string str;
  mapping g_info;
  string guild;
  mixed *stuff;
  string bing;
  string *g_sorted;

  stuff = TOP_TEN_HANDLER->query_family_info();
  str = "<h2>Top families!</h2>\n<ul>\n"
         "<li>The most members " +
         club_wrap(stuff[TOP_TEN_LARGEST_FAMILY])  + ".\n"
         "<li>The oldest average age " +
         club_wrap(stuff[TOP_TEN_OLDEST_FAMILY]) + ".\n"
         "<li>Most average quest points " +
         club_wrap(stuff[TOP_TEN_MOST_QUEST_POINTS]) + ".\n
"
         "<li>Most player killers " +
         club_wrap(stuff[TOP_TEN_MOST_PKS]) + ".\n"
         "<li>Largest single gender " +
         club_wrap(stuff[TOP_TEN_SINGLE_GENDER]) + ".\n"
         "<li>Oldest average logon time " +
         club_wrap(stuff[TOP_TEN_OLDEST_LOGONS]) + ".\n"
         "<li>Most average relationships " +
         club_wrap(stuff[TOP_TEN_MOST_RELATIONSHIPS]) + ".\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 &&
                                                 !$1->query_real_guild_object() :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("<li>%s %s.\n",
               "Most " + (guild->query_name()),
               club_wrap(bing));
      }
   }
   str += "</ul>\n";
   return str;
} /* top_families() */

private string top_clubs() {
  string str;
  mixed *stuff;
  string guild;
  string bing;
  string *g_sorted;
  mapping g_info;

  stuff = TOP_TEN_HANDLER->query_club_info();
  str = "<h2>Top clubs!</h2>\n<ul>\n"
         "<li>The most members " +
         club_wrap(stuff[TOP_TEN_LARGEST_FAMILY])  + ".\n"
         "<li>The oldest average age " +
         club_wrap(stuff[TOP_TEN_OLDEST_FAMILY]) + ".\n"
         "<li>Most average quest points " +
         club_wrap(stuff[TOP_TEN_MOST_QUEST_POINTS]) + ".\n
"
         "<li>Most player killers " +
         club_wrap(stuff[TOP_TEN_MOST_PKS]) + ".\n"
         "<li>Largest single gender " +
         club_wrap(stuff[TOP_TEN_SINGLE_GENDER]) + ".\n"
         "<li>Oldest average logon time " +
         club_wrap(stuff[TOP_TEN_OLDEST_LOGONS]) + ".\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 &&
                                                 !$1->query_real_guild_object() &&
                                                 $1->query_name() != "object" :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("<li>%s %s.\n",
               "Most " + (guild->query_name()),
               club_wrap(bing));
      }
   }
   str += "</ul>\n";
   return str;
} /* top_clubs() */

/**
 * Cache the request for an hour...
 */
string www_request(string str, mapping args, class http_request req) {
   string ret;

   switch (args["type"]) {
      case "family" :
         ret = create_header("Current families");
         if (!_family_string) {
            _family_string = top_families();
            _family_string += www_club_list("unknown", 1, args["start"], 2000);
            call_out((: _family_string = 0 :), 120 * 60);
         }
         ret += _family_string;
         break;
      case "club" :
         ret = create_header("Current clubs");
         if (!_club_string) {
            _club_string = top_clubs();
            _club_string += www_club_list("unknown", 0, args["start"], 2000);
            call_out((: _club_string = 0 :), 120 * 60);
         }
         ret += _club_string;
         break;
   }
   ret += "/www/footer"->www_function("footer", ([ ]), req);
   return ret;
} /* www_request() */
// --- END [/mnt/home2/grok/lib/www/secure/clubs.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/domains.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/domains.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626785   Available: 13574139
Inodes: Total: 5242880    Free: 4960132
166 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/domains.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626785   Available: 13574139
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>

string www_request(string str, mapping args, class http_request req) {
  return "/www/domains"->www_request(str, args, req);
} /* www_request() */
// --- END [/mnt/home2/grok/lib/www/secure/domains.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/boards.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/boards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626784   Available: 13574138
Inodes: Total: 5242880    Free: 4960132
165 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/boards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626784   Available: 13574138
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>

string www_request(string str, mapping args, class http_request req) {
  return "/www/boards"->www_request(str, args, req);
} /* www_request() */
// --- END [/mnt/home2/grok/lib/www/secure/boards.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626784   Available: 13574138
Inodes: Total: 5242880    Free: 4960132
165 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626784   Available: 13574138
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>

string www_request(string str, mapping args, class http_request req) {
  return "/www/finger"->www_request(str, args, req);
} /* www_request() */
// --- END [/mnt/home2/grok/lib/www/secure/finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/creator/project.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/creator/project.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626784   Available: 13574138
Inodes: Total: 5242880    Free: 4960132
87608 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/creator/project.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626784   Available: 13574138
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *  Creator Project Management System Web Interface
 *  @author Drakkos (god forgive me)
 *  @started 26/08/2001
 *
 */
 
 
#include <http.h>
#include <player_handler.h>
#include <project_management.h>
#include <permissions.h>

string get_project_menu();
varargs string get_add_project(mapping);
string get_web_page (string, string);
string www_project_info (class project);
varargs string get_modify_project (string, string, string);
varargs string get_add_note (mapping, string);
string get_add_task (mapping, string);
string do_add_file (mapping, string); 
string get_modify_task (string, string);
string get_add_file (mapping, string);
string get_modify_note (string, string);
string get_modify_file (string, string, int);
string get_notes_list (string*);
string get_notes_summary (string);
string get_tasks_summary (string);
string get_view_project (string, int);
string get_view_page (string, string, string);
string get_view_note (string, string);
string get_files_summary (string);



string get_id(string str) {
  return implode (map (explode (str, " "), (: capitalize ($1) :)),
    "");   
}

varargs string *explode_to_array (string str, int cap) {
  string *arr;
  arr = explode (replace (str, ({" ", ""})), ",");

  if (!cap) {
    arr = map (arr, (: lower_case ($1) :));
  }
  
  return arr;
}  
  
string* normalise_guilds (string str) {
  string *valid_guilds = ({"wizards", "witches", "priests", "warriors",
    "thieves", "assassins"});  
  string *good = ({ });
  string *start;
  
  start = explode_to_array (str);
  
  foreach (string s in start) {
    if (member_array (s, valid_guilds) == -1) {
      s = s + "s";
    }
    if (member_array (s, valid_guilds) != -1 && 
        member_array (s, good) == -1) {
      good += ({ s });
    }
  }
      
  return good;
}


/**
 *  Take the type of timescale and the number, and multiply them together
 *  to give a time value estimate.
 *  @param number the number of units
 *  @param value the type of units
 *  @returns the number of seconds until the estimated completion date.
 */
 
int get_time_value (string number, string value) {
  int est, time;
  
  est = to_int (number);
  
  switch (value) {
    case "day":
      time = DAY;
    break;
    case "week":
      time = DAY * 7;
    break;
    case "month":
      time = DAY * 30;
    break;
    case "year":
      time = DAY * 365;
    break;
  }
  
  est *= time;

  return est;
}

string* get_twiki_links (class project p) {
  string *ret = ({ });
  string *details;
  string domain, page;
  if (!sizeof (p->twiki)) {
    return ret;
  }
  
  foreach (string t in p->twiki) {
    details = explode (t, ".");
  
    if (sizeof (details) == 2) {
      domain = details[0];
      page = details[1];
    }
    else {
      domain = p->domains[0];
      page = t;
    }

    ret += ({ "<a href=" + TWIKI_BASE + capitalize (domain) + "/" + page + ">"
     + page + "</a>"});
    
  }
  
  return ret;    
}

string* get_domain_links (class project p) {
  string *ret = ({ });
  if (!sizeof (p->domains)) {
    return ret;
  }
  
  foreach (string d in p->domains) {
    ret += ({ "<a href=project.c?misc=Domlist&domain=" + d + ">"
      + capitalize (d) + "</a>" });
  }
  
  if (!sizeof (ret)) {
    ret = ({"Error!"});
  }
  
  
  return ret;    
}

string *get_creator_links (mixed cre) {
  string *creators;
  string *ret = ({ });
  
  if (arrayp (cre)) {
    creators = cre;
  }
  else {
    creators = ({ cre });
  }
  
  creators = sort_array (creators, 1);
  
  foreach (string c in creators) {
    ret += ({ "<a href=project.c?misc=Crelist&creator=" + c + ">"
        + capitalize (c) + "</a>" });
  }
      
  return ret;
  
}


string parse_details (class project *tmp) {
  string ret = "";

  if (!sizeof (tmp)) {
    return "There are no projects in this category.<P>";
  }

  
  ret += "<ol>";
  
  foreach (class project t in tmp) {
    ret += "<li>";
    ret += "<TABLE width=100%>";
    ret += "<TD width=80%>";      
    ret += sprintf ("<B>%s:</b>  %s (%s).<br>%s<br>",
      query_multiple_short (map (t->domains, (: capitalize ($1) :))), t->id, 
      t->name, (sizeof (t->creators) ? 
      "Assigned creators: " + query_multiple_short (get_creator_links 
      (t->creators)) + "." : "<b>Unassigned</b>"));
    if (t->last_touched) {
      ret += "  Last touched: " + ctime (t->last_touched) + " by " + 
      (t->touched_by ? query_multiple_short (get_creator_links 
      (t->touched_by)) : "Nobody");
    }
    else {
      ret += "  This project has not been touched since creation.";
    }
    
    ret += "<TD>";      
               
    ret += "<b>[ </b><a href=project.c?projecttype=Details&pid=" 
      + t->id + ">Details</a> <b>|</b> "
      "<a href=project.c?pid=" + 
      t->id + "&projecttype=Edit>Edit</a> <b>]</b>" 
      "<TR>";
    ret += "</TABLE>";

  }
  
  ret += "</ol>";
    
  return ret;
}

string get_project_list() {
  class project *tmp = PROJECT_HANDLER->data_dump();
  
  return parse_details (tmp);;
  
}


string get_domain_project_list(string domain) {
  class project *tmp = PROJECT_HANDLER->filter_by_query((["domains" : 
    domain]));
  
  return parse_details (tmp);;
  
}

string get_creator_project_list(string creator) {
  class project *tmp = PROJECT_HANDLER->filter_by_query((["creators" : 
    creator]));
  
  return parse_details (tmp);;
  
}

/**
 *  Get the HTML code for the estimated completion data drop down menus.
 *  @returns the HTML code.
 */
 
varargs string get_estimate(int ignore) {
  string ret = "<SELECT NAME=\"number\">";
  
  for (int i = 0; i < 13; i++) {
    ret += "<OPTION VALUE + \"" + i + "\">" + i;
  }
  
  ret += "</SELECT>";    
  
  ret += "<SELECT NAME=\"time\">";
    
  foreach (string stat in ({"day", "week", "month", "year"}))  {   
    ret += "<OPTION value = \"" + stat+ "\">" + stat;
  }  
  
  ret += "</SELECT>";
  
  if (!ignore) {
    ret += "<INPUT type = \"checkbox\" name = \"newest\"> Update?";
  }
  
  return ret;
}

string get_tasks_summary (string id) {
  class task *tmp = PROJECT_HANDLER->project_task_data(id);
  string ret = "";
  

  ret += "<HR>"
    "<B>Tasks: </B>" 
    "<b>[</b> <a href=project.c?pid=" + id + "&tasktype=Add>"
    "Add New Task</a> <b>]</b><p>";
  
  if (sizeof (tmp)) {
    ret += "<ol>";
      
    foreach (class task t in tmp) {
      ret += "<li><TABLE width=100%>";
      ret += "<TD width=70%>";      
      ret += sprintf ("<b>%s (%s) [%d%%] </b><br>%s<br>Added by %s on %s",
        t->id, t->task_name, to_int (t->percent_complete), (sizeof (t->assigned_to) ? 
          "Assigned creators: " + query_multiple_short (
          get_creator_links (t->assigned_to)) :
          "<b>Unassigned</b>"), query_multiple_short (get_creator_links 
            (t->added_by)), 
          ctime (t->date_added));
      ret += "<TD>";
      ret += "<b>[</b> <a href=project.c?tid=" + t->id + 
        "&tasktype=Details&pid=" 
        + id + ">Details</a> | "
        "<a href=project.c?tid=" + t->id + "&tasktype=Edit&pid=" + id +">"
      "Edit</a> <b>]</b>";
      ret += "<TR>";
      ret += "</TABLE>";
  
    }
    
    ret += "</ol>";
  }
    
  return ret;
}  


varargs string get_view_task (string id, string task) {
  string ret = "";
  class task tmp;

  ret += get_view_project (id, 0);
  
  
  tmp  = PROJECT_HANDLER->get_task_file (id, task);
    
  if (!tmp) {
    return "";    
  }
  
  ret += "<HR>"
      "<B>Task " + task+ ":  </B><a href=project.c?tid=" 
      + tmp->id + "&tasktype=Edit&pid=" 
      + id + ">Edit Task</a><P> "
    "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<TABLE width=100%>"
    "<TR>"
    "<TH width=30% align = \"left\"> Task ID: </TH>" 
    "<TD>" + tmp->id + "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Task Name: </TH>" 
    "<TD>" + tmp->task_name + "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Added by: </TH>" 
    "<TD>" + query_multiple_short (get_creator_links(tmp->added_by)) + " at " 
      + ctime (tmp->date_added) 
      + "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Comments: </TH>" 
    "<TD>" + (tmp->comments? tmp->comments : "") + "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Project creators (separated by comma): "
    "</TH>" 
    "<TD>";
    if (sizeof (tmp->assigned_to)) {      
      ret += query_multiple_short (get_creator_links 
        (tmp->assigned_to));  
    }
  ret += "<TD><TR>"
    "<TH align = \"left\"> Percent Complete: </TH>" 
    "<TD>" + tmp->percent_complete+ "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Task Aims: </TH>" 
    "<TD>" + tmp->aims + "<TD>";
    if (tmp->completion_date) {
    ret += "<TR><TH align = \"left\"> Estimated completion: </TH>" 
    "<TD>" + ctime (tmp->completion_date) + "<TD>"  
    "<TR>";
  }    
    
  ret += "</TABLE>";

  return ret;
}

varargs string get_view_file (string id, string file, string task) {
  string ret = "";
  class file tmp;
  
  ret += get_files_summary (id);
  
  tmp  = PROJECT_HANDLER->get_file (id, file, task);
    
  if (!tmp) {
    return "";    
  }
  
  ret += "<HR>"
      "<B>Access for " + file + ":  </B><a href=project.c?filetype=Delete&pid=" 
      + id + "&fid="+file + "&task=" + task + ">Delete this File</a><P> "
    "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<TABLE width=100%>"
    "<TR>"
    "<TH width=30% align = \"left\"> Filename: </TH>" 
    "<TD>" + tmp->file + "<TD>"  
    "<TR>"
    "<TH align = \"left\"> File Access: </TH>" 
    "</SELECT>"    
    "<SELECT NAME=\"access\">";
    
    foreach (string stat in ({"read", "read+write", "read+write+grant"}))  {   
      ret += "<OPTION value = \"" + stat+ "\">" + stat;
    }  
  
    ret += "</SELECT>"    
    "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Leader Only: </TH>" 
    "<SELECT NAME=\"leader\">";
    
    foreach (string stat in ({"yes", "no"}))  {   
      ret += "<OPTION value = \"" + stat+ "\">" + stat;
    }  
    ret += "</SELECT>"  
    "</TABLE>";

  return ret;
}

string get_files_summary (string id) {
  class file *tmp = PROJECT_HANDLER->query_files(id);
  string ret = "";
  string acc_str, cohort;
  
  ret += "<HR>"
    "<B>Files: </B>" 
    "<b>[</b><a href=project.c?pid=" + id + "&filetype=Add>"
    "Add New File Permission</a><b>]</b><P>";
             
  if (sizeof (tmp)) {             
    ret += "<ol>";        
     foreach (class file t in tmp) {
        switch (t->access) {
          case 4:
            acc_str = "read+write+grant";
          break;
          case 2:
            acc_str = "read+write";
          break;
          case 1:
            acc_str = "read";
          break;
        }
        
      if (t->task == "leader") {
        cohort = " the project leader";
      }
      else if (sizeof (t->task)) {
        cohort = " members assigned to task " + t->task;
      }
      else {
        cohort = " project members";
      }
      

      ret += "<li><TABLE width=100%>";
      ret += "<TD width=70%>";      
      ret += sprintf ("<b>%s</b>:  %s access for %s.",
        t->file, acc_str, cohort);
      ret += "<TD>";
      ret += "<b>[ </b>"
        "<a href=project.c?fid=" + t->file + "&filetype=Delete&pid=" + id 
        +"&task=" + t->task + ">"
      "Delete</a> <b>]</b>";
  
      ret += "<TR>";
      ret += "</TABLE>";
    }
    
    ret += "</ol>";

  }
  
  return ret;
}  

string get_notes_summary (string id) {
  class note *tmp = PROJECT_HANDLER->project_note_data(id);
  string ret = "";
  

  ret += "<HR>"
    "<B>Notes: </B>" 
    "<b>[</b><a href=project.c?pid=" + id + "&notetype=Add>"
    "Add New Note</a><b>]</b><P>";
             
  if (sizeof (tmp)) {             
    ret += "<ol>";
    
    foreach (class note t in tmp) {
      ret += "<li><TABLE width=100%>";
      ret += "<TD width=70%>";      
      ret += sprintf ("<b>%s</b><br>  Added by %s %s.",
        t->id, query_multiple_short (get_creator_links (t->added_by)), 
          ctime (t->date_added));
      ret += "<TD>";
      ret += "<b>[</b><a href=project.c?nid=" + t->id + 
        "&notetype=Details&pid=" 
        + id + ">Details</a> | "
        "<a href=project.c?nid=" + t->id + "&notetype=Edit&pid=" + id +">"
      "Edit</a> <b>]</b>";
  
      ret += "<TR>";
      ret += "</TABLE>";
    }
    
    ret += "</ol>";

  }
  
  return ret;
}  
/**
 *  Deal with updaing a project's task and returning the appropriate 
 *  web page.  It will check for consistency of data and the neccessary
 *  updating of the project management PROJECT_HANDLER.  It will only do this 
 *  if the user has valid access to perform the operation.
 *  @param data the task data
 *  @param name the name of the user.
 *  @returns the HTML code for the page
 */
  
protected string do_update_task(mapping data, string name) {
  string *required = ({"taskname"});
  string *creators;  
  class task tmp;
  int valid;
  
  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_modify_task(data["projid"], 
      data["tid"]), "The " + r + " field is required.");
    }
  }
  
  data["projid"] = get_id (data["projid"]);
  data ["tid"] = get_id (data["tid"]);
  
  if (PROJECT_HANDLER->valid_operation (name, TASK, data["projid"])) {
      valid = 1;
  }
  
  if (!valid) {
    return get_web_page (get_modify_project(data["projid"]), 
        "You do not have access to perform this operation.");
  }    
   
  tmp = PROJECT_HANDLER->get_task_file (data["projid"], data["tid"]);   
  
  if (!tmp) {
      return get_web_page (get_modify_task(data["projid"], 
        data["tid"]), "Oh no, error!");
  }
  
  if (sizeof (data["assigned"])) {
    creators = filter (explode_to_array (data["assigned"]), 
      (: PLAYER_HANDLER->test_creator ($1) :));
  }
  if (tmp->task_name != data ["taskname"]) {
    tmp->task_name = data["taskname"];
  }
  if (tmp->comments != data ["comments"]) {
    tmp->comments = data["comments"];
  }

  if (tmp->percent_complete != data ["completed"]) {
    tmp->percent_complete = to_int (data["completed"]);
  }
    
  if (tmp->assigned_to != creators) {
    if (sizeof (creators)) {
      tmp->assigned_to = map (creators, (: lower_case ($1) :));
    }
    else {
      tmp->assigned_to = ({ });
    }
    
  }
  
  if (tmp->aims != data["aims"]) {
    tmp->aims = data ["aims"];
  }
  
  if (data ["newest"] == "on") {
    tmp->completion_date = time() + get_time_value (data["number"], 
      data["time"]);
  }
    
  PROJECT_HANDLER->set_task_file (data["projid"], data ["tid"], tmp, name);  
  
  return get_view_page (get_view_task (data["projid"], data["tid"]), 
    data["projid"], "Task modifed");      
}    

/**
 *  Deal with updating a project's note and returning the appropriate 
 *  web page.  It will check for consistency of data and the neccessary
 *  updating of the project management PROJECT_HANDLER.  It will only do this 
 *  if the user has valid access to perform the operation.
 *  @param data the note data
 *  @param name the name of the user.
 *  @returns the HTML code for the page
 */
 
protected string do_update_note(mapping data, string name) {
  string *required = ({"nid"}); 
  class note tmp;
  int valid;
  
  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_modify_task(data["projid"], 
      data["nid"]), 
      "The " + r + " field is required.");
    }
  }

  data ["projid"] = get_id (data ["projid"]);
  data ["nid"] = get_id (data["nid"]);


  tmp = PROJECT_HANDLER->get_note_file (data["projid"], data["nid"]);   
  
  if (!tmp) {
      return get_web_page (get_modify_task(data["projid"], 
        data["nid"]), "Oh no, error!");
  }
  
  if (PROJECT_HANDLER->valid_operation (name, NOTE, data["projid"], 
      PROJECT_HANDLER->query_project_domains(data["projid"]))) {
      valid = 1;
  }
  
  if (!valid) {
    return get_web_page (get_modify_project(data["projid"]), 
        "You do not have access to perform this operation.");
  }    

  if (tmp->note != data ["note"]) {
    tmp->note = data["note"];
  }

    
  PROJECT_HANDLER->set_note_file (data["projid"], data ["nid"], tmp, name);    
      
  return get_view_page (get_view_note(data["projid"], data["nid"]), 
    data["projid"], "Note modifed");      
} 

/*
protected string do_update_file(mapping data, string name) {
  string *required = ({"file", "access", "lead"}); 
  class file tmp;
  int valid;
  
  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_modify_file(data["projid"], 
      data["fid"], to_int (data["lead"])), 
      "The " + r + " field is required.");
    }
  }

  data ["projid"] = get_id (data ["projid"]);

  tmp = PROJECT_HANDLER->get_file (data["projid"], data["fid"], 
  to_int (data["lead"]));   
  
  if (!tmp) {
      return get_web_page (get_modify_file(data["projid"], 
        data["fid"], to_int (data["lead"])), "Oh no, error!");
  }
  
  if (PROJECT_HANDLER->valid_operation (name, FILE, data["projid"], 
      PROJECT_HANDLER->query_project_domains(data["projid"]))) {
      valid = 1;
  }
  
  if (!valid) {
    return get_web_page (get_modify_project(data["projid"]), 
        "You do not have access to perform this operation.");
  }    

  if (tmp->file != data ["file"]) {
    tmp->file = data["file"];
  }

  if (tmp->access != data ["access"]) {
    tmp->access = data["access"];
  }

  if (tmp->leader_only != data ["lead"]) {
    tmp->leader_only = data["lead"];
  }

    
  PROJECT_HANDLER->set_file (data["projid"], data ["fid"], data["access"],
  data ["leader"]);    
      
  return get_view_page (get_view_note(data["projid"], data["nid"]), 
    data["projid"], "Note modifed");      
} 
*/

/**
 *  Deal with updaing a project and returning the appropriate 
 *  web page.  It will check for consistency of data and the neccessary
 *  updating of the project management PROJECT_HANDLER.  It will only do this is
 *  the user has valid access to perform the operation.
 *  @param data the project data
 *  @param name the name of the user.
 *  @returns the HTML code for the page
 */
 
protected string do_update_project (mapping data, string name) {
  string *required = ({"projid", "name", "domains"});
  string *domains, *creators, *twiki, *sub, *pts;  
  class project tmp;
  int tmp_val, valid;
  
  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_modify_project(data["projid"]), 
        "The " + r + " field is required.");
    }
  }

  data ["projid"] = get_id (data["projid"]);

  domains = filter (explode_to_array (data["domains"]), 
    (: find_object ("/d/" + $1 + "/master") :));
   
  if (PROJECT_HANDLER->valid_operation (name, PROJECT, data["projid"], 
      domains)) {
      valid = 1;
  }
  
  pts = explode_to_array (data["playtesters"]);

  tmp = PROJECT_HANDLER->get_project_file (data["projid"]);   

  if (sizeof (pts & tmp->playtesters) != sizeof (tmp->playtesters)) {
    if (PROJECT_HANDLER->valid_operation (name, PROJECT, data["projid"], 
      domains)) {
      valid = 1;
    }
  }
  
     
  if (!valid) {
    return get_web_page (get_modify_project(data["projid"]), 
        "You do not have access to perform this operation.");
  }  
  
  
  if (PROJECT_HANDLER->find_project (data["projid"]) == -1) {
      return get_web_page (get_modify_project(data["projid"]), 
        "The project " + data["projid"] + " does not exist.");
  }
   
  if (!sizeof (domains)) {
      return get_web_page (get_modify_project(data["projid"]), 
        "At least one valid domain required.");
  }

  creators = filter (explode_to_array (data["creators"]), 
    (: PLAYER_HANDLER->test_creator ($1) :));
     
  if (sizeof (data["twiki"])) {
    twiki = explode (replace (data["twiki"], ({" ", ""})), ",");
  }
  

  if (sizeof (data["sub"])) {
    sub = explode (replace (data["sub"], ({" ", ""})), ",");
  }      
  
  if (data["size"]) {
    tmp->size = member_array (data["size"], SIZE);    
  }
  if (data["complexity"]) {
    tmp->complexity = member_array (data["complexity"], COMPLEXITY);    
  }
  if (sizeof (data["guilds"])) {
    tmp->guild_specific = normalise_guilds (data["guilds"]);
      
  }
      
  if (tmp->name != data ["name"]) {
    tmp->name = data["name"];
  }
  if (tmp->pt_notes != data ["ptnotes"]) {
    tmp->pt_notes = data["ptnotes"];
  }
  if (tmp->leader != data ["leader"]) {
    tmp->leader = data["leader"];
  }
  
  if (tmp->description != data ["description"]) {
    tmp->description = data ["description"];
  }  

  if (tmp->percent_complete != data ["completed"]) {
    tmp->percent_complete = to_int (data ["completed"]);
  }  
  
  if (tmp->domains!= domains) {
    tmp->domains = domains;
  }
  
  if (tmp->creators != creators) {
    tmp->creators = map (creators, (: lower_case ($1) :));
  }

//  if (tmp->files != files) {
//    tmp->files = files;
//  }

  if (tmp->twiki != twiki) {
    tmp->twiki = twiki;
  }

  if (tmp->sub_projects != sub) {
    tmp->sub_projects = sub;
  }

  if (data["newest"] == "on") {
    tmp_val = get_time_value (data["number"], data["time"]);
    if (tmp_val > 0) {
      tmp->estimated_completion = (time() + tmp_val);
    }
    else {
      tmp->estimated_completion = 0;
    }    
  }

  if (STATUS[tmp->status] != data["status"] && 
    member_array (data["status"], STATUS) != -1 ) {
    tmp->status = member_array (data["status"], STATUS);
    PROJECT_HANDLER->catch_status_change (tmp->id, tmp->status);
  }

  PROJECT_HANDLER->assign_playtesters (data["projid"], pts, name);   
            
  PROJECT_HANDLER->set_project_file (data["projid"], tmp, name);    
      
  return get_view_page (get_view_project (data["projid"], 1), 
    data["projid"], "Project modifed");      
}  

/**
 *  Do a query on the data and return the results in a list. 
 *  @param query the query data
 *  @returns the HTML code for the page
 */
 
string web_query (mapping query) {
  class project *tmp;
  string ret = "";
  

  query ["touched"] = get_time_value (query["number"], query["time"]);
  
  tmp = PROJECT_HANDLER->filter_by_query (query);
  
  ret += "<B>" + capitalize (query_num (sizeof(tmp))) + 
  (sizeof (tmp) == 1 ? " project matches " : " projects match ") 
    + "this query: </B><P>";
  ret += parse_details (tmp);
  
  return ret;
}

protected string do_add_project (mapping data, string name) {
  string *required = ({"projid", "name", "domains"});
  string *domains, *creators, *twiki;  
  int valid = 0, size, complexity;

  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_add_project(data), 
        "The " + r + " field is required.");
    }
  }
  
  data ["projid"] = get_id (data["projid"]);
  
  if (PROJECT_HANDLER->find_project (data["projid"]) != -1) {
      return get_web_page (get_add_project(data), 
        "The project " + data["projid"] + " already exists.");
  }
    
  domains = filter (explode_to_array (data["domains"]), 
    (: find_object ("/d/" + $1 + "/master") :));
   
  if (!sizeof (domains)) {
      return get_web_page (get_add_project(data), 
        "At least one valid domain required.");
  }
  
  if (PROJECT_HANDLER->valid_operation (name, PROJECT, data["projid"], 
      domains)) {
      valid = 1;
  }
  
  if (!valid) {
    return get_view_page (get_project_list (), 
      data["projid"], "You do not have access to perform this "
      "operation.");
  }

    
  creators = filter (explode_to_array (data["creators"]), 
    (: PLAYER_HANDLER->test_creator ($1) :));
     
  if (sizeof (data["twiki"])) {
    twiki = explode (replace (data["twiki"], ({" ", ""})), ",");
  }
  
  if (data["size"]) {
    size = member_array (data["size"], SIZE);
  }
  if (data["complexity"]) {
    complexity = member_array (data["complexity"], COMPLEXITY);
  }
  
  
  
//  if (sizeof (data["files"])) {
//    files = explode (replace (data["files"], ({" ", ""})), ",");
//  }
      
  
  PROJECT_HANDLER->add_project (data["projid"], data["name"], data["leader"],
    data["description"], domains, creators, name, size, complexity, 
    normalise_guilds (data["guilds"]));

  if (data["newest"] == "on") {
    PROJECT_HANDLER->set_completion_date(data["projid"], time() + 
      get_time_value (data["number"], data["time"]));
  }
    
          
  return get_view_page (get_view_project (data["projid"], 1), data["projid"], 
    "Project added.");      
}  

protected string do_add_note (mapping data, string name) {
  string *required = ({"nid", "note"});
  int valid;
  
  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_add_note(data, data["projid"]), 
        "The " + r + " field is required.");
    }
  }
  
  data ["nid"] = get_id (data["nid"]);
  
  if (PROJECT_HANDLER->valid_operation (name, NOTE, data["projid"], 
      PROJECT_HANDLER->query_project_domains(data["projid"]))) {
      valid = 1;
  }
  
  if (!valid) {
    return get_web_page (get_modify_project (data["projid"]), 
        "You do not have access to perform this operation.");
  }

  if (PROJECT_HANDLER->find_project (data["projid"]) == -1) {
      return get_web_page (get_add_note(data, data["projid"]), 
        "The project " + data["projid"] + " does not exist.");
  }

  if (PROJECT_HANDLER->find_note (data["projid"], data["nid"]) != -1) {
      return get_web_page (get_add_note(data, data["projid"]), 
        "The task " + data["nid"] + " already exists.");
  }

  PROJECT_HANDLER->add_note_to_project (data["projid"], data["nid"], 
    data["note"], name);
                  
  return get_view_page (get_view_project (data["projid"], 1), data["projid"], 
    "Note Added.");      
}

protected string do_add_file (mapping data, string name) {
  string *required = ({"fid", "access", "task"});
  int valid, access, k;
  string task;
  object ob;
  
  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_add_file(data, data["projid"]), 
        "The " + r + " field is required.");
    }
  }
  
  
  if (PROJECT_HANDLER->valid_operation (name, FILE, data["projid"], 
      PROJECT_HANDLER->query_project_domains(data["projid"]))) {
      valid = 1;
  }
  
  if (!valid) {
    return get_web_page (get_modify_project (data["projid"]), 
        "You do not have access to perform this operation.");
  }

  if (PROJECT_HANDLER->find_project (data["projid"]) == -1) {
      return get_web_page (get_add_note(data, data["projid"]), 
        "The project " + data["projid"] + " does not exist.");
  }
  
  if (data["task"] == "Leader only") {
    task = "leader";
  }
  else if (data["task"] == "All project members") {
    task = "";
  }
  else {
    task = data["task"];
  }
  
  if (sizeof (PROJECT_HANDLER->find_file (data["projid"], data["fid"], task))) {
      return get_web_page (get_add_file(data, data["projid"]), 
        "Permissions for this file and task  already exist.  Please "
        "remove if you wish to change the access rights.");
  }

  switch (data["access"]) {
    case "grant":
      access = GRANT_MASK;
    break;
    case "write":
      access = WRITE_MASK;
    break;
    default:
      access = READ_MASK;
    break;
  }

  ob = find_player (name);
    
  if (access == GRANT_MASK) {
  
    if (!ob) {
      return get_web_page (get_add_file(data, data["projid"]), 
        "You must be online to add grant access to a file.");
    }
  }
  
  k = master()->valid_grant(name, data["fid"], access);
  
  tell_creator ("drakkos", "%d.\n", k);
  if (!k) {
      return get_web_page (get_add_file(data, data["projid"]), 
        "You do not have valid access to add this file to the tracker.");
  }

  PROJECT_HANDLER->add_file (data["projid"], data["fid"], 
    access, name, task);
                  
  return get_view_page (get_view_project (data["projid"], 1), data["projid"], 
    "File Permission Added.");      
}

protected string do_add_task (mapping data, string name) {
  string *required = ({"tid", "taskname"});
  string *creators;
  int i, valid;
  
  foreach (string r in required) {
    if (undefinedp (data[r])) {
      return get_web_page (get_add_task(data, data["projid"]), 
        "The " + r + " field is required.");
    }
  }
  
  data ["tid"] = get_id (data["tid"]);

  if (PROJECT_HANDLER->find_project (data["projid"]) == -1) {
      return get_web_page (get_add_task(data, data["projid"]), 
        "The project " + data["projid"] + " does not exist.");
  }

  if (PROJECT_HANDLER->find_task (data["projid"], data["tid"]) != -1) {
      return get_web_page (get_add_task(data, data["projid"]), 
        "The task " + data["tid"] + " already exists.");
  }
  
  if (PROJECT_HANDLER->valid_operation (name, TASK, data["projid"])) {
      valid = 1;
  }
  
  if (!valid) {
    return get_view_page (get_view_task(data["projid"], 
      data ["tid"]), data["projid"], "You do not have access to "
      "perform this operation.");
  }  

  creators = filter (explode_to_array (data["creators"]), 
    (: PLAYER_HANDLER->test_creator ($1) :));
     
  PROJECT_HANDLER->add_task_to_project (data["projid"], data["tid"], name);
  
  if (sizeof (data["taskname"])) {
    PROJECT_HANDLER->set_task_name (data["projid"], data["tid"],
      data["taskname"]);
  }

  if (sizeof (data["aims"])) {
    PROJECT_HANDLER->set_task_aims (data["projid"], data["tid"],
      data["aims"]);
  }

  if (sizeof (data["comments"])) {
    PROJECT_HANDLER->set_task_comments (data["projid"], data["tid"],
      data["comments"]);
  }
   
  if (sizeof (creators)) {
    foreach (string c in creators) {
      PROJECT_HANDLER->add_task_creator (data["projid"], data["tid"],
        c);
    }      
  }

  i = to_int (data["completed"]);
  
  if (i > 0 && i <= 100) {
    PROJECT_HANDLER->set_task_completion (data["projid"], data["tid"],
      i);
  }
  
  if (sizeof(data["number"]) && data["newest"] == "on") {
   PROJECT_HANDLER->set_task_completion_date (data["projid"], data["tid"],
        time() + get_time_value (data["number"], data["time"]));
  }
  
                
    return get_view_page (get_view_task(data["projid"], 
      data ["tid"]), data["projid"], "Task Added");    
}

string get_view_project (string id, int verbose) {
  string ret = "";
  class project p;

//  verbose = 1;
    
  p = PROJECT_HANDLER->get_project_file (id);
    
  if (!p) {
    return "There is no project with that ID.\n";
  }  
  ret +="<B>Project " + id + ":  </B><b>[</b> <a href=project.c?pid=" + 
    p->id + "&projecttype=Edit>Edit Project</a> | " 
  "<a href=project.c?pid=" + p->id + "&projecttype=Details>"
    "Project Details</a><b> ]</b><P>" 
  "<B>" + PROJECT_HANDLER->query_touched (p->id) + "</B><P>";      

  ret += "<TABLE width=100%>"
  "<TR>"
  "<TH width=30% align = \"left\"> Project ID: </TH>"
  "<TD>" + p->id + "<TD>"
  "<TR>"
  "<TR>"    
  "<TH align = \"left\"> Project Name: </TH>" 
  "<TD>" + p->name + "<TD>"    
  "<TR>"    
  "<TH align = \"left\"> Project Domains: </TH>" 
  "<TD>" + query_multiple_short (get_domain_links(p)) 
    + "<TD>"   
  "<TR>"        
  "<TH align = \"left\"> Project Leader: </TH>" 
  "<TD>" + query_multiple_short (get_creator_links (p->leader)) + "<TD>";
  if (sizeof (p->creators)) {
    ret += "<TR>"    
    "<TH align = \"left\"> Project Creators: </TH>" 
    "<TD>" +  query_multiple_short (get_creator_links (p->creators)) 
      + "<TD>";
  }    
  
  if (verbose) {
    ret += "<TD>"        
    "<TR>"    
    "<TH align = \"left\"> Percent complete: </TH>" 
    "<TD>";  

    if (!p->percent_complete) {           
      ret += PROJECT_HANDLER->query_project_completeness (p->id);
    }
    else {
      ret += "" + p->percent_complete;
    }
    
    ret += "%";
       
    if (sizeof (p->playtesters)) {           
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Assigned Playtesters: </TH>" 
      "<TD>";  
      ret += query_multiple_short (map (p->playtesters, 
        (: capitalize ($1) :)));   
    }   
    if (p->estimated_completion) {           
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Estimated Completion Date: </TH>" 
      "<TD>";  
      ret += ctime (p->estimated_completion);
    }                
    if (p->description) {           
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Description: </TH>" 
      "<TD>";  
      ret += p->description;
    }       

    if (p->size >= 0) {
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Size: </TH>" 
      "<TD>";  
      ret += capitalize (SIZE[p->size]);
    }
    if (p->complexity >= 0) {
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Complexity: </TH>" 
      "<TD>";  
      ret += capitalize (COMPLEXITY [p->complexity]);
    }
    if (sizeof (p->guild_specific)) {           
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Guild Specific: </TH>" 
      "<TD>";  
      ret += query_multiple_short (map (p->guild_specific, 
        (: capitalize ($1) :)));   
    }       
    
    if (p->last_rotation) {
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Last rotation: </TH>" 
      "<TD>";  
      ret += ctime(p->last_rotation);
    }      
      
    if (sizeof (p->pt_notes)) {           
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Notes for Playtesters: </TH>" 
      "<TD>";  
      ret += p->pt_notes;
    }     
    ret += "<TD>"    
    "<TR>"    
    "<TH align = \"left\"> Currently in: </TH>" 
    "<TD>";  
    ret += capitalize (STATUS[p->status]);
    if (p->last_status_change) {           
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Last Status Change: </TH>" 
      "<TD>";  
      ret += ctime (p->last_status_change);
    }    
    ret += "<TD>"
      "<TR>"               
      "<TH align = \"left\"> Added by: </TH>" 
      "<TD>";  
    ret += query_multiple_short (get_creator_links(p->added_by)) + " at " 
      + ctime (p->date_added);            
    if (sizeof (p->sub_projects)) {
      ret += "<TD>"
      "<TR>"    
      "<TH align = \"left\"> Subproject IDs: </TH>" 
      "<TD>";  
      ret += query_multiple_short (map (p->sub_projects, (: "<a href="
        "project.c?projecttype=Details&pid=" + $1 + ">" + $1 + "</a>":)));             
    }    
//    if (sizeof (p->files)) {
//      ret += "<TD>"
//      "<TR>"    
//      "<TH align = \"left\"> Project Files: </TH>" 
//      "<TD>";  
//      ret += query_multiple_short (p->files);        
//    }
    if (sizeof (p->twiki)) {
      ret += "<TD>"
      "<TR>"    
      "<TH align = \"left\"> Project Twiki: </TH>" 
      "<TD>";  
      ret += query_multiple_short (get_twiki_links (p));               
    }
  }

 ret += "</TABLE>";
      
  return ret;        
}

string get_view_page (string page, string id, string title) {
  string ret = "";
  
  ret += page;

  ret += get_tasks_summary (id);
  ret += get_notes_summary (id);  
  ret += get_files_summary (id);  


  return get_web_page (ret, title);
}  
  
string www_task_info (class task p) {
  string ret = "";
  
  if (!p) {
    ret += "There is no task with that ID.\n";
  }
  
  else {
    ret += "<TABLE>"
    "<TR><TH align = \"left\"> Task ID: </TH>"
    "<TD>";
    ret += p->id;
    ret += "<TD>";
    ret += "<B>This task was added by: " + p->added_by + "</B>"
    "<TR>"    
    "<TH align = \"left\"> Task Name: </TH>" 
    "<TD>";  
    ret += p->task_name;
    ret += "<TD>"
    "<TR>";          
    ret += "<B>Added: " + ctime (p->date_added) + " </B>"
    "<TD>"    
    "<TR>"    
    "<TH align = \"left\"> Task creators: </TH>" 
    "<TD>";  
    ret += query_multiple_short (get_creator_links (p->assigned_to));
    ret += "<TD>"
    "<TR>";                   
    if (p->completion_date) {           
      ret += "<B> Estimated Completion Date: " + ctime (p->completion_date) 
        + "</B>"; 
    }                
    ret += "<TD>";        
    if (p->percent_complete) {           
      ret += "<TD>"        
      "<TR>"    
      "<TH align = \"left\"> Currently completed percentage: </TH>" 
      "<TD>";  
      ret += query_num (p->percent_complete);
      ret += "<TD>"
      "<TR>";   
    }   
    ret += "</TABLE>";
  }
  
  return ret;        
}


  
varargs string get_project_menu() {  
  string ret = "";
  string *no_project_list = ({"fluffy", "admin", "decrepit", "am_old"});
  string *domains = (master()->query_domains() - no_project_list);
  
  ret += "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<TABLE>"
    "<TR><TH align = \"left\"> Projects: </TH>"
    "<TD>"  
    "<b>[</b> <a href=project.c?projecttype=Add>"
    "Add Project</a> | "    
    "<a href=project.c?projecttype=List>"
    "List Projects</a> | "
    "<a href=project.c?misc=Query> "
    "Query Projects </a> <b>]</b>"
    "<TD>"
    "<TR>"   
    "<TH align = \"left\"> Queries: </TH>"
    "<TD>"
    "<b>[</b> <a href=project.c?misc=Week> "
    "One Week Summary </a> | "
    "<a href=project.c?misc=Playtesting> "
    "Projects in Playtesting</a> <b>]</b>"
    "<TD>"
    "<TR>"
    "<TH align = \"left\"> Domains: </TH>" 
    "<TD> <b>[</b> ";
    
    for (int i = 0; i < sizeof (domains); i++) {      
      ret += "<a href=project.c?misc=Domlist&domain=" + domains[i] + ">"
        + capitalize (domains[i]) + "</a>";
      
      if (i != sizeof (domains) -1) {
        ret += " | ";
      }
      
    }
    
    ret += " <b>]</b></TABLE>"
    "<HR>";

  return ret;
  
}


varargs string get_add_project (mapping tmp) {
  string ret = "";
  
  if (!tmp) {
    tmp = ([ ]);
  }
  ret += "This is the add project page.  Enter the details of the project "
    "you wish to add, and then click 'add' to record them with the system.  "
    "Required fields are Project ID, Project Name and Project Description.  "
    "If you forget to complete any of these fields, you will be prompted "
    "again for details.<p><p>"
    "<hr><p>"
    "<TABLE>";
    
  ret += "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">";

  ret += "<TR>" 
    "<TH align = \"left\"> Project ID: </TH>"
    "<TD><INPUT NAME=\"projid\"";
  
  if (tmp["projid"]) {
    ret += "VALUE = \"" + tmp ["projid"] + "\"";
  }

  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Name: </TH>" 
    "<TD><INPUT NAME=\"name\"";

  if (tmp["name"]) {
    ret += "VALUE = \"" + tmp ["name"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Leader: </TH>" 
    "<TD><INPUT NAME=\"leader\"";

  if (tmp["leader"]) {
    ret += "VALUE = \"" + tmp ["leader"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Domains (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"domains\"";
  
  if (sizeof (arrayp (tmp ["domains"]))) {
    ret += "VALUE = \"" + tmp["domains"] + "\"";
  }
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Estimated Completion: </TH>" 
    "<TD>";
    ret += get_estimate();
    ret += "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Creators (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"creators\"";

  if (sizeof (tmp ["creators"])) {
    ret += "VALUE = \"" + tmp["creators"]  + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Size: </TH><TD>";
       
  ret += "<SELECT NAME=\"size\">";
  
  for (int i = 0; i < sizeof (SIZE); i++) {
    ret += "<OPTION VALUE + \"" + SIZE[i] ;
    if (tmp["size"] == SIZE[i]) {
      ret += "selected ";
    }
  
    ret += "\">" + SIZE[i];
  }
  
  ret += "</SELECT>";

  ret += "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Complexity: </TH><TD>";
       
  ret += "<SELECT NAME=\"complexity\">";
  
  for (int i = 0; i < sizeof (COMPLEXITY); i++) {
    ret += "<OPTION VALUE + \"" + COMPLEXITY[i] ;
    if (tmp["complexity"] == COMPLEXITY[i]) {
      ret += "selected ";
    }
  
    ret += "\">" + COMPLEXITY[i];
  }
  
  ret += "</SELECT>";

    ret += "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Guilds (Of the form 'wizards,thieves', separated by comma, or leave blank): </TH>" 
    "<TD><INPUT NAME=\"guilds\"";

  if (sizeof (tmp ["guilds"])) {
    ret += "VALUE = \"" + tmp["guilds"]  + "\"";
  }      
  
//  if (sizeof (tmp["twiki"])) {
//    foreach (string t in twiki) {
//      PROJECT_HANDLER->add_twiki (data["projid"], t);
//    }
//  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Subproject IDs (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"sub\"";
//  ret += "><TD>"  
//    "<TR>"
//    "<TH align = \"left\"> Project Files (separated by comma): </TH>" 
//    "<TD><INPUT NAME=\"files\"";

//  if (sizeof (tmp ["files"])) {
//    ret += "VALUE = \"" + tmp["files"] + "\"";
//  }
  
  ret += "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Twiki (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"twiki\"";

  if (sizeof (tmp ["twiki"])) {
    ret += "VALUE = \"" + tmp["twiki"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "</TABLE>"
    "<B>Project Description:</B><P>" 
    "<TD><TEXTAREA cols=70 rows=6 wrap=\"virtual\""
      "NAME=\"description\">";
  if (tmp["description"]) {
    ret += tmp ["description"];
  }

  ret += "</TEXTAREA><P>";

  ret += "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Add\">";
  ret += "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";
   
  return ret;
}

varargs string get_add_task (mapping tmp, string project) {
  string ret = "";
  
  if (!tmp) {
    tmp = ([ ]);
  }
  ret += "This is the add task page.  Enter the details of the task "
    "you wish to add, and then click 'add' to record them with the system.  "
    "Required fields are task ID, and task Name. you will be prompted "
    "again for details.<p><p>"
    "<hr><p>"
    "<TABLE>";

      
  ret += "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">";

 ret += "<TR>" 
    "<TH align = \"left\"> Project ID: </TH>"
    "<TD><INPUT NAME=\"projid\"";
  
  if (project) {
    ret += "VALUE = \"" + project + "\"";
  }
  ret += "<TD>"
    "<TR>" 
    "<TH align = \"left\"> Task ID: </TH>"
    "<TD><INPUT NAME=\"tid\"";
  
  if (tmp["tid"]) {
    ret += "VALUE = \"" + tmp ["tid"] + "\"";
  }

  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Task Name: </TH>" 
    "<TD><INPUT NAME=\"taskname\"";

  if (tmp["taskname"]) {
    ret += "VALUE = \"" + tmp ["taskname"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Comments: </TH>" 
    "<TD><INPUT NAME=\"comments\"";

  if (tmp["comments"]) {
    ret += "VALUE = \"" + tmp ["comments"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Task Creators (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"creators\"";

  if (sizeof (tmp ["creators"])) {
    ret += "VALUE = \"" + tmp["creators"]  + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Percent Completed: </TH>" 
    "<TD><INPUT NAME=\"completed\"";

  if (tmp["completed"]) {
    ret += "VALUE = \"" + tmp ["completed"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Estimated completion: </TH>" 
    "<TD>" + get_estimate();    
  ret += "<TD>"  
    "<TR>"
    "</TABLE>"
  "<B>Task aims:</B><P>" 
    "<TD><TEXTAREA rows=6 cols=70 wrap=\"virtual\""
      "NAME=\"aims\">";
  if (tmp["aims"]) {
    ret += tmp ["aims"];
  }
  ret += "</TEXTAREA><P>"  
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Add Task\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";
   
  return ret;
}


varargs string get_add_note (mapping tmp, string project) {
  string ret = "";
  
  if (!tmp) {
    tmp = ([ ]);
  }
  ret += "This is the add note page.  Enter the details of the note "
    "you wish to add, and then click 'add' to record them with the system.  "
    "Required fields are note ID, and the note itself. you will be prompted "
    "again for details.<p><p>"
    "<hr><p>"
    "<TABLE>";
    
  ret += "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">";

  ret += "<TR>" 
    "<TH align = \"left\"> Project ID: </TH>"
    "<TD><INPUT NAME=\"projid\"";
  
  if (project) {
    ret += "VALUE = \"" + project + "\"";
  }

  ret += "><TD>"  
    "<TR>" 
    "<TH align = \"left\"> Note ID: </TH>"
    "<TD><INPUT NAME=\"nid\"";
  
  if (tmp["nid"]) {
    ret += "VALUE = \"" + tmp ["nid"] + "\"";
  }

  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Note: </TH>" 
    "<TD><TEXTAREA NAME=\"note\" rows=6 cols=70"
    " wrap=virtual>" + (tmp["note"] ? tmp ["note"] : 
    "") + "</TEXTAREA>"  
    "<TD>"
    "</TABLE>"
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Add Note\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";
   
  return ret;
}

varargs string get_add_file (mapping tmp, string project) {
  string ret = "";
  string *tasks = ({ });
  class project proj;
  
  proj = PROJECT_HANDLER->get_project_file (project);
  
  foreach (class task t in proj->tasks) {
    tasks += ({ t->id });    
  }
  
  
  if (!tmp) {
    tmp = ([ ]);
  }
   ret+= "<TABLE>"
    "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<TR>" 
    "<TH align = \"left\"> Project ID: </TH>"
    "<TD><INPUT NAME=\"projid\"";
  
  if (project) {
    ret += "VALUE = \"" + project + "\"";
  }

  ret += "><TD>"  
    "<TR>" 
    "<TH align = \"left\"> Filename: </TH>"
    "<TD><INPUT NAME=\"fid\"";
  
  if (tmp["fid"]) {
    ret += "VALUE = \"" + tmp ["fid"] + "\"";
  }

  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Access: </TH>" 
    "<TD>"
    "<SELECT NAME=\"access\">";
    
    foreach (string a in ({"read", "read+write", "read+write+grant"}))  {   
      ret += "<OPTION  \"" + a + "\">"+ a;
    }
    
  ret += "</SELECT>"   
    "<TD>"  
    "<TR>" 
    "<TH align = \"left\"> Access Rights: </TH>"
    "<TD>"
    "<SELECT NAME=\"task\">";
    
    foreach (string a in ({"All project members", "Leader only"}) +
      tasks)  {   
      ret += "<OPTION  \"" + a + "\"" + (tmp["task"] == a ? 
      "selected" : "") + ">"+ a;
    }
    
  ret += "</SELECT>"   
     "</TABLE>"
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Add File\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";

  return ret;
}

varargs string get_modify_project (string id, string swit, string id_two, 
  int lead) {
  string ret = ""; 
  
  class project tmp = PROJECT_HANDLER->get_project_file (id);
  
  
  if (!tmp) {
    return "";    
  }
  
  
  ret += "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<B>Project " + id + ": </B><b>[</b><a href=project.c?pid=" 
    + id + "&projecttype=Delete>"
    "Delete This Project</a> | "
    "<a href=project.c?pid=" 
    + id + "&projecttype=Details>"
    "Project Details</a> <b>]</b>"
    "<P><B>" + PROJECT_HANDLER->query_touched (tmp->id) + "</B></P>"
    "<HR><TABLE><TR>" 
    "<TH align = \"left\"> Project ID: </TH>"
    "<TD><INPUT NAME=\"projid\""
    "VALUE = \"" + tmp->id + "\""  
    "><TD>"
    "<TR>"
    "<TH align = \"left\"> Project Name: </TH>" 
    "<TD><INPUT NAME=\"name\""
    "VALUE = \"" + tmp->name + "\""    
    "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Leader: </TH>" 
    "<TD><INPUT NAME=\"leader\""
    "VALUE = \"" + tmp->leader + "\""  
    "><TD>"  
    "<B> This project was added by " + tmp->added_by +"</B>"     
    "<TR>"
    "<TH align = \"left\"> Project Domains (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"domains\""
    "VALUE = \"" + implode (tmp->domains, ",") + "\""
    "><TD>"  
    "<B> Added: " + ctime (tmp->date_added) +"</B>"     
    "<TD>"
    "<TR>"
    "<TH align = \"left\"> Project Creators (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"creators\""
    "VALUE = \"" + implode (tmp->creators, ",") 
    + "\"><TD>"
    "<TR>"
    "<TH align = \"left\"> Project Playtesters (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"playtesters\"";
    if (tmp->playtesters) {
      ret += "VALUE = \"" + implode (tmp->playtesters, ",");
    }
    ret += "\">";

    ret += "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Size: </TH><TD>";
       
    ret += "<SELECT NAME=\"size\">";
  
    for (int i = 0; i < sizeof (SIZE); i++) {
      ret += "<OPTION VALUE + \"" + SIZE[i] ;
      if (tmp->size  == i) {     
        ret += " selected ";
      }
  
      ret += "\">" + SIZE[i];
  }

    ret += "</SELECT>";     
    ret += "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Complexity: </TH><TD>";
       
    ret += "<SELECT NAME=\"complexity\">";
  
    for (int i = 0; i < sizeof (COMPLEXITY); i++) {
      ret += "<OPTION VALUE + \"" + COMPLEXITY[i] ;
      if (tmp->complexity  == i) {
        ret += " selected ";
      }
  
      ret += "\">" + COMPLEXITY[i];
  }
  
  ret += "</SELECT>"    
    "<TD>"
    "<TR>"
    "<TH align = \"left\"> Guilds (Of the form 'wizards,thieves', separated by comma, "
      "or leave blank): </TH>" 
    "<TD><INPUT NAME=\"guilds\"";
    if (tmp->guild_specific) {
      ret += "VALUE = \"" + implode (tmp->guild_specific, ",");
    }
    ret += "\">";    
    ret += "<TD><TR>"
    "<TH align = \"left\"> Percent complete: </TH>" 
    "<TD><INPUT NAME=\"completed\"";
    if (tmp->percent_complete) {
      ret += "VALUE = \"" + tmp->percent_complete;
    }
    ret += "\"><TD><TR>";     
    if (tmp->estimated_completion) {
      ret += "<B> Estimated Completion: " + ctime 
        (tmp->estimated_completion) + "</B>";
    } 
   
    
    ret += "<TR>"
    "<TH align = \"left\"> Subproject IDs (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"sub\"";    
    if (sizeof (tmp->sub_projects)) {
        ret += "VALUE = \"" + implode (tmp->sub_projects, ",") + "\"";
    }
  
    ret += "><TD>"   
    "<TR>"
    "<TH align = \"left\"> Project Twiki (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"twiki\"";    
    if (sizeof (tmp->twiki)) {
        ret += "VALUE = \"" + implode (tmp->twiki, ",") + "\"";
    }
      
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Update Estimate: </TH>" 
    "<TD>";
    ret += get_estimate();
    ret += "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Status: </TH>" 
    "<TD><SELECT NAME=\"status\">";
    
    foreach (string stat in STATUS)  {   
      ret += "<OPTION  \"" + stat+ "\"";
    
      if (stat == STATUS[tmp->status]) {
        ret += " selected "; 
      }
      
      ret += ">" + stat;
    }      
  ret += "</SELECT>"
    "</TABLE>"
    
    "<B>Project Description:</B><P>"
    "<TEXTAREA NAME=\"description\" rows=6 cols=70 "
    "wrap=\"virtual\">" + tmp->description+ "</TEXTAREA><P>"    
    "<B>Notes for Playtesters:</B><P>"
    "<TEXTAREA NAME=\"ptnotes\" rows=6 cols=70 "
    "wrap=\"virtual\">" + tmp->pt_notes + "</TEXTAREA><P>"
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Update\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\">";    

    
  if (swit) {
    switch (swit) {
      case "task":
        ret += get_modify_task(id, id_two);
      break;
      case "note":
        ret += get_modify_note(id, id_two);
      break;
      case "file":
        ret += get_modify_file (id, id_two, lead);
    }
    
  }
    
  ret += get_tasks_summary (id);
  ret += get_notes_summary (id);
  ret += get_files_summary (id);

  
  return ret;
  
}

varargs string get_modify_task (string id, string task) {
  string ret = "";  
  class task tmp;

  tmp  = PROJECT_HANDLER->get_task_file (id, task);
  
  ret += get_view_project (id, 0);
  
  ret += "<HR><TABLE>";  
  
  if (!tmp) {
    return "";    
  }
  
  ret += 
    "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<B>Task " + id + ": </B><b>[</b><a href=project.c?pid=" + id 
    + "&tasktype=Delete&tid=" + task + ">"
    "Delete This Task</a> <b>]</b> <p>"    
    "<TABLE>"
    "<TH align = \"left\"> Project ID: </TH>" 
    "<TD><INPUT NAME=\"projid\""
    "VALUE = \"" + id + "\""    
    "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Task ID: </TH>" 
    "<TD><INPUT NAME=\"tid\""
    "VALUE = \"" + tmp->id + "\""    
    "><TD>"  
    "<B>This task was added by " + tmp->added_by + "</B>"
    "<TR>"
    "<TH align = \"left\"> Task Name: </TH>" 
    "<TD><INPUT NAME=\"taskname\""
    "VALUE = \"" + tmp->task_name + "\""    
    "><TD>"  
    "<B>Added: " + ctime (tmp->date_added) + " </B>"
    "<TR>"
    "<TH align = \"left\"> Comments: </TH>" 
    "<TD><INPUT NAME=\"comments\""
    "VALUE = \"" + tmp->comments+ "\""  
    "><TD>";  
    if (tmp->completion_date) {
    ret += "<B>Estimated Completion: " + ctime (tmp->completion_date) 
      + "</B>";
    }
    ret += "<TR><TH align = \"left\"> Project creators (separated by "
    "comma): "
    "</TH>" 
    "<TD>"
    "<INPUT NAME=\"assigned\"";
    if (sizeof (tmp->assigned_to)) {      
      ret += "VALUE = \"" + implode (tmp->assigned_to, ",") + "\"";  
    }
    ret += "><TD><TR>"
      "<TH align = \"left\"> Percent Complete: </TH>" 
      "<TD><INPUT NAME=\"completed\""
      "VALUE = \"" + tmp->percent_complete+ "\""  
      "><TD>"  
      "<TR>"
      "<TH align = \"left\"> Estimated Completion date: </TH>"
      "<TD>";
    ret += get_estimate();
    ret += "<TD>"  
      "<TR>"
      "</TABLE>"
      "<B>Task Aims:</B><P>"
      "<TEXTAREA NAME=\"aims\" rows=6 cols=70 "
      "wrap=\"virtual\">" + tmp->aims+ "</TEXTAREA><P>"  
      "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Update Task\">"
      "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";  
  return ret;
}


varargs string get_modify_file (string id, string file, string task) {
  string ret = "";  
  class file tmp;

  
  tmp  = PROJECT_HANDLER->get_file (id, file, task);
  
  ret += get_view_project (id, 0);
  
  ret += "<HR><TABLE>";  
  
  if (!tmp) {
    return "";    
  }
  ret += 
    "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<B>File " + file + ": </B><b>[</b> <a href=project.c?pid=" + id 
    + "&filetype=Delete&fid=" + file+ "&task=" + task+ ">"
    "Delete This Permission</a> <b>]</b><p>"    
    "<TABLE width=100%>"
    "<TR>"
    "<TH align = \"left\"> Project ID: </TH>" 
    "<TD width=50%><INPUT NAME=\"projid\""
    "VALUE = \"" + id + "\""    
    "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Filename: </TH>" 
    "<TD width=50%><INPUT NAME=\"file\""
    "VALUE = \"" + file + "\""    
    "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Access: </TH>" 
    "<TD>"
    "<SELECT NAME=\"access\">";
    
    foreach (string a in ({"read", "write", "grant"}))  {   
      ret += "<OPTION  \"" + a + "\">"+ a;
    }
    
    ret += "</SELECT>"   
    "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Leader Only: </TH>" 
    "<TD>"
    "<SELECT NAME=\"lead\">";
    
    foreach (string a in ({"yes", "no"}))  {   
      ret += "<OPTION  \"" + a + "\">" + a;
    }
    ret += "</SELECT>"
      "</TABLE>"
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Update File\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";

  return ret;
}

varargs string get_modify_note (string id, string note) {
  string ret = "";  
  class note tmp;

  
  tmp  = PROJECT_HANDLER->get_note_file (id, note);
  
  ret += get_view_project (id, 0);
  
  ret += "<HR><TABLE>";  
  
  if (!tmp) {
    return "";    
  }
  ret += 
    "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">"
    "<B>Note " + note + ": </B><b>[</b> <a href=project.c?pid=" + id 
    + "&notetype=Delete&nid=" + note + ">"
    "Delete This Note</a> <b>]</b><p>"    
    "<TABLE width=100%>"
    "<TR>"
    "<TH align = \"left\"> Project ID: </TH>" 
    "<TD width=50%><INPUT NAME=\"projid\""
    "VALUE = \"" + id + "\""    
    "><TD>"
    "<B>This note was added by " + tmp->added_by + "</B><BR>"
    "<TR>"    
    "<TH align = \"left\"> Note ID: </TH>" 
    "<TD><INPUT NAME=\"nid\""
    "VALUE = \"" + tmp->id + "\""    
    "><TD>"
    "<B>Added: " + ctime (tmp->date_added) + "</B>"      
    "</TABLE>"
    "<TEXTAREA NAME=\"note\" ROWS=6 COLS=70 "
    " wrap=virtual>" + tmp->note + "</TEXTAREA><P>"    
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Update Note\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";
  
  return ret;
}

varargs string get_view_note (string id, string note) {
  string ret = "";  
  class note tmp;

  ret += get_view_project (id, 0);  
  
  tmp  = PROJECT_HANDLER->get_note_file (id, note);
  
  
  if (!tmp) {
    return "";    
  }
    
  ret += "<HR>"
      "<B>Note " + note + ": </b><a href=project.c?nid=" + tmp->id + 
      "&notetype=Edit&pid=" 
      + id + ">Edit Note</a><P> "
    "<TABLE width=100%>"
    "<TR>"
    "<TH width=30% align = \"left\"> Note ID: </TH>" 
    "<TD>" + tmp->id + "<TD>"  
    "<TR>"
    "<TH align = \"left\"> Added by: </TH>" 
    "<TD>" + capitalize (tmp->added_by) + " at " + ctime (tmp->date_added) 
      + "<TD>"  
    "<TR>"
    "<TH valign = \"top\" align = \"left\"> Note: </TH>" 
    "<TD>" + replace (tmp->note, ({"\n\n", "<p>", "\n", "<br>"})) + "<TD>"  
    "<TR>"


    "</TABLE>";

  return ret;
}

varargs string get_query_project (mapping tmp) {
  string ret = "<TABLE>";
  
  if (!tmp) {
    tmp = ([ ]);
  }
  
  ret += "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">";

  ret += "<TR>" 
    "<TH align = \"left\"> Project Domains (separated by comma): </TH>"
    "<TD><INPUT NAME=\"domains\"";
  
  if (tmp["domains"]) {
    ret += "VALUE = \"" + tmp ["creators"] + "\"";
  }

  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Creators (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"creators\"";

  if (tmp["creators"]) {
    ret += "VALUE = \"" + tmp ["creators"] + "\"";
  }
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Playtesters (separated by comma): </TH>" 
    "<TD><INPUT NAME=\"playtesters\"";

  if (tmp["playtesters"]) {
    ret += "VALUE = \"" + tmp ["playtesters"] + "\"";
  }  

  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Minimum completeness: </TH>" 
    "<TD><INPUT NAME=\"completeness\"";

  if (tmp["completeness"]) {
    ret += "VALUE = \"" + tmp ["completeness"] + "\"";
  }
    
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Leader: </TH>" 
    "<TD><INPUT NAME=\"leader\"";

  if (tmp["leader"]) {
    ret += "VALUE = \"" + tmp ["leader"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Project Status: </TH>" 
    "<TD><SELECT NAME=\"status\">";
    
    foreach (string stat in STATUS)  {   
      ret += "<OPTION  \"" + stat+ "\">" + stat;
    }

  ret += "<OPTION  \"all\" selected> all"  
    "</SELECT>"
    "<TR><TH align = \"left\"> Last touched: </TH>" 
    "<TD>" + get_estimate(1) + "<TD><TR>";

  if (tmp["leader"]) {
    ret += "VALUE = \"" + tmp ["leader"] + "\"";
  }

  ret +="</TABLE>"
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Query\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";

  return ret;
}

varargs string get_query_task (mapping tmp) {
  string ret = "<TABLE>";
  
  if (!tmp) {
    tmp = ([ ]);
  }
  
  ret += "<form action=\"project.c\" METHOD=POST "
    "action=\"project.c?\">";

  ret += "<TR>" 
    "<TH align = \"left\"> Task Creators (separated by comma): </TH>"
    "<TD><INPUT NAME=\"creators\"";
  
  if (tmp["creators"]) {
    ret += "VALUE = \"" + tmp ["creators"] + "\"";
  }

  ret += "><TD>"  
    "<TR>"
    "<TH align = \"left\"> Percent Completed: </TH>" 
    "<TD><INPUT NAME=\"completed\"";

  if (tmp["completed"]) {
    ret += "VALUE = \"" + tmp ["completed"] + "\"";
  }
  
  ret += "><TD>"  
    "<TR>"
    "</TABLE>"
    "<INPUT TYPE=\"submit\" NAME = \"button\" VALUE=\"Query\">"
    "<INPUT TYPE=\"reset\" VALUE=\"Reset\"><p>";

  return ret;
}



void create() {
  seteuid (geteuid());
}

  
string get_header(string title) {
  string ret = "";
  
  ret += "<html><head><title> Project Management 0.7a</title>";
  ret += "<meta http-equiv=\"Content-Type\" content=\"text/html; "
    "charset=iso-8859-1\"><meta http-equiv=\"Cache-Control\" "
     "content=\"expires=-1\"/></head><body bgcolor=\"#ffffff\" "
    "text=\"#000030\" link=\"#4a529c\" vlink=\"#b57339\">"
    "<table width=\"75%\" border=\"0\"><tr VALIGN=TOP>";
  ret += "<td><font face=\"arial,helvetica\"><img align=left "
    "src = \"http://discworld.imaginary.com/external//pics/dw4.gif\">"
    "</font></td>"
    "<td><font face=\"arial,helvetica\">" 
    "<h2>Project Management 0.7a</h2>";
  ret += "</font>"
    "<p><font face=\"arial,helvetica\"><h2>" + title + "</h2>"
    "</p>"
    "<a href=project.c?misc=instructions>Instructions</a>"
    "<br>"
    "<a href=../../secure>Back to the secure pages</a>"
    "</td></tr></table>";
  ret += get_project_menu();
  
  return ret;
}

/**
 *  This function requests the standard footer for the Discworld
 *  web-pages.
 *  @return string  The HTML code for the footer.
 *
 */
 
string get_footer() {
    return "/www/footer"->www_function("footer", ([ ])) +"</body></html>";
}

string get_web_page (string text, string title) {
  return get_header (title) + text + get_footer();
}


string get_instructions(string category) {
  string ret = "";
  

  ret += "<h2>Index Of Help</h2>"
    "<a href=project.c?misc=instructions&cat=access>Access "
        "Rights</a><br>" 
    "<a href=project.c?misc=instructions&cat=addnote>Adding a note</a><br>"        
    "<a href=project.c?misc=instructions&cat=addproject>Adding a project"
      "</a><br>"
    "<a href=project.c?misc=instructions&cat=addtask>Adding a task</a><br>"
    "<a href=project.c?misc=instructions&cat=domainstuff>Master object "
      "modifications</a><br>"
    "<a href=project.c?misc=instructions&cat=modnote>Modifying a note"
      "</a><br>"      
    "<a href=project.c?misc=instructions&cat=modproject>Modifying a "
      "project</a><br>"      
    "<a href=project.c?misc=instructions&cat=modtask>Modifying a "
      "task</a><br>"      
    "<a href=project.c?misc=instructions&cat=queryprojects>Querying the "
      "database</a><p>";
        
  switch (category){ 
    case "access":
      ret += "<h2>Access Rights</h2>"
      "The access rights for the system are as default:<p>"
      "<ol>"
      "<li>Highlords have full write to all data within the system."
      "<li>Everyone can read everything in the system."
      "<li>The lord and deputy of the playtesters domain can modify "
        "playtester assignments in any domain."
      "<li>Domain lords can assign playtesters to projects within their "
        "domains."
      "<li>Domain lords and deputies can add, delete and edit all projects, "
        "notes and tasks within their domain."       
      "<li>Project leaders can delete and modify the projects they are "
        "leading, and can add, delete and edit tasks and notes for the "
        "projects they are actively coding for."
      "<li>Project creators can add, delete and modify tasks and notes "
        "for the projects they are assigned to."
      "</ol>"
      "Domain lords can override 4, 5, 6 and 7 by modifying their master "
      "objects to over-ride the defaults.  See 'master object "
      "modifications' for more details.<p>";
    break;
    case "domainstuff":
      ret += "<h2>Domain stuff</h2>"
        "You can use the features of the project tracker within your "
        "own domain.  The simplest way to make use of it is to use "
        "the $project$ string in your creator's projects.  This will "
        "be expanded to their list of projects are returned from the "
        "tracker.<p>"
        "You can also over-ride the default functionality of the "
        "security restrictions by defining a function in your "
        "domain object called project_callback:<p>"
        "<pre>"
        "int project_callback (string name, string action, string project) {"
        "<br>  if (name == LORD) {"
        "<br>     return 1;"
        "<br>  }"
        "<br>  return 0;"
        "<br>}"
        "<br></pre>"
        "<p>This is an extreme example, of course, and restricts it so "
        "only the lord of the domain is allowed to modify any aspect "
        "of any project within the domain.<p>"
        "<b>Name</b> is the name of the creator making a change to the "
        "database.<br>"
        "<b>Action</b> is the action being performed, one of 'project', "
        "'task', 'note' or 'playtesting'<br>"
        "<b>Project</b> is the project being modified.<p>"
        "The function should return 1 if the action is allowed, 0 if it "
        "is not, and -1 if the defaults should be used.<p>";              
    break;
    case "addproject":
      ret += "<h2>Adding a Project</h2>"
      "First, click on 'add a project'.  This will bring up a form "
      "containing the information you need to enter into the system. "
      "Enter each of these pieces of information in turn as required.  "
      "You will need to enter at least a project ID, a project name, "
      "and at least one domain for the project.<p>"
      "<b>Project ID</b>:  This is the unique code for the project that "
      "identifies it in the database.  If you put mutliple words in "
      "this field, it will concatonate them into 'twiki notation'... "
      "so 'project tracker' becomes ProjectTracker.<p>"
      "<b>Project Name</b>: This is a descriptive name for the project.  "
      "This differs from the project ID in that the project ID is used "
      "internally within the tracker, whereas the name is used "
      "externally, for example in domain finger info and the list of "
      "projects in playtesting.<p>"
      "<b>Project Leader</b>: The leader for the project.  Project leaders "
      "have full access over the project in the tracker, and can update the "
      "project file, and add tasks and notes as required.  See " 
      "<a href=project.c?misc=instructions&cat=access>Access Rights</a> "
      "for more information on how access rights work.<p>"
      "<b>Project Domains</b>: The domains the project belongs to.  You "
      "must be a HL or the lord of at least one of the domains to add "
      "a project to the tracker.<p>"
      "<b>Estimated Completion</b>: The rough estimate of how long it "
      "will take to complete the project.  If you wish to have this "
      "estimate recorded with the system, check the 'update' checkbox.  "
      "If you do not, it will ignore any estimate you place into the "
      "system.<p>"
      "<b>Project Creators</b>: The creator assigned to the project.  "
      "These do not actually have to be members of the domain to "
      "be assigned, but if they are not they will not have their "
      "project displaying in their finger info.<p>"
      "<b>Subproject IDs</b>: The larger projects that form part of "
      "the main project.  While these stand as projects in themselves, "
      "their state of completion reflects on that of the main project.  "
      "The percentage of a project's completion will be modified by "
      "how complete any sub projects are.<p>"
      "<b>Project Files</b>: Any relevant files related to the project.<p>"
      "<b>Project Twiki</b>: Any relevant twiki pages for the project.  "
      "If you simply enter a twiki name (such as ProjectTracker) it will "
      "assume the twiki page may be found on the project's first domain.  "
      "So if you have a project belonging to Forn and Main, it will "
      "assume you mean Forn.ProjectTracker.  If you wish to direct the "
      "link to a particular twiki page, you will need to give the web, then "
      "the page... so Main.ProjectTracker.<p>"
      "<b>Description</b>: The description of what the project actually "
      "involves.<p>"
      "Once you've entered all the information you have, click 'add' to "
      "add the project to the database.  If you have left anything out "
      "or do not have authority to add projects, you will find yourself "
      "back at the add project page.<p>";
    break;
    case "addtask":
      ret += "<h2>Adding a Task</h2>"
      "First, click on the 'add new task' link in the project details.  "
      "page.  This will bring up a form "
      "containing the information you need to enter into the system. "
      "Enter each of these pieces of information in turn as required.  "
      "You will need to enter at least a project ID, a task ID, "
      "and a task ID.<p>"
      "<b>Project ID</b>:  This is the project that the task "
      "belongs to.<p>"      
      "<b>Task ID</b>:  This is the unique code for the task that "
      "identifies it in the database.  If you put mutliple words in "
      "this field, it will concatonate them into 'twiki notation'... "
      "so 'project tracker' becomes ProjectTracker.<p>"
      "<b>Task Name</b>: This is a descriptive name for the task."
      "<b>Comments</b>: Any points of note about this task, such as "
      "'everyone who ever worked on this project has died in a "
      "freak accident involving baby dolphins'.<p>"
      "<b>Task Creators</b>: The creators assigned to the task.  "
      "These do not actually have to be members of the project to "
      "be assigned.<p>"
      "<b>Percent complete</b>: How much of the task has been "
      "completed.<p>"
      "<b>Estimated completion</b>: The rough estimate of how long it "
      "will take to complete the project.  If you wish to have this "
      "estimate recorded with the system, check the 'update' checkbox.  "
      "If you do not, it will ignore any estimate you place into the "
      "system.<p>"
      "<b>Task aims</b>: What is the task concerned with.<p>"
      "Once you've entered all the information you have, click 'add' to "
      "add the task to the the project.  If you have left anything out "
      "or do not have authority to add tasks, you will find yourself "
      "back at the add tasks page.<p>";
    break;
    case "addnote":
      ret += "<h2>Adding a Note</h2>"
      "First, click on the 'add new note' link in the project details.  "
      "page.  This will bring up a form "
      "containing the information you need to enter into the system. "
      "Enter each of these pieces of information in turn as required.  "
      "You will need to enter at least a project ID, a note ID, "
      "and a note.<p>"
      "<b>Project ID</b>:  This is the project that the task "
      "belongs to.<p>"      
      "<b>Note ID</b>:  This is the unique code for the note that "
      "identifies it in the database.  If you put mutliple words in "
      "this field, it will concatonate them into 'twiki notation'... "
      "so 'project tracker' becomes ProjectTracker.<p>"
      "<b>Note</b>: The note itself.<p>";
    break;    
    case "modnote":
      ret += "<h2>Modifying a Note</h2>"
      "First, click on the 'edit note' for the note in the project "
      "details.  page.  This will bring up a form "
      "containing the information you need to enter into the system. "
      "Enter each of these pieces of information in turn as required.  "
      "You will need to enter at least a project ID, a note ID, "
      "and a note.<p>"
      "<b>Project ID</b>:  This is the project that the task "
      "belongs to.<p>"      
      "<b>Note ID</b>:  This is the unique code for the note that "
      "identifies it in the database.  If you put mutliple words in "
      "this field, it will concatonate them into 'twiki notation'... "
      "so 'project tracker' becomes ProjectTracker.<p>"
      "<b>Note</b>: The note itself.<p>";
    break;        
    case "modtask":
      ret += "<h2>Modifying a Task</h2>"
      "First, click on the 'edit' link for the task in the project "
      "details.  page.  This will bring up a form "
      "containing the information you need to enter into the system. "
      "Enter each of these pieces of information in turn as required.  "
      "You will need to enter at least a project ID, a task ID, "
      "and a task ID.<p>"
      "<b>Project ID</b>:  This is the project that the task "
      "belongs to.<p>"      
      "<b>Task ID</b>:  This is the unique code for the task that "
      "identifies it in the database.  If you put mutliple words in "
      "this field, it will concatonate them into 'twiki notation'... "
      "so 'project tracker' becomes ProjectTracker.<p>"
      "<b>Task Name</b>: This is a descriptive name for the task."
      "<b>Comments</b>: Any points of note about this task, such as "
      "'everyone who ever worked on this project has died in a "
      "freak accident involving baby dolphins'.<p>"
      "<b>Task Creators</b>: The creators assigned to the task.  "
      "These do not actually have to be members of the project to "
      "be assigned.<p>"
      "<b>Percent complete</b>: How much of the task has been "
      "completed.<p>"
      "<b>Estimated completion</b>: The rough estimate of how long it "
      "will take to complete the project.  If you wish to have this "
      "estimate recorded with the system, check the 'update' checkbox.  "
      "If you do not, it will ignore any estimate you place into the "
      "system.<p>"
      "<b>Task aims</b>: What is the task concerned with.<p>"
      "Once you've entered all the information you have, click 'add' to "
      "add the task to the the project.  If you have left anything out "
      "or do not have authority to add tasks, you will find yourself "
      "back at the add tasks page.<p>";
    break;    
    case "modproject":
      ret += "<h2>Modifying a Project</h2>"
      "First, click on the 'edit' link for the project.  This will bring up "
      "a form containing the information you need to enter into the system. "
      "Enter each of these pieces of information in turn as required.  "
      "You will need to enter at least a project ID, a task ID, "
      "and a task ID.<p>"
      "<b>Project ID</b>:  This is the unique code for the project that "
      "identifies it in the database.  If you put mutliple words in "
      "this field, it will concatonate them into 'twiki notation'... "
      "so 'project tracker' becomes ProjectTracker.<p>"
      "<b>Project Name</b>: This is a descriptive name for the project.  "
      "This differs from the project ID in that the project ID is used "
      "internally within the tracker, whereas the name is used "
      "externally, for example in domain finger info and the list of "
      "projects in playtesting.<p>"
      "<b>Project Leader</b>: The leader for the project.  Project leaders "
      "have full access over the project in the tracker, and can update the "
      "project file, and add tasks and notes as required.  See " 
      "<a href=project.c?misc=instructions&cat=access>Access Rights</a> "
      "for more information on how access rights work.<p>"
      "<b>Project Domains</b>: The domains the project belongs to.  You "
      "must be a HL or the lord of at least one of the domains to add "
      "a project to the tracker.<p>"
      "<b>Project Creators</b>: The creator assigned to the project.  "
      "These do not actually have to be members of the domain to "
      "be assigned, but if they are not they will not have their "
      "project displaying in their finger info.<p>"
      "<b>Project Playtesters</b>: The playtesters who are assigned "
      "to this project.  The lord of the domain and the lord or "
      "deputies of the playtesting domain can modify this field.<p>"
      "<b>Project Completeness</b>: How complete the project is.  If "
      "you set a value for this, it will over-ride the automatic "
      "calculation used.  If you leave this blank, the project "
      "completeness will be calculated by adding together the completess "
      "of all tasks and subprojects.  For projects that do not have either, "
      "the value will need to be updated manually.<p>"
      "<b>Subproject IDs</b>: The larger projects that form part of "
      "the main project.  While these stand as projects in themselves, "
      "their state of completion reflects on that of the main project.  "
      "The percentage of a project's completion will be modified by "
      "how complete any sub projects are.<p>"
      "<b>Project Files</b>: Any relevant files related to the project.<p>"
      "<b>Project Twiki</b>: Any relevant twiki pages for the project.  "
      "If you simply enter a twiki name (such as ProjectTracker) it will "
      "assume the twiki page may be found on the project's first domain.  "
      "So if you have a project belonging to Forn and Main, it will "
      "assume you mean Forn.ProjectTracker.  If you wish to direct the "
      "link to a particular twiki page, you will need to give the web, then "
      "the page... so Main.ProjectTracker.<p>"
      "<b>Update estimate</b>: The rough estimate of how long it "
      "will take to complete the project.  If you wish to have this "
      "estimate recorded with the system, check the 'update' checkbox.  "
      "If you do not, it will ignore any estimate you place into the "
      "system.<p>"
      "<b>Project status</b>: The status of the project.  Heap refers "
      "to a project that is still conceptual.  Development is a project "
      "that is actively being coded.  Playtesting is a project that has "
      "been approved for playtesting and is undergoing revisions.  "
      "Play is a project that has been put into the game.  Limbo is "
      "for projects that fall somewhere between these stages... mainly "
      "projects that are no longer conceptual, but are not under active "
      "development.<p>"
      "<b>Description</b>: The description of what the project actually "
      "involves.<p>"
      "Once you've entered all the information you have, click 'update' to "
      "modify the project in the database.  If you have left anything out "
      "or do not have authority to add projects, you will find yourself "
      "back at the modify project page.<p>";
    break;    
    case "queryprojects":
      ret += "<h2>Querying projects</h2>"
      "First, click on the 'query projects' link.  This will bring up "
      "a form containing the information you need to enter into the system. "
      "Enter each of these pieces of information in turn as required.  If "
      "you do not enter anything, you will simply get the list of all "
      "projects in the system (the same one you get by clicking "
      "'list projects').<p>"
      "<b>Project Domains</b>: The domains the project belongs to. This is "
      "an AND search... if you enter two domains here, it will look for "
      "projects that belong to domain A and domain B.<p>"
      "<b>Project creators</b>: The creators assigned to the project. "
      "This is an AND search... if you enter two creators here, it will "
      "look for projects that are assigned to creator A and creator B.<p>"
      "<b>Project playtesters</b>: The playtesters assigned to the project. "
      "This is an AND search... if you enter two PTs here, it will "
      "look for projects that are assigned to PT A and PT B.<p>"
      "<b>Minimum completeness</b>: Match projects only that have at "
      "least this level of completeness.  So if you want only projects "
      "that are at least half completed, you would search for 50.<p>"
      "<b>Project leader</b>: Search for the projects that this creator "
      "is a leader of.<p>"
      "<b>Project status</b>: Search for projects that have a specific "
      "status.  'all' will match all projects, regardless of status.<p>"
      "<b>Last touched</b>: Return only projects that have been touched "
      "in the specified amount of time.<p>"
      "These queries are cumulative, so if you enter 'drakkos' in the "
      "creator box, and 'forn' in the domain box, you will get all the "
      "projects in the forn domain that have drakkos as a creator, and "
      "so forth.<p>";   
    break;        
    default:
      ret += "This is the creator project management system for "
      "the Discworld MUD.<p>  "
      "The interface is hopefully fairly intuitive.  The top row of links "
      "are project options.  You can add a project if you have the authority "
      "to do so, list all the projects in the database, or list projects "
      "according to whatever information you are looking for.<p>"
      "The next row of links are the domains covered by the project tracker.  "
      "Click on a domain to get the project list for that domain only.<p>"
      "When you see a project you are interested in, click on 'details' for "
      "the project details and a list of any tasks/notes assosciated with "
      "that project.  Click on edit if you wish to alter the details for that "
      "project.  If you wish to delete a project, you must first click on "
      "edit and then the delete link from there.  That may seem awkwardly "
      "obscure, but it's intentional in that you have to follow a process to "
      "delete an entry from the database, rather than being able to do it "
      "with a misplaced click.<p>"  
      "<h2>Thx bye!</h2>"
      "The system as, at the moment, still undergoing adjustments and "
      "modifications.  If you have any feedback on the interface or requests "
      "for further functionality, mail Drakkos with your suggestions.<p>"
      "Thx bye, flyheads!<p>";      
  }
  
    
  return ret;
}

string www_request (string name, mapping args, class http_request request) {
  
  mapping data = request->body->data;
  class project *tmp;
  string ret = "";
  int i;

  if (request->user != "drakkos") {
    tell_creator ("drakkos", "%s: %d.\n", request->user, sizeof (data));
  }
    
  switch (args["tasktype"]) {
    case "Details":
      ret = get_view_page (get_view_task (args["pid"], args["tid"]),
        args["pid"], "Task Details");
    break;   
    case "Delete":
      if (PROJECT_HANDLER->valid_operation (request->user, TASK, 
        args["pid"])) {      
        PROJECT_HANDLER->delete_task(args["pid"], args["tid"], request->user);
        ret = get_view_page(get_view_project(args["pid"], 1), args["pid"], 
          "Task deleted.");
      }
      else {
        ret = get_web_page ("", "You do not have the authority to "
          "perform this operation.");
       }      
    break; 
    case "Add":
      ret = get_web_page (get_add_task(data, args["pid"]), "Adding a task");
    break;     
    case "Edit":
      ret = get_web_page (get_modify_task(args["pid"], args["tid"]), 
        "Editting a task");    
    break;          
  }    

  switch (args["notetype"]) {
    case "Details":
      ret = get_view_page (get_view_note (args["pid"], args["nid"]), 
        args["pid"], "Note Details");
    break;   
    case "Delete":
      if (PROJECT_HANDLER->valid_operation (request->user, NOTE, 
        args["pid"])) {      
        PROJECT_HANDLER->delete_note(args["pid"], args["nid"], request->user);
        ret = get_view_page(get_view_project(args["pid"], 1), args["pid"],
          "Note deleted.");
      }
      else {
        ret = get_web_page (get_modify_project (args["pid"]), "You do not "
          "have the authority to perform this operation.");
       }      
    break; 
    case "Add":
      ret = get_web_page (get_add_note(data, args["pid"]), "Adding a note");
    break;     
    case "Edit":
      ret = get_web_page (get_modify_note(args["pid"], args["nid"]), 
        "Editting a note");    
    break;           
  }  

  switch (args["filetype"]) {
    case "Add":
      ret = get_web_page (get_add_file(data, args["pid"]), "Adding File "
        "Permission");
    break;     
    case "Delete":
      if (PROJECT_HANDLER->valid_operation (request->user, FILE, 
        args["fid"])) {    
        tell_creator ("drakkos", "%O.\n", args);
        i = PROJECT_HANDLER->remove_file(args["pid"], args["fid"], 
          args["task"],
          request->user);
        tell_creator ("drakkos", "%d.\n", i);
        ret = get_view_page(get_view_project(args["pid"], 1), args["pid"], 
          "File Permissions deleted.");
      }
      else {
        ret = get_web_page ("", "You do not have the authority to "
          "perform this operation.");
       }        
    break;
  }  
    
  switch (args["projecttype"]) {
    case "Delete":
      if (PROJECT_HANDLER->valid_operation (request->user, PROJECT, 
        args["pid"])) {      
        PROJECT_HANDLER->delete_project (args["pid"], request->user);
        ret = get_web_page (get_project_list(), "Project deleted.");
      }
      else {
        ret = get_web_page (get_modify_project (args["pid"]), "You do not "
          "have the authority to perform this operation.");
       }       
    break;  
    case "Add":
      ret = get_web_page (get_add_project(), "Adding a project");
    break;    
    case "List":
      ret = get_web_page (get_project_list(), "Project List");
    break;        
    case "Details":
      ret = get_view_page (get_view_project(args["pid"], 1), args["pid"], 
        "Project Details");
    break;    
    case "Edit":
      ret = get_web_page (get_modify_project(args["pid"]), 
        "Editting a project");
    break;
    case "File":
      ret = get_web_page (get_files_summary (args["pid"]), 
        "File Permission Details");
    break;    
      
  }
  
  switch (args["misc"]) {    
    case "Query":
      ret = get_web_page (get_query_project(), "Query Projects");
    break;  
    case "Domlist":
      ret = get_web_page (get_domain_project_list(args["domain"]), "Projects "
        "in the " + args["domain"] + " domain");
    break;
    case "goto":
      ret = get_web_page (get_modify_project(data["Goto"]), "Project "
        "Details");
    break;
    case "Crelist":
      ret = get_web_page (get_creator_project_list (args["creator"]), 
          "Projects for " + capitalize (args["creator"]));
      break;
    case "instructions":
      ret = get_web_page (get_instructions (args["cat"]), 
          "Project Manager instructions");
    break;
    case "Week":
      tmp = PROJECT_HANDLER->filter_by_query((["touched" : 
      (7 * 24 * 60 * 60)]));
  
      if (!sizeof (tmp)) {
        ret = get_web_page ("There are no projects that have been touched "
          "within the past week.", "Projects Updated This Week");
      }
      else {
        ret = get_web_page (parse_details (tmp), "Projects Updated This Week");    
      }
    break;     
    case "Playtesting":
      tmp = PROJECT_HANDLER->filter_by_query((["status" : 
        "playtesting"]));
  
      if (!sizeof (tmp)) {
        ret = get_web_page ("There are no projects in playtesting.", 
          "Projects In Playtesting");
      }
      else {
        ret = get_web_page (parse_details (tmp), "Projects In Playtesting");    
      }
    break;       
  }
                
  switch (data["button"]) {
    case "Add":
      ret = do_add_project (data, request->user);
    break;
    case "Add Task":
      ret = do_add_task (data, request->user);
    break;
    case "Add Note":
      ret = do_add_note (data, request->user);
    break;
    case "Add File":
      ret = do_add_file (data, request->user);
    break;
    case "Query":
      ret = get_web_page (web_query (data), "Query Completed");
    break;
    case "Update":
      ret = do_update_project (data, request->user);
    break;
    case "Update Task":
      ret = do_update_task (data, request->user);
    break;
    case "Update Note":
      ret = do_update_note (data, request->user);
    break;            
  }    
  
  if (!sizeof (ret)) {
  tmp = PROJECT_HANDLER->filter_by_query((["touched" : 
   (7 * 24 * 60 * 60)]));
  
  ret = get_web_page (parse_details (tmp), "Projects Updated This Week");

  
  }    

//  ret = "<h1>Come back later, Drakkos is breaking stuff.</h1>";
   
  return ret;
} 





// --- END [/mnt/home2/grok/lib/www/secure/creator/project.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/creator/bug_top.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/creator/bug_top.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626762   Available: 13574116
Inodes: Total: 5242880    Free: 4960132
8209 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/creator/bug_top.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626762   Available: 13574116
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

#include <db.h>
#include <config.h>

inherit "/w/taffyd/html_library";

#include <http.h>

#define MAKE_SQL_REQUEST( cmd, fp ) DB_HANDLER->make_sql_request( \
 "errors", CONFIG_DB_ERRORS_USER, "", (cmd), (fp) )

#define TYPO "Type = 'TYPO'" /*is a typo*/
#define BUG "Type = 'BUG'" /*is a bug*/
#define IDEA "Type = 'IDEA'" /*is an idea*/
#define FIXED "Status = 'FIXED'" /*is fixed*/
#define OPEN "Status = 'OPEN'" /*open bug*/
#define DENIED "Status = 'DENIED'" /*denied report*/
#define FIXER "Fixer is not NULL" /*has a fixer*/
#define FORWARDER_QUERY "Forwarder is not NULL"

#define RESULT_KEY "A"

int _doing_queries;
string _error_cache; 
function *_finished_funcs; 

mixed *_queries = ({ 
    ({ 
        ({ "Bug Fixers", "Fixer", "errors",  ({ FIXER, BUG, FIXED }) }),
        ({ "Bugs Fixed", "Reporter", "errors",  ({ FIXER, BUG, FIXED }) }),
        ({ "Open Bugs", "Reporter", "errors",  ({ OPEN, BUG }) }),
        ({ "Bugs Reported", "Reporter", "errors",  ({ BUG }) }),
    }),

    ({ 
        ({ "Typo Fixers", "Fixer", "errors",  ({ FIXER, TYPO, FIXED }) }),
        ({ "Typo Fixed", "Reporter", "errors",  ({ FIXER, TYPO, FIXED }) }),
        ({ "Open Typos", "Reporter", "errors",  ({ OPEN, TYPO }) }),
        ({ "Typos Reported", "Reporter", "errors",  ({ TYPO }) }),
    }),

    ({ 
        ({ "Idea \"Fixers\"", "Fixer", "errors",  ({ FIXER, IDEA, FIXED }) }),
        ({ "Ideas \"Fixed\"", "Reporter", "errors",  ({ FIXER, IDEA, FIXED }) }),
        ({ "Open Ideas ", "Reporter", "errors",  ({ OPEN, IDEA }) }),
        ({ "Ideas Reported", "Reporter", "errors",  ({ IDEA }) }),
    }),

    ({ 
        ({ "Total Fixers", "Fixer", "errors",  ({ FIXER, FIXED }) }),
        ({ "Total Fixed", "Reporter", "errors",  ({ FIXER, FIXED }) }),
        ({ "Open Reports", "Reporter", "errors",  ({ OPEN }) }),
        ({ "Reported", "Reporter", "errors",  ({ }) }),
    }),

    ({ 
        ({ "Denied Reports By Player", "Reporter", "errors",  ({ DENIED }) }),
        ({ "Denied Reports By Creator", "Fixer", "errors",  ({ DENIED }) }),
        ({ "Report Forwarders", "Forwarder", "forwards",  ({ FORWARDER_QUERY }) }),
        ({ "Commenter", "Commenter", "comments",  ({ }) }),
    }),
});

mixed *_finished_queries; 

void build_tables(int row, int column);
void build_error_stats();

void create() {
    html_library::create(); 
    
    set_title( "Bug Fixing Statistics" ); 
    build_error_stats();
} /* create() */ 

void build_error_stats() {
    int i, j; 
    int size; 

    _error_cache = 0; 
    _finished_queries = allocate( sizeof( _queries ) ); 
    _doing_queries = 0; 
    _finished_funcs = ({ }); 

    for ( i = 0; i < sizeof( _queries ); i++ ) {
        size = sizeof( _queries[ i ] );
        _doing_queries += size; 
        _finished_queries[ i ] = allocate( size ); 

        for ( j = 0; j < size; j++ ) {
            call_out( (: build_tables :), i, i, j); 
        }
    }
} /* build_error_stats() */ 

string make_table( string header, mixed *data ) {
    return "<table cellpadding=\"5\" cellspacing=\"0\" width=\"100%\">\n" 
        "<tr><th>" + header + "</th><th>Number</th></tr>\n" +
        implode( map( data, (: "<tr><td>" + $1[0] + "</td><td>" + 
            $1[1]  + "</td></tr>" :) ), "\n" ) + 
        "</table>\n";
} /* make_table() */ 

string build_full_sql_query(string who, string table, string select){
    return sprintf("SELECT %s, COUNT(*) AS " + RESULT_KEY + " FROM %s %s "
        "GROUP BY %s ORDER BY " + RESULT_KEY + " DESC LIMIT 10", who, table, 
        select, who);
} /* make_query() */ 

mixed build_sql_query(string who, string table, string *select) {
    string query;

    if ( sizeof(select) ) { 
        query = sprintf("WHERE %s", implode(select, " AND "));
    }
    else {
        query = "";
    }

    return build_full_sql_query(who, table, query);
} /* build_sql_query() */ 

string build_final_tables() {
    string txt;
    int i, j;

    txt = "";

    for ( i = 0; i < sizeof( _finished_queries ); i++ ) {
        txt += "<table cellpadding=\"5\" cellspacing=\"0\" width=\"100%\">\n"
            "<tr>";
        for ( j = 0; j < sizeof( _finished_queries[ i ] ); j++ ) {
            txt += "<td>" + _finished_queries[i][j] + "</td>";
        }

        txt += "</tr>"
            "</table>\n<hr>";
    }

    txt += "\n<div style=\"text-align: center;font-size: 10pt;\">\n"
        "<em>Statistics are generated once a reboot.</em>\n"
        "</div>\n";

    return construct_html_document(txt); 
} /* build_final_tables() */

void check_finished() {
    if ( !_doing_queries ) {
        _error_cache = build_final_tables(); 
        
        foreach( function func in _finished_funcs ) { 
            if ( functionp(func) ) { 
                evaluate( func, _error_cache ); 
            }
        }

        _finished_funcs = ({ }); 
    }
} /* check_finished() */ 

void finished_sql_query(int status, mixed *data, string key, string title, int row, int column) {

    mixed *results; 

    if ( status != DB_SUCCESS ) {
        _doing_queries--;
        check_finished(); 
        return;
    }

/* 0: ({
  ([ 
    "A" : 1905,
    "Reporter" : "hagi",
  ]),
  ([ 
    "A" : 837,
    "Reporter" : "lanfear",
  ]),
*/ 
    results = ({ });

    foreach( mapping result in data ) { 
        results += ({ ({ result[ key ], result[ RESULT_KEY ] }) });
    }
    
    _finished_queries[ row ][ column ] = make_table( title, results ); 

    _doing_queries--;

    // tell_creator( "taffyd", "%s, %d\n", _finished_queries[ row ][ column ], _doing_queries ); 
    
    check_finished(); 
} /* finished_sql_query() */

void build_tables(int row, int column) {
    mixed *bits; 
    string query;
    bits = _queries[ row ][ column ]; 
    
    query = build_sql_query( bits[1], bits[2], bits[3] );

    MAKE_SQL_REQUEST(query, (: finished_sql_query($1, $2, $(bits)[1], $(bits)[0], $(row), $(column)) :)); 

    tell_creator( "taffyd", "%s\n", query );
} /* build_tables() */ 

mixed www_delayed( function func, string str, mapping args, class http_request req ) {
    if ( _doing_queries ) {
        _finished_funcs += ({ func }); 
        return 1; 
    }
    
    return 0; 
} /* www_delayed() */ 

string www_request(string, mapping args, class http_request req) {
    if ( _error_cache ) {
        return _error_cache;
    }

    return construct_html_document( "No error statistics are available "
        "at the moment.\n");
} /* www_request() */

#ifdef OLD_CODE_JESUS_CHRIST_MY_EYES
  sixth = cont {
  rows = do_query("select Reporter, EntryDate, Directory, Filename, Status "
                  "from errors where Status != 'FIXED' and Status != "
                  "'DENIED' and Type = 'BUG' order by EntryDate",
              fix(({"select Reporter", "EntryDate", "Directory", "Filename",
                      "Status"}), {

  ret += make_table(rows, "Oldest bugs", "reporter", "date", "directory",
                    "filename", "status");
  
  ret += "<br clear=left>";
  /* 
  rows = db_exec(db, "select Reporter, EntryDate, Directory, Filename, Status "
                 "from errors where Status != 'FIXED' and Status != "
                 "'DENIED' and Type = 'IDEA' order by EntryDate");

  ret += make_table(rows, "Oldest ideas", "reporter", "date", "directory",
                    "filename", "status");

  ret += "<br clear=left>";

  
  rows = db_exec(db, "select Reporter, EntryDate, Directory, Filename, Status "
                 "from errors where Status != 'FIXED' and Status != "
                 "'DENIED' and Type = 'TYPO' order by EntryDate");
  
  ret += make_table(rows, "Oldest typos", "reporter", "date", "directory",
                    "filename", "status");

  ret += "<br clear=left>";
    
  rows = db_exec(db, "select Filename, count(*) as bing from errors where "
                 OPEN " and " BUG " group by filename order by bing desc");
  ret += make_table(rows, "Files with most bug reports", "file", "reports");
    
  rows = db_exec(db, "select Filename, count(*) as bing from errors where "
                 OPEN " and " IDEA " group by filename order by bing desc");
  ret += make_table(rows, "Files with most idea reports", "file", "reports");
  */
#endif
// --- END [/mnt/home2/grok/lib/www/secure/creator/bug_top.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/edit.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/edit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626760   Available: 13574114
Inodes: Total: 5242880    Free: 4960132
1861 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/edit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626760   Available: 13574114
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>
#include <player_handler.h>

string this_file;

void create(){
    this_file = __FILE__[strsrch(__FILE__, "/", - 1) + 1..];
}

string www_request(string, mapping args, class http_request req){
  if(!req->user)
    return "Error!";

  if(!PLAYER_HANDLER->test_creator(req->user))
    return "You are not a creator!";

  if(args["file"] && file_size(args["file"]) > 0){
    if(!unguarded((: master()->valid_read($(args["file"]), $(req->user), "cat"):)))
      return "You don't have access to that file!";

    if(req->body->data["body"]){
      mixed stats;
      if(arrayp(stats = stat("/tmp/"+req->user)) && sizeof(stats))
        unguarded((:rm, "/tmp/"+req->user:));
      
      if(arrayp(stats))
        unguarded((:mkdir, "/tmp/"+req->user:));

      unguarded((:write_file, "/tmp/" + req->user + "/" +
                 explode(args["file"], "/")[<1], req->body->data["body"], 1:));

      return "saved in /tmp/" + req->user + "/" + 
        explode(args["file"], "/")[<1];
    }
    return sprintf(@END
<form method=post action="%s?file=%s">
<textarea name="body" rows="20" cols="80" wrap="hard">
END, this_file, args["file"]) + HTTPD->escape_html(read_file(args["file"])) + @END
</textarea><br>
<input type=submit value="save"></form>
END;
  } else {
    return sprintf("No such file, or no file selected."
                   "<hr><form action=\"%s\" METHOD=GET>"
                   "<b>File:</b> <input type=\"text\" name=\"file\" size=62><p>"
                   "<p>"
                   "<input type=\"submit\" value=\"Get file\">"
                   "<input type=\"reset\" value=\"Reset\">"
                   "</form><br><b><a HREF=\"file_browser.c?"
                   "action=/secure/%s,check_file,"
                   "%s,file\">Browse</a>", allocate(3, this_file) ...);
  }
}
      
int check_file(string file){
  return 1;
}
// --- END [/mnt/home2/grok/lib/www/secure/edit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/secure/extra_boards.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/secure/extra_boards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626759   Available: 13574113
Inodes: Total: 5242880    Free: 4960132
1529 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/secure/extra_boards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626759   Available: 13574113
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:04.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>
#include <clubs.h>
#include <player_handler.h>

string www_function(string fname, mapping fields, class http_request req) {
   string ret;
   string *clubs;
   string bing;

   ret = "";
   if (req->user) {
      if (PLAYER_HANDLER->test_property(req->user, "philosopher")) {
         ret += "<h3><a href=\"boards.c?board=philosophers\">"
            "<font face=\"arial, helvetica\">Philosophers</a></h3>\n";
      }
      clubs = CLUB_HANDLER->query_boards();
      foreach (bing in clubs) {
         if (CLUB_HANDLER->is_member_of(bing, req->user)) {
            ret += "<h3><a href=\"boards.c?board=" +
               CLUB_HANDLER->query_club_board_name(bing) + "\">"
               "<font face=\"arial, helvetica\">" +
               CLUB_HANDLER->query_club_name(bing) + "</a></h3>\n";
         }
      }

      ret += "<h3><a href=\"boards.c?board=flame\">"
         "<font face=\"arial, helvetica\">Flame</a></h3>\n";
      ret += "<h3><a href=\"boards.c?board=fluff\">"
         "<font face=\"arial, helvetica\">Fluff</a> for all your happy feelings</h3>\n";
      ret += "<h3><a href=\"boards.c?board=never+wending+story\">"
         "<font face=\"arial, helvetica\">Never wending story</a></h3>\n";
      ret += "<h3><a href=\"boards.c?board=alt.fan.pratchett\">"
         "<font face=\"arial, helvetica\">alt.fan.pratchett</a></h3>\n";
      ret += "<h3><a href=\"boards.c?board=equality\">"
         "<font face=\"arial, helvetica\">Equality</a></h3>\n";
   }
   return ret;
} /* www_function() */
// --- END [/mnt/home2/grok/lib/www/secure/extra_boards.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/footer.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/footer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626759   Available: 13574113
Inodes: Total: 5242880    Free: 4960132
1147 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/footer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626759   Available: 13574113
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>

string www_function(string fname, mapping fields, class http_request req,
                    int dont_inc_date, int no_hr) {
  string ret;
  mixed *stuff;

  if (!no_hr) {
    ret = "<hr>\n";
  } else {
    ret = "";
  }
  ret += "<center>\
<font size=\"-1\"><a href=\"http://discworld.imaginary.com/login.html\">Discworld MUD</a>'s \
distribution world wide web pages.<br>\
brought to you by<br>\
<strong>Cut Me Own Throat Dibbler's \
<a href=\"http://discworld.imaginary.com/sausages.html\">Sensational Sausages</a>;\
&nbsp;buy one while they are hot.</strong><br>";
  if (fname == "footer") {
    fname = HTTPD->query_current_file();
  }
  if(fname[<2..] != ".c") {
    stuff = stat(fname);
  }

  if (stuff && sizeof ( stuff ) && !dont_inc_date && intp(stuff[1])) {
    ret += "File last modified: "+HTTPD->format_date(stuff[1]);
  }
  if (req && req->user) {
     ret += "<br><a href=\"/secure\">Secure section</a>, logged on as " + capitalize(req->user) + "\n";
  }
  ret += "<br>\n<hr>\
Lost?  Try Discworld's <a href=\"http://discworld.imaginary.com/\">home page</a>.\
</center>";
  return ret;
} /* www_function() */

// --- END [/mnt/home2/grok/lib/www/footer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/boards.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/boards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626758   Available: 13574112
Inodes: Total: 5242880    Free: 4960132
55957 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/boards.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626758   Available: 13574112
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:05.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <http.h>
#include <board.h>
#undef DAYS
#undef MONTHS
#include <config.h>
#include <mail.h>
#include <login_handler.h>
#include <login.h>
#include <clubs.h>
#include <player_handler.h>
#include <playtesters.h>

#undef SAVE_FILE
#define SAVE_FILE "/save/www/boards"

#define THREADING 0

// One day...
#define TIME_INTERVAL_FOR_POSTING (24 * 60 * 60)
// Maximum number of posts per time period
#define TIME_POSTING_MAXIMUM 5

class player_info {
    mapping newsrc;
    int newsrc_changed;
    string *current_order;
    int current_order_changed;
}

class message_cache {
    string message;
    int last_read;
}

class player_cache {
    string* order;
    int last_read;
    int new_index;
}

private nosave string *_allowed_creator_boards = ({ "commonroom", "learning",
  "development", "dwclone",
  "mudlib", "ram", "am", "sur", "klatch", "forn",
  "special projects",
  "cwc",
  "fluffos",
  "playerhelp",
  "discipline",
  "applications",
  "style", "liaison", "guilds", "underworld"});

nosave string *_allowed_playtester_boards = ({
  "ptforum", "playtesters", "playtester_bugs",
});

nosave string *_allowed_boards = ({ "frog", "newspaper", "warriorsguild",
  "thievesguild", "priestsguild", "assassinsguild",
  "witchesguild", "wizardsguild", "announcements",
  "philosophers", "never wending story",
  "alt.fan.pratchett", "flame", "fluff",
  "ankh morpork council",
  "ankh morpork magistrates",
  "klatch council",
  "klatch magistrates",
  "the green slab",
  "the am daily",
  "equality", "player killers", "role-playing", "tarnach's" });
private nosave mapping _board_pics;
/*
 * This is a mapping containging function pointers which
 * control access to special boards.  eg: philosphers.
 */
private nosave mapping _special_access_boards;
private nosave mapping _read_protected_boards;
private nosave string *no_post_boards = ({ "announcements" });

/* Two globals to do terrible things with data. */
// we have three now.
private nosave string board;
private nosave string html_board;
private nosave mixed messages;

private nosave mapping _subjects;
private nosave mapping _messages;
private nosave mapping _board_order;

mapping posted_stuff;

class posted_information {
    int time_first_posted;
    int count;
}

private int is_allowed_special_access(string board, string name);
private string subjects(class http_request req, int threaded);
private string read(string str, class http_request req, int post_ok,
                    int threaded);
private string new_message(class http_request req, int threaded);
private string followup(string str, class http_request req, int threaded);
private string delete_message(string str, class http_request req, int threaded);
private string postform(string subject, string body, string note,
                        string action, class http_request, int threaded);
private string post(string str, class http_request req, int threaded);
private string create_header(string title);
private string board_summary(class http_request req, int threaded);
private string complete_board_summary(class http_request req, int threaded);
private int is_allowed_access(string board, string name);
private string mail_reply(string note, class http_request req, int threaded);
private string send_mail(string note, class http_request req, int threaded);
private string remove_control_chars(string str);
private void do_post_note(string name);
private void do_delete_note(string name);
private string can_post_note(string name, string board);
private int can_followup_note(string name, string board, mixed *stuff);
private string read_order(class http_request req, int threaded);
private string *get_allowed_boards(string name);
string* get_user_board_order(string user);
private int has_new_messages(string board,
                             string user,
                             mapping newsrc);
private void add_board_picture(string board, string picture);

void create() {
    string* boards;
    string name;

    _subjects = ([ ]);
    _messages = ([ ]);
    _board_order = ([ ]);
    seteuid("WWW");
    /* This is used to flush out newsrc's... */
    _special_access_boards = ([
      "philosophers" : (: PLAYER_HANDLER->test_property($1, "philosopher") :),
      "tarnach's" : (:
             "/d/special/player_shops/tarnach's_office"->query_employee($1) :),
     ]);
     _read_protected_boards = ([
    ]);
    _read_protected_boards = ([
      "ankh morpork magistrates" : 1,
      "klatch magistrates" : 1,
      "the green slab" : 1,
      "the am daily" : 1,
    ]);
    seteuid(getuid());
    /* Do -this every 10 minutes... */
    unguarded( (: restore_object(SAVE_FILE) :) );
    if (!posted_stuff) {
        posted_stuff = ([ ]);
    }
    boards = CLUB_HANDLER->query_boards();
    _allowed_boards += boards;
    foreach (name in boards) {
       _read_protected_boards[name] = 1;
    }

    // Frogs!
    _board_pics = ([ ]);
    add_board_picture("default", "pics/tfrog-news.gif");

    // Custom frogs!
    // Guilds
    add_board_picture("assassinsguild", "pics/boards/assassin_frog0.gif");
    add_board_picture("assassinsguild", "pics/boards/assassin_frog4.gif");
    add_board_picture("assassinsguild", "pics/boards/assassin_frog9.gif");
    add_board_picture("priestsguild", "pics/boards/priest_frog0.gif");
    add_board_picture("priestsguild", "pics/boards/priest_frog4.gif");
    add_board_picture("priestsguild", "pics/boards/priest_frog9.gif");
    add_board_picture("thievesguild", "pics/boards/thief_frog0.gif");
    add_board_picture("thievesguild", "pics/boards/thief_frog4.gif");
    add_board_picture("thievesguild", "pics/boards/thief_frog4b.gif");
    add_board_picture("thievesguild", "pics/boards/thief_frog9.gif");
    add_board_picture("warriorsguild", "pics/boards/warrior_frog0.gif");
    add_board_picture("warriorsguild", "pics/boards/warrior_frog4.gif");
    add_board_picture("warriorsguild", "pics/boards/warrior_frog9.gif");
    add_board_picture("witchesguild", "pics/boards/witch_frog0.gif");
    add_board_picture("witchesguild", "pics/boards/witch_frog4.gif");
    add_board_picture("witchesguild", "pics/boards/witch_frog9.gif");
    add_board_picture("wizardsguild", "pics/boards/wizard_frog0.gif");
    add_board_picture("wizardsguild", "pics/boards/wizard_frog4.gif");
    add_board_picture("wizardsguild", "pics/boards/wizard_frog9.gif");
    // Domains
    add_board_picture("am", "pics/boards/am_frog6.gif");
    add_board_picture("klatch", "pics/boards/klatch_frog5.gif");
    add_board_picture("liaison", "pics/boards/liaison_frog7.gif");
    // Clubs
    add_board_picture("club pcdc", "pics/boards/pcdc_frog5.gif");
    // Random boards
    add_board_picture("ankh morpork magistrates",
                      "pics/boards/ammagistrate_frog4.gif");
    add_board_picture("announcements", "pics/boards/news_frog1.gif");
    add_board_picture("announcements", "pics/boards/news_frog2.gif");
    add_board_picture("announcements", "pics/boards/news_frog4.gif");
    add_board_picture("announcements", "pics/boards/news_frog9.gif");
    add_board_picture("development", "pics/boards/development_frog6.gif");
    add_board_picture("discipline", "pics/boards/discipline_frog0.gif");
    add_board_picture("discipline", "pics/boards/discipline_frog5.gif");
    add_board_picture("discipline", "pics/boards/discipline_frog7.gif");
    add_board_picture("equality", "pics/boards/equality_frog4.gif");
    add_board_picture("flame", "pics/boards/flame_frog0.gif");
    add_board_picture("flame", "pics/boards/flame_frog1.gif");
    add_board_picture("flame", "pics/boards/flame_frog4.gif");
    add_board_picture("flame", "pics/boards/flame_frog9.gif");
    add_board_picture("fluff", "pics/boards/fluff_frog4.gif");
    add_board_picture("fluff", "pics/boards/fluff_frog9.gif");
    add_board_picture("learning", "pics/boards/learning_frog6.gif");
    add_board_picture("mudlib", "pics/boards/mudlib_frog3.gif");
    add_board_picture("newspaper", "pics/boards/newspaper_frog5.gif");
    add_board_picture("never wending story", "pics/boards/nw_frog0.gif");
    add_board_picture("never wending story", "pics/boards/nw_frog2.gif");
    add_board_picture("never wending story", "pics/boards/nw_frog4.gif");
    add_board_picture("philosophers", "pics/boards/philosopher_frog0.gif");
    add_board_picture("philosophers", "pics/boards/philosopher_frog4.gif");
    add_board_picture("player killers", "pics/boards/pk_frog2.gif");
    add_board_picture("player killers", "pics/boards/pk_frog2b.gif");
    add_board_picture("player killers", "pics/boards/pk_frog4.gif");
    add_board_picture("role-playing", "pics/boards/rp_frog4.gif");
    add_board_picture("role-playing", "pics/boards/rp_frog4b.gif");
    add_board_picture("style", "pics/boards/style_frog7.gif");
    add_board_picture("style", "pics/boards/style_frog7b.gif");
    add_board_picture("style", "pics/boards/style_frog7c.gif");
    add_board_picture("style", "pics/boards/style_frog7d.gif");

    add_board_picture("klatch council", "pics/boards/klatch_council_frog0.gif");
    add_board_picture("klatch magistrates", "pics/boards/klatch_council_frog0.gif");
    add_board_picture("tarnach's", "pics/boards/tarnachs_frog.gif");
    // Clean up the cache every 30 minutes.
    call_out("clean_up_cache", 30 * 60);
} /* create() */

/**
 * Do some work to clean up the cache, throw away any messages not read for
 * 25 minutes.
 */
void clean_up_cache() {
   class message_cache cache;
   class player_cache order;
   int num;
   string name;

   call_out("clean_up_cache", 30 * 60);
   foreach (num, cache in _messages) {
      if (cache->last_read + 25 * 60 < time()) {
         map_delete(_messages, num);
      }
   }
   foreach (name, order in _board_order) {
      if (cache->last_read + 10 * 60 < time()) {
         map_delete(_board_order, name);
      }
   }
}

string the_date(int i) {
    return ctime(i)[4..9];
} /* the_date() */

string htmlify_no_address(string str) {
    return replace(str, ({
        "&", "&amp;",
        "<", "&lt;",
        ">", "&gt;",
        " ", "&nbsp;",
        "\n", "<br>\n",
      }) );
} /*  htmlify_no_address() */

/*
 * Makes all the '<' turn into $gt; and the '>' the same.  Turn
 * http addresses into real addresses...
 */
string htmlify(string  str) {
    string *bits;
    string start;
    string end;
    string extra;
    int i;
    int indent = 0;
    int amount; 
    int pos;

    str =  htmlify_no_address(str);
    if (strsrch(str, "http:") > 0) {
        bits = explode("#" + str, "http:");
        bits[0] = bits[0][1..];
        for (i = 1; i < sizeof(bits); i++) {
            if (sscanf(bits[i], "%s&nbsp;%s", start, end) == 2) {
                end = "&nbsp;" + end;
                if (sscanf(start, "%s<br>%s", start, extra) == 2) {
                    end = "<br>" + extra + end;
                }
            } else if (sscanf(bits[i], "%s<br>%s", start, end) == 2) {
                end = "<br>" + end;
            } else {
                start = bits[i];
                end = "";
            }
            if (start[<1] == '.') {
                start = start[0..<2];
                end = "." + end;
            }
            bits[i] = "<a href=\"http:" + start + "\">http:" + start + "</a>" +
            end;
        }
        str = implode(bits, "");
    }
    
    // Replace any non breaking spaces with normal spaces. We want them 
    // out so that browsers can wrap text properly. 
    
    str = replace( str, ({ 
        "&nbsp;", " ",                      
    }) );

    // Check to see if there are any MUD indentation codes in the post.

    if ( strsrch(str, "$I$") > -1 ) {
        bits = explode( "#" + str, "$I$" ); 
        bits[0] = bits[0][1..];

        for (i = 1; i < sizeof(bits); i++) {
            if (sscanf(bits[i], "%d=%s", amount, end) == 2) {
                if ( indent && amount == 0 ) {
                    end = "\n<!-- END OF INDENT -->\n"
                        "</blockquote>" + end; 
                } 
                
                if ( amount ) { 
                    // Ok. With $I$x=, we indent by x characters AFTER the
                    // first line has been written out.  This means
                    // we are going to have to search for the next 
                    // \n and insert the <blockquote> in after there. 

                    pos = strsrch( end, "\n" );
                
                    // If there are no carriage returns in here, then 
                    // well just have to indent at the end of this 
                    // block of text. 

                    if ( pos == -1 ) {
                        end = "\n<!-- BEGINNING OF INDENT -->\n"
                            "<blockquote>" + end;                    
                    } else {
                        end = end[0..pos - 1] + "\n<!-- BEGINNING OF INDENT -->\n"
                            "<blockquote>" + end[pos..];                    
                    }
                    indent++; 
                }
            }

            bits[ i ] = end;
        }

        if ( indent ) { 
            while( indent ) {
                bits[ <1 ] = bits[ <1 ] + "\n<!-- END OF INDENT, "
                    "CLEANUP -->\n"
                    "</blockquote>";
                indent--;
            }
        }


        str = implode( bits, "" );
    }

    return str;
} /* htmlify() */

private void add_board_picture(string board, string picture) {
   if (!_board_pics[board]) {
      _board_pics[board] = ({ });
   }
   _board_pics[board] += ({ picture });
} /* add_board_picture() */

private string query_board_picture(string board) {
   if (_board_pics[board]) {
      return _board_pics[board][random(sizeof(_board_pics[board]))];
   }
   return _board_pics["default"][random(sizeof(_board_pics["default"]))];
} /* query_board_picture() */

string www_request(string str, mapping args, class http_request req) {
  int threaded;
  
  if (!undefinedp(args["board"])) {
    board = args["board"];
    html_board = replace(board, " ", "+");
    if (!is_allowed_access(board, req->user)) {
      return "<b>Access to "+board+" is denied.</b>\n"+
  ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    threaded = to_int(args["threaded"]);
    switch (args["type"]) {
    case "read" :
      return read(args["note"], req, 0, threaded);
    case "followup" :
      return followup(args["note"], req, threaded);
    case "post" :
      return post(args["note"], req, threaded);
    case "new" :
      return new_message(req, threaded);
    case "eat" :
      return delete_message(args["note"], req, threaded);
    case "summary" :
      return board_summary(req, threaded);
    case "summary-all" :
      return complete_board_summary(req, threaded);
    case "mailreply" :
      return mail_reply(args["note"], req, threaded);
    case "sendmail" :
      return send_mail(args["note"], req, threaded);
    case "readorder" :
      return read_order(req, threaded);
    default :
      return subjects(req, threaded);
    }
  }
  return "<b>Incorrect argument!</b>"+
    ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
} /* www_request() */

private string create_header(string title) {
    return "<html><head>"
    "<title>" + title + "</title>"+
    "</head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" "
    "VLINK=\"#b57339\"><font face=\"arial,helvetica\">";
} /* create_header() */

private string *get_next_new_note(string user, mapping newsrc,
                                  class http_request req, int threaded) {
    string *allowed;
    //string *boards;
    int pos;
    mixed *new_stuff;
    string bing;
    int changed;

    allowed = get_user_board_order(user);
    // So killed boards don't get linked to.
    //allowed -= BOARD_HAND->list_killfile(req->user);
    foreach (bing in allowed) {
        if (is_allowed_special_access(bing, user)) {
           pos = has_new_messages(bing, user, newsrc);
           if (pos > 0) {
              new_stuff = BOARD_HAND->get_subjects(bing, req->user);
              pos = new_stuff[<pos][B_NUM];
              if (changed) {
                 BOARD_HAND->set_newsrc(req->user, newsrc);
              }
              return ({ "<a href=\"boards.c?board=" +
                replace_string(bing, " ", "+") +
                "&amp;type=read&amp;threaded=" + threaded +
                          "&amp;note=" + pos + "\">Next new</a>" });
           }
        }
    }
    return ({ });
} /* get_next_new_note() */

private string show_line(mixed stuff, class http_request req, mapping newsrc,
                         int threaded) {
  string ret;

  if (_subjects[stuff[B_NUM]]) {
     ret = _subjects[stuff[B_NUM]];
  } else {
     ret = sprintf("<li><a href=\"boards.c?board=%s&amp;type=read&amp;"
                   "threaded=" + threaded + "&amp;note=%d\">%s</a> ("
                "<a href=\"/" + (req->user?"secure/":"") +
                "finger.c?player=%s\">%s</a>, %s)</a>",
                html_board, stuff[B_NUM],
                htmlify_no_address(stuff[B_SUBJECT]), stuff[B_NAME],
                capitalize(stuff[B_NAME]),
                the_date(stuff[B_TIME]));
     _subjects[stuff[B_NUM]] = ret;
  }
  if (req->user && newsrc[board] < stuff[B_TIME] &&
      req->user != lower_case(stuff[B_NAME])) {
    ret += " <b>[new]</b> ";
  }
  return ret + "\n";
}

private string find_followups(int thread, int start, class http_request req,
                              mapping newsrc, int threaded) {
  int i;
  string ret;
  mixed followups;

  followups = filter(messages[start..], (: $1[B_REPLY_NUM] == $2 :), thread);

  if(!sizeof(followups))
    return "";

  ret = "<ul>\n";
  for(i=0; i<sizeof(followups); i++) {
    ret += show_line(followups[i], req, newsrc, threaded);
    ret += find_followups(followups[i][B_NUM], i, req, newsrc, threaded);
  }
  messages = filter(messages, (: $1[B_REPLY_NUM] != $2 :), thread);

  ret += "</ul>\n";

  return ret;
}

private string subjects(class http_request req, int threaded) {
    int i;
    mixed *stuff;
    string ret;
    mapping newsrc;
    string *tmp;

    ret = create_header("Board: "+board);
    ret += "<h2><img src=\"http:/external/" +
           query_board_picture(board) + "\" alt=\" \">"
    "Notes on the " +
    capitalize(board) + " board</h2>\n";
    stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);
    if (req->user) {
        newsrc = BOARD_HAND->query_newsrc(req->user);
        if (!newsrc) {
            newsrc = ([ ]);
        }
    }

    tmp = ({ });
    if (req->user) {
        if (member_array(board, no_post_boards) == -1) {
                tmp += ({ "<a href=\"boards.c?type=new&threaded=" + threaded +
                            "&amp;board=" + html_board + "\">New&nbsp;note</a>" });
        }
    }
    tmp += ({ "<a href=\"boards.c?type=summary&amp;threaded=" + threaded +
                "&amp;board=" + html_board + "\">Summary</a>",
                "<a href=\"boards.c?board=frog&amp;type=summary-all&amp;"
                "threaded=" + threaded + "\">All&nbsp;Boards</a>" });
    if(threaded)
      tmp += ({ "<a href=\"boards.c?board=" + board + "&amp;threaded=0\">"
                  "Subjects&nbsp;by&nbsp;Date</a>"});
    else
      tmp += ({ "<a href=\"boards.c?board=" + board + "&amp;threaded=1\">"
                  "Subjects&nbsp;by&nbsp;Thread</a>"});
      
    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
      "&nbsp;]</strong></font><br clear=both>\n";

    if (!sizeof(stuff)) {
        return ret + "<b>The board is completely empty.</b><p>" +
          "/www/footer"->www_function("footer", ([ ]), req)+"</body></html>";
    }

    if(!threaded) {
      ret += "<ol>";
      for (i=0;i<sizeof(stuff);i++) {
        ret += show_line(stuff[i], req, newsrc, 0) + "\n";
      }
      ret += "</ol><br>";
    } else {
      messages = stuff;
      ret += "<ul>\n";
      for(i=0; i<sizeof(messages); i++) {
        ret += show_line(messages[i], req, newsrc, 1);
        ret += find_followups(messages[i][B_NUM], i, req, newsrc, 1);
      }
      ret += "</ul>\n";
    }
    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
      "&nbsp;]</strong></font><br clear=both>\n";

    return ret + ("/www/footer"->www_function("footer", ([ ]), req)) +
      "</body></html>";
} /* subjects() */

private int count_lines(string str) {
    return sizeof(explode(str, "\n"));
} /* count_lines() */

private string read(string str, class http_request req, int post_ok,
                    int threaded) {
    int num, i, b_num;
    int next_thread = 1;
    mixed stuff;
    string ret;
    string *tmp;
    mapping newsrc;
    string mess;
    string middle;
    string line;
    class message_cache cache;

    ret = create_header("Note "+str+" on board "+board);
    stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);
    if (sscanf(str, "%d", b_num) != 1) {
        return ret + "<b>Incorrect argument!</b>" +
        ("/www/footer"->www_function("footer", ([ ]), req)) +
        "</body></html>";
    }

    num = -1;
    for (i=0;i<sizeof(stuff);i++) {
        if (stuff[i][B_NUM] == b_num) {
            num = i+1;
        }
    }

    if (num < 1 || num > sizeof(stuff)) {
        return ret + "<b>No note of that number</b>" +
        ("/www/footer"->www_function("footer", ([ ]), req)) +
        "</body></html>";
    }

    num --;
    if (req->user) {
        newsrc = BOARD_HAND->query_newsrc(req->user);
        if (!newsrc) {
            newsrc = ([ ]);
        }
        if (newsrc[board] < stuff[num][B_TIME]) {
            newsrc[board] = stuff[num][B_TIME];
            BOARD_HAND->set_newsrc(req->user, newsrc);
        }
    }

    tmp = ({ });
    if (num<sizeof(stuff)-1) {
      tmp += ({ "<a href=\"boards.c?board="+html_board+
                  "&amp;type=read&amp;threaded=" + 0 + "&amp;note="+
                  stuff[num+1][B_NUM]+ "\">Next</a>" });

      for(i=num+1; i<sizeof(stuff); i++) {
        if(stuff[i][B_REPLY_NUM] == stuff[num][B_NUM] ||
           (stuff[num][B_REPLY_NUM] &&
            stuff[i][B_REPLY_NUM] == stuff[num][B_REPLY_NUM])) {
          tmp += ({ "<a href=\"boards.c?board="+html_board+
                      "&amp;type=read&amp;threaded=1&amp;note="+stuff[i][B_NUM]+
                      "\">Next&nbsp;in&nbsp;Thread</a>" });
          next_thread = 0;
          break;
        }
      }
      if(next_thread) {
        tmp += ({ "<a href=\"boards.c?board="+html_board+
                    "&amp;type=read&amp;threaded=1&amp;note="+
                    stuff[num+1][B_NUM]+ "\">Next Thread</a>" });
        
      }
    } else if (req->user) {
      tmp += get_next_new_note(req->user, newsrc, req, threaded);
    }

    if (num>=1) {
      tmp += ({ "<a href=\"boards.c?board="+html_board+
                  "&amp;type=read&amp;threaded=" + threaded + "&amp;note="+
                  stuff[num-1][B_NUM]+ "\">Previous</a>" });
    }
    tmp += ({ "<a href=\"boards.c?board="+html_board+"&amp;threaded=0"
                "\">Subjects&nbsp;by&nbsp;Date</a>" });
    tmp += ({ "<a href=\"boards.c?board="+html_board+"&amp;threaded=1"
                "\">Subjects&nbsp;by&nbsp;Thread</a>" });

    if (req->user) {
        if (member_array(board, no_post_boards) == -1) {
            tmp += ({ "<a href=\"boards.c?board=" + html_board +
              "&amp;type=followup&amp;threaded=" + threaded + "&amp;note=" +
              stuff[num][B_NUM] + "\">Followup</a>",
              "<a href=\"boards.c?board=" + html_board +
              "&amp;type=new&amp;threaded=" + threaded + "\">New&nbsp;note</a>" });
        }
        tmp += ({ "<a href=\"boards.c?board=" + html_board +
              "&amp;type=eat&amp;threaded=" + threaded + "&amp;note=" +
                    stuff[num][B_NUM] +"\">Eat&nbsp;note</a>",
          "<a href=\"boards.c?board=" + html_board +
          "&amp;type=mailreply&amp;note=" +
          stuff[num][B_NUM] + "\">Mail&nbsp;reply</a>",
         "<a href=\"boards.c?board=frog&amp;type=summary&amp;threaded=" +
                    threaded + "\">Summary</a>",
         "<a href=\"boards.c?board=frog&amp;type=summary-all&amp;threaded=" +
                    threaded + "\">All&nbsp;Boards</a>"
                    });
    }

    mess = BOARD_HAND->get_message(board, num, req->user);
    if (!stringp(mess)) {
        mess = "Horribly broken message with eggs for ears.\n";
    }
    ret += "<h2><img src=\"http://discworld.imaginary.com/external/" +
             query_board_picture(board) + "\" alt=\" \">"+
       htmlify_no_address(stuff[num][B_SUBJECT])+"</h2>\n";
    line = "<font size=-1><strong>[&nbsp;"+implode(tmp, " | ")+"&nbsp;]</strong></font>\n";
    ret += line;
    if (_messages[b_num]) {
       ret += "<h3>Note #" + (num + 1) + (_messages[b_num]->message);
       _messages[b_num]->last_read = time();
    } else {
       middle = " by <a href=\"/" + (req->user?"secure/":"") +
       "finger.c?player="+
       stuff[num][B_NAME]+"\">"+capitalize(stuff[num][B_NAME])+"</a> at "+
       ctime(stuff[num][B_TIME])+" on board " + board + "</h3>\n<p>"+
       ""+htmlify(strip_colours(mess))+
       "</p>\n";

       ret += "<h3>Note #" + (num + 1) + middle;
       cache = new(class message_cache);
       cache->message = middle;
       cache->last_read = time();
       _messages[b_num] = cache;
    }
    return ret + line +
    ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
} /* read() */

private string followup(string str, class http_request req, int threaded) {
    int num, i, b_num;
    mixed stuff;
    string ret;
    string subject;

    ret = create_header("Note "+str+" on board "+board);
    stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);
    if (sscanf(str, "%d", b_num) != 1 || !req->user) {
        return ret+"<b>Incorrect argument!</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req)) +
        "</body></html>";
    }

    num = -1;
    for (i=0;i<sizeof(stuff);i++) {
        if (stuff[i][B_NUM] == b_num) {
            num = i+1;
        }
    }

    if (num < 1 || num > sizeof(stuff)) {
        return ret+"<b>No note of that number</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    num --;
    if (!can_followup_note(req->user, board, stuff[num])) {
        return ret + "<b>Unable to followup to this message, too many messages "
        "posted today (Maximum " + TIME_POSTING_MAXIMUM + ")</b>" +
        ("/www/footer"->www_function("footer", ([ ]), req)) +
        "</body></html>";
    }

    ret += "<h2><img src=\"http://discworld.imaginary.com/external/" +
            query_board_picture(board) + "\" alt=\" \">"
    "Followup to Note #" +
    (num + 1) + " on board " + board + "<br>'" +
    htmlify_no_address(stuff[num][B_SUBJECT]) + "'</h2>\n";

    if (sscanf(stuff[num][B_SUBJECT], "Re:#%d %s", i, subject) != 2) {
        subject = "Re:#1 "+ stuff[num][B_SUBJECT];
    } else {
        subject = "Re:#"+ ( i + 1 ) +" "+ subject;
    }

    ret += postform(subject,
                    "On " + ctime(stuff[num][B_TIME]) + ", " +
                    stuff[num][B_NAME] +
                    " wrote:\n> " +
                    implode(explode(strip_colours(sprintf("%-=76s",
              BOARD_HAND->get_message(board, num, req->user))), "\n"), "\n> "),
                    str, "post", req, threaded);
    return ret + ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
} /* followup() */

private string mail_reply(string str, class http_request req, int threaded) {
    int num, i, b_num;
    mixed stuff;
    string ret;
    string subject;

    ret = create_header("Note "+str+" on board "+board);
    stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);
    if (sscanf(str, "%d", b_num) != 1 || !req->user) {
        return ret+"<b>Incorrect argument!</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    num = -1;
    for (i=0;i<sizeof(stuff);i++) {
        if (stuff[i][B_NUM] == b_num) {
            num = i+1;
        }
    }

    if (num < 1 || num > sizeof(stuff)) {
        return ret+"<b>No note of that number</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    num --;
    ret += "<h2><img src=\"http://discworld.imaginary.com/external/" +
      query_board_picture(board) + "\" alt=\" \">"
      "Reply mail to Note #" + (num + 1) + " on board " + board + "<br>'" +
      htmlify_no_address(stuff[num][B_SUBJECT]) + "'</h2>\n";

    if (sscanf(stuff[num][B_SUBJECT], "Re:#%d %s", i, subject) != 2) {
        subject = "Re:#1 "+ stuff[num][B_SUBJECT];
    } else {
        subject = "Re:#"+ ( i + 1 ) +" "+ subject;
    }

    ret += postform(subject,
                    "> " + implode(explode(
          strip_colours(sprintf("%-=76s", BOARD_HAND->get_message(board, num, req->user))), "\n"), "\n> "),
                    str, "sendmail", req, threaded);

    return ret +
      ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
} /* mail_reply() */

private string send_mail(string str, class http_request req, int threaded) {
    string ret;
    string body;
    string subject;
    string *rep_arr;
    string mail_to;
    int num;
    int i;
    int b_num;
    mixed *stuff;

    /* Whooo... */
    ret = create_header("Note "+str+" on board "+board);

    if (str && req->user) {
        if (sscanf(str, "%d", b_num) != 1) {
            return ret+"<b>Incorrect argument!</b>"+
            ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
        }

        stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);

        num = -1;
        for (i=0;i<sizeof(stuff);i++) {
            if (stuff[i][B_NUM] == b_num) {
                num = i+1;
                mail_to = stuff[i][B_NAME];
            }
        }

        if (num < 1 || num > sizeof(stuff)) {
            return ret+"<b>No note of that number</b>"+
            ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
        }

        num --;
    } else {
        return ret+"<b>Incorrect argument!</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    rep_arr = ({ " ", "", "\n", "", "\r", ""});

    if (undefinedp(req->body->data["body"]) ||
      undefinedp(req->body->data["subject"]) ||
      replace(req->body->data["body"], rep_arr) == "" ||
      replace(req->body->data["subject"], rep_arr) == "") {
        ret += "\n<!-- " + sprintf("%O", req->body) + " -->";
        ret += "\n<!-- " + req->body->data["body"] + " -->";
        ret += "\n<!-- " + req->body->data["subject"] + " -->";
        return ret + "<b>Posted data is incorrect.</b>\n" +
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    body = remove_control_chars(strip_colours(req->body->data["body"]));

    /* Format it better...  */
    body = sprintf("%-=78s", body);

    subject = remove_control_chars(req->body->data["subject"]);

    if (MAILER->do_mail_message(mail_to, req->user,
        subject,
        "",
        body)) {
        return read(str, req, 1, 0);
    } else {
        return ret + "<b>Unable to mail the message. :(</b>" +
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }
} /* send_mail() */

private string delete_message(string str, class http_request req,
                              int threaded) {
    int num, i, b_num;
    mixed stuff;
    string ret;

    ret = create_header("Note "+str+" on board "+board);
    stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);
    if (sscanf(str, "%d", b_num) != 1 || !req->user) {
        return ret+"<b>Incorrect argument!</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    num = -1;
    for (i=0;i<sizeof(stuff);i++) {
        if (stuff[i][B_NUM] == b_num) {
            num = i+1;
        }
    }

    if (num < 1 || num > sizeof(stuff)) {
        return ret+"<b>No note of that number</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    num --;
    if (BOARD_HAND->delete_message(board, num, req->user)) {
        do_delete_note(req->user);
        event( users(), "inform", req->user +
          " eats a note off "+ board + " {web}", "message", this_object() );
        if (num + 1 > sizeof(stuff)) {
            return read(stuff[num + 1][B_NUM] + "", req, 1, threaded);
        } else if (num > 0) {
            return read(stuff[num - 1][B_NUM] + "", req, 1, threaded);
        } else {
            return subjects(req, threaded);
        }
    }
    return ret + "<b>Unable to delete note " + num + " on board " + board +
    "</b>\n" +
    ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
} /* delete_message() */

private string new_message(class http_request req, int threaded) {
    string ret, tmp;

    ret = create_header("New message on board "+board);

    if (!req->user)
      return ret + "<b>Unable to post message." +
        ("/www/footer"->www_function("footer", ([ ]), req)) +
        "</body></html>";

    tmp = can_post_note(req->user, board);
    if(tmp != "")
      return ret + "<b>Unable to post a message, " + tmp + ".</b>" +
        ("/www/footer"->www_function("footer", ([ ]), req)) +
        "</body></html>";

    ret += "<h2><img src=\"http://discworld.imaginary.com/external/" +
           query_board_picture(board) + "\" alt=\" \">New hairy message on "
            "board " + board + "</h2>\n"    ;

    ret += postform("", "", 0, "post", req, threaded);

    return ret + ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
} /* new_message() */

/*
 * This returns the number of new messages.
 */
private int has_new_messages(string board,
  string user,
  mapping newsrc) {
    mixed *stuff;
    int i;
    int tim;
    int window_bottom;
    int window_top;

    stuff = BOARD_HAND->get_subjects(board, user);
    i = sizeof(stuff) - 1;
    tim = newsrc[board];
    if (i >= 0 && stuff[i][B_TIME] > tim) {
        window_bottom = 0;
        window_top = sizeof(stuff) - 1;
        while (window_bottom < window_top) {
           i = (window_bottom + window_top) / 2;
           if (stuff[i][B_TIME] > tim) {
              window_top = i;
           } else {
              window_bottom = i + 1;
           }
        }

        // Skip over our messages.  Might need to skip one more
        while (window_bottom < sizeof(stuff) &&
               lower_case(stuff[window_bottom][B_NAME]) == user) {
            window_bottom++;
        }
  
        return sizeof(stuff) - window_bottom;
    }
    return 0;
} /* has_new_messages() */

private int is_allowed_special_access(string board, string name) {
  if (_special_access_boards[board]) {
    return evaluate(_special_access_boards[board], name) ||
      PLAYER_HANDLER->test_creator(name);
  }
  if (_read_protected_boards[board]) {
    return BOARD_HAND->test_can_read(board, this_object(), name, 0);
  }
  return 1;
}  /* is_allowed_access() */

private int is_allowed_access(string board, string name) {
  if(member_array(board,_allowed_boards) != -1)
    return 1;

  if(!name)
    return 0;

  if (_special_access_boards[board]) {
    return is_allowed_special_access(board, name);
  }

  if(member_array(board, _allowed_creator_boards) != -1 &&
     PLAYER_HANDLER->test_creator(name))
    return 1;

  if (member_array(board, _allowed_playtester_boards) != -1 &&
     PLAYTESTER_HAND->query_playtester(name) || 
     PLAYER_HANDLER->test_creator(name)) {
      return 1;
  }
    
  if(board == "lordboard" && "/secure/master"->query_lord(name))
    return 1;

  return 0;
}  /* is_allowed_access() */

private string board_summary(class http_request req, int threaded) {
    string *tmp;
    mapping newsrc;
    string  *boards;
    string ret;
    //string *current_order;
    string sum;

    ret = create_header("Board Summary");

    if (!req->user) {
        return ret + "<b>Not logged on</b>\n " +
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    newsrc = BOARD_HAND->query_newsrc(req->user);
    if (!newsrc) {
        newsrc = ([ ]);
    }
    boards = get_user_board_order(req->user);

    tmp = ({ });
    tmp += get_next_new_note(req->user, newsrc, req, 0);
    tmp += ({ "<a href=\"boards.c?type=summary-all&amp;threaded=" + threaded +
                "&amp;board=frog\">All&nbsp;Boards</a>",
              "<a href=\"boards.c?type=readorder&amp;threaded=" + threaded +
                "&amp;board=frog\">Read&nbsp;Order</a>" });

    ret += "<h2><img src=\"http://discworld.imaginary.com/external/pics/tfrog-news.gif\" alt=\" \">Boards with new "
      "messages</h2>";
    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
      "&nbsp;]</strong></font>\n";
     sum = implode(map(boards, function(string board, string user, mapping newsrc, int threaded) {
                  int num;

                  num = has_new_messages(board, user, newsrc);
                  if (num && is_allowed_special_access(board, user)) { 
                     return "<dt><img src=\"http://discworld.imaginary.com/external/pics/red-ball.gif\" "
              "width=12 height=12 alt=\" o \">"
              "<a href=\"boards.c?type=subject&amp;threaded=" + threaded +
                       "&amp;board=" + replace($1, " ", "+") + "\">" +
                       capitalize($1) + "</a> [&nbsp;" + num +
                       " new message" + (num ==1 ? "" : "s") + "&nbsp;]\n";
                  } else {
                    return "";
                  }
               } ,
            req->user, newsrc, threaded), "");
    if (sum != "") {
       ret += "<dl>\n" + sum + "</dl>";
    } else {
       ret += "<br><br><strong>No boards with new messages!</strong><p>\n"
              "<h5>Enjoy it while it lasts...</h5>";
    }
    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
      "&nbsp;]</strong></font>\n";
    return ret + "/www/footer"->www_function("footer", ([ ]), req) +
      "</body></html>";
} /* board_summary() */

private string complete_board_summary(class http_request req, int threaded) {
    string *tmp;
    mapping newsrc;
    string  *boards;
    string ret;
    //string *current_order;
    string sum;

    ret = create_header("Board Summary");

    if (!req->user) {
        return ret + "<b>Not logged on</b>\n " +
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    newsrc = BOARD_HAND->query_newsrc(req->user);
    if (!newsrc) {
        newsrc = ([ ]);
    }

    boards = get_user_board_order(req->user) +
      sort_array(BOARD_HAND->list_killfile(req->user), 1);
    //current_order = BOARD_HAND->query_board_order(req->user);
    //boards = current_order + sort_array(boards - current_order, 1);
    
    tmp = ({ });
    tmp += get_next_new_note(req->user, newsrc, req, 0);
    tmp += ({ "<a href=\"boards.c?type=summary&amp;threaded=" + threaded +
                "&amp;board=frog\">"
      "Summary</a>",
      "<a href=\"boards.c?type=readorder&amp;threaded=" + threaded +
                "&amp;board=frog\">"
      "Read Order</a>" });

    /*
     * Filter out the boards which need special access but keep ones that
     * don't have new messages
     */
    boards = filter(boards, (: is_allowed_special_access($1, $2) :),
                    req->user);
    ret += "<h2><img src=\"http://discworld.imaginary.com/external/pics/tfrog-news.gif\" alt=\" \">Complete Summary</h2>";
    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
      "&nbsp;]</strong></font>\n";
    sum = implode(map(boards,
                      function(string board, string user, mapping newsrc, int threaded)
        {
          int num;
          if (is_allowed_special_access(board, user)) {
            num = has_new_messages(board, user, newsrc);
            return "<dt><img src=\"http://discworld.imaginary.com/external/pics/red-ball.gif\" "
              "width=12 height=12 alt=\" o \">"
              "<a href=\"boards.c?type=subject&amp;threaded=" + threaded +
              "&amp;"
              "board=" + replace($1, " ", "+") + "\">" +
              capitalize($1) + "</a> [&nbsp;" + num +
              " new message" + (num ==1 ? "" : "s") + "&nbsp;]\n";
                  } else {
                    return "";
                  }
               } ,
            req->user, newsrc, threaded), "");
    if (sum != "") {
       ret += "<dl>\n" + sum + "</dl>";
    } else {
       ret += "<br><br><strong>No boards you can access</strong><p>\n";
    }

    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
      "&nbsp;]</strong></font>\n";
    return ret + "/www/footer"->www_function("footer", ([ ]), req) +
      "</body></html>";
} /* complete_board_summary() */

/*
 * The action can be 'post' or 'sendmail'
 */
private string postform(string subject, string body, string note,
                        string action, class http_request req, int threaded) {
    string ret;

    if (note) {
        ret = "<form method=\"post\" action=\"boards.c?type=" + action +
        "&amp;threaded=" + threaded + "&amp;board=" + html_board +
        "&amp;note=" + note + "\">\n";
    } else {
        ret = "<form method=\"post\" action=\"boards.c?type=" + action +
        "&amp;threaded=" + threaded + "&amp;board=" + html_board +
        "\">\n";
    }
    ret += "Subject: <input name=\"subject\" type=\"text\" size=\"60\" "
        "value=\"" + replace(htmlify_no_address(subject),"\"","&#34;") + 
        "\">\n<br>";
    ret += "<font face=\"monospace\">\n";
    ret += "<textarea name=\"body\" rows=\"20\" cols=\"70\">\n";
    ret += replace_string(htmlify_no_address(body), "<br>", ""); //, "&", "&");
    ret += strip_colours(replace_string(htmlify_no_address(PLAYER_HANDLER->query_signature(req->user)), "<br>", ""));
    ret += "</textarea><br>\n</font>\n";
    if (note) {
        if (action == "post") {
            ret += "<input type=\"submit\" value=\"Post followup\">";
        } else {
            ret += "<input type=\"submit\" value=\"Mail&nbsp;reply\">";
        }
    } else {
        ret += "<input type=\"submit\" value=\"Post message\">";
    }
    ret += "<input type=\"reset\" value=\"Reset to start values\">\n</form>\n";
    return ret;
} /* postform() */

private string remove_control_chars(string str) {
    int i;

    for (i = 0; i < strlen(str); i++) {
        /* This will also change the hard space back to a space. */
        if ((str[i] < ' '  && str[i] != '\n' && str[i] != '\r') ||
          str[i] == 160 ) {
            str[i] = ' ';
        }
        if (i + 1 < strlen(str) &&
          (str[i] == '%' && str[i+1] == '^')) {
            str[i] = ' ';
            str[i + 1] = ' ';
        }
    }
    return str;
} /* remove_control_chars() */

private string post(string str, class http_request req, int threaded) {
    string ret;
    string tmp;
    string body;
    string subject;
    string *rep_arr;
    int num;
    int i;
    int b_num;
    int note_num;
    mixed *stuff;
    int no_quotes;
    int no_lines;

    /* Whooo... */
    ret = create_header("Note "+str+" on board "+board);

    if (!req->user || member_array(board, no_post_boards) != -1) {
        return ret + "<b>Unable to post message, access denied.</b>"+
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    if (str) {
        if (sscanf(str, "%d", b_num) != 1) {
            return ret+"<b>Incorrect argument!</b>"+
            ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
        }

        stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);

        num = -1;
        for (i=0;i<sizeof(stuff);i++) {
            if (stuff[i][B_NUM] == b_num) {
                num = i+1;
            }
        }

        if (num < 1 || num > sizeof(stuff)) {
            return ret+"<b>No note of that number</b>"+
            ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
        }
        num --;

        if (!can_followup_note(req->user, board, stuff[num])) {
            return ret + "<b>Unable to post this message, too many messages "
            "posted today (Maximum " + TIME_POSTING_MAXIMUM + ")</b>" +
            ("/www/footer"->www_function("footer", ([ ]), req)) +
            "</body></html>";
        }

        tmp = "> " + implode(explode(strip_colours(BOARD_HAND->get_message(board, num, req->user)),
            "\n"), "\n> ");
        note_num = stuff[num][B_NUM];
    } else {
      tmp = can_post_note(req->user, board);
      if(tmp != "")
        return ret + "<b>Unable to post a message, " + tmp + ".</b>" +
          ("/www/footer"->www_function("footer", ([ ]), req)) +
          "</body></html>";
        tmp = "test";
    }

    rep_arr = ({ " ", "", "\n", "", "\r", ""});
    tmp = replace(tmp, rep_arr);

    if (undefinedp(req->body->data["body"]) ||
      undefinedp(req->body->data["subject"]) ||
      tmp == replace(req->body->data["body"], rep_arr) ||
      replace(req->body->data["body"], rep_arr) == "" ||
      replace(req->body->data["subject"], rep_arr) == "") {
        ret += "\n<! -- " + sprintf("%O", req->body) + ">";
        ret += "\n<! -- " + req->body->data["body"] + ">";
        ret += "\n<! -- " + req->body->data["subject"] + ">";
        return ret + "<b>Posted data is incorrect.</b>\n" +
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }

    body = remove_control_chars(strip_colours(req->body->data["body"]));
    body = replace_string(body, "\r\n", "\n");
    /* Format it better...  */
    //body = sprintf("%-=78s", body);
    no_quotes = sizeof(explode(body, "\n>"));
    ret += "\n<! no quotes = " + no_quotes + ">\n";
    if (no_quotes > 5) {
        /* Strip out blank lines... */
        no_lines = sizeof(explode(replace_string(body, " ", ""), "\n") - ({ }));
        ret += "\n<! no lines = " + no_lines + ">\n";
        if (no_lines - no_quotes < no_quotes - 5) {
            return ret + "<b>You need to have as many normal "
            "lines as quoted lines.<br>NB: Notes which get around "
            "this with lots of blank space will be deleted.</b>\n" +
            ("/www/footer"->www_function("footer", ([ ]), req)) +
            "</body></html>";
        }
    }

    subject = remove_control_chars(req->body->data["subject"]);

    if (BOARD_HAND->add_message(board, capitalize(req->user),
        subject[0..80],
        body,
        note_num)) {
        if(board == "flame" || !PLAYER_HANDLER->test_creator(req->user))
            do_post_note(req->user);
        // Re-get this to move onto the nice note...
        stuff = (mixed *)BOARD_HAND->get_subjects(board, req->user);
        for (i=0;i<sizeof(stuff);i++) {
            if (stuff[i][B_NUM] == b_num) {
                // Try to move to the next note.
                if (i + 1 < sizeof(stuff)) {
                    str = stuff[i + 1][B_NUM] + "";
                }
            }
        }

        if (str) {
            return read(str, req, 1, threaded);
        } else {
          return subjects(req, threaded);
        }
    } else {
        return ret + "<b>Unable to post the note. :(</b>" +
        ("/www/footer"->www_function("footer", ([ ]), req))+"</body></html>";
    }
} /* post() */

private string read_order(class http_request req, int threaded) {
    string *board_names;
    string ret;
    string *current_order;
    string board;
    string bing;
    string *tmp;
    mapping new_order;
    int *order;
    int i;
    int pos;

    ret = create_header("Order of reading boards");

    if (!req->user) {
        ret += "<b>Not logged on</b>" +
        ("/www/footer"->www_function("footer", ([ ]), req)) +
        "</body></html>";
        return ret;
    }

    board_names = get_user_board_order(req->user);

    if (sizeof(req->body->data)) {
        new_order = ([ ]);
        foreach (bing in board_names) {
            board = replace_string(bing, " ", "+");
            if (req->body->data[board] &&
              req->body->data[board] != "default") {
                if (sscanf(req->body->data[board], "%d", pos) == 1) {
                    if (new_order[pos]) {
                        new_order[pos] += ({ bing });
                    } else {
                        new_order[pos] = ({ bing });
                    }
                }
            }
        }

        if (sizeof(new_order)) {
            order = sort_array(keys(new_order), 1);
            current_order = ({ });
            foreach (pos in order) {
                current_order += new_order[pos];
            }
        }
        BOARD_HAND->set_board_order(req->user, current_order);
    }


    /* If the order is not set, use the default. */
    if (!current_order) {
        current_order = BOARD_HAND->query_board_order(req->user);
    }

    ret += "<h2><img src=\"http://discworld.imaginary.com/external/pics/tfrog-news.gif\" alt=\" \">"
      "Order of reading boards</h2>\n";

    tmp = ({ });
    tmp += get_next_new_note(req->user, BOARD_HAND->query_newsrc(req->user),
                             req, 0);
    tmp += ({ "<a href=\"boards.c?type=summary&amp;threaded=" + threaded +
                "&amp;board=frog\">" +
      "Summary</a>" });
    tmp += ({ "<a href=\"boards.c?board=frog&amp;threaded=" + threaded +
                "&amp;type=summary-all\">"
              "All&nbsp;Boards</a>" });
    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
    "&nbsp;]</strong></font>\n";

    ret += "<blockquote>This page allows you to set the order in which the boards "
      "will be displayed for you on the web.  This sets the order "
      "for the 'next new note' button as well.  If you do not specify "
      "a postion (leave it as default) then the order will be detemined "
      "by the mud itself.  The order listed here and the board summary "
      "will always be correct.</blockquote>\n";
    ret += "<form method=post action=\"boards.c?type=readorder&amp;board=frog\">\n";



    //ret += "<table cols=2><tr>\n";
    board_names = current_order + (board_names - current_order);
    foreach (board in board_names) {
        //ret += "<td>";
        ret += "<select name=\"" + replace_string(board, " ", "+") + "\">\n";
        pos = member_array(board, current_order);
        if (pos == -1) {
            ret += "<option selected>default\n";
        } else {
            ret += "<option>default\n";
        }
        pos++;
        for (i = 1; i < sizeof(board_names) + 1; i++) {
            if (i != pos) {
                ret += "<option>" + i + "\n";
            } else {
                ret += "<option selected>" + i + "\n";
            }
        }
        ret += "</select>";
        ret += board + "<br>\n";
    }

    //ret += "</tr></table>";
    ret += "<input type=submit value=\"Set board order\">" +
    "<input type=reset value=\"Reset to start values\">\n</form>\n";

    ret += "<font size=-1><strong>[&nbsp;" + implode(tmp, " | ") +
    "&nbsp;]</strong></font>\n";

    ret += ("/www/footer"->www_function("footer", ([ ]), req)) +
    "</body></html>";

    return ret;
} /* read_order() */

string *get_allowed_boards(string name) {
    string *ret;

    ret = ({ });

    if("/secure/master"->query_lord(name))
      ret += ({ "lordboard", "complaints" });

    if (PLAYER_HANDLER->test_creator(name)) {
        ret += _allowed_creator_boards;
        ret += _allowed_playtester_boards;
    }
    if (PLAYTESTER_HAND->query_playtester (name)) {
      ret += _allowed_playtester_boards;
    }
    
    ret += _allowed_boards;

    return ret;
} /* get_allowed_boards() */

string* get_user_board_order(string user) {
    string* allowed;
    string* boards;
    class player_cache cache;

    if (_board_order[user] && _board_order[user]->order) {
       _board_order[user]->last_read = time();
       return _board_order[user]->order;
    }
    allowed = get_allowed_boards(user);
    boards = BOARD_HAND->query_board_order(user);
    allowed = boards + sort_array(allowed - boards, 1);
    allowed -= BOARD_HAND->list_killfile(user);
    cache = new(class player_cache);
    cache->order = allowed;
    cache->last_read = time();
    _board_order[user] = cache;
    return allowed;
}

/*
 * This is called when something is posted, it will increment the
 * count and fiddle with stuff.
 */
private void do_post_note(string name) {
    class posted_information bing;

    if (!undefinedp(posted_stuff[name])) {
        bing = (class posted_information)posted_stuff[name];
    } else {
        bing = new (class posted_information);
    }
    if (time() > bing->time_first_posted + TIME_INTERVAL_FOR_POSTING) {
        bing->time_first_posted = time();
        bing->count = 0;
    }
    bing->count++;
    posted_stuff[name] = bing;
    unguarded( (: save_object(SAVE_FILE) :) );
} /* do_post_note() */

/*
 * This is called when a note is eaten, it will decrement the allowed
 * number of posts.
 */
private void do_delete_note(string name) {
    class posted_information bing;

    if (!undefinedp(posted_stuff[name])) {
        bing = (class posted_information)posted_stuff[name];
        if (time() > bing->time_first_posted + TIME_INTERVAL_FOR_POSTING) {
            map_delete(posted_stuff, name);
        } else {
            bing->count--;
            posted_stuff[name] = bing;
        }
        unguarded( (: save_object(SAVE_FILE) :) );
    }
} /* do_delete_note() */

private string can_post_note(string name, string board) {
    class posted_information bing;

    if ("/secure/bastards"->query_suspended(name))  {
      return "account is suspended";
    }

    // Tests to see if you can write to the board.
    // Turn off this check.
    if (!BOARD_HAND->test_can_write(board, this_object(), name)) {
      return "no write access";
    }

    // Check to see if they are less than 6 hours old.
    if (PLAYER_HANDLER->test_age(name) > - 6 * 60 * 60) {
      return "character is too young";
    }

    // inactive players can't post.
    if(!PLAYER_HANDLER->test_active(name)) {
      return "character is inactive";
    }

    if (undefinedp(posted_stuff[name]) || (board != "flame" && PLAYER_HANDLER->test_creator(name))) {
        return "";
    }

    bing = (class posted_information)posted_stuff[name];
    if (time() > bing->time_first_posted + TIME_INTERVAL_FOR_POSTING) {
        map_delete(posted_stuff, name);
        return "";
    }


    // Upto N posts - number of days since last login.
    // Test_last returns a -ve number.
    if (bing->count < (TIME_POSTING_MAXIMUM -
        (time() - PLAYER_HANDLER->test_last(name)) / 85400)) {
        return "";
    }
    return "daily posting limit (" + TIME_POSTING_MAXIMUM + ") exceeded";
}

private int can_followup_note(string name, string board, mixed *stuff) {
    class posted_information bing;

    if ("/secure/bastards"->query_suspended(name))  {
        return 0;
    }

    // Tests to see if you can write to the board.
    if (!BOARD_HAND->test_can_write(board, this_object(), name) &&
      !stuff[B_REPLY_TYPE]) {
        return 0;
    }

    // inactive players can't post.
    if(!PLAYER_HANDLER->test_active(name))
        return 0;

    if (undefinedp(posted_stuff[name]) || (board != "flame" && PLAYER_HANDLER->test_creator(name))) {
        return 1;
    }

    bing = (class posted_information)posted_stuff[name];
    if (time() > bing->time_first_posted + TIME_INTERVAL_FOR_POSTING) {
        map_delete(posted_stuff, name);
        return 1;
    }
    // Test_last returns a -ve number.
    if (bing->count < (TIME_POSTING_MAXIMUM -
        (time() - PLAYER_HANDLER->test_last(name)) / 85400)) {
        return 1;
    }
    return 0;
} /* can_followup_note() */

void dest_me() {
    destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/www/boards.c] ---
// --- BEGIN [/mnt/home2/grok/lib/www/finger.c] ---
// Size:   File: "/mnt/home2/grok/lib/www/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626745   Available: 13574099
Inodes: Total: 5242880    Free: 4960132
5099 bytes, Last Modified:   File: "/mnt/home2/grok/lib/www/finger.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626745   Available: 13574099
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:05.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
#include "term.h"
#include <http.h>
#include <player_handler.h>

void create() {
  seteuid(getuid());
} /* create() */

int can_reference(object thing, string user) {
   string *allowed;

   if (thing->query_invis()) {
      if (!user || thing->query_login_ob()) {
         return 0;
      }
      allowed = (string *)thing->query_allowed();
      if ( pointerp( allowed ) ) {
          if ( member_array( user, allowed ) != -1 ) {
              return 1;
          }
      }
   }
   switch ( (int)thing->query_invis() ) {
      case 3 :
         return (int)master()->query_trustee( user );
      case 2 :
         return (int)master()->query_director( user );
      case 1 :
         return (int)PLAYER_HANDLER->test_creator( user );
      default :
         return 1;
   }
} /* can_reference() */

/**
 * This function is from /www/boards.c, it effectively removes embedded
 * HTML. 
 * @param str the string to remove html from
 */
string htmlify_no_address(string str) {
    return replace(str, ({
        "&", "&amp;",
        "<", "&lt;",
        ">", "&gt;",
        /* " ", "&nbsp;", */ 
        "\n", "<br>\n",
      }) );
} /*  htmlify_no_address() */


string www_who_line(object ob, string user) {
  string ret, tmp;

  if(!can_reference(ob, user)) {
    return "";
  }
  
  ret = "<B><A HREF=\"/" + (user?"secure/":"") +
    "finger.c?player="+ob->query_name()+
    "\">"+ob->query_cap_name()+"</A></B>";
  if(ob->query_property("guest"))
    ret += " guest of Discworld";
  else if (tmp = (string)ob->query_gtitle())
    ret += htmlify_no_address(" " + tmp);
  else
    ret += " the adventurer";
  if (tmp = (string)ob->query_property("player_title"))
    ret += htmlify_no_address(", " + tmp);
  if (tmp = (string)ob->query_title())
    ret += htmlify_no_address(", " + tmp);
/*
  if (tmp = (string)ob->query_atitle())
    ret += " (" + tmp + ")";
 */

  switch(ob->query_object_type()) {
  case "T":
    ret += " <B>Trustee</B>";
    break;
  case "D":
    ret += " <B>Director</B>";
    break;
  case "S":
    ret += " <B>Senior Creator</B>";
    break;
  case "C":
    ret += " <B>Creator</B>";
    break;
  case "p":
    ret += " <B>Playtester</B>";
    break;
  }
  switch ( ob->query_invis() ) {
    case 3 :
      ret += ", <b>(Trustee Invisible)</b>";
      break;
    case 2 :
      ret += ", <b>(Director Invisible)</b>";
      break;
    case  1 :
      ret += ", <b>(Invisible)</b>";
      break;
  }
  ret += "<BR>\n";
  return ret; 
}

string www_request(string name, mapping names, class http_request req) {
  string ret;

  ret = "<html><head>"
      "<title>Discworld's player information center</title>"+
      "</head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" "
      "VLINK=\"#b57339\"><font face=\"arial,helvetica\">"
      "<h2>Player Information Centre</h2>";
  ret += "<!-- " + req->user+ "(ps: to whoever noticed this, sorry, your right) -->\n";
    
  if (mapp(names) && names["player"]) {
    string finger;

    names["player"] = htmlify_no_address(names["player"]);
    ret += "<h3>Information on "+capitalize(names["player"])+":</h3>";
    names["player"] = lower_case(names["player"]);

//    if (file_size("/d/"+names["player"]) != -1) {
//      ret += "/www/domains"->domain_info(names["player"]);
//    } else {
      if (file_size("/w/"+names["player"]+"/public_html/index.html") > 0)
        ret += "<h4><a href=\"../~"+names["player"]+"/index.html\">"+
               capitalize(names["player"])+"'s home page</a></h4>";

      finger = "/secure/finger"->www_finger_info(names["player"], req->user);
      if (finger)
        ret += finger;
      else
        ret += "Sorry, "+names["player"]+" has not visited us yet.  "
               "Perhaps you should "
               "suggest it to them.<p>\n";
//    }
  } else {
    object *players;
    string tmp;
    int i;
    
    players = filter(users(), (: $1 :));

    if(!sizeof(players))
      ret += "<h3>There is noone logged on at the moment.</h3>";
    else {
      players = sort_array(players, (: strcmp($1->query_name(), 
                                         $2->query_name()) :) );
      ret += sprintf("<h3>There are currently %d players on Discworld.</h3>",
                     sizeof(users()));
    
      for(i=0; i<sizeof(players); i++) {
        tmp = www_who_line(players[i], req->user);
        if(tmp)
          ret += tmp;
      }
    }
    ret += "<hr><form action=\"finger.c\" METHOD=GET>"+
      "<b>Query:</b> <input type=\"text\" name=\"player\" size=62><p>"+
        "<p>"+
          "<input type=\"submit\" value=\"Find info\">"+
            "<input type=\"reset\" value=\"Reset\">"+
              "</form>";
  }

  if (!req->user) {
     ret += "<hr width=50%>\n <center><b>"
            "<a href=\"http://discworld.imaginary.com:5678/secure/finger.c";
     if (mapp(names) && names["player"]) {
        ret += "?player=" + names["player"];
     }
     ret += "\">[ Login ]</a></b></center>\n";
  }

  ret = strip_colours(ret);
  ret += "/www/footer"->www_function("footer", ([ ]), req);
  return ret;
} /* www_request() */
// --- END [/mnt/home2/grok/lib/www/finger.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/rituals/agoraphobia.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/rituals/agoraphobia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626743   Available: 13574097
Inodes: Total: 5242880    Free: 4960132
251 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/rituals/agoraphobia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626743   Available: 13574097
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
Agoraphobia
Discworld ritual help
Agoraphobia

.SH Name
.SP 5 5
Agoraphobia -- Invokes a fear of wide spaces in a target.
.EP

.SH Description
.SP 5 5
Agoraphobia invokes a fear of wide open spaces in a target, forcing them to run for safety.
.EP
// --- END [/mnt/home2/grok/lib/doc/rituals/agoraphobia.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.scabbard.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626743   Available: 13574097
Inodes: Total: 5242880    Free: 4960132
1621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626743   Available: 13574097
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
scabbard.c
DW_wibble autodoc help
scabbard.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/container and /std/basic/wearable.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/virtual.h and /include/move_failures.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^no_types_in_long%^RESET%^
.EI
.SI 5
int no_types_in_long()
.EI

.SI 3
* %^BOLD%^query_scabbard%^RESET%^
.EI
.SI 5
int query_scabbard()
.EI
.SP 7 5

This method determines if the object is a scabbard or not.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
always returns 1 for a scabbard

.EP

.SI 3
* %^BOLD%^query_types%^RESET%^
.EI
.SI 5
string * query_types()
.EI
.SP 7 5

This method returns the types of weapons that can be sheathed in the
scabbard.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the types that can be sheathed

.EP

.SI 3
* %^BOLD%^set_no_types_in_long%^RESET%^
.EI
.SI 5
int set_no_types_in_long(int val)
.EI

.SI 3
* %^BOLD%^set_types%^RESET%^
.EI
.SI 5
void set_types(string * words)
.EI
.SP 7 5

This method sets the types of weapons that can be sheathed in the
scabbard.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
words - the array of types that can be sheathed

.EP

.SI 3
* %^BOLD%^setup_scabbard%^RESET%^
.EI
.SI 5
void setup_scabbard(int number)
.EI
.SP 7 5

This method sets up the scabbards current condition.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
number - the current condition fo the scabbard

.EP

.SI 3
* %^BOLD%^test_type_ok%^RESET%^
.EI
.SI 5
int test_type_ok(object thing, int flag)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.scabbard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.roommak.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.roommak.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626742   Available: 13574096
Inodes: Total: 5242880    Free: 4960132
280 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.roommak.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626742   Available: 13574096
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
roommak.c
DW_wibble autodoc help
roommak.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/object.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^do_new%^RESET%^
.EI
.SI 5
int do_new(string str)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.roommak.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.fence.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.fence.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626742   Available: 13574096
Inodes: Total: 5242880    Free: 4960132
2303 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.fence.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626742   Available: 13574096
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
fence.c
DW_wibble autodoc help
fence.c

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/monster.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/money.h, /include/armoury.h, /include/move_failures.h and /include/shops/bank.h.
.EP

.SH Classes

.SI 3
* %^BOLD%^hist_offer%^RESET%^
class hist_offer {
                   object ob;
                   int old_offer;
                   int value;
}

.EI

.SI 3
* %^BOLD%^offer%^RESET%^
class offer {
              object who;
              int amount;
              int offer_time;
              object * objects;
}

.EI


.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^attack_by%^RESET%^
.EI
.SI 5
int attack_by(object ob)
.EI

.SI 3
* %^BOLD%^busy%^RESET%^
.EI
.SI 5
int busy()
.EI

.SI 3
* %^BOLD%^calc_place%^RESET%^
.EI
.SI 5
string calc_place()
.EI

.SI 3
* %^BOLD%^check_cont%^RESET%^
.EI
.SI 5
void check_cont()
.EI

.SI 3
* %^BOLD%^cost_str%^RESET%^
.EI
.SI 5
string cost_str(int amt)
.EI

.SI 3
* %^BOLD%^cost_string%^RESET%^
.EI
.SI 5
string cost_string(object thing, string place, object buyer)
.EI

.SI 3
* %^BOLD%^do_fence%^RESET%^
.EI
.SI 5
int do_fence(object * in_dir, string direct, string indirect, mixed args, string format)
.EI

.SI 3
* %^BOLD%^do_no%^RESET%^
.EI
.SI 5
void do_no(object player)
.EI

.SI 3
* %^BOLD%^do_yes%^RESET%^
.EI
.SI 5
void do_yes(object person)
.EI

.SI 3
* %^BOLD%^event_exit%^RESET%^
.EI
.SI 5
void event_exit(object ob, string message, object to)
.EI

.SI 3
* %^BOLD%^give_back%^RESET%^
.EI
.SI 5
void give_back()
.EI

.SI 3
* %^BOLD%^judge_value%^RESET%^
.EI
.SI 5
int judge_value(object ob, string type)
.EI

.SI 3
* %^BOLD%^query_cont%^RESET%^
.EI
.SI 5
object query_cont()
.EI

.SI 3
* %^BOLD%^query_cost%^RESET%^
.EI
.SI 5
int query_cost(object thing, object buyer)
.EI

.SI 3
* %^BOLD%^query_current_offer%^RESET%^
.EI
.SI 5
string query_current_offer()
.EI

.SI 3
* %^BOLD%^query_item_type%^RESET%^
.EI
.SI 5
string query_item_type(object ob)
.EI

.SI 3
* %^BOLD%^scaled_value%^RESET%^
.EI
.SI 5
int scaled_value(int n)
.EI

.SI 3
* %^BOLD%^set_fence_type%^RESET%^
.EI
.SI 5
void set_fence_type(string str)
.EI

.SI 3
* %^BOLD%^whisper%^RESET%^
.EI
.SI 5
void whisper(object ob, string message)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.fence.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.ring.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626741   Available: 13574095
Inodes: Total: 5242880    Free: 4960132
1075 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.ring.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626741   Available: 13574095
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
ring.c
DW_wibble autodoc help
ring.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/basic/artifact and /obj/armour.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/tasks.h and /include/artifacts.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^do_twist%^RESET%^
.EI
.SI 5
int do_twist()
.EI

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping map)
.EI

.SI 3
* %^BOLD%^init_static_arg%^RESET%^
.EI
.SI 5
void init_static_arg(mapping map)
.EI

.SI 3
* %^BOLD%^long%^RESET%^
.EI
.SI 5
string long(int word, int dark)
.EI

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_magic_ring%^RESET%^
.EI
.SI 5
int query_magic_ring()
.EI

.SI 3
* %^BOLD%^query_static_auto_load%^RESET%^
.EI
.SI 5
mapping query_static_auto_load()
.EI

.SI 3
* %^BOLD%^set_weight%^RESET%^
.EI
.SI 5
void set_weight(int number)
.EI

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed * stats()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.ring.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.lantern.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626741   Available: 13574095
Inodes: Total: 5242880    Free: 4960132
1396 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.lantern.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626741   Available: 13574095
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
lantern.c
DW_wibble autodoc help
lantern.c

.SH Description
.SP 5 5

This method returns the maximum amount of fuel for the object.

.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /std/object.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/fuel_handler.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^consume_fuel%^RESET%^
.EI
.SI 5
void consume_fuel()
.EI

.SI 3
* %^BOLD%^do_dowse%^RESET%^
.EI
.SI 5
int do_dowse()
.EI

.SI 3
* %^BOLD%^do_extinguish%^RESET%^
.EI
.SI 5
int do_extinguish()
.EI

.SI 3
* %^BOLD%^do_light%^RESET%^
.EI
.SI 5
int do_light()
.EI

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping arg)
.EI

.SI 3
* %^BOLD%^out_of_fuel%^RESET%^
.EI
.SI 5
void out_of_fuel()
.EI

.SI 3
* %^BOLD%^pretty_plural%^RESET%^
.EI
.SI 5
string pretty_plural(object thing)
.EI

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_fuel_left%^RESET%^
.EI
.SI 5
int query_fuel_left()
.EI

.SI 3
* %^BOLD%^query_max_fuel%^RESET%^
.EI
.SI 5
int query_max_fuel()
.EI

.SI 3
* %^BOLD%^set_fuel_left%^RESET%^
.EI
.SI 5
void set_fuel_left(int i)
.EI

.SI 3
* %^BOLD%^short%^RESET%^
.EI
.SI 5
string short(int i)
.EI

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed * stats()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.lantern.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.container.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626740   Available: 13574094
Inodes: Total: 5242880    Free: 4960132
10702 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626740   Available: 13574094
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
container.c
DW_wibble autodoc help
container.c

.SH Description
.SP 5 5

This is main container type object that players will use.  For
example, buckets and stuff would use this.  A backpack would be
a type of clothing and a potion bottle should be a vessel.
.EP
.SP 10 5


Written by Who knows, Pinkfish, Ember, Jeremy
.EP



.SH See also
.SP 5 5
/obj/vessel.c and /obj/clothing.c

.EP
.SH Inherits
.SP 5 5
This class inherits the following classes /std/container and /std/basic/close_lock_container.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/move_failures.h, /include/parse_command.h and /include/potion_attrs.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_ps_vect%^RESET%^
.EI
.SI 5
void add_ps_vect(int * v, int quant)
.EI
.SP 7 5

This method adds a potion space vector with a particular
quantity to the object.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
v - the vector to add
.EP
.SP 9 5
quant - the quantity to add

.EP

.SI 3
* %^BOLD%^begin_config%^RESET%^
.EI
.SI 5
void begin_config()
.EI

.SI 3
* %^BOLD%^change_concentration%^RESET%^
.EI
.SI 5
mixed * change_concentration(mixed * potion, int new_conc)
.EI
.SP 7 5

This method changes the concentration of the liquid to be a new
and exciting concentration.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
potion - the potion to change the concentration of
.EP
.SP 9 5
new_conc - the new concentration of the liquid

.EP

.SI 3
* %^BOLD%^check_breakages%^RESET%^
.EI
.SI 5
void check_breakages()
.EI
.SP 7 5

This method checks to see if any of the things contained in the
container should be broken.
.EP

.SI 3
* %^BOLD%^config%^RESET%^
.EI
.SI 5
void config(int vari, mixed cont)
.EI

.SI 3
* %^BOLD%^consistency_string%^RESET%^
.EI
.SI 5
string consistency_string(int cons)
.EI

.SI 3
* %^BOLD%^contents_vect%^RESET%^
.EI
.SI 5
int * contents_vect()
.EI
.SP 7 5

This method returns the vector of the contents of the container.
This is based on the vectors of all the liquid with a vector set
on them.

.EP

.SI 3
* %^BOLD%^dest_active_contents%^RESET%^
.EI
.SI 5
int dest_active_contents()
.EI
.SP 7 5

This method will destroy all the liquid contents of the object.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the number of object destroyed

.EP

.SI 3
* %^BOLD%^empty_formula%^RESET%^
.EI
.SI 5
int empty_formula()
.EI
.SP 7 5

This method returns the amount of the liquid you can actually empty
from a container.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the amount of liquid that can be emptied

.EP

.SI 3
* %^BOLD%^end_config%^RESET%^
.EI
.SI 5
void end_config()
.EI

.SI 3
* %^BOLD%^ensure_open%^RESET%^
.EI
.SI 5
int ensure_open()
.EI
.SP 7 5

This method returns true if the object is open and prints a message
about the open status of the object.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it is open, 0 if not

.EP

.SI 3
* %^BOLD%^fullness_adjectives%^RESET%^
.EI
.SI 5
string * fullness_adjectives()
.EI
.SP 7 5

This returns an adjective for how full the current object is with
liquid.  This is used in the parse command handling code.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the fullness adjective
.EP

.SI 3
* %^BOLD%^liquid_name%^RESET%^
.EI
.SI 5
string liquid_name()
.EI
.SP 7 5

This method returns the name of the current liquid inside the container.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the name of the current liquid

.EP

.SI 3
* %^BOLD%^merge_potions%^RESET%^
.EI
.SI 5
mixed * merge_potions(mixed * potion1, mixed * potion2, int vol1, int vol2, int tot_vol)
.EI

.SI 3
* %^BOLD%^mix_liq%^RESET%^
.EI
.SI 5
mixed * mix_liq(mixed * arr1, mixed * arr2, int vol1, int vol2, int tot_vol)
.EI

.SI 3
* %^BOLD%^parse_command_adjectiv_id_list%^RESET%^
.EI
.SI 5
string * parse_command_adjectiv_id_list()
.EI

.SI 3
* %^BOLD%^parse_command_id_list%^RESET%^
.EI
.SI 5
string * parse_command_id_list()
.EI

.SI 3
* %^BOLD%^query_active_attrs%^RESET%^
.EI
.SI 5
int * query_active_attrs()
.EI

.SI 3
* %^BOLD%^query_all_attrs%^RESET%^
.EI
.SI 5
int * query_all_attrs()
.EI

.SI 3
* %^BOLD%^query_frac_parse_id%^RESET%^
.EI
.SI 5
object query_frac_parse_id(mixed * arr)
.EI

.SI 3
* %^BOLD%^query_full_weight%^RESET%^
.EI
.SI 5
int query_full_weight()
.EI
.SP 7 5

This method returns the full weight of the container.
.EP

.SI 3
* %^BOLD%^query_leak_rate%^RESET%^
.EI
.SI 5
int query_leak_rate()
.EI
.SP 7 5

This method returns the leak rate of the container
.EP

.SI 3
* %^BOLD%^query_liquid_short%^RESET%^
.EI
.SI 5
string query_liquid_short()
.EI
.SP 7 5

This method returns the short description of the liquid.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the short description of the liquid
.EP

.SI 3
* %^BOLD%^query_max_volume%^RESET%^
.EI
.SI 5
int query_max_volume()
.EI
.SP 7 5

This method returns the current maxium volume associated with this
container.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current maximum volume

.EP

.SI 3
* %^BOLD%^query_misc_attrs%^RESET%^
.EI
.SI 5
int * query_misc_attrs()
.EI

.SI 3
* %^BOLD%^query_parse_id%^RESET%^
.EI
.SI 5
object query_parse_id(mixed * arr)
.EI

.SI 3
* %^BOLD%^query_ps_coord%^RESET%^
.EI
.SI 5
int * query_ps_coord()
.EI
.SP 7 5

This method returns the potion space co-ordinates of the liquid.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the potion space co-ordinates
.EP

.SI 3
* %^BOLD%^query_ps_quantity%^RESET%^
.EI
.SI 5
int query_ps_quantity()
.EI
.SP 7 5

This method returns the quantity of liquid at the potion space.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the quantity of liquid
.EP

.SI 3
* %^BOLD%^query_volume%^RESET%^
.EI
.SI 5
int query_volume()
.EI
.SP 7 5

This method returns the current amount of liquid in the container.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current amount of liquid in the container

.EP

.SI 3
* %^BOLD%^query_volume_left%^RESET%^
.EI
.SI 5
int query_volume_left()
.EI
.SP 7 5

This method returns the amount of volume left for liquids to be
added into.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the amount of volume left
.EP

.SI 3
* %^BOLD%^query_water_volume%^RESET%^
.EI
.SI 5
int query_water_volume()
.EI
.SP 7 5

This method returns the volume of water in the container.
.EP

.SI 3
* %^BOLD%^query_weight_left%^RESET%^
.EI
.SI 5
int query_weight_left()
.EI
.SP 7 5

This method returns the current amount of weight left that can
be filled on the container.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current amount of weight left

.EP

.SI 3
* %^BOLD%^remove_volume%^RESET%^
.EI
.SI 5
int remove_volume(int vol_lost)
.EI
.SP 7 5

This method removes some volume of liquid from the container.
.EP

.SI 3
* %^BOLD%^set_full_weight%^RESET%^
.EI
.SI 5
void set_full_weight(int i)
.EI
.SP 7 5

This method sets the weight of the container when it is full.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the new weight of the containe when full.
.EP

.SI 3
* %^BOLD%^set_leak_rate%^RESET%^
.EI
.SI 5
void set_leak_rate(int i)
.EI
.SP 7 5

This method sets the leak rate of the container.  The leak rate is how
fast stuff leaks out of the container.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the new leak rate of the container
.EP

.SI 3
* %^BOLD%^set_max_volume%^RESET%^
.EI
.SI 5
void set_max_volume(int i)
.EI
.SP 7 5

This method sets the maximum volume of the container.  This also
sets the maximum weight of the container to one tenth of the
volume (if there is not current maximum weight).
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the new maximum volume
.EP

.SI 3
* %^BOLD%^set_max_weight%^RESET%^
.EI
.SI 5
void set_max_weight(int i)
.EI
.SP 7 5

This method sets the maximum weight of the container.  This also sets
the maximum volume of the container to 10 times its maximum weight.
(If there is no current maximum volume).
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the maxium weight of the container
.EP

.SI 3
* %^BOLD%^set_misc_attrs%^RESET%^
.EI
.SI 5
void set_misc_attrs(mixed * new_misc_attrs, int misc_vol)
.EI

.SI 3
* %^BOLD%^set_ps_coord_quantity%^RESET%^
.EI
.SI 5
void set_ps_coord_quantity(int * new_coord, int new_quantity)
.EI
.SP 7 5

This method sets the quantity of the position space co-ordinate
to be the new quantity.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
new_coord - the new co-ordinate of the liquid
.EP
.SP 9 5
new_quantity - the new quantity of the liquid

.EP

.SI 3
* %^BOLD%^set_ps_quantity%^RESET%^
.EI
.SI 5
void set_ps_quantity(int n)
.EI

.SI 3
* %^BOLD%^set_volume%^RESET%^
.EI
.SI 5
void set_volume(int i)
.EI
.SP 7 5

This method sets the current amount of liquid in the container.  If
the container has a leak rate, it starts to leak.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the new amount of liquid in the containe
.EP

.SI 3
* %^BOLD%^set_water_volume%^RESET%^
.EI
.SI 5
void set_water_volume(int n)
.EI
.SP 7 5

This method sets the volume of water in the container.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
n - the new volume of water

.EP

.SI 3
* %^BOLD%^sort_func%^RESET%^
.EI
.SI 5
int sort_func(int * x, int * y)
.EI

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed stats()
.EI

.SI 3
* %^BOLD%^test_add%^RESET%^
.EI
.SI 5
int test_add(object ob, int flag)
.EI
.SP 7 5

This method stops the container being added when it is 
closed.  It also handles the same flags as the liing
object.  We assume this is not the same
as the default containers used
by things like item rooms and such.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
ob - the object being added
.EP
.SP 9 5
flag - the addition flag
.EP

.SI 3
* %^BOLD%^transfer_liquid_to%^RESET%^
.EI
.SI 5
void transfer_liquid_to(object dest, int vol_misc, mixed * misc, int vol_water, int * coord, int quantity)
.EI
.SP 7 5

This method does the actual liquid transfer, as needed by the
filling, emptying and pour operations.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
dest - where the liquid is to go
.EP
.SP 9 5
vol_misc - the volume of non-water to move
.EP
.SP 9 5
misc - the attributes for the non-water
.EP
.SP 9 5
vol_water - the volume of water to move
.EP
.SP 9 5
coord - the co-ordinate of the liquid
.EP
.SP 9 5
quantity - the quantity of the potion space liquid

.EP

.SI 3
* %^BOLD%^transparency_string%^RESET%^
.EI
.SI 5
string transparency_string(int trans)
.EI

.SI 3
* %^BOLD%^update_potion_parse%^RESET%^
.EI
.SI 5
void update_potion_parse()
.EI
.SP 7 5

This method updates the values used for the find_match() parseing
due to the liquids.
.EP

.SI 3
* %^BOLD%^void_liquid%^RESET%^
.EI
.SI 5
void void_liquid()
.EI
.SP 7 5

This method zaps all the liquid stuff in the container.

.EP


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.container.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.implement.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.implement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626737   Available: 13574091
Inodes: Total: 5242880    Free: 4960132
1360 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.implement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626737   Available: 13574091
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
implement.c
DW_wibble autodoc help
implement.c

.SH Description
.SP 5 5

This is a generic held implement used for cutlery, lockpicks, tissues,
basically anything you could hold in your hand but which would not be a
weapon. Now of course you could try and fight someone with a dessert
spoon but it would be pretty silly so use this instead of a weapon.

Best way to use this is via the .imp virtual object.

.EP
.SP 10 5


Written by Ceres
.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /std/basic/holdable and /std/object.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/money.h, /include/virtual.h, /include/move_failures.h and /include/shops/bank.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping map,  object)
.EI

.SI 3
* %^BOLD%^init_static_arg%^RESET%^
.EI
.SI 5
void init_static_arg(mapping map)
.EI

.SI 3
* %^BOLD%^int_query_static_auto_load%^RESET%^
.EI
.SI 5
mapping int_query_static_auto_load()
.EI

.SI 3
* %^BOLD%^player_wield%^RESET%^
.EI
.SI 5
void player_wield(int pos)
.EI

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_static_auto_load%^RESET%^
.EI
.SI 5
mapping query_static_auto_load()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.implement.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.peddler.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.peddler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626737   Available: 13574091
Inodes: Total: 5242880    Free: 4960132
6609 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.peddler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626737   Available: 13574091
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
peddler.c
DW_wibble autodoc help
peddler.c

.SH Description
.SP 5 5

This is the peddler object, it acts as a walking talking item
shop.
Added event_enter so to stop food from decaying when the peddler
sells it. Siel, October 2001


.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/monster and /std/shops/inherit/clone_on_demand.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/money.h, /include/move_failures.h, /include/armoury.h, /include/virtual.h and /include/shops/bank.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^cost_string%^RESET%^
.EI
.SI 5
string cost_string(object thing, string place, object buyer)
.EI
.SP 7 5

This method returns the costs of the item as a string.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
thing - the thing to buy
.EP
.SP 9 5
place - the money area it is being bought in
.EP
.SP 9 5
buyer - the person who is buying the object
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the string money value

.EP

.SI 3
* %^BOLD%^do_browse%^RESET%^
.EI
.SI 5
int do_browse(mixed indirect_obs, string dir_match, string indir_match, string * words)
.EI
.SP 7 5

The main entrace to the browse for things command.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^do_buy%^RESET%^
.EI
.SI 5
int do_buy(mixed indirect_obs, string dir_match, string indir_match, string * words)
.EI
.SP 7 5

The main entrace to the buy things command.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^do_list%^RESET%^
.EI
.SI 5
int do_list()
.EI
.SP 7 5

The main entrace to the list stuff command.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^event_enter%^RESET%^
.EI
.SI 5
void event_enter(object ob, string mess, object from)
.EI

.SI 3
* %^BOLD%^event_exit%^RESET%^
.EI
.SI 5
void event_exit(object ob, string message, object to)
.EI

.SI 3
* %^BOLD%^query_cost%^RESET%^
.EI
.SI 5
int query_cost(object thing, object buyer)
.EI
.SP 7 5

This method returns the cost of the specified item to the buyer.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
thing - the thing to cost
.EP
.SP 9 5
buyer - who is buying it
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the cost of the item

.EP

.SI 3
* %^BOLD%^sell_thing%^RESET%^
.EI
.SI 5
void sell_thing(object player, object thing)
.EI
.SP 7 5

The main entrace to the sell stuff command.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^set_all_out_mess%^RESET%^
.EI
.SI 5
void set_all_out_mess(string s)
.EI
.SP 7 5

Overrides the default chat of the item being out of stock when a player
tries to buy it
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with.  Must include $item$, which
will be replaced by the item short.

.EP

.SI 3
* %^BOLD%^set_busy_mess%^RESET%^
.EI
.SI 5
void set_busy_mess(string s)
.EI
.SP 7 5

Overrides the default chat of the peddler being busy selling
something already.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with

.EP

.SI 3
* %^BOLD%^set_dont_sell_mess%^RESET%^
.EI
.SI 5
void set_dont_sell_mess(string s)
.EI
.SP 7 5

Overrides the default chat of the peddler not selling an item
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with.  Must include $item$, which
will be replaced by the item short.

.EP

.SI 3
* %^BOLD%^set_in_combat_mess%^RESET%^
.EI
.SI 5
void set_in_combat_mess(string s)
.EI
.SP 7 5

Overrides the default chat of the peddler being in combat and hence unable
to sell his wares!
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with

.EP

.SI 3
* %^BOLD%^set_list_item_mess%^RESET%^
.EI
.SI 5
void set_list_item_mess(string s)
.EI
.SP 7 5

Overrides the default chat of listing a stock item's price and stock
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with.  Must include $num_left$,
$display$ and $cost$, which will be replaced by the appropriate
strings.

.EP

.SI 3
* %^BOLD%^set_list_mess%^RESET%^
.EI
.SI 5
void set_list_mess(string s)
.EI
.SP 7 5

Overrides the default chat to announcing the stock list
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with

.EP

.SI 3
* %^BOLD%^set_missing_punter_mess%^RESET%^
.EI
.SI 5
void set_missing_punter_mess(string s)
.EI
.SP 7 5

Overrides the default chat to the player having wandered off
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with

.EP

.SI 3
* %^BOLD%^set_no_stock_mess%^RESET%^
.EI
.SI 5
void set_no_stock_mess(string s)
.EI
.SP 7 5

Overrides the default reply to having no listable stock
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with

.EP

.SI 3
* %^BOLD%^set_none_left_mess%^RESET%^
.EI
.SI 5
void set_none_left_mess(string s)
.EI
.SP 7 5

Overrides the default reply to having none left
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with

.EP

.SI 3
* %^BOLD%^set_out_of_item_mess%^RESET%^
.EI
.SI 5
void set_out_of_item_mess(string s)
.EI
.SP 7 5

Overrides the default chat of being out of an item that is browsed
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with.  Must include $item$, which
will be replaced by the item short.

.EP

.SI 3
* %^BOLD%^set_show_item_mess%^RESET%^
.EI
.SI 5
void set_show_item_mess(string s)
.EI
.SP 7 5

Overrides the default chat of showing an item to a player
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with.  Must include $item$ and
$cost$, which will be replaced by the item short and the cost of the item
respectively.

.EP

.SI 3
* %^BOLD%^set_too_heavy_mess%^RESET%^
.EI
.SI 5
void set_too_heavy_mess(string s)
.EI
.SP 7 5

Overrides the default chat of the player being too burdened to carry an
item
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with.  Must include $item$, which
will be replaced by the item short.

.EP

.SI 3
* %^BOLD%^set_too_poor_mess%^RESET%^
.EI
.SI 5
void set_too_poor_mess(string s)
.EI
.SP 7 5

Overrides the default chat of the player being too poor to buy an item
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the chat to replace the default with.  Must include $item$, which
will be replaced by the item short.

.EP


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.peddler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.surf_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.surf_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626735   Available: 13574089
Inodes: Total: 5242880    Free: 4960132
667 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.surf_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626735   Available: 13574089
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
surf_save.c
Dead DW2 autodoc help
surf_save.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/surface.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^check_euid%^RESET%^
.EI
.SI 5
void check_euid()
.EI

.SI 3
* %^BOLD%^do_load%^RESET%^
.EI
.SI 5
void do_load()
.EI

.SI 3
* %^BOLD%^do_save%^RESET%^
.EI
.SI 5
void do_save()
.EI

.SI 3
* %^BOLD%^set_save_file%^RESET%^
.EI
.SI 5
void set_save_file(string file)
.EI

.SI 3
* %^BOLD%^test_add%^RESET%^
.EI
.SI 5
int test_add(object ob, int flag)
.EI

.SI 3
* %^BOLD%^test_remove%^RESET%^
.EI
.SI 5
int test_remove(object ob, int flag)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.surf_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.staff.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.staff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626735   Available: 13574089
Inodes: Total: 5242880    Free: 4960132
1080 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.staff.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626735   Available: 13574089
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
staff.c
Dead DW2 autodoc help
staff.c

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/weapon and /std/basic/artifact.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/tasks.h and /include/artifacts.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^do_invoke%^RESET%^
.EI
.SI 5
int do_invoke()
.EI

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping map)
.EI

.SI 3
* %^BOLD%^init_static_arg%^RESET%^
.EI
.SI 5
void init_static_arg(mapping map)
.EI

.SI 3
* %^BOLD%^long%^RESET%^
.EI
.SI 5
string long(int word, int dark)
.EI

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_magic_staff%^RESET%^
.EI
.SI 5
int query_magic_staff()
.EI

.SI 3
* %^BOLD%^query_static_auto_load%^RESET%^
.EI
.SI 5
mapping query_static_auto_load()
.EI

.SI 3
* %^BOLD%^set_weight%^RESET%^
.EI
.SI 5
void set_weight(int number)
.EI

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed * stats()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.staff.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.food.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.food.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626734   Available: 13574088
Inodes: Total: 5242880    Free: 4960132
23601 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.food.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626734   Available: 13574088
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
food.c
DW_wibble autodoc help
food.c

.SH Description
.SP 5 5


.EP
.SP 5 5
This is the main inheritable for food objects. It allows you to create food and drink. Virtual files may also be coded if given the *.food extention. There are many examples of these virtual food files in the /obj/food directory. Food does the following things. 
.EP
.SP 5 5

.EP
.SP 5 5
- It can be eaten or drunk. 
.EP
.SP 5 5
- Food can be changed from solid to liquid with set_liquid(), and changed from liquid to solid with reset_liquid(). 
.EP
.SP 5 5
- The weight of each bite can be set with set_weight_per_bite(). 
.EP
.SP 5 5
- Effects can be added to the player when they are splashed with the food, get food rubbed on them, or get food applied to them with add_external_effect. 
.EP
.SP 5 5
- Splashing, applying, and rubbing can be pk-checked with set_external_pk_check() 
.EP
.SP 5 5
- Splashing can be activated with set_splashable() 
.EP
.SP 5 5
- Splashing can be deactivated with unset_splashable() 
.EP
.SP 5 5
- Applying can be activated with set_applicable() 
.EP
.SP 5 5
- Applying can be deactivated with unset_applicable() 
.EP
.SP 5 5
- Effects can be added to the player when they consume the food with add_eat_effect(). 
.EP
.SP 5 5
- Functions can be added to be carried out when the food is consumed with add_eat_func(). This function can be stored on another object if the set_eat_object() is used. 
.EP
.SP 5 5
- An eat message can be set with set_eat_mess(). 
.EP
.SP 5 5
- Food can be cut up into pieces with sharp weapons. 
.EP
.SP 5 5
- The description of the new 'pieces' can be set using set_piece_description(), set_piece_short(), set_piece_plural(), and set_piece_substance(). 
.EP
.SP 5 5
- Non-liquid food decays and will eventually crumble to dust. 
.EP
.SP 5 5
- The decay speed can be set with set_decay_speed(). 
.EP
.SP 5 5
- Food can be 'pickled' to prevent decay using do_cure(). 
.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /std/basic/virtual_update and /obj/cont_medium.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/move_failures.h, /include/bits_controller.h, /include/drinks.h, /include/playtesters.h and /include/weapon.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_eat_effect%^RESET%^
.EI
.SI 5
int add_eat_effect(mixed word, int number)
.EI
.SP 7 5

This adds an eat effect to the food.  This will be added to
the player or NPC when the food is eaten.


The effect is added with a number as the argument. The number is based on the amount which is eaten (in weight units), and usually represents the strength of the effect. If the object is continuous, the weight is calculated from the amount and weight_unit array... 


.EP
.SP 7 5
eff_num = (amount * number * weight_unit[0]) / weight_unit[1] 

...where the number is passed into the add_eat_effect() function. If the effect already exists, then the number is added onto the existing number. 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The file name of the effect to add.
.EP
.SP 9 5
number - The number to set to the effect to.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
The current value of the effect in the mapping

.EP

.SI 3
* %^BOLD%^add_external_effect%^RESET%^
.EI
.SI 5
int add_external_effect(string word, int number)
.EI
.SP 7 5

This adds an external effect to the food.  This will be added to
the player or NPC when the liquid is splashed, applied, or rubbed on them.


The effect is added with a number as the argument. The number is based on the amount which is splashed (in weight units), and usually represents the strength of the effect. If the object is continuous, the weight is calculated from the amount and weight_unit array... 


.EP
.SP 7 5
eff_num = (amount * number * weight_unit[0]) / weight_unit[1] 

...where the number is passed into the add_external_effect() function. If the effect already exists, then the number is added onto the existing number. 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The file name of the effect to add.
.EP
.SP 9 5
number - The number to set to the effect to.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
The current value of the effect in the mapping

.EP

.SI 3
* %^BOLD%^check_for_container%^RESET%^
.EI
.SI 5
int check_for_container()
.EI
.SP 7 5

This checks the outside of us for a container and then destroys ourselves
if it is not a container.

.EP

.SI 3
* %^BOLD%^check_sharp%^RESET%^
.EI
.SI 5
int check_sharp(object weapon)
.EI
.SP 7 5

This checks to see if a weapon is sharp.  This is used later
to determine whather an object can be cut up with the weapon.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
weapon - The weapon to check to see if it is sharp.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if it is sharp, or 0 otherwise.

.EP

.SI 3
* %^BOLD%^consume%^RESET%^
.EI
.SI 5
varargs void consume(object consumer, int amount, string type)
.EI
.SP 7 5

This consumes some of the food.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
consumer - The person doing the consumption.
.EP
.SP 9 5
amount - The amount being consumed.
.EP
.SP 9 5
type - Use "splash" or "apply" or "external" to use external
 effects, anything else for eat effects.


.EP

.SI 3
* %^BOLD%^do_apply%^RESET%^
.EI
.SI 5
int do_apply(object * things)
.EI
.SP 7 5

This handles applying things

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if it succeeded, or return 0 if it failed.

.EP

.SI 3
* %^BOLD%^do_cure%^RESET%^
.EI
.SI 5
int do_cure()
.EI
.SP 7 5

This is called by the pickling stick.  It stops the food
object decaying.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
returns 1 for suceess and 0 for failure.

.EP

.SI 3
* %^BOLD%^do_cut%^RESET%^
.EI
.SI 5
varargs int do_cut(int num_pieces)
.EI
.SP 7 5

This cuts the food up into bits.  This is the command called
with add_command() and does the actual cutting up into bits.  If
the num_pieces parameter is undefined, the food is cut in half.
If the food is continuous, the cutting is handled by
the state_change handler (all continuous objects must be cut this
way).

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
num_pieces - The number of pieces to cut the food into.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it succeeded, 0 if not.

.EP

.SI 3
* %^BOLD%^do_drink%^RESET%^
.EI
.SI 5
int do_drink()
.EI
.SP 7 5

This gives the appropriate message for drinking things.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if it succeeded, or return 0 if it failed.

.EP

.SI 3
* %^BOLD%^do_dry%^RESET%^
.EI
.SI 5
int do_dry()
.EI
.SP 7 5

This method dries the food.  Dried food no longer decays.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
returns 1 for suceess and 0 for failure.

.EP

.SI 3
* %^BOLD%^do_eat%^RESET%^
.EI
.SI 5
varargs int do_eat(int no_mess)
.EI
.SP 7 5

This is the eat command call.  This is setup with add_command()
and does the actual eating.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
no_mess - don't use success messages
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 on success, 2 on success + last bit eaten and return 0 on failure.
.EP

.SI 3
* %^BOLD%^do_mince%^RESET%^
.EI
.SI 5
varargs int do_mince()
.EI

.SI 3
* %^BOLD%^do_quaff%^RESET%^
.EI
.SI 5
int do_quaff()
.EI
.SP 7 5

This gives the appropriate message for quaffing things. Its
rather like drinking but a lot of it gets splashed on you.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if it succeeded, or return 0 if it failed.

.EP

.SI 3
* %^BOLD%^do_splash%^RESET%^
.EI
.SI 5
int do_splash(object * things)
.EI

.SI 3
* %^BOLD%^query_applicable%^RESET%^
.EI
.SI 5
int query_applicable(object applier, object appliee)
.EI
.SP 7 5

This queries applicability of the food. (rubbing on someone)
Note that the food can only be applied when
set_applicable() has been called
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
applier - - Who applies it
.EP
.SP 9 5
appliee - - Who it is applied to.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it can be applied, 0 if it can't
.EP

.SI 3
* %^BOLD%^query_bites_gone%^RESET%^
.EI
.SI 5
int query_bites_gone()
.EI
.SP 7 5

This returns the number of bites that have been taken out
of the food object.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
The number of bites which have been taken from
the object.
.EP

.SI 3
* %^BOLD%^query_cured%^RESET%^
.EI
.SI 5
int query_cured()
.EI
.SP 7 5

This returns the cured state of the bit.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it is cured, 0 if not

.EP

.SI 3
* %^BOLD%^query_decay_divisor%^RESET%^
.EI
.SI 5
float query_decay_divisor()
.EI
.SP 7 5
This tells us the current divisor used to determine decay.  This can
 be modified with set_decay_speed.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
float the divisor
.EP

.SI 3
* %^BOLD%^query_decay_level%^RESET%^
.EI
.SI 5
int query_decay_level()
.EI
.SP 7 5

This returns the level of the decay.  This will be a number
between 1 and 6.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
The level of decay, which is between 1 and 6.

.EP

.SI 3
* %^BOLD%^query_decay_speed%^RESET%^
.EI
.SI 5
int query_decay_speed()
.EI
.SP 7 5

This returns the decay speed.  If this is 0 then the object
is not decaying.  This is the length of time it takes
for the whole object to decay.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
The decay speed.

.EP

.SI 3
* %^BOLD%^query_decays%^RESET%^
.EI
.SI 5
int query_decays()
.EI
.SP 7 5

This query tells us whether the food decays.  All objects
which decay should have this function on them.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if the object decays.
.EP

.SI 3
* %^BOLD%^query_dried%^RESET%^
.EI
.SI 5
int query_dried()
.EI
.SP 7 5

This returns the dried state of the bit.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it is dried, 0 if not

.EP

.SI 3
* %^BOLD%^query_eat_effects%^RESET%^
.EI
.SI 5
mapping query_eat_effects()
.EI
.SP 7 5

The eat effects of the food.  The mapping contains a set of
strings (the effect) and a number associated with the
effect.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
A mapping containing the eat effects.

.EP

.SI 3
* %^BOLD%^query_eat_func%^RESET%^
.EI
.SI 5
string query_eat_func()
.EI
.SP 7 5

This returns the name of the eat function to carry out
when the object is eaten.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
A string which is the name of the eat function.

.EP

.SI 3
* %^BOLD%^query_eat_mess%^RESET%^
.EI
.SI 5
string query_eat_mess()
.EI
.SP 7 5

This returns the eat message of the object.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
A string of text which is the eat message.

.EP

.SI 3
* %^BOLD%^query_eat_object%^RESET%^
.EI
.SI 5
string query_eat_object()
.EI
.SP 7 5

This returns the eat object on which the eat function
of the food of the food is stored.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
A string which is the the name of the eat object.

.EP

.SI 3
* %^BOLD%^query_edible%^RESET%^
.EI
.SI 5
int query_edible()
.EI
.SP 7 5

This tells us if the food is edible (ie. can be
consumed using 'eat' instead of 'drink'.  If it is
edible then it is not a liquid.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if the food is a liquid, and return 0 if it is not.

.EP

.SI 3
* %^BOLD%^query_external_effects%^RESET%^
.EI
.SI 5
mapping query_external_effects()
.EI
.SP 7 5

The external (splash,apply,rub) effects of the food.  The
mapping contains a set of strings (the effect) and a number
associated with the effect.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
A mapping containing the external effects.

.EP

.SI 3
* %^BOLD%^query_food_object%^RESET%^
.EI
.SI 5
int query_food_object()
.EI
.SP 7 5

This method returns 1 if the item is a food object.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 when it is a food object

.EP

.SI 3
* %^BOLD%^query_in_pieces%^RESET%^
.EI
.SI 5
int query_in_pieces()
.EI
.SP 7 5

If the food has been cut up (using the 'cut' command)
then this will return true.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if it is in pieces, and return 0 otherwise.

.EP

.SI 3
* %^BOLD%^query_liquid%^RESET%^
.EI
.SI 5
int query_liquid()
.EI
.SP 7 5

This function returns one if the food is a liquid.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if the food is a liquid, and return 0 if it is not.

.EP

.SI 3
* %^BOLD%^query_long_decay_level%^RESET%^
.EI
.SI 5
string query_long_decay_level()
.EI
.SP 7 5

This method returns the decay level for the object as a string, 
it is used in the long() function.

.EP

.SI 3
* %^BOLD%^query_long_eat_level%^RESET%^
.EI
.SI 5
string query_long_eat_level()
.EI
.SP 7 5

This method returns how much of the item has been nibbled on. 
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
a string used in long().

.EP

.SI 3
* %^BOLD%^query_piece_description%^RESET%^
.EI
.SI 5
string query_piece_description()
.EI
.SP 7 5

This returns the long description of the food object when
it is cut up into pieces.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
A string of text which is the piece description.

.EP

.SI 3
* %^BOLD%^query_rotten%^RESET%^
.EI
.SI 5
int query_rotten()
.EI
.SP 7 5
This tells us if the food has started to rot

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
Return 1 if the food has started to rot, 0 otherwise.

.EP

.SI 3
* %^BOLD%^query_short_rotten_adjective%^RESET%^
.EI
.SI 5
string query_short_rotten_adjective()
.EI
.SP 7 5

This method returns the current rotten adjective that's used 
in the short description for decaying objects.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
a string like slightly rotten, mostly rotten, etc.

.EP

.SI 3
* %^BOLD%^query_splashable%^RESET%^
.EI
.SI 5
int query_splashable(object splasher, object splashee)
.EI
.SP 7 5

This queries splashability of the food.
Note that the food can only be splashed when liquid and when
set_splashable() has been called
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
splasher - - Who splashes.
.EP
.SP 9 5
splashee - - Who is splashed.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it can splash, 0 if it can't
.EP

.SI 3
* %^BOLD%^query_weight_per_bite%^RESET%^
.EI
.SI 5
int query_weight_per_bite()
.EI
.SP 7 5

This sets the weight of each bite of the food object.
This is used along with the total weight of the object
to calculate how many bites of the food can be taken.

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
The weight of each bite.

.EP

.SI 3
* %^BOLD%^remove_eat_effect%^RESET%^
.EI
.SI 5
void remove_eat_effect(string word)
.EI
.SP 7 5

This removes the eat effect of the given name.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The name of the effect to delete.
.EP

.SI 3
* %^BOLD%^remove_external_effect%^RESET%^
.EI
.SI 5
void remove_external_effect(string word)
.EI
.SP 7 5

This removes the external effect of the given name.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The name of the effect to delete.
.EP

.SI 3
* %^BOLD%^reset_liquid%^RESET%^
.EI
.SI 5
void reset_liquid()
.EI
.SP 7 5

This changes the food object into a solid.  Solids are not
'continuous' and the decay speed will be set back to the
default.

.EP

.SI 3
* %^BOLD%^set_applicable%^RESET%^
.EI
.SI 5
void set_applicable()
.EI
.SP 7 5

This sets it so the food can be applied.
Note this is the default case.
.EP

.SI 3
* %^BOLD%^set_bites_gone%^RESET%^
.EI
.SI 5
void set_bites_gone(int number)
.EI
.SP 7 5

This sets the number of bites gone.  This helps determine
the total weight of the object.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
number - The number of bites gone.

.EP

.SI 3
* %^BOLD%^set_decay_level%^RESET%^
.EI
.SI 5
void set_decay_level(int level)
.EI
.SP 7 5

This sets the decay level.  This should be anumber
between 1 and 6.  It lets you make a food object seem
as though it is already decaying.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
level - The new decay level.

.EP

.SI 3
* %^BOLD%^set_decay_speed%^RESET%^
.EI
.SI 5
void set_decay_speed(int decay)
.EI
.SP 7 5

This sets the speed at which a food object decays.  The
speed is set in seconds and is the total amount of time
before the food decays.


If the decay speed is set to 0, then the object will never decay. 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
speed - The speed at which the object will decays.
.EP

.SI 3
* %^BOLD%^set_eat_effects%^RESET%^
.EI
.SI 5
void set_eat_effects(mapping map)
.EI
.SP 7 5

This sets all the eat effects.  This function should NOT
be used.  Please use add_eat_effect.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
map - The eat effects mapping.

.EP

.SI 3
* %^BOLD%^set_eat_func%^RESET%^
.EI
.SI 5
void set_eat_func(string word)
.EI
.SP 7 5

This sets the eat function of the food.  This is called when
the food is eaten.


If the eat object is set, then the eat function needs to be set as well. If the function is not set then setting the object has no effect. 

The function will be called with two parameters, the first being the object being eaten and the second being the person eating the object. 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The function to set as the eat function.
.EP

.SI 3
* %^BOLD%^set_eat_mess%^RESET%^
.EI
.SI 5
void set_eat_mess(mixed word)
.EI
.SP 7 5

This sets the eat function of the food.  The function is
carried out when the food is consumed.  The eat message,
set with set_eat_mess(), is displayed when this function
is carried out.


The eat mess should be treated exactly the same as a add_succeeded_mess(), as it is processed later as add_succeeded_mess(eat_mess, ({ })); 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The string or array to be used as
the add_succeeded_mess() when eating the food.

.EP

.SI 3
* %^BOLD%^set_eat_object%^RESET%^
.EI
.SI 5
void set_eat_object(string word)
.EI
.SP 7 5

This sets the object on which the eat function is stored.


If the eat object is set, then the eat function needs to be set as well. If the function is not set then setting the object has no effect. 

The function will be called with two parameters, the first being the object being eaten and the second being the person eating the object. 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The object containing the eat function.
.EP

.SI 3
* %^BOLD%^set_external_effects%^RESET%^
.EI
.SI 5
void set_external_effects(mapping map)
.EI
.SP 7 5

This sets all the external effects.  This function should NOT
be used.  Please use add_external_effect.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
map - The external effects mapping.

.EP

.SI 3
* %^BOLD%^set_external_pk_check%^RESET%^
.EI
.SI 5
void set_external_pk_check()
.EI
.SP 7 5

This makes the external effects pk checked.
.EP

.SI 3
* %^BOLD%^set_in_pieces%^RESET%^
.EI
.SI 5
void set_in_pieces(int number)
.EI
.SP 7 5

This sets the in_pieces flag.  This allows you to make the
food seem as though it has already been cut into pieces.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
number - The number of pieces.
.EP

.SI 3
* %^BOLD%^set_liquid%^RESET%^
.EI
.SI 5
void set_liquid()
.EI
.SP 7 5

This changes the food object into a liquid.  Liquids are
automatically a 'continuous' medium, which means it will
combine with other liquids of the same type.


This will automatically set the decay speed to 0. Liquids do not decay. 
.EP

.SI 3
* %^BOLD%^set_piece_description%^RESET%^
.EI
.SI 5
void set_piece_description(string word)
.EI
.SP 7 5

This sets the long description of the food when it is has
'cut' into pieces.


If this is set then the short of the object is changed to 'piece of cake'. If the piece description is not set the short description of the object is not changed. 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The long description to use when cut into pieces.
.EP

.SI 3
* %^BOLD%^set_piece_plural%^RESET%^
.EI
.SI 5
void set_piece_plural(string plural)
.EI
.SP 7 5

This plural description used for the pieces.  It is only
really of use if the piece short pluralises in an unusual
manner.  If it is not set the piece plural is set to what
the pice short has been set to with an "s" stuck on the
end, for example, slice to slices.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The plural used for the 'pieces' when cut into
pieces.
.EP

.SI 3
* %^BOLD%^set_piece_short%^RESET%^
.EI
.SI 5
void set_piece_short(string short)
.EI
.SP 7 5

This is the description used in the short for the pieces.
When the object is cut up this is used as part of the
short description.  For example, it can change
'piece of cake' to 'slice of cake', 'piece of chocolate'
to 'square of chocolate', and so on.  If this the piece
short has not been set it is set to the default which is
simply "piece".

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The short to use for the 'piece' when cut into
pieces.
.EP

.SI 3
* %^BOLD%^set_piece_substance%^RESET%^
.EI
.SI 5
void set_piece_substance(string substance)
.EI
.SP 7 5

This sets a new description for what there are pieces of.
For example, if you want the short of the food before it
is cut up to be 'bar of chocolate', without the piece
substance being set, when it is cut up it will become
'a piece of bar of chocolate'.  If you set this in enables
you to change that unwieldly description to 'a piece of
chocolate'.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - The description of what the 'piece' is of.
.EP

.SI 3
* %^BOLD%^set_splashable%^RESET%^
.EI
.SI 5
void set_splashable()
.EI
.SP 7 5

This sets it so the food can be splashed.
Note that the food can only be splashed when liquid in any case.
Note this is NOT the default case.
.EP

.SI 3
* %^BOLD%^set_weight_per_bite%^RESET%^
.EI
.SI 5
void set_weight_per_bite(int number)
.EI
.SP 7 5

This sets weight of each bite of the food object.  This is
used along with the total weight of the object to calculate
how many bites of the food can be taken.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
number - The weight each bite should be.

.EP

.SI 3
* %^BOLD%^setup_eat%^RESET%^
.EI
.SI 5
void setup_eat(string ob, string func)
.EI
.SP 7 5

This sets up the eat object and function.  This is used when
the food is eaten.  The eat function is called on the eat
object.  If successful the eat message is added to the player.

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
ob - The object to use.
.EP
.SP 9 5
func - The function to use.

.EP

.SI 3
* %^BOLD%^setup_eat_piece_messages%^RESET%^
.EI
.SI 5
void setup_eat_piece_messages(mixed piece, mixed amt, mixed last)
.EI
.SP 7 5

This sets up the eat messages for pieces and stuff.  The amount message
will replace the $amt$ string in the message with the amount_string().  
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
piece - the eat piece message. This can be either a string or an
array, it is passed to add_succeeded_mess().
.EP
.SP 9 5
amt - the amount messages
.EP
.SP 9 5
last - the message to print out when the last bit gets eaten

.EP

.SI 3
* %^BOLD%^unset_applicable%^RESET%^
.EI
.SI 5
void unset_applicable()
.EI
.SP 7 5

This sets it so the food cannot be applied.
.EP

.SI 3
* %^BOLD%^unset_external_pk_check%^RESET%^
.EI
.SI 5
void unset_external_pk_check()
.EI
.SP 7 5

This makes the external effects not pk checked.
.EP

.SI 3
* %^BOLD%^unset_splashable%^RESET%^
.EI
.SI 5
void unset_splashable()
.EI
.SP 7 5

This sets it so the food cannot be splashed.
Note that the food can only be splashed when liquid in any case.
.EP


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.food.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.shield.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.shield.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626728   Available: 13574082
Inodes: Total: 5242880    Free: 4960132
894 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.shield.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626728   Available: 13574082
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
shield.c
DW_wibble autodoc help
shield.c

.SH Description
.SP 5 5

.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/armour and /std/basic/holdable.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/virtual.h and /include/move_failures.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^move%^RESET%^
.EI
.SI 5
varargs int move(mixed dest, string messin, string messout)
.EI

.SI 3
* %^BOLD%^query_no_limbs%^RESET%^
.EI
.SI 5
int query_no_limbs()
.EI

.SI 3
* %^BOLD%^query_wearable%^RESET%^
.EI
.SI 5
int query_wearable()
.EI

.SI 3
* %^BOLD%^replace_me%^RESET%^
.EI
.SI 5
void replace_me()
.EI

.SI 3
* %^BOLD%^set_holder%^RESET%^
.EI
.SI 5
mixed set_holder(object thing, int number)
.EI

.SI 3
* %^BOLD%^set_no_limbs%^RESET%^
.EI
.SI 5
void set_no_limbs(int number)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.shield.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.mineral.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.mineral.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626728   Available: 13574082
Inodes: Total: 5242880    Free: 4960132
1686 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.mineral.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626728   Available: 13574082
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
mineral.c
DW_wibble autodoc help
mineral.c

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/food.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/mineral.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^check_tool%^RESET%^
.EI
.SI 5
int check_tool(object * tools, string * needed)
.EI

.SI 3
* %^BOLD%^do_chip%^RESET%^
.EI
.SI 5
int do_chip(object * tools)
.EI

.SI 3
* %^BOLD%^do_eat%^RESET%^
.EI
.SI 5
int do_eat()
.EI

.SI 3
* %^BOLD%^do_pulverise%^RESET%^
.EI
.SI 5
int do_pulverise(object * tools)
.EI

.SI 3
* %^BOLD%^do_smash%^RESET%^
.EI
.SI 5
int do_smash(object * tools)
.EI

.SI 3
* %^BOLD%^do_sprinkle%^RESET%^
.EI
.SI 5
int do_sprinkle(object * obs)
.EI

.SI 3
* %^BOLD%^init_static_arg%^RESET%^
.EI
.SI 5
void init_static_arg(mapping map)
.EI

.SI 3
* %^BOLD%^int_query_static_auto_load%^RESET%^
.EI
.SI 5
mapping int_query_static_auto_load()
.EI

.SI 3
* %^BOLD%^long%^RESET%^
.EI
.SI 5
string long(string words, int dark)
.EI

.SI 3
* %^BOLD%^make_mineral%^RESET%^
.EI
.SI 5
varargs void make_mineral(string word, int number, string * inputs)
.EI

.SI 3
* %^BOLD%^parse_command_adjectiv_id_list%^RESET%^
.EI
.SI 5
string * parse_command_adjectiv_id_list()
.EI

.SI 3
* %^BOLD%^query_material%^RESET%^
.EI
.SI 5
string query_material()
.EI

.SI 3
* %^BOLD%^query_mineral%^RESET%^
.EI
.SI 5
string query_mineral()
.EI

.SI 3
* %^BOLD%^query_static_auto_load%^RESET%^
.EI
.SI 5
mapping query_static_auto_load()
.EI

.SI 3
* %^BOLD%^set_decay_level%^RESET%^
.EI
.SI 5
void set_decay_level(int level)
.EI

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed * stats()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.mineral.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.shut.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.shut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626727   Available: 13574081
Inodes: Total: 5242880    Free: 4960132
1259 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.shut.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626727   Available: 13574081
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
shut.c
Dead DW2 autodoc help
shut.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/container.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/socket_errors.h and /include/network.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^blue%^RESET%^
.EI
.SI 5
void blue()
.EI

.SI 3
* %^BOLD%^check_ghosts%^RESET%^
.EI
.SI 5
void check_ghosts()
.EI

.SI 3
* %^BOLD%^do_ambushed%^RESET%^
.EI
.SI 5
void do_ambushed()
.EI

.SI 3
* %^BOLD%^end_it_all%^RESET%^
.EI
.SI 5
void end_it_all()
.EI

.SI 3
* %^BOLD%^force_quit%^RESET%^
.EI
.SI 5
void force_quit(object ob)
.EI

.SI 3
* %^BOLD%^heart_beat%^RESET%^
.EI
.SI 5
void heart_beat()
.EI

.SI 3
* %^BOLD%^long%^RESET%^
.EI
.SI 5
string long(string str, int dark)
.EI

.SI 3
* %^BOLD%^person_dead%^RESET%^
.EI
.SI 5
void person_dead(object thing, int number)
.EI

.SI 3
* %^BOLD%^person_died%^RESET%^
.EI
.SI 5
void person_died(string word, int number)
.EI

.SI 3
* %^BOLD%^query_time_to_crash%^RESET%^
.EI
.SI 5
int query_time_to_crash()
.EI

.SI 3
* %^BOLD%^query_unambushable%^RESET%^
.EI
.SI 5
int query_unambushable()
.EI

.SI 3
* %^BOLD%^shut%^RESET%^
.EI
.SI 5
void shut(int minutes, string reason)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.shut.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.money.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626727   Available: 13574081
Inodes: Total: 5242880    Free: 4960132
3451 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.money.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626727   Available: 13574081
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
money.c
DW_wibble autodoc help
money.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/object.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/money.h, /include/move_failures.h, /include/obj_parser.h and /include/shops/bank.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^adjust_money%^RESET%^
.EI
.SI 5
varargs int adjust_money(mixed amount, string type)
.EI

.SI 3
* %^BOLD%^check_adjectives%^RESET%^
.EI
.SI 5
void check_adjectives()
.EI
.SP 7 5

This method goes through the coins and sets up all the adjectives
and plurals it needs to.

.EP

.SI 3
* %^BOLD%^find_best_fit%^RESET%^
.EI
.SI 5
int find_best_fit(mixed word)
.EI

.SI 3
* %^BOLD%^fixup_money_weight%^RESET%^
.EI
.SI 5
void fixup_money_weight()
.EI
.SP 7 5

This method fixes up the weight of the money object to be what it should
be.

.EP

.SI 3
* %^BOLD%^force_no_join%^RESET%^
.EI
.SI 5
void force_no_join()
.EI

.SI 3
* %^BOLD%^group_object%^RESET%^
.EI
.SI 5
int group_object()
.EI

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping map,  object)
.EI

.SI 3
* %^BOLD%^merge_coins%^RESET%^
.EI
.SI 5
object merge_coins()
.EI
.SP 7 5

This method merges two coin object together.  Or attempts to anyway.
This will occur whenever a coin object moves.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the merged coin object

.EP

.SI 3
* %^BOLD%^new_money_object%^RESET%^
.EI
.SI 5
object new_money_object(mixed number, string type)
.EI
.SP 7 5

This method creates a new money object from the current object.  It uses
the current objects values to make the money and removes the avlues from
the coins.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
number - the number of coins to remove
.EP
.SP 9 5
type - the type of coins to remove
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the new money object

.EP

.SI 3
* %^BOLD%^query_already_joined%^RESET%^
.EI
.SI 5
int query_already_joined()
.EI

.SI 3
* %^BOLD%^query_collective%^RESET%^
.EI
.SI 5
int query_collective()
.EI

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_merger%^RESET%^
.EI
.SI 5
int query_merger()
.EI

.SI 3
* %^BOLD%^query_money%^RESET%^
.EI
.SI 5
int query_money(string type)
.EI
.SP 7 5

This method returns the amount of type of money there is in the array.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
type - the type of money to check
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the number of coins of that type

.EP

.SI 3
* %^BOLD%^query_money_array%^RESET%^
.EI
.SI 5
mixed * query_money_array()
.EI

.SI 3
* %^BOLD%^query_no_join%^RESET%^
.EI
.SI 5
int query_no_join()
.EI

.SI 3
* %^BOLD%^query_number_coins%^RESET%^
.EI
.SI 5
int query_number_coins()
.EI
.SP 7 5

This method returns the number of coins in the object.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the number of coins

.EP

.SI 3
* %^BOLD%^reset_already_joined%^RESET%^
.EI
.SI 5
void reset_already_joined()
.EI

.SI 3
* %^BOLD%^reset_no_join%^RESET%^
.EI
.SI 5
void reset_no_join()
.EI

.SI 3
* %^BOLD%^set_already_joined%^RESET%^
.EI
.SI 5
void set_already_joined()
.EI

.SI 3
* %^BOLD%^set_money_array%^RESET%^
.EI
.SI 5
void set_money_array(mixed * new_array)
.EI

.SI 3
* %^BOLD%^set_no_join%^RESET%^
.EI
.SI 5
void set_no_join()
.EI

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed * stats()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.money.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.shovel.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.shovel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626726   Available: 13574080
Inodes: Total: 5242880    Free: 4960132
1201 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.shovel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626726   Available: 13574080
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
shovel.c
DW_wibble autodoc help
shovel.c

.SH Description
.SP 5 5

This is a clonable shovel object (a "shovel" in this case being anything
that can be used for digging, from a garden trowel to a steam shovel).
The "dig" command is defined with the following syntax:

.EP
.SO 6 2 -10

	*	"with <direct:object> in <string>" 
	*	"with <direct:object> in <indirect:object>" 
	*	"with <direct:object>" 
	*	"[in] <string> with <direct:object>" 
	*	"[in] <indirect:object> with <direct:object>" 
.EO
.SP 5 5

.EP
.SP 5 5
The do_dig() function tries to call a function dig() on this_player()'s environment, which should be defined as 

int dig( object indir, string indir_s ) 

where 
.EP
.SO 9 2 -13

	*	%^CYAN%^indir%^RESET%^is the <indirect:object> matched (if any) 
	*	%^CYAN%^indir_s%^RESET%^is the <string> matched, or the string that matched <indirect:object> 
.EO
.SP 5 5

.EP
.SP 5 5
Note that the command can match either actual objects or just strings; also note that, although it will match room items, the object passed won't really be of much use (which is why the string is passed also). 
.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/weapon.
.EP

// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.shovel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.hotfood.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.hotfood.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626725   Available: 13574079
Inodes: Total: 5242880    Free: 4960132
1380 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.hotfood.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626725   Available: 13574079
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
hotfood.c
DW_wibble autodoc help
hotfood.c

.SH Description
.SP 5 5



.EP
.SP 5 5
This is an inherit for hot food which cools down, based on the temperature of the room in which it finds itself and any containers it might be in. 

It performs just as normal food, apart from the following: 

- If eaten while still hot it will cause the consumer to warm up for a period of time. 

- It only decays once it has finished cooling. 

It's cooling level can be checked by query_cool_level(). This starts at a value of twenty times the original weight of the hot food and determines how long it takes to cool down. Larger items cool more slowly. 

The level of cooling is shown in the long and short of the object. These are created using query_short_rotten_adjective and query_long_decay_level, and are based on the percentage by which it has cooled. 

Differant messages can be displayed when the food is eaten hot or cold These can be set using set_hot_eat_message() and set_cold_eat_message() Messages can also be set for eating bites of food where appropriate using setup_cold_eat_piece_messages() and setup_hot_eat_piece_messages() 
.EP
.SP 10 5


Written by Sightblinder


.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/food.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/weather.h and /include/bits_controller.h.
.EP

// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.hotfood.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.multiple_scabbard.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.multiple_scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626725   Available: 13574079
Inodes: Total: 5242880    Free: 4960132
1097 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.multiple_scabbard.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626725   Available: 13574079
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
multiple_scabbard.c
DW_wibble autodoc help
multiple_scabbard.c

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/scabbard.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/move_failures.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^do_hurl%^RESET%^
.EI
.SI 5
int do_hurl(object * knives, object * targets, int targeted)
.EI

.SI 3
* %^BOLD%^query_capacity%^RESET%^
.EI
.SI 5
int query_capacity()
.EI

.SI 3
* %^BOLD%^query_clothing%^RESET%^
.EI
.SI 5
int query_clothing()
.EI

.SI 3
* %^BOLD%^query_pocket_mess%^RESET%^
.EI
.SI 5
string query_pocket_mess()
.EI

.SI 3
* %^BOLD%^query_throwable%^RESET%^
.EI
.SI 5
int query_throwable()
.EI

.SI 3
* %^BOLD%^set_capacity%^RESET%^
.EI
.SI 5
void set_capacity(int i)
.EI

.SI 3
* %^BOLD%^set_throwable%^RESET%^
.EI
.SI 5
void set_throwable(int i)
.EI

.SI 3
* %^BOLD%^test_add%^RESET%^
.EI
.SI 5
int test_add(object thing, int flag, int noprint)
.EI

.SI 3
* %^BOLD%^throw%^RESET%^
.EI
.SI 5
void throw(object * knives, object * targets)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.multiple_scabbard.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.meltable.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.meltable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626724   Available: 13574078
Inodes: Total: 5242880    Free: 4960132
1336 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.meltable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626724   Available: 13574078
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
meltable.c
DW_wibble autodoc help
meltable.c

.SH Description
.SP 5 5



.EP
.SP 5 5
This is an inheritable for frozen food which melts, based on the temperature of the room environment in which it finds itself. 

It performs just as normal food, apart from the following: 

- It cannot be cured or dried 

- It does not decay 

- It cannot be forced to behave as a liquid 

- When applied or eaten, it will cause a brief decrease in temperature of the user. 

It will melt into a liquid, which can be set using set_melt_result(). This is default at water, and can be queried using query_melt_result(). 

It's melt level can be checked by query_melt_level(). This starts at a value of ten times the original weight of the meltable food. 

It's rate of melting adjusts itself regularly, based on the temperature. This can be checked with query_melt_rate(), and set temporarily with set_melt_rate. 

The level of melting is shown in the long and short of the object. These are created using query_short_rotten_adjective and query_long_decay_level, and are based on the percentage of object left. 
.EP
.SP 10 5


Written by Carmine


.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/food.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/weather.h and /include/bits_controller.h.
.EP

// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.meltable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.holdable.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.holdable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626724   Available: 13574078
Inodes: Total: 5242880    Free: 4960132
464 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.holdable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626724   Available: 13574078
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
holdable.c
DW_wibble autodoc help
holdable.c

.SH Description
.SP 5 5

The holdable inherit.  This is to make something holdable that is not
a weapon, for example torches and candles.
.EP
.SP 10 5


Written by Pinkfish

Started Wed Apr 18 16:13:17 PDT 2001

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /std/basic/holdable and /std/object.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/move_failures.h.
.EP

// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.holdable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.package.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.package.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626723   Available: 13574077
Inodes: Total: 5242880    Free: 4960132
508 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.package.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626723   Available: 13574077
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
package.c
DW_wibble autodoc help
package.c

.SH Description
.SP 5 5

Basic inheritable for a package. The main difference between this and
/obj/baggage is that the value of this is the sum of the values of the
items in the package.

.EP
.SP 10 5


Written by ceres

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/baggage.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^query_value%^RESET%^
.EI
.SI 5
int query_value()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.package.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.virtual_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.virtual_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626723   Available: 13574077
Inodes: Total: 5242880    Free: 4960132
852 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.virtual_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626723   Available: 13574077
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
virtual_room.c
DS2 Discworld autodoc help
virtual_room.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/room.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/virtual.h and /include/virtual_room.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_cloned_object%^RESET%^
.EI
.SI 5
void add_cloned_object(int flag, int delay, mixed clone_info, string entry_mess)
.EI

.SI 3
* %^BOLD%^query_cloned_definitions%^RESET%^
.EI
.SI 5
mixed * query_cloned_definitions()
.EI

.SI 3
* %^BOLD%^query_cloned_objects%^RESET%^
.EI
.SI 5
mixed * query_cloned_objects()
.EI


.SH Protected Functions
.SP 5 5
These are functions that only objects inheriting the class can access.
.EP

.SI 3
* %^BOLD%^make_object%^RESET%^
.EI
.SI 5
void make_object(int i)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.virtual_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.vessel.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626723   Available: 13574077
Inodes: Total: 5242880    Free: 4960132
5864 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.vessel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626723   Available: 13574077
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
vessel.c
Dead DW2 autodoc help
vessel.c

.SH Description
.SP 5 5

This is a container specifically for holding liquids.  The hope is
to reduce the memory requirements by taking all of the liquid stuff
out of /obj/container, since most of the containers are sacks and
chests.  Also, the reaction handler will replace the potion space.


Some additional notes: 
.EP
.SO 6 3 -11

	1. 	As is (hopefully) documented elsewhere, the base units of volume for most continuous media are drops and pinches, both of which are roughly 1/4 of a cc. This means that water has 200 drops per weight unit (1g/cc). Non-continuous objects are assumed to be the same density as water. 
.EO
.SP 5 5

.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/baggage.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/volumes.h, /include/tasks.h and /include/move_failures.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_volume%^RESET%^
.EI
.SI 5
int add_volume(int vol)
.EI
.SP 7 5

This method returns the amount of volume left for liquids to be
added into.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
vol - the amount of volume added
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if the addition was successful, 0 if not
.EP

.SI 3
* %^BOLD%^calc_liquid%^RESET%^
.EI
.SI 5
void calc_liquid()
.EI

.SI 3
* %^BOLD%^cmp_amount_r%^RESET%^
.EI
.SI 5
int cmp_amount_r(object a, object b)
.EI

.SI 3
* %^BOLD%^cmp_weight_r%^RESET%^
.EI
.SI 5
int cmp_weight_r(object a, object b)
.EI

.SI 3
* %^BOLD%^drink_amount%^RESET%^
.EI
.SI 5
int drink_amount(int drinking, object player)
.EI
.SP 7 5

This method drinks a certain amount of the liquid in the container.
It will do all the fudging for being in combat and drinking too
much, as well as dropping the bottle and so on.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
drinking - the amount to drink 

.EP

.SI 3
* %^BOLD%^fullness_adjectives%^RESET%^
.EI
.SI 5
string * fullness_adjectives()
.EI
.SP 7 5

This returns an adjective for how full the current object is with
liquid.  This is used in the parse command handling code.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the fullness adjective
.EP

.SI 3
* %^BOLD%^is_fighting_bottle_smashed%^RESET%^
.EI
.SI 5
int is_fighting_bottle_smashed(object player, object me)
.EI
.SP 7 5

This method checks to see if the person doing the drinking can hold onto
their bottle without loosing it while in combat.  Warning!  This code
may be used in other objects to deal with handling drinking while in
combat.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
player - the player doing the drinking
.EP
.SP 9 5
me - the object being drunk 
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if the bottle is stopped, 0 if it is not
.EP

.SI 3
* %^BOLD%^query_cont_volume%^RESET%^
.EI
.SI 5
int query_cont_volume()
.EI

.SI 3
* %^BOLD%^query_fullness_desc%^RESET%^
.EI
.SI 5
string query_fullness_desc()
.EI
.SP 7 5

This method returns the fullness description of the vessel.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the fullness description of the vessel 
.EP

.SI 3
* %^BOLD%^query_leak_rate%^RESET%^
.EI
.SI 5
int query_leak_rate()
.EI
.SP 7 5

This method returns the leak rate of the container
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current leak rate 
.EP

.SI 3
* %^BOLD%^query_liquid%^RESET%^
.EI
.SI 5
int query_liquid()
.EI
.SP 7 5

This method returns if this vessel is currenly a liquid.  This means
it has a liquid inside it.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it is a liquid, 0 if not 
.EP

.SI 3
* %^BOLD%^query_liquid_desc%^RESET%^
.EI
.SI 5
string query_liquid_desc()
.EI
.SP 7 5

This method returns the description of the liquid inside the vessel.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current liquids description 
.EP

.SI 3
* %^BOLD%^query_max_volume%^RESET%^
.EI
.SI 5
int query_max_volume()
.EI
.SP 7 5

This method returns the current maxium volume associated with this
container.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current maximum volume 
.EP

.SI 3
* %^BOLD%^query_vessel%^RESET%^
.EI
.SI 5
int query_vessel()
.EI

.SI 3
* %^BOLD%^query_volume%^RESET%^
.EI
.SI 5
int query_volume()
.EI
.SP 7 5

This method returns the current amount of liquid in the container.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current amount of liquid in the container 
.EP

.SI 3
* %^BOLD%^query_volume_left%^RESET%^
.EI
.SI 5
int query_volume_left()
.EI
.SP 7 5

This method returns the amount of volume left for liquids to be
added into.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the amount of volume left
.EP

.SI 3
* %^BOLD%^remove_volume%^RESET%^
.EI
.SI 5
int remove_volume(int vol_lost)
.EI
.SP 7 5

This method removes some volume of liquid from the container.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
vol_lost - the amount of volume removed
.EP

.SI 3
* %^BOLD%^set_leak_rate%^RESET%^
.EI
.SI 5
void set_leak_rate(int i)
.EI
.SP 7 5

This method sets the leak rate of the container.  The leak rate is how
fast stuff leaks out of the container.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the new leak rate of the container
.EP

.SI 3
* %^BOLD%^set_max_volume%^RESET%^
.EI
.SI 5
void set_max_volume(int v)
.EI
.SP 7 5

This method sets the maximum volume of the container.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
v - the new maximum volume
.EP

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed stats()
.EI

.SI 3
* %^BOLD%^xfer_volume%^RESET%^
.EI
.SI 5
int xfer_volume(int vol_xferred, object dest)
.EI
.SP 7 5

This method transfers a given amount of a liquid to a new container.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
dest - the destination of the liquid
.EP
.SP 9 5
vol_xferred - the amount of volume transfered 
.EP


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.vessel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.key.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626721   Available: 13574075
Inodes: Total: 5242880    Free: 4960132
347 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.key.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626721   Available: 13574075
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
key.c
DW_wibble autodoc help
key.c

.SH Inherits
.SP 5 5
This class inherits the following classes std/object.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^query_type%^RESET%^
.EI
.SI 5
string query_type()
.EI

.SI 3
* %^BOLD%^set_type%^RESET%^
.EI
.SI 5
void set_type(string str)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.key.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.cure_wand.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.cure_wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626721   Available: 13574075
Inodes: Total: 5242880    Free: 4960132
167 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.cure_wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626721   Available: 13574075
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
cure_wand.c
DW_wibble autodoc help
cure_wand.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/effects/healing/basic_cure and /obj/wand.
.EP

// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.cure_wand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.fungus.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.fungus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626721   Available: 13574075
Inodes: Total: 5242880    Free: 4960132
2325 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.fungus.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626721   Available: 13574075
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
fungus.c
DW_wibble autodoc help
fungus.c

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/food.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/move_failures.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^do_get%^RESET%^
.EI
.SI 5
int do_get()
.EI

.SI 3
* %^BOLD%^do_pick%^RESET%^
.EI
.SI 5
int do_pick()
.EI

.SI 3
* %^BOLD%^do_take%^RESET%^
.EI
.SI 5
int do_take()
.EI

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping args,  object)
.EI

.SI 3
* %^BOLD%^make_spore%^RESET%^
.EI
.SI 5
object make_spore(object place)
.EI

.SI 3
* %^BOLD%^next_stage%^RESET%^
.EI
.SI 5
void next_stage()
.EI

.SI 3
* %^BOLD%^query_adjs%^RESET%^
.EI
.SI 5
string query_adjs()
.EI

.SI 3
* %^BOLD%^query_delay%^RESET%^
.EI
.SI 5
int query_delay()
.EI

.SI 3
* %^BOLD%^query_extra%^RESET%^
.EI
.SI 5
string query_extra()
.EI

.SI 3
* %^BOLD%^query_growing%^RESET%^
.EI
.SI 5
int query_growing()
.EI

.SI 3
* %^BOLD%^query_large_weight%^RESET%^
.EI
.SI 5
int query_large_weight()
.EI

.SI 3
* %^BOLD%^query_medium_short%^RESET%^
.EI
.SI 5
string query_medium_short()
.EI

.SI 3
* %^BOLD%^query_messages%^RESET%^
.EI
.SI 5
string * query_messages()
.EI

.SI 3
* %^BOLD%^query_stage%^RESET%^
.EI
.SI 5
int query_stage()
.EI

.SI 3
* %^BOLD%^query_static_auto_load%^RESET%^
.EI
.SI 5
mapping query_static_auto_load()
.EI

.SI 3
* %^BOLD%^query_type%^RESET%^
.EI
.SI 5
string query_type()
.EI

.SI 3
* %^BOLD%^set_adjs%^RESET%^
.EI
.SI 5
void set_adjs(string words)
.EI

.SI 3
* %^BOLD%^set_delay%^RESET%^
.EI
.SI 5
void set_delay(int number)
.EI

.SI 3
* %^BOLD%^set_extra%^RESET%^
.EI
.SI 5
void set_extra(string words)
.EI

.SI 3
* %^BOLD%^set_large_weight%^RESET%^
.EI
.SI 5
void set_large_weight(int number)
.EI

.SI 3
* %^BOLD%^set_messages%^RESET%^
.EI
.SI 5
void set_messages(string * words)
.EI

.SI 3
* %^BOLD%^set_stage%^RESET%^
.EI
.SI 5
void set_stage(int number)
.EI

.SI 3
* %^BOLD%^set_type%^RESET%^
.EI
.SI 5
void set_type(string word)
.EI

.SI 3
* %^BOLD%^setup_spore%^RESET%^
.EI
.SI 5
void setup_spore()
.EI

.SI 3
* %^BOLD%^test_non_spore%^RESET%^
.EI
.SI 5
int test_non_spore(object thing)
.EI

.SI 3
* %^BOLD%^too_heavy_mess%^RESET%^
.EI
.SI 5
void too_heavy_mess(object thing)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.fungus.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.corpse.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626720   Available: 13574074
Inodes: Total: 5242880    Free: 4960132
5450 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.corpse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626720   Available: 13574074
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
corpse.c
DW_wibble autodoc help
corpse.c

.SH Description
.SP 5 5

This method returns the id associated with the corpse.
.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /std/container, /std/living/carrying and /std/basic/virtual_quit_control.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/corpse.h, /include/move_failures.h and /include/bit.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_bit_gone%^RESET%^
.EI
.SI 5
mixed * add_bit_gone(string bit)
.EI

.SI 3
* %^BOLD%^can_find_match_recurse_into%^RESET%^
.EI
.SI 5
int can_find_match_recurse_into(object player)
.EI

.SI 3
* %^BOLD%^do_decay%^RESET%^
.EI
.SI 5
void do_decay()
.EI
.SP 7 5

This is called to decay the corpse.  It is done in a continuous
call out loop until all of the decay has been completed.

.EP

.SI 3
* %^BOLD%^find_inv_match%^RESET%^
.EI
.SI 5
varargs object * find_inv_match(string s, object looker)
.EI

.SI 3
* %^BOLD%^get%^RESET%^
.EI
.SI 5
int get(mixed dest)
.EI

.SI 3
* %^BOLD%^give_permission%^RESET%^
.EI
.SI 5
void give_permission(string words)
.EI

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping map,  object)
.EI

.SI 3
* %^BOLD%^long%^RESET%^
.EI
.SI 5
string long(string words, int dark)
.EI

.SI 3
* %^BOLD%^make_bit%^RESET%^
.EI
.SI 5
object make_bit(string which_bit)
.EI

.SI 3
* %^BOLD%^make_bits%^RESET%^
.EI
.SI 5
object * make_bits(string * what_bits)
.EI

.SI 3
* %^BOLD%^move_or_destruct%^RESET%^
.EI
.SI 5
int move_or_destruct(object dest)
.EI

.SI 3
* %^BOLD%^query_armours%^RESET%^
.EI
.SI 5
object * query_armours()
.EI

.SI 3
* %^BOLD%^query_bit_left%^RESET%^
.EI
.SI 5
string query_bit_left(string s)
.EI

.SI 3
* %^BOLD%^query_bit_left_pl%^RESET%^
.EI
.SI 5
string * query_bit_left_pl(string s)
.EI

.SI 3
* %^BOLD%^query_bits_gone%^RESET%^
.EI
.SI 5
string * query_bits_gone()
.EI

.SI 3
* %^BOLD%^query_bits_left%^RESET%^
.EI
.SI 5
string * query_bits_left()
.EI

.SI 3
* %^BOLD%^query_corpse%^RESET%^
.EI
.SI 5
int query_corpse()
.EI

.SI 3
* %^BOLD%^query_corpse_id%^RESET%^
.EI
.SI 5
int query_corpse_id()
.EI

.SI 3
* %^BOLD%^query_decay%^RESET%^
.EI
.SI 5
int query_decay()
.EI

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_edible_bits_left%^RESET%^
.EI
.SI 5
string * query_edible_bits_left()
.EI

.SI 3
* %^BOLD%^query_holding%^RESET%^
.EI
.SI 5
object * query_holding()
.EI

.SI 3
* %^BOLD%^query_name%^RESET%^
.EI
.SI 5
string query_name()
.EI

.SI 3
* %^BOLD%^query_owner%^RESET%^
.EI
.SI 5
string query_owner()
.EI

.SI 3
* %^BOLD%^query_permitted%^RESET%^
.EI
.SI 5
string * query_permitted()
.EI

.SI 3
* %^BOLD%^query_race_name%^RESET%^
.EI
.SI 5
string query_race_name()
.EI

.SI 3
* %^BOLD%^query_race_ob%^RESET%^
.EI
.SI 5
string query_race_ob()
.EI

.SI 3
* %^BOLD%^query_save_data%^RESET%^
.EI
.SI 5
string query_save_data()
.EI
.SP 7 5

This is used by the corpse handler to get the data used to save
the corpse.

.EP

.SI 3
* %^BOLD%^query_static_auto_load%^RESET%^
.EI
.SI 5
mapping query_static_auto_load()
.EI

.SI 3
* %^BOLD%^query_weapon%^RESET%^
.EI
.SI 5
object query_weapon()
.EI

.SI 3
* %^BOLD%^query_wearing%^RESET%^
.EI
.SI 5
object * query_wearing()
.EI

.SI 3
* %^BOLD%^remove_armour%^RESET%^
.EI
.SI 5
void remove_armour(object arm)
.EI

.SI 3
* %^BOLD%^remove_array_parts%^RESET%^
.EI
.SI 5
string * remove_array_parts(string * a1, string * a2)
.EI

.SI 3
* %^BOLD%^remove_creator_corpse%^RESET%^
.EI
.SI 5
void remove_creator_corpse(object ob)
.EI

.SI 3
* %^BOLD%^set_armours%^RESET%^
.EI
.SI 5
void set_armours(object * things)
.EI

.SI 3
* %^BOLD%^set_bits_gone%^RESET%^
.EI
.SI 5
void set_bits_gone(string * bits)
.EI

.SI 3
* %^BOLD%^set_decay%^RESET%^
.EI
.SI 5
void set_decay(int dec)
.EI

.SI 3
* %^BOLD%^set_decay_messages%^RESET%^
.EI
.SI 5
void set_decay_messages()
.EI
.SP 7 5

This method sets up the various 'states; of the corpse to show 
how decayed it is.

.EP

.SI 3
* %^BOLD%^set_hold%^RESET%^
.EI
.SI 5
int * set_hold(object ob, int pos)
.EI

.SI 3
* %^BOLD%^set_holding%^RESET%^
.EI
.SI 5
void set_holding(object * hold)
.EI

.SI 3
* %^BOLD%^set_owner%^RESET%^
.EI
.SI 5
void set_owner(string words, object thing)
.EI
.SP 7 5

This method initially sets up the corpse object.  Generally
speaking words should be 0 and the 'thing' variable should be
set to the object which just died.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
words - the owner of the object
.EP
.SP 9 5
thing - the object to get the ownership data from

.EP

.SI 3
* %^BOLD%^set_race_name%^RESET%^
.EI
.SI 5
void set_race_name(string str)
.EI

.SI 3
* %^BOLD%^set_race_ob%^RESET%^
.EI
.SI 5
void set_race_ob(string s)
.EI

.SI 3
* %^BOLD%^set_unhold%^RESET%^
.EI
.SI 5
int * set_unhold(object ob)
.EI

.SI 3
* %^BOLD%^set_weapon%^RESET%^
.EI
.SI 5
void set_weapon(object wpn)
.EI

.SI 3
* %^BOLD%^setup_corpse_from_save%^RESET%^
.EI
.SI 5
void setup_corpse_from_save(string str_data, string name, int id)
.EI
.SP 7 5

This method is called by the corpse handler to setup the corpse
properly after it loads.

.EP

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed * stats()
.EI

.SI 3
* %^BOLD%^test_remove%^RESET%^
.EI
.SI 5
int test_remove(object thing, int flag, mixed dest)
.EI

.SI 3
* %^BOLD%^unwield_weapon%^RESET%^
.EI
.SI 5
void unwield_weapon(object wpn)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.corpse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.wand.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626718   Available: 13574072
Inodes: Total: 5242880    Free: 4960132
644 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.wand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626718   Available: 13574072
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:52.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
wand.c
DS2 Discworld autodoc help
wand.c

.SH Description
.SP 5 5

A magic wand object for use with all magic wands.

.EP
.SP 10 5

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/weapon and /std/basic/artifact.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/tasks.h and /include/artifacts.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^query_magic_wand%^RESET%^
.EI
.SI 5
int query_magic_wand()
.EI
.SP 7 5

This method will return true for all magic wands.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 for all wands

.EP


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.wand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.salve.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.salve.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626718   Available: 13574072
Inodes: Total: 5242880    Free: 4960132
1235 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.salve.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626718   Available: 13574072
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
salve.c
DW_wibble autodoc help
salve.c

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/food.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/drinks.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_apply_effect%^RESET%^
.EI
.SI 5
int add_apply_effect(string word, int number)
.EI

.SI 3
* %^BOLD%^being_joined_by%^RESET%^
.EI
.SI 5
void being_joined_by(object thing)
.EI

.SI 3
* %^BOLD%^do_apply%^RESET%^
.EI
.SI 5
int do_apply(object * indir, string dir_s, string indir_s, mixed * args)
.EI

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping map)
.EI

.SI 3
* %^BOLD%^query_apply_effects%^RESET%^
.EI
.SI 5
mapping query_apply_effects()
.EI

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_static_auto_load%^RESET%^
.EI
.SI 5
mapping query_static_auto_load()
.EI

.SI 3
* %^BOLD%^remove_apply_effect%^RESET%^
.EI
.SI 5
void remove_apply_effect(string word)
.EI

.SI 3
* %^BOLD%^set_apply_effects%^RESET%^
.EI
.SI 5
void set_apply_effects(mapping map)
.EI

.SI 3
* %^BOLD%^stats%^RESET%^
.EI
.SI 5
mixed * stats()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.salve.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.state_changer.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.state_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626717   Available: 13574071
Inodes: Total: 5242880    Free: 4960132
3350 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.state_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626717   Available: 13574071
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
state_changer.c
Dead DW2 autodoc help
state_changer.c

.SH Description
.SP 5 5

State Changer Inheritable!
You can use this to write a device which will change the states of
things.
.EP
.SP 10 5


Written by Terano

Started 30/9/02

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/vessel.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/effect.h and /include/tasks.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^beginning%^RESET%^
.EI
.SI 5
object beginning(object apparatus, object tp, int id)
.EI
.SP 7 5

Some effect stuff to save on call outs.

.EP

.SI 3
* %^BOLD%^do_action%^RESET%^
.EI
.SI 5
int do_action(object * obs)
.EI

.SI 3
* %^BOLD%^do_empty%^RESET%^
.EI
.SI 5
int do_empty(object * dest, string me, string him, string prep)
.EI

.SI 3
* %^BOLD%^do_fill%^RESET%^
.EI
.SI 5
int do_fill(object * to, mixed * args_b, mixed * args_a, mixed * args)
.EI

.SI 3
* %^BOLD%^end%^RESET%^
.EI
.SI 5
object end(object apparatus, object tp, int id)
.EI

.SI 3
* %^BOLD%^extra_look%^RESET%^
.EI
.SI 5
string extra_look(object ob)
.EI
.SP 7 5

Something to mask!

.EP

.SI 3
* %^BOLD%^long%^RESET%^
.EI
.SI 5
string long(string word, int dark)
.EI

.SI 3
* %^BOLD%^parse_message%^RESET%^
.EI
.SI 5
string parse_message(string message)
.EI

.SI 3
* %^BOLD%^query_busy%^RESET%^
.EI
.SI 5
int query_busy()
.EI

.SI 3
* %^BOLD%^query_classification%^RESET%^
.EI
.SI 5
string query_classification()
.EI

.SI 3
* %^BOLD%^set_abort_message%^RESET%^
.EI
.SI 5
void set_abort_message(string message)
.EI

.SI 3
* %^BOLD%^set_command%^RESET%^
.EI
.SI 5
void set_command(string _command)
.EI

.SI 3
* %^BOLD%^set_command_mess%^RESET%^
.EI
.SI 5
void set_command_mess(string message)
.EI

.SI 3
* %^BOLD%^set_duration%^RESET%^
.EI
.SI 5
void set_duration(int _duration)
.EI

.SI 3
* %^BOLD%^set_end_func%^RESET%^
.EI
.SI 5
void set_end_func(function f)
.EI

.SI 3
* %^BOLD%^set_end_message%^RESET%^
.EI
.SI 5
void set_end_message(string message)
.EI

.SI 3
* %^BOLD%^set_fail_func%^RESET%^
.EI
.SI 5
void set_fail_func(function f)
.EI

.SI 3
* %^BOLD%^set_fail_message%^RESET%^
.EI
.SI 5
void set_fail_message(string message)
.EI

.SI 3
* %^BOLD%^set_fail_process%^RESET%^
.EI
.SI 5
void set_fail_process(string _process)
.EI

.SI 3
* %^BOLD%^set_gp_cost%^RESET%^
.EI
.SI 5
void set_gp_cost(int gp)
.EI

.SI 3
* %^BOLD%^set_gp_type%^RESET%^
.EI
.SI 5
void set_gp_type(string type)
.EI

.SI 3
* %^BOLD%^set_interim_message%^RESET%^
.EI
.SI 5
void set_interim_message(string message)
.EI

.SI 3
* %^BOLD%^set_process%^RESET%^
.EI
.SI 5
void set_process(string _process)
.EI

.SI 3
* %^BOLD%^set_running_inv_mess%^RESET%^
.EI
.SI 5
void set_running_inv_mess(string mess)
.EI

.SI 3
* %^BOLD%^set_skill%^RESET%^
.EI
.SI 5
void set_skill(string _skill, int _base_bonus)
.EI

.SI 3
* %^BOLD%^set_start_func%^RESET%^
.EI
.SI 5
void set_start_func(function f)
.EI

.SI 3
* %^BOLD%^set_start_message%^RESET%^
.EI
.SI 5
void set_start_message(string message)
.EI

.SI 3
* %^BOLD%^show_message%^RESET%^
.EI
.SI 5
object show_message(object apparatus, object tp, int id)
.EI

.SI 3
* %^BOLD%^test_add%^RESET%^
.EI
.SI 5
int test_add(object ob, int flag)
.EI

.SI 3
* %^BOLD%^test_remove%^RESET%^
.EI
.SI 5
int test_remove(object ob, int flag, mixed dest)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.state_changer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.gatherable.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.gatherable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626716   Available: 13574070
Inodes: Total: 5242880    Free: 4960132
786 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.gatherable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626716   Available: 13574070
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
gatherable.c
DW_wibble autodoc help
gatherable.c

.SH Inherits
.SP 5 5
This class inherits the following classes /std/object.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/parse_command.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^do_get%^RESET%^
.EI
.SI 5
int do_get()
.EI

.SI 3
* %^BOLD%^query_item_name%^RESET%^
.EI
.SI 5
string query_item_name()
.EI

.SI 3
* %^BOLD%^query_scarcity%^RESET%^
.EI
.SI 5
int query_scarcity()
.EI

.SI 3
* %^BOLD%^set_get_failure_mess%^RESET%^
.EI
.SI 5
void set_get_failure_mess(string s)
.EI

.SI 3
* %^BOLD%^set_item_name%^RESET%^
.EI
.SI 5
void set_item_name(string name)
.EI

.SI 3
* %^BOLD%^set_scarcity%^RESET%^
.EI
.SI 5
void set_scarcity(int s)
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.gatherable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.service_provider.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.service_provider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626716   Available: 13574070
Inodes: Total: 5242880    Free: 4960132
2405 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.service_provider.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626716   Available: 13574070
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
service_provider.c
DW_wibble autodoc help
service_provider.c

.SH Description
.SP 5 5

The service provider object.  It is designed to be similar to
the peddler object, only instead of selling objects, it sells
services instead.

.EP
.SP 10 5


Written by Furcifer

March 2000

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /obj/monster.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/armoury.h, /include/shops/bank.h, /include/money.h and /include/move_failures.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_service%^RESET%^
.EI
.SI 5
varargs int add_service(string service, string browse_info, string func, int cost, string * aliases)
.EI
.SP 7 5

This method adds a service to the list of services on offer.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
service - the name of the service
.EP
.SP 9 5
cost - what it costs
.EP
.SP 9 5
the - function which controls
.EP
.SP 9 5
*aliases - an array of aliases for this service.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^check_busy%^RESET%^
.EI
.SI 5
varargs int check_busy(object player)
.EI

.SI 3
* %^BOLD%^do_browse%^RESET%^
.EI
.SI 5
int do_browse(mixed indirect_obs, string dir_match, string indir_match, string * words)
.EI
.SP 7 5

The main entrance to the browse for things command.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^do_list%^RESET%^
.EI
.SI 5
int do_list()
.EI
.SP 7 5

The main entrance to the list stuff command.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^do_request%^RESET%^
.EI
.SI 5
int do_request(mixed indirect_obs, string dir_match, string indir_match, string * words)
.EI
.SP 7 5

The main entrance to the buy things command.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on success, 0 on failure

.EP

.SI 3
* %^BOLD%^remove_service%^RESET%^
.EI
.SI 5
int remove_service(string service)
.EI
.SP 7 5

This method removes a service.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
string - service to be removed
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 on successful removal, 0 on failure

.EP

.SI 3
* %^BOLD%^reset_busy%^RESET%^
.EI
.SI 5
void reset_busy()
.EI

.SI 3
* %^BOLD%^set_busy%^RESET%^
.EI
.SI 5
void set_busy()
.EI


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.service_provider.c] ---
// --- BEGIN [/mnt/home2/grok/lib/doc/autodoc/obj.monster.c] ---
// Size:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626715   Available: 13574069
Inodes: Total: 5242880    Free: 4960132
39777 bytes, Last Modified:   File: "/mnt/home2/grok/lib/doc/autodoc/obj.monster.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626715   Available: 13574069
Inodes: Total: 5242880    Free: 4960132
2006-10-07 20:59:51.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
.DT
monster.c
DW_wibble autodoc help
monster.c

.SH Description
.SP 5 5

This file contains all the information relevant to creating an
npc (or monster).
.EP
.SP 10 5


Written by Pinkfish

.EP

.SH Inherits
.SP 5 5
This class inherits the following classes /global/guild-race, /global/events, /std/living/mon_actions, /std/living/response_mon and /std/living/living.
.EP

.SH Includes
.SP 5 5
This class includes the following files /include/route.h, /include/playtesters.h, /include/skills.h, /include/move_failures.h, /include/top_ten_tables.h, /include/map.h, /include/combat.h, /include/player.h, /include/wander.h, /include/monster.h, /include/living.h and /include/config.h.
.EP

.SH Public Functions
.SP 5 5
These are functions that everyone can access.
.EP

.SI 3
* %^BOLD%^add_achat_string%^RESET%^
.EI
.SI 5
void add_achat_string(mixed weight, mixed chat)
.EI
.SP 7 5

This method adds a single chat string into the current list of
attack message chat strings.  See load_chat() for a longer description of
the chat string.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
weight - the weight of the chat
.EP
.SP 9 5
chat - the new chat string
.EP

.SI 3
* %^BOLD%^add_chat_string%^RESET%^
.EI
.SI 5
void add_chat_string(mixed weight, mixed chat)
.EI
.SP 7 5

This method adds a single chat string into the current list of
chat strings.  See load_chat() for a longer description of
the chat string.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
weight - the weight of the chat
.EP
.SP 9 5
chat - the new chat string
.EP

.SI 3
* %^BOLD%^add_combat_action%^RESET%^
.EI
.SI 5
void add_combat_action(int chance, string name, mixed action)
.EI
.SP 7 5

This method adds a combat action to the npc.  This is an action which
has a chance of occuring during combat.  The name is an identifier
which can be used to remove the action with later.  The action
itself can be a string, then that command will be executed.  If
the action is a function pointer then it will be evaluated with
two arguments, the first being the attacker, the second being the
target.


If the action is an array, if it is one element then the function specified will be called on the attacked with the same arguements as above. If the size of the array is two then the function will be called on the specified object with the arguments as above.
.EP

.SI 3
* %^BOLD%^add_enter_commands%^RESET%^
.EI
.SI 5
int add_enter_commands(mixed str)
.EI
.SP 7 5

This method adds a command to be called whenever the npc enters
a room.  If the command is a string, then it will be executed
as if they had typed it.  If it is a function then the function
will be evaluated and one argument (the npc itself) will be passed
in.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
str - the enter commands to add
.EP

.SI 3
* %^BOLD%^add_language%^RESET%^
.EI
.SI 5
void add_language(string str)
.EI
.SP 7 5

This method adds a language to the npc. 


After the sun has died away
.EP
.SP 7 5
The stars come out and glow
.EP
.SP 7 5
Lighting the embers of good intentions
.EP
.SP 7 5
Ghostly white, unhappily bright
.EP
.SP 7 5
Time lost, the day done
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
str - the language to add

.EP

.SI 3
* %^BOLD%^add_move_zone%^RESET%^
.EI
.SI 5
void add_move_zone(mixed zone)
.EI
.SP 7 5

This method adds a move zone onto the npc.  The move zones control
which areas the npcs will wander into, a move zone is set on the
room and the npcs will only enter rooms which have a matching
move zone.  If there is no move zone, then the npc will enter
any room.


If the parameter is an array each of the elements of the array will be added as a move zone.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
zone - the zone(s) to add
.EP

.SI 3
* %^BOLD%^add_spell_action%^RESET%^
.EI
.SI 5
void add_spell_action(string spell_object, int chance, string name, mixed action)
.EI
.SP 7 5

This method adds an action to the npc that will happen if a specified
spell is cast.  This is an action which
has a chance of occuring when a spell is being cast.
The name is an identifier
which can be used to remove the action with later.  The action
itself can be a string, then that command will be executed.  If
the action is a function pointer then it will be evaluated with
two arguments, the first being the caster, the second being the
target(s) array and the third being the magic arguments class.


If the action is an array, if it is one element then the function specified will be called on the attacked with the same arguements as above. If the size of the array is two then the function will be called on the specified object with an extra first argument being the npc which the effect is being called from.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
spell_object - the spell to respond to
.EP
.SP 9 5
chance - the chance of it working
.EP
.SP 9 5
name - the name of the thing
.EP
.SP 9 5
action - the action to preform

.EP

.SI 3
* %^BOLD%^attack_permission%^RESET%^
.EI
.SI 5
int attack_permission(object ob1, object ob2, string stringy)
.EI
.SP 7 5


attack_permission function, added for use by the allow_attack simul.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
object - The person performing the action
.EP
.SP 9 5
object - The object being acted on, this object usually.
.EP
.SP 9 5
string - Attack type, this will be one of "combat", "theft", or "magic",
this lets you give your NPCs different responses for different attacks. As well
as make them immune to theft and magic (as an example)
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
int 1 if the action is denied, 0 is it can go through.
.EP

.SI 3
* %^BOLD%^basic_setup%^RESET%^
.EI
.SI 5
void basic_setup(string race, string guild, int level)
.EI
.SP 7 5

This method sets up the basic abilities and race of the critter.  It
is equivalent to calling set_race(), set_guild(), and then set_level()
with the same parameters.  But those latter three functions are
deprecated and shouldn't be used.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
race - this is the race of the character.  It should be a
race that's understood by the /std/race.c
.EP
.SP 9 5
guild - this is the guild, class, or profession of the NPC.
.EP
.SP 9 5
level - this is the base skill level of the NPC.  The
number is used by the race object to set ability scores, and
base skills.

.EP

.SI 3
* %^BOLD%^check_anyone_here%^RESET%^
.EI
.SI 5
int check_anyone_here()
.EI
.SP 7 5

This method checks to see if there are any players in the environment
of the npc.  This should be used to determine when chats should
be turned off and other things which should only work in the
presence of players.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if there is a player in the room, 0 otherwise

.EP

.SI 3
* %^BOLD%^cleaning_room%^RESET%^
.EI
.SI 5
int cleaning_room()
.EI

.SI 3
* %^BOLD%^combat_actions_call_back%^RESET%^
.EI
.SI 5
void combat_actions_call_back(object player, object target)
.EI
.SP 7 5

This is the call back from the combat effect to do something
wonderful and wild.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
player - the player
.EP
.SP 9 5
target - the target

.EP

.SI 3
* %^BOLD%^command_override%^RESET%^
.EI
.SI 5
void command_override(function func)
.EI
.SP 7 5

Use this function to set a function that is called with the NPCs input
before command() gets it, return 1 from the function if the
input needs no further parsing (ie the command is handled)

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
func - = function in the players environment to call.

.EP

.SI 3
* %^BOLD%^delay_command%^RESET%^
.EI
.SI 5
int delay_command(string words, int interval)
.EI
.SP 7 5

This method allows you to control the npc and get it to do
actions where they are queued as for players.   The command
is always delayed by delay even if there are no commands pending
unlike queue_command(). This function
is 100% compatible with queue_command() and init_command().
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
words - the action to perform
.EP
.SP 9 5
interval - to wait before the command.
.EP

.SI 3
* %^BOLD%^delete_queued_commands%^RESET%^
.EI
.SI 5
void delete_queued_commands()
.EI
.SP 7 5

This method throws away any queued commands.
It doesn't remove the call_out however if no
new commands are added there will be no effect.
.EP

.SI 3
* %^BOLD%^do_combat_action%^RESET%^
.EI
.SI 5
void do_combat_action(object player, object target, mixed action)
.EI
.SP 7 5

This method does a combat action.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
target - the target of the action
.EP

.SI 3
* %^BOLD%^do_command%^RESET%^
.EI
.SI 5
int do_command(string words)
.EI
.SP 7 5

This method allows you to control the npc and get it to do
actions.  This can be used for npc control and inteligence.

Be very careful with this command! This does not go through any
command queue like players have and so NPCs can end up doing
tons of commands in very short order.

If you're trying to make your NPC act like a player use
eue_command() instead

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
words - the action to preform
.EP

.SI 3
* %^BOLD%^do_follow_move%^RESET%^
.EI
.SI 5
void do_follow_move(string dir)
.EI
.SP 7 5

This method is used to make the npcs follow after attackers when they
leave the room.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
dir - the dirction to follow them in

.EP

.SI 3
* %^BOLD%^do_move%^RESET%^
.EI
.SI 5
void do_move(string move)
.EI
.SP 7 5

This method causes the npc to move in the given direction.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
move - the direction to move

.EP

.SI 3
* %^BOLD%^do_move_after%^RESET%^
.EI
.SI 5
void do_move_after(int running_away)
.EI
.SP 7 5

This is called when the npc decides it must continue down
a certain route.  This will be called by the wander handler
and can be used to force the npc to wander along a route
faster.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
running_away - this is 1 if the npc is running away
.EP

.SI 3
* %^BOLD%^do_route_move%^RESET%^
.EI
.SI 5
void do_route_move()
.EI
.SP 7 5

This method moves the npc one more location along the route it
is following.
.EP

.SI 3
* %^BOLD%^do_spell_action%^RESET%^
.EI
.SI 5
void do_spell_action(object caster, object * targets, mixed action, mixed args)
.EI
.SP 7 5

This method does a combat action.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
caster - the caster of the spell
.EP
.SP 9 5
targets - the targets of the spell
.EP
.SP 9 5
action - the action to do
.EP
.SP 9 5
args - the spell arguements

.EP

.SI 3
* %^BOLD%^drunk_check%^RESET%^
.EI
.SI 5
int drunk_check(string str)
.EI

.SI 3
* %^BOLD%^event_fight_in_progress%^RESET%^
.EI
.SI 5
void event_fight_in_progress(object me, object him)
.EI
.SP 7 5

This event is called when a fight is in progress.  It will
be used for things like joining into currently running
fights and initiating combat with spell casters.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
me - the person initiating the attack
.EP
.SP 9 5
him - the person being attacked

.EP

.SI 3
* %^BOLD%^event_npc_ritual_casting%^RESET%^
.EI
.SI 5
void event_npc_ritual_casting(object ritual, object caster, object * targets, class spell_argument args)
.EI
.SP 7 5

This is the event called when a ritual is being cast.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
spell_ob - the ritual
.EP
.SP 9 5
caster - the caster of the ritual
.EP
.SP 9 5
targets - the targets of the ritual
.EP
.SP 9 5
args - the ritual arguements

.EP

.SI 3
* %^BOLD%^event_npc_spell_casting%^RESET%^
.EI
.SI 5
void event_npc_spell_casting(object spell, object caster, object * targets, class spell_argument args)
.EI
.SP 7 5

This is the event called when a spell is being cast.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
spell_ob - the spell object
.EP
.SP 9 5
caster - the caster of the spell
.EP
.SP 9 5
targets - the targets of the spell
.EP
.SP 9 5
args - the spell arguements

.EP

.SI 3
* %^BOLD%^expand_mon_string%^RESET%^
.EI
.SI 5
void expand_mon_string(mixed str)
.EI
.SP 7 5

This method executes the string passed in.  It handles all the
stuff which is needed from the chat_string stuff.

If the input is a function pointer then it is evaluated with one
parameter, being the npc.

If the input is a string then the first letter determines what will
be done with it.  All these are passed through expand_string
so that exciting things can be done.

.EP
.SO 8 2 -12

	*	# - A call_other will be generated. The parameters are separated by ':'s, so "#frog:bing:fred:chicken" would call
.EO
.SO 8 2 -12
		this_object()->bing("fred", "chicken");
.EO
.SO 8 2 -12
		. ', ", : - These will generate a 'say', 'lsay' or 'emote'. @ - This will run the passed in command. Eg: "@frog" would cause the soul command frog to be used. Anything else will be used as a message to be sent to everyone in the room. 
.EO
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
str - the thing to execute
.EP

.SI 3
* %^BOLD%^expand_string%^RESET%^
.EI
.SI 5
string expand_string(string in_str, object on)
.EI
.SP 7 5

This method is used to expand the message strings used in the
npc messages.  It is used for chat strings and such things like
that.  The strings it expands are of the form:
.EP
.SP 7 5
$lname$, $mname$, $aname$, ...
.EP
.SP 7 5
The first letter determines the type of object being referenced. They are: 
.EP
.SP 7 5
m 
.EP
.SP 10 5
Me! The npc itself. 
.EP
.SP 7 5
l 
.EP
.SP 7 5
A living object, choose a random living object in the npcs environment. 
.EP
.SP 7 5
a 
.EP
.SP 10 5
Chooses a random attacker from those attacking the npc. 
.EP
.SP 7 5
o 
.EP
.SP 10 5
Choose a random object in the inventory of the npc. 
.EP
.SP 7 5
After the first letter is a type of information being request. 
.EP
.SP 10 5
name 
.EP
.SP 13 5
The name of the selected object. 
.EP
.SP 10 5
cname 
.EP
.SP 13 5
The capitalised name of the selected object. 
.EP
.SP 10 5
gender 
.EP
.SP 13 5
The gender string of the selected object (male, female, neuter). 
.EP
.SP 10 5
poss 
.EP
.SP 13 5
The possessive string of the selected object. 
.EP
.SP 10 5
obj 
.EP
.SP 13 5
The objective string of the selected object. 
.EP
.SP 10 5
pronoun 
.EP
.SP 13 5
The pronoun string of the selected object. 
.EP
.SP 10 5
gtitle 
.EP
.SP 13 5
The guild title of the selected object (only useful on livings). 
.EP
.SP 10 5
ashort 
.EP
.SP 13 5
The a_short() call. 
.EP
.SP 10 5
possshort 
.EP
.SP 13 5
The poss_short() call. 
.EP
.SP 10 5
theshort 
.EP
.SP 13 5
The the_short() call. 
.EP
.SP 10 5
oneshort 
.EP
.SP 13 5
The one_short() call. 
.EP
.SP 7 5

.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
in_str - the input string
.EP
.SP 9 5
on - the object to use for the 'o' matching

.EP

.SI 3
* %^BOLD%^get_next_route_direction%^RESET%^
.EI
.SI 5
string get_next_route_direction()
.EI
.SP 7 5

This method gets the next direction to go in the route which is
currently being followed.  It will remove this direction off the
array.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the next direction to go down
.EP

.SI 3
* %^BOLD%^give_money%^RESET%^
.EI
.SI 5
int give_money(int base, int rand, string type)
.EI
.SP 7 5

This method is used to give some startup money to the npc.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
base - the base amount of money to give (fixed)
.EP
.SP 9 5
rand - the random amount of money to give
.EP
.SP 9 5
type - the type of money to give (default: "copper")
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the return value of adjust_money()
.EP

.SI 3
* %^BOLD%^init_command%^RESET%^
.EI
.SI 5
varargs void init_command(string str, int tim)
.EI
.SP 7 5

This method allows you submit delayed commands to the npc
via a call_out.
.EP

.SI 3
* %^BOLD%^init_dynamic_arg%^RESET%^
.EI
.SI 5
void init_dynamic_arg(mapping args, object ob)
.EI

.SI 3
* %^BOLD%^init_equip%^RESET%^
.EI
.SI 5
void init_equip()
.EI
.SP 7 5

This method makes the npc initialise all their equipment, like hold
it and stuff.
.EP

.SI 3
* %^BOLD%^init_static_arg%^RESET%^
.EI
.SI 5
void init_static_arg(mapping args)
.EI

.SI 3
* %^BOLD%^load_a_chat%^RESET%^
.EI
.SI 5
void load_a_chat(int chance, mixed * c_s)
.EI
.SP 7 5

This method loads up the set of chat strings to use while in combat.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
chance - the chance of the chat occuring
.EP
.SP 9 5
c_s - the chat string to use
.EP

.SI 3
* %^BOLD%^load_chat%^RESET%^
.EI
.SI 5
void load_chat(int chance, mixed * c_s)
.EI
.SP 7 5

This method loads up the chat strings for the npc.  This will be
an array containing pairs of elements, the first pair is the
weighting of the chat and the second is the chat to use.


All the weights in the array are added up and then a random number is chosen in the weighting. Then that element is looked up in the array. This way you can control a chat and make it rare. 

If the chat string is an array then this a story, the story will be executed one after another and no other chats will be executed in between. If the first parameter of the story array is a number it will be used as a 1/1000 chance of the next story line being displayed. Special strings can be used which will replace with object names, see expand_mon_string() for further information. 

The chat chance is a chance (in 1000) of the chat occuring. You will need to play with this yourself to see which frequency of chatting you wish for your npcs. 
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
chance - the chance in 1000 of a chat working every 2 seconds
.EP
.SP 9 5
c_s - the chat string to use
.EP

.SI 3
* %^BOLD%^move_me_to%^RESET%^
.EI
.SI 5
varargs void move_me_to(string dest, int delay)
.EI
.SP 7 5

This method will move the npc to the specified destination.  The
npc will walk from where they currently are to the destination using
the time delay specified between the movements.


If the location is reached then the function "stopped_route" will be called on the npc. The first arguement to the function will be 0 if the npc did not reach its destination and 1 if it did.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
dest - the destination to go to
.EP
.SP 9 5
delay - the time delay between each move
.EP

.SI 3
* %^BOLD%^query_achat_chance%^RESET%^
.EI
.SI 5
int query_achat_chance()
.EI
.SP 7 5

This method returns the current chat chance for attack messages on
the npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current attack message chat chance
.EP

.SI 3
* %^BOLD%^query_achat_string%^RESET%^
.EI
.SI 5
string * query_achat_string()
.EI
.SP 7 5

This method queries the current chat string for attack messages on the
npc.  See load_chat() for a longer description of how the
chat string is formatted.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current attack message chat string
.EP

.SI 3
* %^BOLD%^query_aggressive%^RESET%^
.EI
.SI 5
int query_aggressive()
.EI
.SP 7 5

This method returns the current aggressive level of the npc.
If the aggressive is set to 1, then the npc will attack all players
that enter its environment.  If the aggressive is set to 2 then
the npc will attack everything (including other npcs).


See the function start_attack() for information about things you can do to stop aggressive npcs attacking things.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the aggressive level of the npc
.EP

.SI 3
* %^BOLD%^query_always_return_to_default_position%^RESET%^
.EI
.SI 5
int query_always_return_to_default_position()
.EI
.SP 7 5

This method returns the status of the flag that makes the npc return
to the default position if its position is changed.  The flag
specified the length of time to wait before causing the
default position to be restored.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the time to wait before the position is restored
.EP

.SI 3
* %^BOLD%^query_cannot_change_position%^RESET%^
.EI
.SI 5
int query_cannot_change_position()
.EI
.SP 7 5

This method returns the current value of the unable to change
position flag.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the unable to change position flag
.EP

.SI 3
* %^BOLD%^query_cap_name%^RESET%^
.EI
.SI 5
string query_cap_name()
.EI
.SP 7 5

This method returns the current capitalized name of the npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current capitalized name
.EP

.SI 3
* %^BOLD%^query_chat_chance%^RESET%^
.EI
.SI 5
int query_chat_chance()
.EI
.SP 7 5

This method returns the current chat chance for messages on
the npc
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current chat chance
.EP

.SI 3
* %^BOLD%^query_chat_string%^RESET%^
.EI
.SI 5
string * query_chat_string()
.EI
.SP 7 5

This method queries the current chat string for messages on the
npc.  See load_chat() for a longer description of how the
chat string is formatted.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current chat string
.EP

.SI 3
* %^BOLD%^query_combat_actions%^RESET%^
.EI
.SI 5
mixed * query_combat_actions()
.EI
.SP 7 5

This method returns the current array of combat actions on the
npc.


The array will have the format of: 
.EP
.SP 7 5
   ({
.EP
.SP 7 5
       action1_chance,
.EP
.SP 7 5
       action1_name,
.EP
.SP 7 5
       action1_action,
.EP
.SP 7 5
       ...
.EP
.SP 7 5
    })
.EP
.SP 7 5

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the combat action array
.EP

.SI 3
* %^BOLD%^query_death_xp%^RESET%^
.EI
.SI 5
int query_death_xp()
.EI
.SP 7 5

This method returns the amount of death experiecne that would be
gained by killing the npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the amount of death experience for the npc

.EP

.SI 3
* %^BOLD%^query_dynamic_auto_load%^RESET%^
.EI
.SI 5
mapping query_dynamic_auto_load()
.EI

.SI 3
* %^BOLD%^query_enter_commands%^RESET%^
.EI
.SI 5
string * query_enter_commands()
.EI
.SP 7 5

This method returns the current array of enter commands.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current array of enter commands
.EP

.SI 3
* %^BOLD%^query_fight_type%^RESET%^
.EI
.SI 5
int query_fight_type()
.EI
.SP 7 5

This method returns the flag which allows the npc to join into fights.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if the npc is to join fights, 0 if not
.EP

.SI 3
* %^BOLD%^query_follow_speed%^RESET%^
.EI
.SI 5
int query_follow_speed()
.EI
.SP 7 5

This method queries the speed at which the npc will follow
after a player when they leave combat.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current follow speed
.EP

.SI 3
* %^BOLD%^query_following_route%^RESET%^
.EI
.SI 5
string * query_following_route()
.EI
.SP 7 5

This method returns the current array of directions we are following
as a route.
.EP

.SI 3
* %^BOLD%^query_guild%^RESET%^
.EI
.SI 5
string query_guild()
.EI
.SP 7 5

This method returns the current guild of the npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
this current guild of the npc
.EP

.SI 3
* %^BOLD%^query_guild_ob%^RESET%^
.EI
.SI 5
mixed query_guild_ob()
.EI
.SP 7 5

This returns the guild object associated with the npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the guild object associated with the npc
.EP

.SI 3
* %^BOLD%^query_join_fights%^RESET%^
.EI
.SI 5
string query_join_fights()
.EI
.SP 7 5

This method returns the message to use when joining into fights.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the message to print when joining a fight
.EP

.SI 3
* %^BOLD%^query_last_route_direction%^RESET%^
.EI
.SI 5
int query_last_route_direction()
.EI
.SP 7 5

This method tells us if the npc is currently following a route.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if there are route directions to follow still
.EP

.SI 3
* %^BOLD%^query_level%^RESET%^
.EI
.SI 5
int query_level()
.EI
.SP 7 5

This method returns the current guild level of the npc.  This is
a pass through call to a function on the guild object associated
with this npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current guild level of the object
.EP

.SI 3
* %^BOLD%^query_move_after%^RESET%^
.EI
.SI 5
mixed query_move_after()
.EI
.SP 7 5

This method returns the current move after values.
It returns an array of the form:
.EP
.SP 7 5
   ({
.EP
.SP 7 5
     after,
.EP
.SP 7 5
     rand,
.EP
.SP 7 5
    })
.EP
.SP 7 5

.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the move after values
.EP

.SI 3
* %^BOLD%^query_move_zones%^RESET%^
.EI
.SI 5
string * query_move_zones()
.EI
.SP 7 5

This method returns the current list of move zones on the npc
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current list of move zones
.EP

.SI 3
* %^BOLD%^query_ok_turn_off_heart_beat%^RESET%^
.EI
.SI 5
int query_ok_turn_off_heart_beat()
.EI
.SP 7 5

This method returns 1 if it is ok to turn of the npc's heart beat.
THis can be overridden for times when the heart beat needs to be
kept on for some reason.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if the heart beat should go off, 0 if it should stay on

.EP

.SI 3
* %^BOLD%^query_queued_commands%^RESET%^
.EI
.SI 5
mixed * query_queued_commands()
.EI
.SP 7 5

This method returns the queued command list.
.EP

.SI 3
* %^BOLD%^query_race%^RESET%^
.EI
.SI 5
string query_race()
.EI
.SP 7 5

This method returns the current race of the npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current race of the object
.EP

.SI 3
* %^BOLD%^query_race_ob%^RESET%^
.EI
.SI 5
mixed query_race_ob()
.EI
.SP 7 5

This returns the race object associated with the npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the race object associated with the npc
.EP

.SI 3
* %^BOLD%^query_spell_actions%^RESET%^
.EI
.SI 5
mapping query_spell_actions()
.EI
.SP 7 5

This method returns the list of spell actions present on the
npc.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the list of spell actions

.EP

.SI 3
* %^BOLD%^query_throw_out%^RESET%^
.EI
.SI 5
mixed * query_throw_out()
.EI
.SP 7 5

This method returns the current throw out array.
The array consists of
({
.EP
.SP 7 5
  hps,
.EP
.SP 7 5
  chance,
.EP
.SP 7 5
  their_mess,
.EP
.SP 7 5
  everyone_mess
.EP
.SP 7 5
})
.EP
.SP 7 5
The parameters are the same as used in the set_throw_out function.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the throw out array

.EP

.SI 3
* %^BOLD%^query_true_location%^RESET%^
.EI
.SI 5
string query_true_location()
.EI
.SP 7 5

This method returns the true location of the npc.  This is
the real room it is in, not the room it is currently in.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the true location of the npc
.EP

.SI 3
* %^BOLD%^query_virtual_move%^RESET%^
.EI
.SI 5
int query_virtual_move()
.EI

.SI 3
* %^BOLD%^queue_command%^RESET%^
.EI
.SI 5
varargs int queue_command(string words, int interval)
.EI
.SP 7 5

This method allows you to control the npc and get it to do
actions where they are queued as for players.  If there are no
commands pending the command is executed immediately.  This function
is 100% compatible with delay_command() and init_command().
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
words - the action to perform
.EP
.SP 9 5
interval - to wait before processing another command.
If omitted defaults to 2 seconds as per players
.EP

.SI 3
* %^BOLD%^rand_num%^RESET%^
.EI
.SI 5
int rand_num(int no, int type)
.EI
.SP 7 5

This method generates a random number.  It used to setup the random
stats.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
no - the number of times to roll the dice
.EP
.SP 9 5
type - the size of the dice
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the randomly generate number

.EP

.SI 3
* %^BOLD%^real_room%^RESET%^
.EI
.SI 5
void real_room(string check_room)
.EI
.SP 7 5

This method moves the npc to room it is really supposed to be in.
This is used with the virtual moving
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
check_room - the place where it thinks we are
.EP

.SI 3
* %^BOLD%^remove_achat_string%^RESET%^
.EI
.SI 5
void remove_achat_string(mixed chat)
.EI
.SP 7 5

This method attempts to remove the given chat string from the
current list of attack message chat strings.  The chat message is checked
to see if it exists in the array, the weighting of the
string is ignored.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
chat - the chat string to remove
.EP

.SI 3
* %^BOLD%^remove_chat_string%^RESET%^
.EI
.SI 5
void remove_chat_string(mixed chat)
.EI
.SP 7 5

This method attempts to remove the given chat string from the
current list of chat strings.  The chat message is checked
to see if it exists in the array, the weighting of the
string is ignored.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
chat - the chat string to remove
.EP

.SI 3
* %^BOLD%^remove_combat_action%^RESET%^
.EI
.SI 5
int remove_combat_action(string name)
.EI
.SP 7 5

This method will remove the combat action with the specified name.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if it is found and removed, 0 if not
.EP

.SI 3
* %^BOLD%^remove_move_zone%^RESET%^
.EI
.SI 5
void remove_move_zone(mixed zone)
.EI
.SP 7 5

This method removes a move zone from the npc.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
zone - the zone to remove
.EP

.SI 3
* %^BOLD%^remove_spell_action%^RESET%^
.EI
.SI 5
int remove_spell_action(string name)
.EI
.SP 7 5

This method removes the specified spell action.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
name - the name of the spell to remove
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if successful, 0 if not

.EP

.SI 3
* %^BOLD%^reset_enter_commands%^RESET%^
.EI
.SI 5
void reset_enter_commands()
.EI
.SP 7 5

This method resets the array of enter commands back to nothing.
.EP

.SI 3
* %^BOLD%^run_away%^RESET%^
.EI
.SI 5
int run_away()
.EI
.SP 7 5

This method is used to make the npc run away.  This will be
called by the combat code for wimpy when the npc is bellow the
number of points used to trigger the wimpy action.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
1 if successfuly ran away

.EP

.SI 3
* %^BOLD%^set_achat_chance%^RESET%^
.EI
.SI 5
void set_achat_chance(int i)
.EI
.SP 7 5

This method sets the current chat chance for attack messages on the
npc.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the attack message chat chance
.EP

.SI 3
* %^BOLD%^set_achat_string%^RESET%^
.EI
.SI 5
void set_achat_string(string * chat)
.EI
.SP 7 5

This method sets the current chat string for attack messages on the
npc.  See load_chat() for a longer description of how the
chat string is formatted.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
chat - the new chat attack message strings.
.EP

.SI 3
* %^BOLD%^set_aggressive%^RESET%^
.EI
.SI 5
void set_aggressive(int a)
.EI
.SP 7 5

This method sets the current aggressive level of the npc.
If the aggressive is set to 1, then the npc will attack all players
that enter its environment.  If the aggressive is set to 2 then
the npc will attack everything (including other npcs).


See the function start_attack() for information about things you can do to stop aggressive npcs attacking things.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
a - the new aggressive level

.EP

.SI 3
* %^BOLD%^set_always_return_to_default_position%^RESET%^
.EI
.SI 5
void set_always_return_to_default_position(int tim)
.EI
.SP 7 5

This method sets the status of the flag that makes the npc return
to the default position if its position is changed.  The flag
specified the length of time to wait before causing the
default position to be restored.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
tim - the time to wait before the position is restored
.EP

.SI 3
* %^BOLD%^set_cannot_change_position%^RESET%^
.EI
.SI 5
void set_cannot_change_position(int flag)
.EI
.SP 7 5

This method sets the value of the unable to change position flag.
This flag will be checked by the soul, and by anything else which
deliberatly changes someones position.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
flag - the unable to change position flag
.EP

.SI 3
* %^BOLD%^set_cap_name%^RESET%^
.EI
.SI 5
void set_cap_name(string s)
.EI
.SP 7 5

This method set the current capitalized name of the npc.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
s - the capitalized name of the npc
.EP

.SI 3
* %^BOLD%^set_chat_chance%^RESET%^
.EI
.SI 5
void set_chat_chance(int i)
.EI
.SP 7 5

This method sets the current chat chance for messages on the
npc.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the chat chance
.EP

.SI 3
* %^BOLD%^set_chat_string%^RESET%^
.EI
.SI 5
void set_chat_string(string * chat)
.EI
.SP 7 5

This method sets the current chat string for messages on the
npc.  See load_chat() for a longer description of how the
chat string is formatted.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
chat - the new chat strings.
.EP

.SI 3
* %^BOLD%^set_follow_speed%^RESET%^
.EI
.SI 5
void set_follow_speed(int f)
.EI
.SP 7 5

This method sets the speed at which the npc will follow
after a player when they leave combat.
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
the current follow speed
.EP

.SI 3
* %^BOLD%^set_guild%^RESET%^
.EI
.SI 5
int set_guild(string str)
.EI
.SP 7 5

This method is deprecated.  Use basic_setup() instead.

This method sets the current guild of the npc to the
passed in value.  The guild should be one of
the guilds listed in the /std/race.c object.
This is used in conjuction with the
race when set_level is called to setup the default
attributes for the npc.  This should only be
called *before* set_level() is called.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
str - the new guild for the npc
.EP

.SI 3
* %^BOLD%^set_guild_ob%^RESET%^
.EI
.SI 5
void set_guild_ob(mixed g)
.EI
.SP 7 5

This method sets the guild object associated with the npc.
This will probably not do what you expect and cannot be used
in conjucton with set_level to set the guild.  It is called
by /std/race.c when set_level() is called.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
g - the new guild object

.EP

.SI 3
* %^BOLD%^set_join_fight_type%^RESET%^
.EI
.SI 5
void set_join_fight_type(int i)
.EI
.SP 7 5

This method sets the flag which allows the npc to join into fights.
If this is set to a non-zero value then the npc will join into
fights in progress using the fight joining message.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - 1 if the npc is to join fights, 0 if not
.EP

.SI 3
* %^BOLD%^set_join_fights%^RESET%^
.EI
.SI 5
void set_join_fights(string str)
.EI
.SP 7 5

This method sets the message to use when joining into fights.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
str - the message to print when joining a fight
.EP

.SI 3
* %^BOLD%^set_level%^RESET%^
.EI
.SI 5
void set_level(int i)
.EI
.SP 7 5

This function is deprecated.  Use basic_setup() instead.

This method sets the level of the npc.  This should only be called
*after* the race and guild are set.  If this is called before that
the results will be unexpected.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
i - the level to set the npc to

.EP

.SI 3
* %^BOLD%^set_move_after%^RESET%^
.EI
.SI 5
void set_move_after(int after, int rand)
.EI
.SP 7 5

This method sets the speed at which the npc will randomly
wander around.  The npc will wander at the speed:
.EP
.SP 7 5
speed = after + random(rand)
.EP
.SP 7 5
This is called every time the npc sets up for its next move. 

The move zones control which areas the npcs will wander into, a move zone is set on the room and the npcs will only enter rooms which have a matching move zone. If there is no move zone, then the npc will enter any room.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
after - the fixed amount of time
.EP
.SP 9 5
rand - the random amount of time
.EP

.SI 3
* %^BOLD%^set_race%^RESET%^
.EI
.SI 5
int set_race(string str)
.EI
.SP 7 5

This function is deprecated.  Use basic_setup() instead.

This method sets the race of the npc.  The race should be one of
the races listed in the /std/race.c object.
This is used in conjuction with the
guild when set_level is called to setup the default
attributes for the npc.  This should only be
called *before* set_level() is called.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
str - the race to set
.EP
.SI 7
%^BOLD%^Returns:%^RESET%^
.EI
.SP 9 5
always returns 1
.EP

.SI 3
* %^BOLD%^set_race_ob%^RESET%^
.EI
.SI 5
void set_race_ob(mixed r)
.EI
.SP 7 5

This method sets the race object associated with the npc.
This will probably not do what you expect and cannot be used
in conjucton with set_level to set the race.  It is called
by /std/race.c when set_level() is called.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
r - the new race object

.EP

.SI 3
* %^BOLD%^set_random_stats%^RESET%^
.EI
.SI 5
void set_random_stats(int no, int type)
.EI
.SP 7 5

This method sets the stats for the npc to some exciting random
values.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
no - the number of times to roll the dice
.EP
.SP 9 5
type - the size of the dice
.EP

.SI 3
* %^BOLD%^set_throw_out%^RESET%^
.EI
.SI 5
void set_throw_out(int hps, int chance, string their_mess, string everyone_mess)
.EI
.SP 7 5

This method is used to determine when to throw people out of a
room.  This is what detritus uses to throw people out of the
mended drum when it gets a bit rowdy.


The hps is the level of hps at which the npc will start throwing people out with the chance of it occuring (chance is a percentage). 

People will be thrown into a random room, if the property "no throw out"is specified on the room then they will not be thrown into that room.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
hps - the number of hps at which to start throwing people out
.EP
.SP 9 5
chance - the percentage chance of being thrown out
.EP
.SP 9 5
their_mess - the message to show them
.EP
.SP 9 5
everyone_mess - the message to show everyone else
.EP

.SI 3
* %^BOLD%^set_true_location%^RESET%^
.EI
.SI 5
void set_true_location(string word)
.EI
.SP 7 5

This method sets the true location of the npc.  This is
the real room it is in, not the room it is currently in.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
word - the new true location of the npc
.EP

.SI 3
* %^BOLD%^set_virtual_move%^RESET%^
.EI
.SI 5
void set_virtual_move(int number)
.EI
.SP 7 5

This method sets the current virual move ability of the npc.
NB: This is currently disabled virtual moving is not possible
at all.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
number - 1 for virtual moving, 0 for not
.EP

.SI 3
* %^BOLD%^setup_nationality%^RESET%^
.EI
.SI 5
void setup_nationality(string nationality, string region)
.EI
.SP 7 5

This method sets up a nationality and sets up a region in the
nationality for the npc.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
nationality - the nationality to set
.EP
.SP 9 5
region - the region in the nationality

.EP

.SI 3
* %^BOLD%^start_attack%^RESET%^
.EI
.SI 5
void start_attack(object who)
.EI
.SP 7 5

This method check to see if the npc should start attacking someone
when they enter the npcs environment.  It is called from inside
init().  It will only attack if the agressive is set and the
person is visible to be attacked.  The property
"no attack"can be set on the npc (or player) to stop them being attacked.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
who - the person to potentially start attacking
.EP


.SH Protected Functions
.SP 5 5
These are functions that only objects inheriting the class can access.
.EP

.SI 3
* %^BOLD%^got_the_route%^RESET%^
.EI
.SI 5
void got_the_route(string * route, int delay, string dest)
.EI
.SP 7 5

This method is called by the move_me_to function after the
route handler has successfuly discovered the route to follow.
.EP
.SI 7
%^BOLD%^Parameters:%^RESET%^
.EI
.SP 9 5
route - the route to follow
.EP
.SP 9 5
delay - the delay to follow it with
.EP
.SP 9 5
dest - route destination
.EP


// --- END [/mnt/home2/grok/lib/doc/autodoc/obj.monster.c] ---
// --- BEGIN [/mnt/home2/grok/lib/w/pinkfish/quarto.c] ---
// Size:   File: "/mnt/home2/grok/lib/w/pinkfish/quarto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626705   Available: 13574059
Inodes: Total: 5242880    Free: 4960132
3857 bytes, Last Modified:   File: "/mnt/home2/grok/lib/w/pinkfish/quarto.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626705   Available: 13574059
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Quarto, a nifty game of connect-4.
 * @author Pinkfish
 * @started Mon Dec 11 08:49:30 PST 2000
 */
inherit "/obj/furnitures/misc/games/multiplayer_base";
inherit "/std/room/furniture/basic";

private mixed* _board;
private int _next_piece;
private int* _pool;

#define FLAG_SIZE   1
#define FLAG_CENTER 2
#define FLAG_COLOUR 4
#define FLAG_SHAPE  8

void create() {
   multiplayer_base::create();
   basic::create();
} /* create() */

void setup() {
   set_short("quarto board");
   add_adjective("quarto");
   add_alias("quarto");
   set_name("board");

   set_long("A small board with 4 x 4 circles draw on the surface.  There "
            "are 16 pieces of varying colours and sizes placed in little "
            "sockets around the board.\n");

   add_player_id_type("green", 0);
   add_player_id_type("red", 0);

   set_minimum_needed(2);

   reset_game();
} /* setup() */

/**
 * This method resets the board to the start position.
 */
void reset_game() {
   int i;

   _board = allocate(4, (: allocate(4, -1) :));
   _pool = allocate(16);
   for (i = 0; i < sizeof(_pool); i++) {
      _pool[i] = i;
   }
} /* reset_game() */

/**
 * This method is called to start the game.
 */
void start_game() {
   string id;

   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
} /* start_game() */

/**
 * This method returns the type of the piece as an array.
 * @param id the id of the piece
 * @return the piece type
 */
string* query_piece_type_string(int id) {
   string outside;
   string center;

   if (id == -1) {
      return ({ "    ",
                "    ",
                "    ",
                "    " });
   }

/*
 *     +
 *    +X+
 *     +
 *
 *    +++
 *    + +
 *    +++
 *
 *    ++++      ++
 *    +XX+     +  +
 *    +XX+     +  +
 *    ++++      ++
 */
   if (id & FLAG_CENTER) {
      center = "X";
   } else {
      center = " ";
   }

   if (id & FLAG_COLOUR) {
      outside = "*";
   } else {
      outside = "+";
   }

   if (id & FLAG_SIZE) {
      if (id & FLAG_SHAPE) {
         return ({ outside + outside + outside + outside,
                   outside + center + center + outside,
                   outside + center + center + outside,
                   outside + outside + outside + outside });
      } else {
         return ({ " " + outside + outside + " ",
                   outside + center + center + outside,
                   outside + center + center + outside,
                   " " + outside + outside + " " });
      }
   } else {
      if (id & FLAG_SHAPE) {
         return ({ "    ",
                   " " + outside + outside + outside,
                   " " + outside + center + outside,
                   " " + outside + outside + outside });
      } else {
         return ({ "    ",
                   "  " + outside + " ",
                   " " + outside + center + outside,
                   "   " + outside + " " });
      }
   }
} /* query_piece_type() */

/**
 * The board itself.
 * @return the board string
 */
string query_board_string() {
   string ret;
   string* lines;
   string* bit;
   int x;
   int y;
   int i;

   ret = "";
   for (y = 0; y < sizeof(_board[0]); y++) {
      ret += ".....";
   }
   ret += ".\n";
   for (x = 0; x < sizeof(_board); x++) {
      lines = allocate(4, "");
      for (y = 0; y < sizeof(_board[x]); y++) {
         bit = query_piece_type_string(_board[x][y]);
         for (i = 0; i < sizeof(bit); i++) {
            lines[i] += "." + bit[i];
         }
      }
      for (i = 0; i < sizeof(bit); i++) {
         ret += lines[i] + ".\n";
      }
      for (y = 0; y < sizeof(_board[x]); y++) {
         ret += ".....";
      }
      ret += ".\n";
   }

   return ret;
} /* query_board_string() */

string long() {
   return ::long() + query_board_string();
} /* long() */

void init() {
   ::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/w/pinkfish/quarto.c] ---
// --- BEGIN [/mnt/home2/grok/lib/w/pinkfish/card_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/w/pinkfish/card_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626704   Available: 13574058
Inodes: Total: 5242880    Free: 4960132
6588 bytes, Last Modified:   File: "/mnt/home2/grok/lib/w/pinkfish/card_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626704   Available: 13574058
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a base to make up randomised decks of cards.
 * @author Pinkfish
 * @started Thu Dec  7 07:34:10 PST 2000
 */
#include "card_base.h"

#define CARD_NUM_MAX CARD_NUMBER_KING

class playing_card* make_deck(int number_of_decks,
                              int number_of_jokers) {
   class playing_card* deck;
   class playing_card card;
   int i;
   int suit;
   int num;

   for (i = 0; i < number_of_decks; i++) {
      for (suit = CARD_SUIT_HEARTS; suit <= CARD_SUIT_SPADES; suit++) {
         for (num = 1; num <= CARD_NUM_MAX; num++) {
            card = new(class playing_card);
            card->suit = suit;
            card->number = num;
            deck += ({ card });
         }
      }
   }
   for (i = 0; i < number_of_jokers; i++) {
      card = new(class playing_card);
      card->suit = CARD_SUIT_JOKER;
      deck += ({ card });
   }
   return deck;
} /* make_deck() */

/**
 * This method scrabled the deck and shuffles it.
 * @param deck the deck to shuffle
 * @return a shuffled deck
 */
class playing_card* shuffle_deck(class playing_card* deck) {
   class playing_card* new_deck;
   int pos;
   int i;

   for (i = 0; i < 2; i++) {
      new_deck = ({ });
      while (sizeof(deck)) {
         pos = random(sizeof(deck));
         new_deck += deck[pos..pos];
         deck = deck[0..pos - 1] + deck[pos+1..];
      }
      deck = new_deck;
   }
   return deck;
} /* shuffle_deck() */

/**
 * This method returns the three character string for the card.
 * @return the three character string for the card
 */
string query_card_string(class playing_card card) {
   string ret;

   ret = "";
   switch (card->suit) {
   case CARD_SUIT_SPADES :
      ret = "S";
      break;
   case CARD_SUIT_HEARTS :
      ret = "H";
      break;
   case CARD_SUIT_DIAMONDS :
      ret = "D";
      break;
   case CARD_SUIT_CLUBS :
      ret = "C";
      break;
   case CARD_SUIT_JOKER :
      return "*J*";
   }

   if (card->number > 10) {
      switch (card->number) {
      case CARD_NUMBER_JACK :
         ret = "J " + ret;
         break;
      case CARD_NUMBER_QUEEN :
         ret += "Q " + ret;
         break;
      case CARD_NUMBER_KING :
         ret += "K " + ret;
         break;
      }
   } else {
      ret = sprintf("%2d%s", card->number, ret);
   }
   return ret;
} /* query_card_string() */

/**
 * This method determines if the card colour is red.
 * @param card the card to check
 * @return 1 if it is, 0 if not
 */
int is_card_red(class playing_card card) {
   return card->suit == CARD_SUIT_HEARTS || card->suit == CARD_SUIT_DIAMONDS;
} /* is_card_red() */

/**
 * This method determines if the card colour is black.
 * @param card the card to check
 * @return 1 if it is, 0 if not
 */
int is_card_black(class playing_card card) {
   return card->suit == CARD_SUIT_SPADES || card->suit == CARD_SUIT_CLUBS;
} /* is_card_black() */

/**
 * This method checks to see if the card is a joker.
 * @param card the card to check
 * @return 1 if it is, 0 if not
 */
int is_card_joker(class playing_card card) {
   return card->suit == CARD_SUIT_JOKER;
} /* is_card_joker() */

/**
 * This method makes a array for a 3x3 card.
 * @param card the card to make 3x3
 * @return the three line array
 */
string* query_card_three(class playing_card card) {
   string* lines;

   lines = allocate(3);
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] = "H  ";
      lines[2] = "  H";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] = "D  ";
      lines[2] = "  D";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] = "C  ";
      lines[2] = "  C";
      break;
   case CARD_SUIT_SPADES :
      lines[0] = "S  ";
      lines[2] = "  S";
      break;
   case CARD_SUIT_JOKER :
      lines[0] = "J *";
      lines[1] = " O ";
      lines[2] = "* K";
      return lines;
   }

   if (card->number <= 10) {
      lines[1] = sprintf(" %2d", card->number);
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] = " K ";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] = " Q ";
         break;
      case CARD_NUMBER_JACK :
         lines[1] = " J ";
         break;
      }
   }
   return lines;
} /* query_card_three() */

/**
 * This method makes a array for a 2x2 card.
 * @param card the card to make 2x2
 * @return the two line array
 */
string* query_card_two(class playing_card card) {
   string* lines;

   lines = allocate(2);
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] = "H ";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] = "D ";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] = "C ";
      break;
   case CARD_SUIT_SPADES :
      lines[0] = "S ";
      break;
   case CARD_SUIT_JOKER :
      lines[0] = "J*";
      lines[1] = "*O";
      return lines;
   }

   if (card->number <= 10) {
      lines[1] = sprintf("%-2d", card->number);
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] = " K";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] = " Q";
         break;
      case CARD_NUMBER_JACK :
         lines[1] = " J";
         break;
      }
   }
   return lines;
} /* query_card_three() */

/**
 * This method returns a string showing the hand.
 * @param hand the hand to show
 * @param three 1 for a 3x3, 0 for a 2x2
 * @return a string representation of the hand
 */
string query_hand_string(class playing_card* hand, int flags) {
   string hand_str;
   int i;
   int j;
   string top;
   string line;
   string start;
   string end;
   mixed card_str;

   hand_str = "";
   if (!(flags & CARD_HAND_NO_ADORNMENTS)) {
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         top = "+---+";
      } else {
         top = "+--+";
      }

      //
      // Make the top of the card.
      //
      line = "";
      for (i = 0; i < sizeof(hand); i++) {
         line += top;
      }
      line += "\n";
      hand_str += line;

      start = "|";
      end = "|";
   } else {
      line = "";
      start = " ";
      end = " ";
   }

   hand_str += "\n";

   if (flags & CARD_HAND_THREE) {
      card_str = map(hand, (: query_card_three :));
   } else if (flags & CARD_HAND_SINGLE) {
      card_str = map(hand, (: ({ query_card_string($1) }) :));
   } else {
      card_str = map(hand, (: query_card_two :));
   }

   for (j = 0; j < sizeof(card_str[0]); j++) {
      for (i = 0; i < sizeof(card_str); i++) {
         card_str += start + (card_str[i][j]) + end;
      }
   }

   hand_str += line;

   return hand_str;
} /* query_hand_string() */
// --- END [/mnt/home2/grok/lib/w/pinkfish/card_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/w/pinkfish/multiplayer_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/w/pinkfish/multiplayer_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626702   Available: 13574056
Inodes: Total: 5242880    Free: 4960132
16454 bytes, Last Modified:   File: "/mnt/home2/grok/lib/w/pinkfish/multiplayer_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626702   Available: 13574056
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The base chunk for doing multiplayer board games.
 * @author Pinkfish
 * @started Thu Dec  7 01:27:46 PST 2000
 */
private inherit "/std/basic/auto_load";

#define LOAD_TAG "multiplayer base"

class player_info {
   int number;
   string cap_name;
   string name;
   mixed data;
}

private mapping _players;
private string _winner;
private string* _ids_when_started;
private string _current_player;
private int _minimum_needed;
private int _maximum_allowed;
private int _can_join_as_new;
private int _game_started;

string* query_currently_playing_ids();
void delete_gone_players();
string find_player_id_of_person(object person);

void create() {
   _players = ([ ]);
   _ids_when_started = ({ });
} /* create() */

/**
 * This method should be defined in the top level, it should also
 * call this method to setup stuff as needed when a game starts.
 */
void reset_game() {
//   renumber_players();
} /* reset_game() */

/**
 * This method should be called when a game starts.
 * @return 1 if started, 0 if not enough players
 */
int start_game() {
   delete_gone_players();
   if (sizeof(query_currently_playing_ids()) < _minimum_needed) {
      return 0;
   }
   _winner = 0;
   _game_started = 1;
   _ids_when_started = query_currently_playing_ids();
   //
   // Pick one of these guys to start with.
   //
   _current_player = _ids_when_started[random(sizeof(_ids_when_started))];
   return 1;
} /* start_game() */

/**
 * This method is called when the game ends to set the winner.
 * @param winner the winner
 */
void finish_game(string winner) {
   _winner = winner;
   _game_started = 0;
} /* finish_game() */

/**
 * This method returns the current winner of the game.
 * @return the winner of the game
 */
string query_winner() {
   return _winner;
} /* query_winner() */

/**
 * This method checks to see if the game has started.
 * @return 1 if it has, 0 if it has not
 */
int is_game_started() {
   return _game_started;
} /* is_game_started() */

/**
 * This method checks to see if you can join as a new player, or only
 * occupy the slots from the start of the game.
 * @return 1 if you can join as new
 */
int can_join_as_new_player() {
   return _can_join_as_new;
} /* can_join_as_new_player() */

/**
 * This method sets the flag to allow you to make the game allow players
 * to join after they have started the game.
 * @param join 1 if they can join after the game has started
 */
void set_can_join_as_new_player(int join) {
   _can_join_as_new = join;
} /* set_can_join_as_new_player() */

/**
 * This method checks to see if the person is here.
 * @param person the person to check
 * @return 1 if they are, 0 if not
 */
int is_person_playing(string id) {
   if (_players[id]->name) {
      if (find_player(_players[id]->name) &&
          is_in_me_or_environment(this_object(),
                                  find_player(_players[id]->name)) &&
          interactive(find_player(_players[id]->name))) {
         return 1;
      }
   }
   return 0;
} /* is_person_player() */

/**
 * This method checks to see if the player is player.
 * @return 1 if they are playing, 0 if not
 */
int is_playing(object ob) {
   string id;

   id = find_player_id_of_person(ob);
   return id != 0;
} /* is_playing() */

/**
 * This method checks to see if the object is the current player or not.
 * @return 1 if they are, 0 if not
 */
int is_current_player(object ob) {
   string id;

   id = find_player_id_of_person(ob);
   return id == _current_player;
} /* is_current_player() */

/**
 * This method lets the person join the game.
 * @param id the id of the person to add
 * @param person the person to join
 * @return 1 on success, 0 on failure
 */
int add_person_to_game(string id, object person) {
   class player_info info;

   if (is_person_playing(id)) {
      return 0;
   }
   info = _players[id];
   //info->player_num = _current_player_num++;
   info->name = person->query_name();
   info->cap_name = person->query_cap_name();
   return 1;
} /* add_person_to_game() */

/**
 * This method removes a person from the game.
 * @param person the person to remove
 * @return 1 on success, 0 on failure
 */
int remove_person_object_from_game(object person) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         info->name = 0;
         info->cap_name = 0;
         return 1;
      }
   }
   return 0;
} /* remove_person_object_from_game() */

/**
 * This method removes a person from the game.
 * @param id the id to remove
 * @return 1 on success, 0 on failure
 */
int remove_person_id_from_game(string id) {
   if (_players[id]->name) {
      _players[id]->name = 0;
      return 1;
   }
   return 0;
} /* remove_person_object_from_game() */

/**
 * This method randomises the numbers  of the players.
 */
void randomise_player_numbers() {
   string* ids;
   int num;
   int pos;

   ids = keys(_players);
   num = 0;
   while (sizeof(ids)) {
      pos = random(sizeof(ids));
      _players[ids[pos]]->number = num;
      ids = ids[0..pos-1] + ids[pos+1..];
      num++;
   }
} /* randomise_player_nambers() */

/**
 * This method adds a type of allowed player.
 * @param id the id to be allowed
 * @param number the start player number
 */
void add_player_id_type(string id, int number) {
   _players[id] = new(class player_info);
   _players[id]->number = number;
} /* add_player_id_type() */

/**
 * This method removes a player id type.
 * @param id the id to remove
 */
void remove_player_id_type(string id) {
   map_delete(_players, id);
} /* remove_player_id_type() */

/**
 * This method figures out the info structure from the number of the player.
 * @param number the number to lookup
 * @return the info structure, 0 if not found
 */
class player_info find_player_info_from_number(int num) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (info->number == num) {
         return info;
      }
   }
   return 0;
} /* find_player_info_from_number() */

/**
 * This method figures out the id from the number of the player.
 * @param number the number to lookup
 * @return the id, 0 if not found
 */
string find_player_id_from_number(int num) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (info->number == num) {
         return id;
      }
   }
   return 0;
} /* find_player_info_from_number() */

/**
 * This method returns all the ids for the players.
 * @return the ids for the player
 */
string* query_player_ids() {
   return keys(_players);
} /* query_player_ids() */

/**
 * This method returns the list of ids who are current playing.
 * @return the list of currently playing ids
 */
string* query_currently_playing_ids() {
   return filter(keys(_players), (: _players[$1]->name :));
} /* query_currently_playing_ids() */

/**
 * This method returns the list of ids of people who started playing the
 * game.
 * @return the list of people who started playing the game
 */
string* query_started_player_ids() {
   return _ids_when_started;
} /* query_started_player_ids() */

/**
 * This method returns the players cap name from the player id.
 * @param id the id to look up from
 * @return the players cap name
 */
string query_player_cap_name(string id) {
   if (_players[id]->name) {
      return _players[id]->cap_name;
   }
   return "No one";
} /* query_player_cap_name() */

/**
 * This method returns the player object from the player id.
 * @param id the id for the player
 * @return the player object
 */
object query_player_object(string id) {
   return find_player(_players[id]->name);
} /* query_player_object() */

/**
 * This method nips through the list of players and checks to see if they
 * are in the room or not.  If they are not it deletes them from the array.
 * Useful for start games or cleanups.
 */
void delete_gone_players() {
   string id;
   class player_info info;

   foreach (id, info in _players) {
      if (info->name) {
         if (!find_player(info->name) ||
             !is_in_me_or_environment(this_object(), find_player(info->name))) {
            info->name = 0;
         }
      }
   }
} /* delete_gone_players() */

/**
 * This method sets the minimum number of players needed to play the
 * game.
 * @param minimum the minimum needed
 */
void set_minimum_needed(int minimun) {
   _minimum_needed = minimun;
} /* set_minimum_needed() */

/**
 * This method checks to see if the minimum requirements for starting the
 * game have been met.
 * @return 1 on success, 0 on failure
 */
int can_start_game() {
   if (sizeof(query_currently_playing_ids()) > _minimum_needed) {
      return 1;
   }
   return 0;
} /* can_start_game() */

/**
 * This method finds the next player to the specified one.
 * @param id the id of the player to find, 0 means current player
 * @return the next id
 */
string find_next_player(string id) {
   class player_info info;
   int start;
   int cur;
   string new_id;

   if (!id) {
      id = _current_player;
   }

   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur + 1) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
                member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
} /* find_next_player() */

/**
 * This method finds the previous player to the specified one.
 * @param id the id of the player to find, 0 means current player
 * @return the previous id
 */
string find_previous_player(string id) {
   class player_info info;
   int start;
   string new_id;
   int cur;

   if (!id) {
      id = _current_player;
   }

   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur - 1 + sizeof(_players)) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
               member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
} /* find_previous_player() */

/**
 * This method increments the player number to the next available player.
 */
void increment_current_player() {
   _current_player = find_next_player(_current_player);
} /* increment_current_player() */

/**
 * This method finds the id of the person from their object.
 * @param person the person to find
 * @return the id of the person
 */
string find_player_id_of_person(object person) {
   class player_info info;
   string id;

   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         return id;
      }
   }
   return 0;
} /* find_id_of_person() */

/**
 * This method finds the id of the current player.
 * @return the id of the current player
 */
string query_current_player() {
   if (!_current_player) {
      _current_player = find_player_id_from_number(0);
   }
   return _current_player;
} /* query_current_player() */

/**
 * This method finds the specified person and sets the current player
 * number to them.
 * @param person the person to find
 * @return the id the of the person, 0 on failure
 */
string set_current_player(string id) {
   _current_player = id;
} /* set_current_player() */

/**
 * This method tells the specified player the message.
 * @param id the id to tell the message to
 * @param message the message to send
 */
void tell_player(string id, string message) {
   object player;

   player = find_player(_players[id]->name);
   if (player) {
      tell_object(player, message);
   }
} /* tell_player() */

/**
 * THis method tells a message to the current player.
 * @param message the message to send
 */
void tell_current_player(string message) {
   tell_player(_current_player, message);
} /* tell_current_player() */

/**
 * This method tells everyone playing the game something.
 * @param message the message to send to everyone
 * @param exclude the ids to optionaly exclude
 */
varargs void tell_all_players(string message, string* exclude) {
   class player_info info;
   string id;

   if (!exclude) {
      exclude = ({ });
   }
   foreach (id, info in _players) {
      if (member_array(id, exclude) == -1) {
         tell_player(id, message);
      }
   }
} /* tell_all_players() */

/**
 * This method gets the extra data associated with the player id.
 * @param id the id to look up the data for
 * @return the extra data
 */
mixed query_player_data(string id) {
   return _players[id]->data;
} /* query_player_data() */

/**
 * This method sets the extra data associated with the player id.
 * @param id the id to set the data for
 * @param data the data to set
 */
void set_player_data(string id, mixed data) {
   _players[id]->data = data;
} /* set_player_data() */

/**
 * This method is called when an id joins the game.  This method should 
 * be overridden in higher up objects to handle special events.
 * @param id the id of the person joining
 */
void multiplayer_someone_joins(string id) {
} /* multiplayer_someone_joins() */

/**
 * This method is called when an id resigns from the game.  This method should 
 * be overridden in higher up objects to handle special events.
 * @param id the id of the person joining
 */
void multiplayer_someone_resigns(string id) {
} /* multiplayer_someone_resigns() */

/**
 * This method scrambles the array.
 * @return the array shuffled
 */
mixed* shuffle_array(mixed *arr) {
   int i;
   int pos;
   mixed* new_arr;

   for (i = 0; i < 2; i++) {
      new_arr = ({ });
      while (sizeof(arr)) {
         pos = random(sizeof(arr));
         new_arr += arr[pos..pos];
         arr = arr[0..pos - 1] + arr[pos + 1..];
      }
      arr = new_arr;
   }
   return arr;
} /* shuffle_array() */

/**
 * This method is the one that does the joining.
 * @param id the id they wish to join as
 * @return 1 on success, 0 on failure
 */
int do_join(string id) {
   if (is_person_playing(id)) {
      add_failed_mess("Someone is already playing " + id + " on $D.\n");
      return 0;
   }

   if (is_playing(this_player())) {
      add_failed_mess("You are already playing on $D.\n");
      return 0;
   }

   if (is_game_started() &&
       !can_join_as_new_player() &&
       member_array(id, query_started_player_ids()) == -1) {
      add_failed_mess("You can only take over one of the spots vacated by "
                      "someone else.\n");
      return 0;
   }

   if (add_person_to_game(id, this_player())) {
      add_succeeded_mess("$N $V as " + id + " on $D.\n");
      multiplayer_someone_joins(id);
      return 1;
   }

   add_failed_mess("Some weird error joining game on $D.\n");
   return 0;
} /* do_join() */

/**
 * This method is the one that does the resignation from the game.
 * @return 1 on success, 0 on failure
 */
int do_resign() {
   string id;

   id = find_player_id_of_person(this_player());
   if (remove_person_object_from_game(this_player())) {
      add_succeeded_mess("$N $V from game on $D.\n");
      multiplayer_someone_resigns(id);
      return 1;
   }
   add_failed_mess("You are not playing on $D to resign.\n");
   return 0;
} /* do_resign() */

/** @ignore yes */
void init() {
   string ids;

   ids = implode(keys(_players), "|");
   add_command("join", "[game] [as] {" + ids + "} on <direct:object>",
                (: do_join($4[0]) :));
   add_command("resign", "[from] [game] on <direct:object>",
               (: do_resign() :));
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      return 0;
   }
   add_auto_load_value(map, LOAD_TAG, "players", _players);
   add_auto_load_value(map, LOAD_TAG, "current player", _current_player);
   add_auto_load_value(map, LOAD_TAG, "started ids", _ids_when_started);
   add_auto_load_value(map, LOAD_TAG, "winner", _winner);
   add_auto_load_value(map, LOAD_TAG, "game started", _game_started);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   if (!map) {
      return ;
   }
   _players = query_auto_load_value(map, LOAD_TAG, "players");
   _current_player = query_auto_load_value(map, LOAD_TAG, "current player");
   _ids_when_started = query_auto_load_value(map, LOAD_TAG, "started ids");
   _winner = query_auto_load_value(map, LOAD_TAG, "winner");
   _game_started = query_auto_load_value(map, LOAD_TAG, "game started");
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/w/pinkfish/multiplayer_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/w/pinkfish/mancala.c] ---
// Size:   File: "/mnt/home2/grok/lib/w/pinkfish/mancala.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626698   Available: 13574052
Inodes: Total: 5242880    Free: 4960132
9418 bytes, Last Modified:   File: "/mnt/home2/grok/lib/w/pinkfish/mancala.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626698   Available: 13574052
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Mancala - an african game of stones.
 * @author Pinkfish
 * @started Mon Dec 11 08:49:30 PST 2000
 */
inherit "/obj/furnitures/misc/games/multiplayer_base";
inherit "/std/room/furniture/basic";

class co_ord {
   int x;
   int y;
}

private int* _board;
private mapping _mancala;

#define LOAD_TAG "mancala"
#define SIDE_LENGTH 6

void create() {
   multiplayer_base::create();
   basic::create();
} /* create() */

void setup() {
   set_short("mancala board");
   add_adjective("mancala");
   add_alias("mancala");
   set_name("board");

   set_long("A small rectangular board with 6 dips on each side and two "
            "bigger dips at each end.  There are a bunch of small multi-"
            "coloured stones in the dips.\n");

   add_player_id_type("green", 0);
   add_player_id_type("red", 0);

   set_minimum_needed(2);

   add_help_file("mancala");

   reset_game();
} /* setup() */

/**
 * This method resets the board to the start position.
 */
void reset_game() {
   _board = allocate(12, (: 4 :));
   _mancala = ([ "red" : 0, "green" : 0 ]);
} /* reset_game() */

/**
 * This method is called to start the game.
 */
int start_game() {
   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }

   reset_game();
   return 1;
} /* start_game() */

/**
 * The board itself.
 * @return the board string
 */
string query_board_string() {
   string ret;
   string id;
   int i;

   ret = "";
   foreach (id in query_player_ids()) {
      ret += sprintf("%-25s %s\n",
             query_player_cap_name(id) + " (" + capitalize(id) + ")",
             (is_game_started() && query_current_player() == id?"<-- Their turn":""));
   }

   ret += "                  ------->\n";
   ret += "%^RED%^+--+%^RESET%^   %^GREEN%^";
   for (i = 0; i < SIDE_LENGTH; i++) {
      ret += "+--+ ";
   }
   ret += "   +--+%^RESET%^\n";

   ret += "%^RED%^|  |%^RESET%^   %^GREEN%^";
   for (i = 0; i < SIDE_LENGTH; i++) {
      ret += sprintf("|%2d| ", _board[i]);
   }
   ret += "   |  |%^RESET%^\n";

   ret += "%^RED%^|  |   %^GREEN%^";
   for (i = 0; i < SIDE_LENGTH; i++) {
      ret += "+--+ ";
   }
   ret += "   |  |%^RESET%^\n";

   ret += sprintf("%%^RED%%^|%2d|%%^RESET%%^   ", _mancala["red"]);
   for (i = 0; i < SIDE_LENGTH; i++) {
      ret += "     ";
   }
   ret += sprintf("   %%^GREEN%%^|%2d|%%^RESET%%^\n", _mancala["green"]);

   ret += "%^RED%^|  |   ";
   for (i = 0; i < SIDE_LENGTH; i++) {
      ret += "+--+ ";
   }
   ret += "   %^GREEN%^|  |%^RESET%^\n";

   ret += "%^RED%^|  |   ";
   for (i = 1; i <= SIDE_LENGTH; i++) {
      ret += sprintf("|%2d| ", _board[2 * SIDE_LENGTH - i]);
   }
   ret += "   %^GREEN%^|  |%^RESET%^\n";

   ret += "%^RED%^+--+   ";
   for (i = 0; i < SIDE_LENGTH; i++) {
      ret += "+--+ ";
   }
   ret += "   %^GREEN%^+--+%^RESET%^\n";

   ret += "                 <-------\n";
   ret += "       ";
   for (i = 0; i < SIDE_LENGTH; i++) {
      ret += sprintf("  %c  ", i + 'A');
   }
   ret += "\n";

   if (query_winner()) {
      ret += "The last winner was " + query_winner() + ".\n";
   }

   return ret;
} /* query_board_string() */

string long() {
   return ::long() + query_board_string();
} /* long() */

/**
 * This method checks to see if there is a 4 in a row on the board somewhere.
 */
int check_winner(class co_ord pos) {
   return 0;
} /* check_winner() */

/**
 * This method returns the location as a string.
 * @param loc the location to look at
 * @return the string version of it
 */
string query_location_string(int loc) {
   if (loc < SIDE_LENGTH) {
      return sprintf("green %c", loc + 'A');
   }
   return sprintf("red %c", 2 * SIDE_LENGTH - loc + 'A' - 1);
} /* query_location_string() */

/**
 * The bin on the opposite side.
 */
int query_opposite_side(int loc) {
   if (loc < SIDE_LENGTH) {
      return 2 * SIDE_LENGTH - loc - 1;
   }
   return SIDE_LENGTH - 1 - (loc % (SIDE_LENGTH));
} /* query_opposite_side() */

/**
 * This method checks to see if the game has ended, and ends the game
 * if it has.
 */
int check_end() {
   int empty;
   int i;

   //
   // If all of one side is empty, sweep the other side.
   //
   empty = 1;
   for (i = 0; i < SIDE_LENGTH; i++) {
      if (_board[i]) {
         empty = 0;
      }
   }

   if (empty) {
      for (i = 0; i < SIDE_LENGTH; i++) {
         _mancala["red"] += _board[i + SIDE_LENGTH];
         _board[i + SIDE_LENGTH] = 0;;
      }
   } else {
      empty = 1;
      for (i = 0; i < SIDE_LENGTH; i++) {
         if (_board[i + SIDE_LENGTH]) {
            empty = 0;
         }
      }
      if (empty) {
         for (i = 0; i < SIDE_LENGTH; i++) {
            _mancala["green"] += _board[i];
            _board[i] = 0;
         }
      }
   }

   if (empty) {
      if (_mancala["red"] > _mancala["green"]) {
         finish_game(query_player_cap_name("red"));
      } else if (_mancala["red"] < _mancala["green"]) {
         finish_game(query_player_cap_name("green"));
      } else {
         finish_game(query_player_cap_name("green") + " and " +
                     query_player_cap_name("red"));
      }
   }
   return empty;
} /* check_end() */

/**
 * This method makes a move and chooses the next piece for the other player.
 * @param pos the position to play the piece
 * @param next the next piece to choose
 */
int do_move(string pos_str) {
   int i;
   int pos;
   int num;
   int loc;
   int my_mancala;
   int my_cutoff;
   int my_cutoff_bot;
   int last_mancala;

   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }

   if (!is_current_player(this_player())) {
      add_failed_mess("It is not your go!\n");
      return 0;
   }

   pos = lower_case(pos_str)[0] - 'a';
   if (pos < 0 || pos >= SIDE_LENGTH || strlen(pos_str) > 1) {
      add_failed_mess("The next piece reference " + pos_str +
                      " is not valid on $D.\n");
      return 0;
   }

   if (query_current_player() == "red") {
      pos = SIDE_LENGTH * 2 - pos - 1;
      my_mancala = 0;
      my_cutoff = 12;
      my_cutoff_bot = 6;
   } else {
      my_mancala = SIDE_LENGTH;
      my_cutoff = 6;
      my_cutoff_bot = 0;
   }

   if (!_board[pos]) {
      add_failed_mess("You can only play from a bin that has stones in it.\n");
      return 0;
   }

   num = _board[pos];
   _board[pos] = 0;
   for (i = 1; i <= num; i++) {
      loc = (pos + i) % (2 * SIDE_LENGTH);
      if (!((pos + i) % SIDE_LENGTH) && loc == my_mancala) {
         //
         // See if we stick a stone in the mancala or not.
         //
         _mancala[query_current_player()]++;
         num--;
         last_mancala = 1;
      }
      if (i <= num) {
         _board[loc]++;
         last_mancala = 0;
      }
   }

   if (!last_mancala &&
       _board[loc] == 1 &&
       loc < my_cutoff &&
       loc >= my_cutoff_bot) {
      //
      // We might do a capture!
      //
      i = query_opposite_side(loc);
      if (_board[i]) {
         add_succeeded_mess("$N capture$s " + query_num(_board[i]) +
                            " pieces from " + query_location_string(i) + ".\n");
         _mancala[query_current_player()] += _board[i] + 1;
         _board[i] = 0;
         _board[loc] = 0;
      }
   }


   if (check_end()) {
      add_succeeded_mess("$N end$s the game and " + query_winner() + " wins "
                         "on $D.\n");
   } else {
      add_succeeded_mess("$N start$s from " + query_location_string(pos) +
                         " and goes to " +
                         query_location_string(loc) + ".\n");

      if (!last_mancala) {
         increment_current_player();
         tell_current_player("%^BOLD%^Your turn!%^RESET%^\n" +
                             query_board_string());
      } else {
         tell_current_player("%^BOLD%^Your turn!%^RESET%^\n" +
                             query_board_string());
      }
   }

   return 1;
} /* do_move() */

/**
 * This method starts a new game.
 */
int do_start() {
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }

   if (!start_game()) {
      add_failed_mess("You need two people to play Quarto.\n");
      return 0;
   }

   add_succeeded_mess("$N $V a game of $D.\n");
   increment_current_player();
   tell_current_player("%^BOLD%^Your turn!%^RESET%^\n" +
                       query_board_string());
   tell_all_players(query_player_cap_name(query_current_player()) +
                    " goes first!\n", ({ query_current_player() }));
   return 1;
} /* do_start() */

void init() {
   ::init();
   add_command("move",
               "<string'position'> on <direct:object>",
               (: do_move($4[0]) :));
   add_command("start", "[new] [game] on <direct:object>", (: do_start() :));
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = basic::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, LOAD_TAG, "board", _board);
   add_auto_load_value(map, LOAD_TAG, "mancala", _mancala);
   return map;
} /* query_dynamic_arg() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   basic::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);
   _board = query_auto_load_value(map, LOAD_TAG, "board");
   _mancala = query_auto_load_value(map, LOAD_TAG, "mancala");
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/w/pinkfish/mancala.c] ---
// --- BEGIN [/mnt/home2/grok/lib/w/pinkfish/reversi_board.c] ---
// Size:   File: "/mnt/home2/grok/lib/w/pinkfish/reversi_board.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626696   Available: 13574050
Inodes: Total: 5242880    Free: 4960132
12521 bytes, Last Modified:   File: "/mnt/home2/grok/lib/w/pinkfish/reversi_board.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626696   Available: 13574050
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/furniture/basic";

class co_ord {
   int x;
   int y;
}

private mixed* _board;
private string _player_white;
private string _player_black;
private nosave class co_ord* _offsets;
private class co_ord _last_move;
private int _move_no;

#define BOARD_SIZE 8
#define BOARD_BLACK "X"
#define BOARD_WHITE "O"

#define BOARD_TAG "reversi table"

void reset_board();

void setup() {
   set_name("table");
   set_short("reversi table");
   add_adjective("reversi");
   set_long("A lovely green coloured board table divided into 8 by 8 grid "
            "with small black lines.  There are two curved indentations on "
            "each side of the table filled with bi coloured discs.\n");

   set_weight(100);
   //
   // Setup the offsets for checking.
   //
   _offsets = allocate(8, (: new(class co_ord) :));
   _offsets[0]->x = 1;
   _offsets[0]->y = 1;
   _offsets[1]->x = 0;
   _offsets[1]->y = 1;
   _offsets[2]->x = -1;
   _offsets[2]->y = 1;
   _offsets[3]->x = -1;
   _offsets[3]->y = 0;
   _offsets[4]->x = -1;
   _offsets[4]->y = -1;
   _offsets[5]->x = 0;
   _offsets[5]->y = -1;
   _offsets[6]->x = 1;
   _offsets[6]->y = -1;
   _offsets[7]->x = 1;
   _offsets[7]->y = 0;

   reset_board();
} /* setup() */

/**
 * This method sets up the board.
 */
void reset_board() {
   int i;

   _board = allocate(BOARD_SIZE);
   for (i = 0; i < sizeof(_board); i++) {
      _board[i] = allocate(BOARD_SIZE);
   }
   _board[3][3] = BOARD_BLACK;
   _board[4][4] = BOARD_BLACK;
   _board[3][4] = BOARD_WHITE;
   _board[4][3] = BOARD_WHITE;
   _move_no = 0;
} /* reset_board() */

private string query_line() {
   int i;
   string str;

   str = "   %^B_GREEN%^+";
   for (i = 0; i < BOARD_SIZE; i++) {
      str += "---+";
   }
   return str + "%^RESET%^\n";;
} /* query_line() */

/**
 * This method returns the person who plays the white player.
 * @return the person who plays the white player
 */
string query_white_player() {
   if (_player_white) {
      return _player_white;
   }
   return "unknown";
} /* query_white_player() */

/**
 * This method returns the person who plays the black player.
 * @return the person who plays the black player
 */
string query_black_player() {
   if (_player_black) {
      return _player_black;
   }
   return "unknown";
} /* query_black_player() */

/**
 * This method returns whose move it is.
 */
string query_whose_move() {
   if (_move_no % 2) {
      return BOARD_BLACK;
   } else {
      return BOARD_WHITE;
   }
} /* query_whose_move() */

/**
 * This method returns the name of the player whose move it is.
 */
string query_player_name_move() {
   if (query_whose_move() == BOARD_BLACK) {
      return query_black_player();
   }
   return query_white_player();
} /* query_player_name_move() */

/**
 * This method returns the board stuff.
 */
mixed* query_board() {
   return _board;
} /* query_board() */

/**
 * This method shows the current state of the board.
 */
string query_board_string() {
   int x;
   int y;
   int no_white;
   int no_black;
   string board_str;

   board_str = "";

   if (query_whose_move() == BOARD_BLACK) {
      board_str += "%^BOLD%^Blacks move.%^RESET%^\n";
   } else {
      board_str += "%^BOLD%^Whites move.%^RESET%^\n";
   }

   board_str += "White player (O): " + query_white_player() + "\n";
   board_str += "Black player (X): " + query_black_player() + "\n";

   board_str += "    ";
   for (x = 1; x <= sizeof(_board); x++) {
      board_str += " " + x + "  ";
   }
   board_str += "\n";
   board_str += query_line();

   for (x = 0; x < sizeof(_board); x++) {
      board_str += sprintf("%c  %%^B_GREEN%%^|", x + 'A');
      for (y = 0; y < sizeof(_board[x]); y++) {
         if (!_board[x][y]) {
            board_str += "   |";
         } else {
            if (_board[x][y] == BOARD_BLACK) {
               board_str += " %^B_BLACK%^X%^B_GREEN%^ ";
               no_black++;
            } else {
               board_str += " %^B_WHITE%^O%^B_GREEN%^ ";
               no_white++;
            }
            board_str += "|";
         }
      }
      board_str += "%^RESET%^\n";
      board_str += query_line();
   }

   board_str += "\nWhite has " + no_white +" pieces and black has " +
                no_black + " pieces.\n";

   return board_str;
} /* query_board_string() */

/** @ignore yes */
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_board_string();
} /* long() */

/**
 * This method deciphers some co-ordinates for us.
 */
class co_ord query_co_ords(string str) {
   class co_ord bing;

   str = lower_case(str);
   if (strlen(str) != 2) {
      return 0;
   }

   bing = new(class co_ord);
   if (str[0] >= '1' && str[0] <= '8') {
      bing->y = str[0] - '1';
      if (str[1] >= 'a' && str[1] <= 'h') {
         bing->x = str[1] - 'a';
      } else {
         return 0;
      }
   } else if (str[0] >= 'a' && str[0] <= 'h') {
      bing->x = str[0] - 'a';
      if (str[1] >= '1' && str[1] <= '8') {
         bing->y = str[1] - '1';
      } else {
         return 0;
      }
   }
   return bing;
} /* query_co_ords() */

/**
 * This method checks to see if the specified move is valid for the specified
 * colour.
 * @param co_ord the co-ordinate
 * @param colour the colour they are
 * @return 1 if valid, 0 if not
 */
int is_valid_move(class co_ord bing, string colour) {
   int x;
   int y;
   string other_colour;
   class co_ord off;

   if (_board[bing->x][bing->y]) {
      return 0;
   }

   if (colour == BOARD_BLACK) {
      other_colour = BOARD_WHITE;
   } else {
      other_colour = BOARD_BLACK;
   }

   //
   // Check stuff.
   //
   foreach (off in _offsets) {
      if (bing->x + off->x < BOARD_SIZE && bing->y + off->y < BOARD_SIZE &&
          bing->x + off->x >= 0 && bing->y + off->y >= 0 &&
          _board[bing->x + off->x][bing->y + off->y] == other_colour) {
printf("Checking %O -- %O\n", off, bing);
         for (x = bing->x + off->x * 2, y = bing->y + off->y * 2;
              x < BOARD_SIZE && y < BOARD_SIZE && x >= 0 && y >= 0;
              x += off->x, y += off->y) {
            if (_board[x][y] == colour) {
               return 1;
            } else if (!_board[x][y]) {
               break;
            }
         }
      }
   }

   return 0;
} /* is_valid_move() */

/**
 * This method makes the move.
 * @param co_ord the co-ordinate
 * @param colour the colour they are
 * @return 1 if valid, 0 if not
 */
int make_move(class co_ord bing, string colour) {
   int x;
   int y;
   string other_colour;
   class co_ord off;

   if (!is_valid_move(bing, colour)) {
      return 0;
   }

   if (colour == BOARD_BLACK) {
      other_colour = BOARD_WHITE;
   } else {
      other_colour = BOARD_BLACK;
   }

   //
   // Check stuff.
   //
   _board[bing->x][bing->y] = colour;
   foreach (off in _offsets) {
      if (bing->x + off->x < BOARD_SIZE && bing->y + off->y < BOARD_SIZE &&
          bing->x + off->x >= 0 && bing->y + off->y >= 0 &&
          _board[bing->x + off->x][bing->y + off->y] == other_colour) {
         for (x = bing->x + off->x * 2, y = bing->y + off->y * 2;
              x < BOARD_SIZE && y < BOARD_SIZE && x >= 0 && y >= 0;
              x += off->x, y += off->y) {
            if (_board[x][y] == colour) {
               for (x = bing->x + off->x, y = bing->y + off->y;
                    ;
                    x += off->x, y += off->y) {
                  if (_board[x][y] == colour) {
                     break;
                  }
                  _board[x][y] = colour;
               }
               break;
            }
         }
      }
   }

   _last_move = bing;
   _move_no++;

   //
   // Send the board data to the other person.
   //
   if (query_whose_move() == BOARD_BLACK) {
      if (find_player(query_black_player())) {
         tell_object(find_player(query_black_player()),
                     query_board_string());
      }
   } else {
      if (find_player(query_white_player())) {
         tell_object(find_player(query_white_player()),
                     query_board_string());
      }
   }

   return 1;
} /* make_move() */

/**
 * This method does the actual move.
 * @param str the co-ordinate
 * @return 1 on success, 0 failure
 */
int do_move(string str) {
   class co_ord bing;

   if (query_player_name_move() != this_player()->query_name()) {
      add_failed_mess("It is not your move!\n");
      return 0;
   }

   bing = query_co_ords(str);
   if (!bing) {
      add_failed_mess("Sorry, " + str + " is not a valid move.\n");
      return 0;
   }

   if (!is_valid_move(bing, query_whose_move())) {
      add_failed_mess("Sorry, " + str + " is not a valid move.\n");
      return 0;
   }

   make_move(bing, query_whose_move());
   add_succeeded_mess("$N make$s an exciting move on $I.\n",
                      ({ this_object() }));
   return 1;
} /* do_move() */

/**
 * This method allows you to join the game.
 * @param colour the colour to join as
 * @return 1 on success, 0 failure
 */
int do_join(string colour) {
   string play;
   string name;

   if (colour == BOARD_BLACK) {
      play = query_black_player();
   } else {
      play = query_white_player();
   }

   if (find_player(play) && find_player(play) == environment()) {
      add_failed_mess("Someone is already playing that colour.\n");
      return 0;
   }

   if (colour == BOARD_BLACK) {
      _player_black = this_player()->query_name();
      name = "black";
   } else {
      _player_white = this_player()->query_name();
      name = "white";
   }

   add_succeeded_mess("$N join$s the game on $I as " + name + ".\n",
                      ({ this_object() }));
   return 1;
} /* do_join() */

/**
 * This method starts a game.
 * @return 1 on success, 0 failure
 */
int do_start() {
   if (query_black_player() == this_player()->query_name() ||
       query_white_player() == this_player()->query_name()) {
      reset_board();
      add_succeeded_mess("$N start$s a new game on $I.\n",
                         ({ this_object() }));
      return 0;
   }
   add_failed_mess("Only the players of the game can start a new one.\n");
   return 0;
} /* do_start() */

/**
 * This method allows you to resign from the game.
 * @return 1 on success, 0 on failure
 */
int do_resign() {
   if (query_black_player() == this_player()->query_name()) {
      _player_black = 0;
      add_succeeded_mess("$N resign$s as the black player on $I.\n",
                        ({ this_object() }));
      return 1;
   }
   if (query_white_player() == this_player()->query_name()) {
      _player_white = 0;
      add_succeeded_mess("$N resign$s as the white player on $I.\n",
                        ({ this_object() }));
      return 1;
   }
   return 0;
} /* do_resign() */

/**
 * This method views the current state of the board.
 */
int do_view() {
   int dark;

   dark = this_player()->check_dark(environment()->query_light());
   if (dark) {
      add_failed_mess("It is too dark to see the board.\n");
      return 0;
   }

   write(query_board_string());
   return 1;
} /* do_view() */

/** @ignore yes */
void init() {
   ::init();
   add_command("join", "game as {black|white}",
               (: do_join($4[0] == "black"?BOARD_BLACK:BOARD_WHITE) :));
   add_command("resign", "from game",
               (: do_resign() :));
   add_command("move", "<string'pos'>", (: do_move($4[0]) :) );
   add_command("start", "new game", (: do_start() :) );
   add_command("view", "", (: do_view() :));
} /* init() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   mapping map;

   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "board", _board);
   add_auto_load_value(map, BOARD_TAG, "move no", _move_no);
   add_auto_load_value(map, BOARD_TAG, "white", _player_white);
   add_auto_load_value(map, BOARD_TAG, "black", _player_black);
   add_auto_load_value(map, BOARD_TAG, "last move", _last_move);
   return map;
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map, object player) {
   ::init_dynamic_arg(map, player);

   _board = query_auto_load_value(map, BOARD_TAG, "board");
   _move_no = query_auto_load_value(map, BOARD_TAG, "move no");
   _player_white = query_auto_load_value(map, BOARD_TAG, "white");
   _player_black = query_auto_load_value(map, BOARD_TAG, "black");
   _last_move = query_auto_load_value(map, BOARD_TAG, "last move");
   if (!_board) {
      reset_board();
   }
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/w/pinkfish/reversi_board.c] ---
// --- BEGIN [/mnt/home2/grok/lib/w/pinkfish/hearts.c] ---
// Size:   File: "/mnt/home2/grok/lib/w/pinkfish/hearts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626692   Available: 13574046
Inodes: Total: 5242880    Free: 4960132
678 bytes, Last Modified:   File: "/mnt/home2/grok/lib/w/pinkfish/hearts.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14626692   Available: 13574046
Inodes: Total: 5242880    Free: 4960132
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A nice little hearts game
 * @author Pinkfish
 * @started Thu Dec  7 08:41:08 PST 2000
 */
inherit DIR "multiplayer_base";
inherit DIR "card_base";
#include "card_base.h"

class playing_card* deck;

void setup() {
   set_short("hearts game");
   add_adjective("hearts");
   set_name("game");

   set_long("A bunch of playing cards that looks wonderful for playing "
            "a game of hearts with.\n");

   add_player_id_type("green", 0);
   add_player_id_type("red", 0);
   add_player_id_type("blue", 0);
   add_player_id_type("yellow", 0);
   add_player_id_type("mauve", 0);
   add_player_id_type("vermillion", 0);
   add_player_id_type("cyan", 0);
} /* setup() */
// --- END [/mnt/home2/grok/lib/w/pinkfish/hearts.c] ---
