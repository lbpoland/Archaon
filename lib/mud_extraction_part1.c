
// --- MUD Extraction File: mud_extraction_part1.c ---
// Generated: 2025-03-07 07:27:40 UTC
// Source Directory: /mnt/home2/grok/lib
// Purpose: Consolidated LPC .c files for analysis and recreation with FluffOS v2019+
//          and Forgotten Realms theming, replicating discworld.starturtle.net:4242
//          with optimizations (UTF-8, JSON, strict typing).
// Note: Each file break is marked with // --- END [file_path] ---
//
// --- BEGIN [/mnt/home2/grok/lib/include/playerinfo2.c] ---
// Size:   File: "/mnt/home2/grok/lib/include/playerinfo2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630065   Available: 13577419
Inodes: Total: 5242880    Free: 4960136
1286 bytes, Last Modified:   File: "/mnt/home2/grok/lib/include/playerinfo2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630065   Available: 13577419
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:53.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the header file for the player information database handler.
 *
 * @author Fiona
 */

#ifndef __PLAYERINFO_H
#define __PLAYERINFO_H

/**
 * Structure containing one database entry. Fields are:
 *    time    - entry's creation timestamp
 *    creator - the name of the creator who added the event
 *    event   - the name of the event
 *    comment - arbitrary comment string
 *    extra   - arbitrary array of arbitrary objects
 * @ignore
 */
class dbentry {
    int     time;
    string  creator;
    string  event;
    string  comment;
    mixed   *extra;
}

/**
 * Structure containing a single player's information. Fields are:
 *    name        - the name of the player (always lowercased)
 *    last_check  - timestamp of the last timeout check
 *    alts        - array containing this player's alt character names
 *    data        - array containing playerinfo entries
 * @ignore
 */
class playerinfo {
    string          name;
    int             last_check;
    string          *alts;
    class dbentry   *data;
    string          main_alt;
}

/** This is the handler for all the player information. Lucky it. */
#define PLAYERINFO_HANDLER "/obj/handlers/playerinfo"

#define VERBOSE_PI "verbose playerinfo"

#endif                         // __PLAYERINFO_H
// --- END [/mnt/home2/grok/lib/include/playerinfo2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/save/books/creator2/cre_book2.c] ---
// Size:   File: "/mnt/home2/grok/lib/save/books/creator2/cre_book2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630027   Available: 13577381
Inodes: Total: 5242880    Free: 4960136
11393 bytes, Last Modified:   File: "/mnt/home2/grok/lib/save/books/creator2/cre_book2.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630027   Available: 13577381
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/book";
#include <colour.h>


void setup() {

  set_name("Command Summary");
  add_alias( ({"book", "command book", "summary", "command summary"})  );
  add_adjective( ({ "small", "black", "small black", "command" }) );
  set_long("This is a pocket size black book, which looks as if it "+
           "has just been printed.\n");
   set_read_mess( "The Creator's Command Quick Reference." );
  set_no_pages(8);
  set_main_plural("small black books");
  add_plural("command summaries");
  add_plural("books");
  set_weight(11);   
  add_property("no recycling", 1);

  set_open_page( 1 );
  add_read_mess( "This book contains some information on basic calls that "
                 "most Creators should be aware of.\n"
                 "\n"
                 "                        Index.\n"
                 "\n"
                 "%^GREEN%^Show a help file to a player%^RESET%^...................2\n"
                 "%^GREEN%^Resurrect a player%^RESET%^.............................3\n"
                 "%^GREEN%^Replace a life%^RESET%^.................................3\n"
                 "%^GREEN%^Locate a player%^RESET%^................................4\n"
                 "%^GREEN%^Travel to a player%^RESET%^.............................4\n"
                 "%^GREEN%^Travel to a room%^RESET%^...............................4\n"
                 "%^GREEN%^Bring a player to you%^RESET%^..........................4\n"
                 "%^GREEN%^Check a player's inventory%^RESET%^.....................5\n"
                 "%^GREEN%^Replace a receipt for a player%^RESET%^.................5\n"
                 "%^GREEN%^Replace other items%^RESET%^............................5\n"
                 "%^GREEN%^Remove an item or receipt from player%^RESET%^..........5\n"
                 "%^GREEN%^Reproduce an item%^RESET%^..............................5\n"
                 "%^GREEN%^Find an item's path%^RESET%^............................5\n"
                 "%^GREEN%^See a player's list of quests%^RESET%^..................6\n"
                 "%^GREEN%^Grant a divorce%^RESET%^................................6\n"
                 "%^GREEN%^Reset a room or item%^RESET%^...........................7\n"
                 "%^GREEN%^Drop or move your Bulletin board%^RESET%^...............7\n"
                 "%^GREEN%^Talk or emote to all Creators%^RESET%^..................7\n"
                 "%^GREEN%^Changing your appearance, entry messages%^RESET%^.......8\n"
                 , 0, "common", 1);

  set_open_page( 2 );
  add_read_mess( "\n%^GREEN%^How to show a helpfile to a player%^RESET%^\n"
                 "\n"
                 "Sometimes the best way to answer a player's questions is "
                 "simply to send her the helpfile.  "
                 "This is accomplished by giving the command:\n"
                 "%^CYAN%^showhelp <player> <helpfile>%^RESET%^.\n"
                 "An example of this would be:\n"
                 "%^CYAN%^showhelp arby liaison%^RESET%^.\n"
                 , 0 , "common", 1);
  set_open_page( 3 );
  add_read_mess( "\n%^GREEN%^How to resurrect a player\n"
                 "How to add a life to that max%^RESET%^\n"
                 "\n"
                 "When a player dies through a bug, it is sometimes necessary to "
                 "resurrect her.  The simplest way to do this is with Oblilix's "
                 "Resurrector, found in your bookcase.  However, the actual call "
                 "can also be used:\n"
                 "%^CYAN%^call remove_ghost() <player>%^RESET%^.\n"
                 "For example:\n"
                 "%^CYAN%^call remove_ghost() ycore%^RESET%^.\n"
                 "In some cases, you may also want to replace, or adjust, the "
                 "maximum number of lives a player has.  The call for this is:\n"
                 "%^CYAN%^call adjust_max_deaths(number) <player>%^RESET%^.\n"
                 "For example:\n"
                 "%^CYAN%^call adjust_max_deaths(1) lagger%^RESET%^.\n" , 0, "common", 1);
  set_open_page( 4 );
  add_read_mess( "\n%^GREEN%^How to locate a player\n"
                 "How to go to a player\n"
                 "How to go to a room\n"
                 "How to bring a player to you%^RESET%^\n"
                 "\n"
                 "There are two commands that allow you to simply locate a player:\n"
                 "%^CYAN%^whereis <player>%^RESET%^\n"
                 "will give you the location of the named player, and the command:\n"
                 "%^CYAN%^people%^RESET%^\n"
                 "on its own will list the names and locations of all players.\n"
                 "To go to a player, simply use:\n"
                 "%^CYAN%^goto <player>'%^RESET%^.\n"
                 "Going to a room is a bit more complex.  You need to first know the "
                 "path of the room.  This can be found by using:\n"
                 "%^CYAN%^cd%^RESET%^ (change directory) and %^CYAN%^ls%^RESET%^ "
                 "(list directory) and moving through the directory structure until you find "
                 "the desired room.  You can also find the path you want by asking "
                 "another cre, by noting convenient spots as you walk around, and "
                 "writing them down, etc.  Once you know the path, the command is:\n"
                 "%^CYAN%^goto <path>%^RESET%^.\n"
                 "The best way to bring a player to you is with Ceres' Transporter, "
                 "since this keeps a portal open to the player's previous location.  "
                 "Otherwise, you can use:\n"
                 "%^CYAN%^trans <player>%^RESET%^.\n"
                 "%^RED%^***%^RESET%^ Remember to note the player's original location so "
                 "you can go there, and trans her back. %^RED%^***%^RESET%^", 0,
                 "common", 1);
  set_open_page( 5 );
  add_read_mess( "\n%^GREEN%^How to check a player's inventory\n"
                 "How to replace a lost item with a receipt\n"
                 "How to replace other items\n"
                 "How to remove items or receipts from a player\n"
                 "Duplicating items\n"
                 "Finding an item's path%^RESET%^\n"
                 "\n"
                 "You can check a player's current inventory by typing:\n"
                 "%^CYAN%^inv <player>%^RESET%^.\n"
                 "To replace an item that the player has a receipt for, first:\n"
                 "%^CYAN%^stat <item> in <player>%^RESET%^.\n"
                 "This will give you all sorts of information on the item that is "
                 "missing.  What you want is the path.  After you note this, type: "
                 "%^CYAN%^clone <path>%^RESET%^,\n"
                 "then hand the item to the player.  To remove the receipt, or any other "
                 "items from the player's inventory:\n"
                 "%^CYAN%^dest <item> in <player>%^RESET%^.\n"
                 "%^RED%^***%^RESET%^ Be cautious when using dest.  Do NOT %^CYAN%^dest "
                 "0 in <player>%^RESET%^ as this will delete her entire inventory. "  
                 "%^RED%^***%^RESET%^\n"                                        
                 "Most of the other items that can be replaced for a player can be done "
                 "using Presto's Wand. "
                 "To copy an item that a player already has one of, use:\n"
                 "%^CYAN%^duplicate <item> in <player>%^RESET%^.\n"
                 , 0, "common", 1);
  set_open_page( 6 );
  add_read_mess( "\n%^GREEN%^How to list the quests a player has done\n"
                 "How to grant a divorce%^RESET%^\n"                              
                 "\n" 
                 "Once in a while you may need to check on whether or not a player has"
                 " completed a certain quest.  This is accomplished with:\n"
                 "%^CYAN%^pquests <player>%^RESET%^.\n" 
                 "This will list all of the player's current quest information.\n" 
                 "In rare cases, a player may approach you to ask about a divorce.  "    
                 "Most often this occurs when a player's MUD spouse is no longer active "     
                 "on Discworld.  What this means is that it is impossible for them "
                 "to have a divorce granted via game channels.  To divorce a player:\n"
                 "%^CYAN%^call remove_property(\"spouse\") <player>\n"
                 "dest wedding ring in <player>%^RESET%^.\n" 
                 , 0, "common", 1);
  set_open_page( 7 );
  add_read_mess( "\n%^GREEN%^To reset a room or item\n"
                 "How to drop or move your Bulletin board\n"
                 "How to emote to other Creators%^RESET%^\n"
                 "\n"
                 "Sometimes, all you need to do to solve a player's problem is to "
                 "reset the room or item that seems to have a problem.  Use great care "
                 "when updating rooms, because this will clear out any items in the room "
                 "that don't belong there.  Update syntax is:\n"
                 "%^CYAN%^update <path> %^RESET%^(if you know the path to the item "
                 "or room.)\n"
                 "%^CYAN%^update <item> in <player> %^RESET%^(to update something in "
                 "the player's inv.)\n"
                 "%^CYAN%^update here %^RESET%^(to update the room you are in.)\n"
                 "If you've picked up your bulletin board, and would like to drop it, or "
                 "stow it in a pocket, or backpack, first use the call:\n"
                 "%^CYAN%^call set_drop() board%^RESET%^.\n"
                 "The command %^CYAN%^cre%^RESET%^ does a few things, depending on syntax:\n"
                 "%^CYAN%^cre <text>%^RESET%^ sends the text as a chat to all creators,\n"
                 "%^CYAN%^cre@ <text>%^RESET%^ sends the text as an emote to all creators,\n"
                 "%^CYAN%^cre?%^RESET%^ lists all the creators currently visible to you, "
                 "and online."
                 , 0, "common", 1);
  set_open_page( 8 ); 
  add_read_mess( "\n%^GREEN%^Changing your appearance%^RESET%^ "
                 "\n"
                 "As a creator, there are a few things you can do to customize "
                 "how you appear to players.  Many of these are listed with the "
                 "%^CYAN%^review%^RESET%^ command.  Review will show you what messages are "
                 "currently displayed when you enter or leave a room, either by walking or "
                 "by using %^CYAN%^goto%^RESET%^ to teleport there.\n"
                 "The exit/entry fields can be changed with:\n"
                 "%^CYAN%^call setmin(\"text\") me%^RESET%^ and \n"
                 "%^CYAN%^call setmout(\"text\") me%^RESET%^.\n"
                 "These will change the message given when you walk into a room.\n"
                 "To change the teleport messages, use:\n"
                 "%^CYAN%^call setmmin(\"text\") me%^RESET%^ and \n"
                 "%^CYAN%^call setmmout(\"text\") me%^RESET%^.\n"
                 "You can also change your description with:\n"
                 "%^CYAN%^call set_long(\"text\") me%^RESET%^.\n"
                 , 0, "common", 1);
  set_open_page( 9 );
  set_open_page( 0 );
}

/* setup */
int do_tear() { return 0; }
int query_binding_force() {return 100; }
// --- END [/mnt/home2/grok/lib/save/books/creator2/cre_book2.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/departures.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/departures.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630024   Available: 13577378
Inodes: Total: 5242880    Free: 4960136
3703 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/departures.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630024   Available: 13577378
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: departures.c,v 1.9 2001/04/27 06:57:56 taffyd Exp $
 *
 *
 */

/*  /std/departures.c

    Change log:

    30/11/93 - copied from void.c as an idea for quitting
                by Ember
    12/12/92 - Modified by Godot to put in a red button because one of 
               his storerooms filled the place up one day.
    17/10/95 - Modified by Ceres to add event_enter check so if people
               login here they get transed to the drum.
               Oh, also tidied the code somewhat and deleted most of the
               unnecessariness.
*/
#include <config.h>
inherit "/std/room/basic_room";

int squish(string cmd);

void setup() {
  set_co_ord(({0,0,-1000})); // somewhere beneath discworld.
  set_light(100);
  set_short("Discworld departure lounge");
  set_long("This is a small room seemingly attached to the underside of the "
           "disc.  Clear walls all around give you a truly mind-twisting "
           "view of Great A'Tuin and the accompanying elephants.  Lined "
           "up next to little doorways are an assortment of demonic "
           "creatures about to set off to other realities all over "
           "the universe.  You will shortly be getting on one to return "
           "to your normal reality.\n");
  add_item("disc", "You can see the underside of the disc.  It seems to "
           "be made of ... well ... something black and smushy.\n");
  add_item("great a'tuin", "A big turtle.  Like real big.\n");
  add_item("elephant", "Like an elephant only bigger.\n");
  add_item(({ "door", "doorway" }), "Little round hatches from which "
           "assorted demonic creatures launch themselves out on journeys "
           "to other worlds.\n");
  add_item("other world", "They are a bit too far away to see.\n");
  add_item("reality", "But who is to say what is real anyway?\n");
  add_item(({"creature", "demonic creature"}),
           "Well, there is a large bird with glowing "
           "red feet, a 6 foot tall spider with ivy growing up its legs, "
           "a chimera and other assorted sillinesses.\n");

  /* It seems a couple of players have managed to mark this place
   * a teleport location.  */
  add_property( "no teleport", 1 );
  set_keep_room_loaded(1);
} /* setup() */

// prevents people doing things they shouldn't in here. It will screw up their
// start position and allow them to use this to trans to the drum.
void init() {
  ::init();
  if (!this_player()) {
    return;
  }
  this_player()->command_override((: squish :));
} /* init() */

int squish(string cmd) {
  if (cmd == "quit" ||
      cmd == "quit2" ||
      cmd == "save" ||
      cmd == "godmother" ||
      cmd == "su") {
    write( "Fat chance, bozo.\n" );
    return 1;
  } else {
    return 0;
  }
} /* squish() */

// if they enter from nowhere (and they aren't greco!) then throw them
// into the drum.  This prevents people logging in and being stuck here.
// Ceres - 1/11/95
void event_enter(object ob, string message, object from) {
  if(!from && interactive(ob)) {
    write("%^CYAN%^Greco says: You shouldn't be in here.%^RESET%^\n"
          "Greco throws you back to the Mended Drum.\n");
    ob->move(CONFIG_START_LOCATION);
  }
} /* event_enter() */

int test_add( object thing, int flag ) {
  if(base_name(thing) != "/global/player" &&
     base_name(thing) != "/global/creator" &&
     base_name(thing) != "/global/lord") {
    call_out( "destroy_thing", 60, thing );
  }
  return 1;
} /* test_add() */

void destroy_thing(object thing) {
  if(!thing) {
    return;
  }

    if ( environment( thing ) != this_object() ) {
        return;
    }

  thing->move("/room/rubbish");
} /* destroy_thing() */
// --- END [/mnt/home2/grok/lib/room/departures.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/transport_start.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/transport_start.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630023   Available: 13577377
Inodes: Total: 5242880    Free: 4960136
1443 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/transport_start.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630023   Available: 13577377
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the room used by the transports to figure out where they
 * should regenerate themselves.
 * @author Pinkfish
 * @started Wed Sep 22 16:52:37 PDT 1999
 */
inherit "/std/room/basic_room";
inherit "/std/basic/virtual_quit_control";

#define TRANSPORT_LOCATION "transport start"

void setup() {
   set_long("A room with bunches of horses and camels milling around in "
            "chunks.  You think you have never seen quite so many "
            "transport animals ever before.\n");
   set_short("transport start");
} /* setup() */

/** @ignore yes */
void player_quitting( object player, object place ) {
   // Add a short term property (we save again immediately).
   tell_creator( "goldenthread", "adding property with player %O and place "
                 "%O with environment %O\n", player, place,
                 environment( place ) );
   player->add_property( TRANSPORT_LOCATION,
                         find_start_pos( player, environment( place ) ), 180 );
} /* player_quitting() */

/** @ignore yes */
void event_enter( object ob ) {
   string location;

   // Something came in here!
   location = ob->query_property( TRANSPORT_LOCATION );
   tell_creator("goldenthread", "location: %s\n", location );
   if ( !location ) {
      // Do something wild!
      location = ob->query_start_pos();
   }
   tell_creator( "goldenthread", "final location: %s\n", location );
   ob->move( location );
} /* event_enter() */
// --- END [/mnt/home2/grok/lib/room/transport_start.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/void.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/void.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630022   Available: 13577376
Inodes: Total: 5242880    Free: 4960136
2019 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/void.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630022   Available: 13577376
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
inherit "/std/room/basic_room";

object  button;

void setup() {
   set_short( "convention in the void" );
   add_property( "determinate", "the " );
   add_property( "no teleport", 1 );
   set_light( 100 );
   set_long("This is where you come when you fall out a room and have " 
      "nowhere to go.  You are inside a large igloo.  Penguin " 
      "waiters (in tuxedos of course) are serving drinks to the " 
      "assembled crowd.  A large wombat sits at the end of a " 
      "banquet table, his head resting peacefully in a bowl of " 
      "soup.\n");
   add_item( "igloo", "The igloo is nice and warm despite the icy decor." );
   add_item( ({ "penguin waiter", "penguin" }),
         "The penguins are all rather formally dressed." );
   add_item( "drink", "The drinks come in a variety of colours and smells." );
   add_item( "crowd", "The crowd consists mostly of iguanas." );
   add_item( "bowl", "The bowl holds the soup.  It is green and hums." );
   add_item( "soup", "The soup is pink and comfortable-looking." );
   add_item( "wombat", "Perhaps you should tell the wombat to use a spoon." );
   co_ord = 0;

   add_exit("out", CONFIG_START_LOCATION, "road");
} /* setup() */

void reset() {
   if ( !button ) {
      button = clone_object( "/obj/misc/button" );
      button->move( this_object() );
   }
} /* reset() */

int squish(string cmd) {
  if (cmd == "get" ||
      cmd == "drag" ||
      cmd == "palm" ||
      cmd == "slip" ||
      cmd == "drop" ||
      cmd == "bury" ||
      cmd == "decompose" ||
      cmd == "ensumpf" ||
      cmd == "envalise" || 
      cmd == "pyroscipate" ||
      cmd == "shroud" ||
      cmd == "ventisepelate") {
    write( "I don't think so.\n" );
    return 1;
  } else {
    return 0;
  }
}

void init() {
   ::init();
   co_ord = 0;
   if (!this_player() || this_player()->query_creator())
     return;
   this_player()->command_override((: squish :));
} /* init() */


int *query_co_ord() { return 0; }

void clean_up(int i) { return; }
// --- END [/mnt/home2/grok/lib/room/void.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/broken.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/broken.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630022   Available: 13577376
Inodes: Total: 5242880    Free: 4960136
1025 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/broken.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630022   Available: 13577376
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*	/std/broken.c

    Change log:

	12/12/92 - Modified by Godot to put in a red button because one of 
			his storerooms filled the place up one day.

        30-Oct-93 - created by ember as a place to record drop-out broken
                    auto load objects
*/
inherit "/std/room/basic_room";

/*
    Global variables.
*/
object	button;

/*
    Function prototypes.
*/
void	after_reset();
void	dest_me();
void	reset();
void	setup();

/*
    Functions.
*/
void
after_reset()
{
     if ( !button )
     {
	button = clone_object( "/obj/misc/button" );
	button->move( this_object() );
     }
}

void
dest_me()
{
    if ( button )  button->dest_me();

    ::dest_me();
}

void
reset()
{
    call_out( "after_reset" , 1 );
}

void setup() {
     set_light(100);
     set_short("Graveyard");
  set_long( "This room is full of broken bits and pieces of objects which "+
      "decided not to work or behave properly.\n" );
}

/* EOF */

void init() {
  ::init();
  co_ord = 0;
} /* init() */

int *query_co_ord() { return 0; }
// --- END [/mnt/home2/grok/lib/room/broken.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/vault.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/vault.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630021   Available: 13577375
Inodes: Total: 5242880    Free: 4960136
2804 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/vault.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630021   Available: 13577375
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/basic_room";

#include <money.h>

//#define DEBUGGER "presto"

#define MAX_OBJECTS 12

nosave private object *list;
nosave private int reused;

void setup() {
  set_short( "vault room" );
  set_long( "This is the vault for money.\n" );
  set_keep_room_loaded(1);
  list = ({ });
}

string long(string word, int dark) {
  if(query_verb() == "scry" )
    return "empty space.";
  
  return ::long(word, dark);
}

int no_init() { return 1; }

// add to the list of objects.
void add_to_list(object ob) {
  if(sizeof(list) >= MAX_OBJECTS) {
    ob->move("/room/rubbish");

#ifdef DEBUGGER
    if (this_player() == find_player(DEBUGGER))
      tell_creator(DEBUGGER,
                   "list too large... throwing away %O\n", ob);
#endif

    return;
  }

#ifdef DEBUGGER
  if (this_player() == find_player(DEBUGGER))
    tell_creator(DEBUGGER, "Saving %O\n", ob);
#endif

  if (member_array(ob, list) > -1)  {
    log_file("MONEY_RECYCLE", ctime(time()) + "Same object (%O) added twice, this "
             "time by %O. Call stack is %O, %O.  CMD == %s\n",
             ob, previous_object(), call_stack(2), call_stack(3),
             this_player()->query_current_cmd());
    return;
  }

  if (!environment(ob)  ||
      environment(ob)->test_remove(ob, ob->drop(this_object()),
                                   this_object()))
  {
    ob->reset_effects();
    ob->force_no_join();
    ob->move(this_object());
    ob->set_already_joined();
    ob->remove_property("dropped");
    list += ({ ob });
  }
  else
    log_file("MONEY_RECYCLE", ctime(time()) + "Could not move %O from %O (%s) to here\n",
             ob, environment(ob), environment(ob)->short());

#ifdef DEBUGGER
  if (this_player() == find_player(DEBUGGER))
    tell_creator(DEBUGGER, "list is now %O\n", list);
#endif
}

object get_money_ob() {
   object ob;

   // Don't do any recycling coz there's some bad money about.
//   return clone_object(MONEY_OBJECT);
   
   if(sizeof(list)) {
      ob = list[0];
      if(ob) {
#ifdef DEBUGGER
         if (this_player() == find_player(DEBUGGER))
           tell_creator(DEBUGGER, "Re-using %O\n", ob);
#endif
         ob->set_money_array(({ }));
         ob->reset_already_joined();
         ob->reset_no_join();
         reused++;
      }
      else
         log_file("MONEY_RECYCLE", ctime(time()) + "Found NULL entry in object list\n");
      list = list[1 .. ];
#ifdef DEBUGGER
      if (this_player() == find_player(DEBUGGER))
        tell_creator(DEBUGGER, "list is now %O\n", list);
#endif
   }
   if(!ob) {
      ob = clone_object(MONEY_OBJECT);
   }
   
   return ob;
}

object *query_list() { return list; }

mixed stats() {
  return ::stats() + ({
    ({ "list", sizeof(list) }),
      ({ "reused", reused }),
  });
}

int query_theft_command() { return -1; }
// --- END [/mnt/home2/grok/lib/room/vault.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/rubbish.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/rubbish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630020   Available: 13577374
Inodes: Total: 5242880    Free: 4960136
1416 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/rubbish.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630020   Available: 13577374
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/basic_room";

nosave private mapping delete_list;
nosave private int destroyed;

void setup() {
  set_short( "rubbish room" );
  set_long( "This is the rubbish room.  Anything coming in here will be "+
            "destroyed five seconds later.\n" );
  set_keep_room_loaded(1);
  delete_list = ([ ]);
  set_heart_beat(1);
  destroyed = 0;
}

string long(string word, int dark) {
  if(query_verb() == "scry" )
    return "empty space.";
  
  return ::long(word, dark);
}

int no_init() { return 1; }

/**
 * @ignore yes
 * Every 2 seconds try to destroy some stuff.
 */
void heart_beat() {
  object ob;
  int i;

  i = 0;
  foreach(ob in all_inventory()) {
    if(!delete_list[ob])
      delete_list[ob] = time();
    else if(delete_list[ob] < time() - 4) {
      destroyed++;
      map_delete(delete_list, ob);
      destruct(ob);
      reset_eval_cost();
    }
  }
}

/**
 * @ignore yes
 * This just cleans up anything that got left behind. If a callout got lost
 * or went wrong or something this'll make sure our rubbish room is clean.
 */
void reset() {
  object *inventory;
   
  set_heart_beat(1);
  inventory = filter( all_inventory( this_object() ), 
                      (: !interactive( $1 ) :) );
    
  map(inventory, (: $1 && destruct($1) :));
}

mixed stats() {
  return ::stats() + ({
    ({ "destroyed", destroyed }),
  });
}

object *query_list() {
  return keys(delete_list);
}
// --- END [/mnt/home2/grok/lib/room/rubbish.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/virtual.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/virtual.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630020   Available: 13577374
Inodes: Total: 5242880    Free: 4960136
710 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/virtual.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630020   Available: 13577374
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/basic_room";

int no_init(){
  return 1;
}

void init(){
  //no_init doesn't work at discworld itself yet, when it does this stops doing
  //anything :) npcs only get here when their rooms unloads anyway, since 
  //virtual moving is off 
  previous_object()->move("/room/rubbish");
}

string long(object npc){
  //duh people might scry us.
  if(query_verb() == "scry"){
    object ob;
    string where;
    ob = load_object(where = npc->query_true_location());
    if(!ob || environment(npc) == this_object()){
      return "This is where NPCs hide from players.";
      //stupid room didn't load, or it wasn't a room!
    }
    return environment(npc)->long();
  }
  return "Go away!";
}

// --- END [/mnt/home2/grok/lib/room/virtual.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/jail.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/jail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630019   Available: 13577373
Inodes: Total: 5242880    Free: 4960136
1093 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/jail.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630019   Available: 13577373
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <command.h>

inherit "/std/room/basic_room";

#define BLOCKED_COMMANDS ({ "quit", "quit2", "save", "su", "godmother", "tell", "t", "shout", "remote", "newbie", "gs", "group say" })

int squish(string cmd);

void setup() {
  set_short( "jail" );
  add_property( "determinate", "the " );
  add_property("no teleport", 1);
  add_property("no godmother", 1);
  set_light( 100 );
  set_long("This is where you are put when you've been a naughty boy (or "
           "girl).  It's a very boring place with nothing to do.\n");
} /* setup() */

void clean_up(int i) { return; }

// prevents people doing things they shouldn't in here. It will screw up their
// start position and allow them to use this to trans to the drum.
void init() {
  ::init();
  if (!this_player()) return;
  this_player()->command_override((: squish :));
}

int squish(string cmd) {
  string *bits;

  if(this_player()->query_creator())
    return 0;
  
  bits = explode(cmd, " ");
  if(member_array(bits[0], BLOCKED_COMMANDS) != -1) {
    write( "I don't think so.\n" );
    return 1;
  } else {
    return 0;
  }
}
// --- END [/mnt/home2/grok/lib/room/jail.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/air.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/air.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630019   Available: 13577373
Inodes: Total: 5242880    Free: 4960136
7004 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/air.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630019   Available: 13577373
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <position.h>
#include <soul.h>
#include <talker.h>

/* Current time for broom flight is 12 seconds */
#define TIME_LIMIT 15
#define BROOMSTICK "/d/guilds/witches/items/broomstick"
#define GRANNY "/d/guilds/witches/chars/granny_weatherwax"

inherit "/std/outside";

int screen_command( string cmd );

string *people;

string *allowed_commands = ({ "l", "look", "glance", /* "eat", "drink",
    "taste", "t", "tell", "say", "lsay", "shout", "emote", "hedgehog",
    "i", "inventory", "sing", "croon", */ });

void setup() {
  set_light( 100 );
  set_short( "high above the Disc" );
  add_property( "determinate", "" );
  set_day_long( "You are high above the Disc, flying through the "
      "air.\n" );
  set_night_long( "You are high above the Disc, flying through the "
      "night sky.\n" );
  add_item( ({ "down", "disc", }), "The Disc spreads out below "
      "you, much too far away to make out anything distinctly." );
  people = ({ });
}

int query_flying( string who ) {
  if( member_array( who, people ) > -1 )
    return 1;
  else
    return 0;
}

void drop_non_living( object ob ) {
  object broom = load_object( BROOMSTICK );
  object player;
  object dest;

  if( ob->query_corpse() ) {
    string name = ob->query_owner();
    name = lower_case( explode( name, " " )[0] );
    player = find_player( name );
  }

  if( !player )
    player = load_object( GRANNY );

  if( !broom || !player )
    return;  // bugger.  Let it hover.

  dest = broom->random_dest( player );
  ob->move( dest, "$N streaks down from above and crashes into the ground "
                  "with a thud, narrowly missing you.",
                  "$N disappear$s from view far below." );
}

/*  Damn, they're still here.  Put them down somewhere.  */
void down_they_go( object witch, object *riding ) {
  object broom;    // the broom she's riding
  object *brooms;  // all the brooms in her inventory
  object *held;    // all the brooms she's *holding*
  string path;     // the path of the place she's headed
  object dest;     // the place she's headed

  // Maybe she's not even here!
  if( !witch )
    return;

  people -= ({ witch->query_name() });

  if( environment( witch ) != this_object() )
    return;

  // Did she enter the air room by flying?  (As opposed to eg restarting
  // here, being here when the room was updated, or some other rare event)
  // If so, use the broom she flew in on to land her.
  // NB: Fireflies, fruitbats etc. don't have a broom in this list.

  if( sizeof( riding ) && riding[0] != 0 ) {
    broom = riding[0];
    tell_creator( "tannah", "broom: %O\n", broom );
  } else {

    // We've lost track of which broom she flew in on.  Let's try to find
    // another one to use.  This might drop her into a destination from a
    // previous flight, but at least it'll drop her somewhere.
    brooms = match_objects_for_existence( "witches' broomstick",
                                          ({ witch }), 0 );

    // does she have any?
    if( !sizeof( brooms ) ) {
      // if she's not holding any brooms, check to see if she's still
      // autoloading
      if( witch->query_auto_loading() ) {
        call_out( (: down_they_go :), TIME_LIMIT, witch, riding );
        tell_object( witch, "Your thighs twitch reflexively and your "
                            "hands scrabble at the air, searching "
                            "for your broom.\n" );
        return;
      } else { // she isn't autoloading and she hasn't got one.  SUX0R!
        broom = load_object( BROOMSTICK );
      }

    } else if( sizeof( brooms ) > 1 ) {

      // if she's got more than one, pick the one she's holding.  If
      // she isn't holding any, pick any of them (she'll crash when she
      // lands)

      held = filter( brooms, (: $1->query_holder() == $(witch) :) );
      if( sizeof( held ) )
        broom = held[0];
      else
        broom = brooms[0];
    } else {
      // she's only got the one.  Use it.
      broom = brooms[0];
    }
  }

  // if it's got a destination, use it.  If not, pick a new one.
  path = broom->query_destination();
  if( path )
    dest = load_object( path );
  else
    dest = broom->random_dest(witch);

  tell_creator( "tannah", "Broom: %O\nLanding in: %O\n", broom, dest );
  broom->land( witch, dest );
}

void event_enter( object ob, string message, object from ) {

  if( !living( ob ) ) { // objects fall straight away
    ob->set_position( "dropping towards the ground" );
    call_out( (: drop_non_living :), 2, ob );
    return;
  }

  /* Block all actions they might take up here and screen out those that
   * aren't allowed */

  ob->command_override( (: screen_command :) );

  /* Sometimes the call_out in the broom gets lost.  This shouldn't be
   * needed too often, but still...  */
  people += ({ ob->query_name() });
  call_out( (: down_they_go :), TIME_LIMIT, ob,
            filter( previous_object(-1), (: $1->id( "broomstick" ) :) ) );
}

mixed query_default_position() {
   return ({ "flying through the air" });
}

void event_exit(object ob, string message, object to) {

   tell_object( ob, "You plummet towards the ground.\n" );
   tell_room( this_object(), ob->the_short()
         +" plummets towards the ground.\n", ob );

   STANDING_CMD->position( ob, 1 );
}

int screen_command( string cmd ) {
  string garbage;  /* the part of the command string we don't need */

  sscanf( cmd, "%s %s", cmd, garbage );

  /* We'll completely ignore aliases unless they're broken down. */

  if( cmd == "END_ALIAS" ||
      (function_exists("query_aliases",this_player()) &&
       member_array( cmd, keys( this_player()->query_aliases() ) ) != -1 ))
    return notify_fail( "" );

  /* We'll check cmd against the list of allowed commands.  If it's in the
   * list, returning 0 allows it to execute normally.  We're not allowing
   * souls for now. */

  if( member_array( cmd, allowed_commands ) != -1 /* ||
      SOUL_OBJECT->query_soul_command( cmd ) */ )
    return 0;

  /* Let cres do things players can't, but warn them. */

  if( this_player()->query_creator() ) {
    write( "You attempt aerial feats mere mortals dare not.\n" );
    return 0;
  }

  /* A nice little array of messages, so they don't get bored with the
   * same warning every time. */

  write( ({
      "You don't dare do that while flying so high above the ground.\n",
      "Your broom lurches alarmingly, nearly tossing you to the ground "
          "below.\n",
      "Your concentration wanes and your broom suddenly loses "
          "altitude.\n",
      })[ random( 3 ) ] );
  return 1;

  /* The rest of the function isn't ever used because of the above return,
   * but I left it here in case we want to expand the list of allowed
   * commands later. */

  /* if the first character is ', then it's a say and allowed. */
  if( cmd[0] == 39 ) return 0;

  /* if the first character is ", then it's a say and allowed. */
  if( cmd[0] == 34 ) return 0;

} /* screen_command() */

string *query_people() { return people; }// --- END [/mnt/home2/grok/lib/room/air.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/garden.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/garden.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630017   Available: 13577371
Inodes: Total: 5242880    Free: 4960136
590 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/garden.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630017   Available: 13577371
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>

inherit "/std/room/basic_room";

void setup() {
  set_light(70);
  set_short("Statue garden");
  set_long(
"This is a nice garden.  Scattered amongst the garden you notice amazingly "+
"accurate statues of people.\n");

  add_exit("drum", CONFIG_START_LOCATION, "path");

  add_item("garden",
           "It is a lovely garden, nice little walk ways drifting off into "+
           "the distance.  Lovely little sheltered groves and grotos.");
  add_item("statue",
           "Very life like statues of people.  Amazing what they can do "+
           "these days.");
}
// --- END [/mnt/home2/grok/lib/room/garden.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/air_terrain.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/air_terrain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630017   Available: 13577371
Inodes: Total: 5242880    Free: 4960136
2827 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/air_terrain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630017   Available: 13577371
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit TERRAIN_MAP_AIR_BASE;

void setup() {
   set_long("Flying up high in the air.");
   set_short("air room");
}

void terrain_setup() {
   int* coords;
   int* ground_coords;
   string ground_room;
   string ground_base_str;

   coords = query_terrain_coords();

   ground_room = query_terrain_handler()->query_ground_room(coords[0], coords[1]);
   ground_coords = ground_room->query_terrain_coords();

   switch (coords[2] - ground_coords[2]) {
   case 0..100 :
      ground_base_str = ground_room->query_long();
      set_long("Down below you see: " + ground_base_str);
      break;
   case 101..200 :
      set_long("Flying up high above " + ground_room->query_short() + ".");
      break;
   default :
      set_long("High up in the sky.");
      break;
   }

}

void event_enter(object ob) {
   // Flying or floating.
   if (ob->query_property("flying")) {
      return ;
   }
   call_out("plumet_down", 2, ob);
}

void plumet_down(object ob) {
   int* coords;
   int* ground_coords;
   class coord coords_real;
   class coord ground_coords_real;
   int z;
   int damage;
   int dist;
   object room;

   if (environment(ob) != this_object() || ob->query_property("flying")) {
      return ;
   }
   coords = query_terrain_coords();
   ground_coords = query_terrain_handler()->query_ground_room_co_ords(coords[0], coords[1]);
   coords_real = query_terrain_handler()->query_real_from_terrain_coord(coords[0], coords[1], coords[2]);
   ground_coords_real = query_terrain_handler()->query_real_from_terrain_coord(ground_coords[0], ground_coords[1], ground_coords[2]);
   dist = coords_real->z - ground_coords_real->z;
   for (z = coords[2] - 1; z > ground_coords[2]; z--) {
      room = query_terrain_handler()->query_room_at(coords[0], coords[1], z);
      if (room) {
         tell_room(room, ob->the_short() + " plumets by on the way to the "
                   "ground.\n");
      }
   }
   // Hit the ground :)
   room = query_terrain_handler()->load_room_at(coords[0], coords[1], ground_coords[2]);
   tell_object(ob, "%^BOLD%^%^RED%^You find it hard to float and make a quick trip " +
                   query_terrain_handler()->query_distance_str(dist) +
                   " downwards.%^RESET%^\n");
   // Figure out the damage.
   ob->move_with_look(room, "$N plumets down out of the sky.",
                  "$N plumets down out of the sky.");
   damage = 2 * dist;
   damage -= ob->query_ac( "blunt", damage );
   ob->adjust_hp(damage, this_object(), this_object());
   tell_object(ob, "%^BOLD%^%^RED%^Ouch, that hurt.%^RESET%^\n");
}

string query_death_message() {
   return "from forgetting they cannot fly";
}

int query_theft_command() {
   return 1;
}

int can_enter_from(string key, string direc) {
   return 0;
}

int can_exit_to(string key, string direc) {
   return 0;
}
// --- END [/mnt/home2/grok/lib/room/air_terrain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/room/morgue.c] ---
// Size:   File: "/mnt/home2/grok/lib/room/morgue.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630016   Available: 13577370
Inodes: Total: 5242880    Free: 4960136
402 bytes, Last Modified:   File: "/mnt/home2/grok/lib/room/morgue.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630016   Available: 13577370
Inodes: Total: 5242880    Free: 4960136
2006-10-07 20:59:56.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
inherit "/std/room/basic_room";

void setup() {
   set_short( "morgue");
   add_property( "determinate", "the " );
   add_property( "no teleport", 1 );
   set_light( 100 );
   set_long("Lots of bodies stacked end on end in long rows.  It looks "
            "like they have stopped sleeping.\n");
} /* setup() */

int *query_co_ord() { return 0; }

void clean_up(int i) { return; }
// --- END [/mnt/home2/grok/lib/room/morgue.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/export_inventory.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/export_inventory.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630016   Available: 13577370
Inodes: Total: 5242880    Free: 4960136
3619 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/export_inventory.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630016   Available: 13577370
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file contains the control functions for exporting your inventory.
 * @author Pinkfish
 * @started Thu Mar  5 21:03:40 CST 1998
 */
 
nosave object *registered_containers;
nosave int can_export_inventory;
 
void create() {
   registered_containers = ({ });
} /* create() */
 
/**
 * This method adds a container to the list of registered containers.
 * A registered container will be used to enhance the inventory of
 * the current container.  This will only be used with find_match
 * inventory items.  The item *must* be contained inside this object
 * to be added.  When checking only visible added objects will have
 * their inventory added.
 * @param cont the new container to add
 * @see find_inv_match()
 * @see remove_inventory_container()
 */
void add_inventory_container(object cont) {
   if (member_array(cont, registered_containers) == -1 &&
       environment(cont) == this_object()) {
      registered_containers += ({ cont });
   }
} /* add_inventory_container() */
 
/**
 * This method removes a container to the list of registered containers.
 * A registered container will be used to enhance the inventory of
 * the current container.  This will only be used with find_match
 * inventory items.
 * @param cont the new container to add
 * @see find_inv_match()
 * @see add_inventory_container()
 */
void remove_inventory_container(object cont) {
  if(!registered_containers || !cont)
    return;
  registered_containers -= ({ cont });
} /* remove_inventory_container() */
 
/**
 * This method allows the objects inside it (which are registered) to
 * export their invetories as well.  You do not want to be able to do
 * this with player or living objects (for instance).
 * The default value for this is reset()
 * @see add_inventory_container()
 * @see query_can_export_inventory()
 * @see reset_can_export_inventory()
 */
void set_can_export_inventory() {
   can_export_inventory = 1;
} /* set_can_export_inventory() */
 
/**
 * This method disables the object from exporting its inventory.
 * @see set_can_export_inventory()
 * @see query_can_export_inventory()
 * @see add_inventory_container()
 */
void reset_can_export_inventory() {
   can_export_inventory = 0;
} /* reset_can_export_inventory() */
 
/**
 * This method returns if the container will export its inventory.
 * @see add_inventory_container()
 * @see query_can_export_inventory()
 * @see reset_can_export_inventory()
 * @see set_can_export_inventory()
 * @return 1 if the container does export its inventory, 0 if not
 */
int query_can_export_inventory() {
   return can_export_inventory;
} /* query_can_export_inventory() */
 
/**
 * This method is not designed to be called from outside
 * the object itself.  It returns the list of objects able to
 * be matched that are container in containers in the container.
 * The third parameter is the set of objects the container
 * must appear in to be used.  This has to be handled sperately
 * so thet the plural matchin does not return the ones deep
 * inside your containers.
 * @param words the words which were matched with
 * @param looker the person doing the matching
 * @param things the current list of things matched.
 */
protected object *find_expanded_inv_match( string words, object looker,
                                           object *things) {
   object *stuff;
   object bing;
 
   stuff = ({ });
   if (can_export_inventory) {
      foreach (bing in registered_containers) {
         if (member_array(bing, things) != -1) {
            stuff += bing->find_inv_match(words, looker);
         }
      }
   }
 
   return stuff;
} /* find_inv_match() */
// --- END [/mnt/home2/grok/lib/std/basic/export_inventory.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/setup.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/setup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630014   Available: 13577368
Inodes: Total: 5242880    Free: 4960136
766 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/setup.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630014   Available: 13577368
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This handles the setup code for rooms and objects.  It simplifies the whole
 * system and makes it nice and generic.
 * @author Pinkfish
 * @started May 16th
 */
private int _do_setup;

/**
 * This method increments the setup variable.
 */
protected void inc_setup() {
   _do_setup++;
} /* inc_setup() */

/**
 * This method decrements the setup variable.
 */
protected void dec_setup() {
   _do_setup--;
} /* dec_setup() */

/**
 * This method checks to see if the setup is possible.
 */
protected void do_setup() {
   if (!_do_setup) {
      this_object()->setup();
   }
} /* do_setup() */

/**
 * This method checks to see if the reset is possible.
 */
protected void do_reset() {
   if (!_do_setup) {
      this_object()->reset();
   }
} /* do_reset() */
// --- END [/mnt/home2/grok/lib/std/basic/setup.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/wearable.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/wearable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630014   Available: 13577368
Inodes: Total: 5242880    Free: 4960136
14398 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/wearable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630014   Available: 13577368
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: wearable.c,v 1.24 2003/05/21 03:44:06 ceres Exp $
 */
/**
 * This file contains all the methods needed to make an object wearable
 * by a player or an npc.
 * @author Pinkfish
 * @see /obj/armour.c
 * @see /obj/clothing.c
 */
inherit "/std/basic/condition";

#include <clothing.h>
#include <move_failures.h>

private string *immune_to;
private string *wear_effects;
private mixed type;
private mixed *wear_remove_func;
nosave object worn_by;

void create() {
   condition::create();
   set_damage_chance( 25 );
   immune_to = ({ "cold", "sound", "gas", "mental" });
   wear_effects = ({ });
   wear_remove_func = ({ });
} /* create() */

/**
 * This method tells us if the object is wearable.
 * In the case of a wearable object it will always return 1.
 * @return always returns 1
 */
int query_wearable() { return 1; }

/** @ignore yes */
string long( string word, int dark ) {
   switch ( dark ) {
      case 0 :
         return cond_string();
      default :
         return "";
   }
} /* long() */

/**
 * This method returns the current function associated with
 * wearing and removing the item.
 * @return the current function for wearing and removing the clothing
 * @see set_wear_remove_func()
 */
mixed *query_wear_remove_func() {
   return wear_remove_func;
} /* query_wear_remove_func() */

/**
 * This method sets the current function associated with wearing and
 * removing the item.  The value of this function should be choosen
 * carefully, using an object reference for the name will work but
 * it will not then be able to restored from the save file.  The same
 * goes for using function pointers.  It is better to use a real
 * file name and a string function name.
 * <p>
 * The function will be called with two arguments, the first argument will
 * be 0 if the object is being removed or the object which it is
 * being worn by if it is non-zero.  The second argument will always
 * be the person who was wearing the item, or is about to wear the
 * item.
 * @example
 * inherit "/std/basic/wearable";
 *
 * void setup() {
 *    ...
 *    set_wear_remove_func(base_name(this_object()), "do_fluff");
 *    ...
 * } /\* setup() *\/
 *
 * void do_fluff(object ob, object player) {
 *    if (!ob) {
 *       write(capitalize(the_short()) + " is being removed.\n");
 *    } else {
 *       write(capitalize(the_short()) + " is being worn.\n");
 *    }
 * } /\* do_fluff() *\/
 * @param file the file to call the function on
 * @param func the function to call
 * @see query_wear_remove_func()
 */
void set_wear_remove_func( mixed file, string func ) {
   wear_remove_func = ({ file, func });
} /* set_wear_remove_func() */

/**
 * This method returns the list of effects to be added to the wearer when
 * it is worn.  These effects will automaticly be added when worn and
 * removed when taken off.
 * @return the list of effects to be added to the wearer when worn
 * @see set_wear_effects()
 * @see add_wear_effect()
 */
string *query_wear_effects() {
  if(!wear_effects)
    wear_effects = ({ });
  return copy(wear_effects);
} /* query_wear_effects() */

/**
 * This method sets the list of effects to be added to the wearer when it
 * is worn.  These effects will automaticly be added when worn and
 * removed when taken off.
 * @param effects the array of effects to be added to the wearer when worn
 * @see query_wear_effects()
 * @see add_wear_effect()
 */
void set_wear_effects( string *effects ) {
   wear_effects = effects;
} /* set_wear_effects() */

/**
 * This method adds a new wear effect to the current wear effect array.  These effects will automaticly be added when worn and
 * removed when taken off.
 * @param effect the effect to add
 * @see query_wear_effects()
 * @see set_wear_effects()
 */
void add_wear_effect( string effect ) {
   if ( member_array( effect, wear_effects ) == -1 ) {
      wear_effects += ({ effect });
   }
} /* add_wear_effect() */

/** @ignore yes */
void do_damage( string type, int amount ) {
   if ( member_array( type, immune_to ) == -1 ) {
      condition::do_damage( type, amount );
   }
} /* do_damage() */

/**
 * This method returns the person who is currently wearing the object.
 * @return the current wearer of the object
 * @see set_worn_by()
 */
object query_worn_by() {
   return worn_by;
} /* query_worn_by() */

/**
 * This method sets the object as being worn by the passed in object.
 * It calls all the various worn functions and sets up or removes
 * all the effects associated with the object.
 * <p>
 * If the object is alreadying being worn the wear_remove_function will
 * be called with an argument of 0.  The method taken_off will be
 * called on the object wearing the object for all the effects associated
 * with this object.
 * <p>
 * If the object is being set to be worn by someone the the wear_remove
 * function will be called with an argument being the person who is to
 * wear the object.   All of the effects associated with the
 * object will be added to the wearer.
 * <p>
 * This calls the method 'person_removing_item' on the effect when some
 * one removes the item.  This can be used to make sure the effects are
 * taken off when the item is removed.
 * @param thing the new person to wear the object (0 for worn by no one)
 * @return 1 if successful, 0 on failure
 * @see set_wear_remove_func()
 * @see add_wear_effect()
 */
int set_worn_by( object thing ) {
   int i;

   /* Do nothing if we are already worn by them. */
   if ( thing == worn_by ) {
      return 1;
   }

   /* We need this thing check here because if thing is 0 we are removing the object! */
   /* Taffyd */

   if (thing && environment() != thing) {
      return 0;
   }

   /* First remove any possible concealment off us */
   this_object()->remove_hide_invis( "concealed" );

   /* If there is a move function, then call it. */
   if ( sizeof( wear_remove_func ) ) {
    if ( !objectp( wear_remove_func[ 0 ] ) && !objectp( load_object( wear_remove_func[ 0 ] ) ) ) {
        debug_printf( "Wear/Remove func is %O. Not called.\n", wear_remove_func );
      return 0;
    }

    if ( worn_by ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], 0, worn_by );
      }
      if ( thing ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], thing, thing );
      }
   }

   /* If there are some wear effects, set them up or remove them. */
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         if ( worn_by ) {
            worn_by->taken_off( this_object(), wear_effects[ i ] );
         }
         if ( thing ) {
            thing->add_effect( wear_effects[ i ], this_object() );
         } else {
            wear_effects[i]->person_removing_item(this_object(), worn_by);
         }
      }
   }

   /*
    * Call the functions on the object doing the wearing to remove or add
    * the item.
    */
   if ( worn_by ) {
      worn_by->now_removed( this_object() );
      this_object()->add_adjective("worn");
      this_object()->remove_adjective("unworn");
   } else {
      this_object()->remove_adjective("worn");
      this_object()->add_adjective("unworn");
   }
   if ( thing ) {
      thing->now_worn( this_object() );
   }
   worn_by = thing;

   return 1;
} /* set_worn_by() */

/**
 * This returns the list of types of damage that the object is immune to.
 * @return the list of damage we are immune to
 * @see /std/basic/condition.c
 * @see add_immune_to()
 * @see remove_immune_to()
 */
string *query_immune_to() {
   return immune_to;
} /* query_immune_to() */

/**
 * This adds a new type of damage that the object is immune to.
 * The parameter can either be a string or an array of strings
 * being the types of damage to be immune to.
 * @param args the type of damage to be immune to
 * @example
 * inherit "/std/basic/wearable";
 *
 * void setup() {
 *    ...
 *    add_immune_to("sharp");
 *    ...
 * } /\* setup() *\/
 * @example
 * inherit "/std/basic/wearable";
 *
 * void setup() {
 *    ...
 *    add_immune_to("sharp");
 *    ...
 * } /\* setup() *\/
 * @see remove_immune_to()
 * @see query_immune_to()
 */
void add_immune_to( mixed args ) {
   int i;

   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         add_immune_to( args[ i ] );
      }
   } else {
      if ( member_array( args, immune_to ) == -1 ) {
         immune_to += ({ args });
      }
   }
} /* add_immune_to() */

/**
 * This method removes a type of damage that the weapon is immune
 * to.
 * @param args the type(s) of damage to remove immunity too
 * @see add_immune_to()
 * @see query_immune_to()
 */
void remove_immune_to( mixed args ) {
   int i;

   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         remove_immune_to( args[ i ] );
      }
   } else {
      i = member_array( args, immune_to );
      if ( i != -1 ) {
         immune_to = delete( immune_to, i, 1 );
      }
   }
} /* remove_immune_to() */

/**
 * This method returns the current type(s) associated with the object.
 * If this method returns a string then there is only one type for this
 * object.  If it returns a string then there is more than one
 * type associated with an object.  An example of something with more
 * than one type is a skirt, which is a dress and a shirt at the
 * same time.
 * @return the current type of the item
 * @see set_type()
 */
string query_type() {
   return type;
} /* query_type() */

/** @ignore yes */
private void log_bad_type( mixed type ) {
  string word, str;

  if ( !clonep( this_object() ) ) {
      return;
  }
  word = (string)this_object()->query_property( "virtual name" );
  if ( word ) {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", word,
           (string)this_object()->query_short(), type );
  } else {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", file_name(),
           (string)this_object()->query_short(), type );
  }
  if ( this_player()) {
    write(str);
  }
  call_out("move", 2, "/room/broken");
} /* log_bad_type() */

/**
 * This method sets the type(s) which are associated with the
 * item.  If the parameter is a string then a single type is associated
 * with the item, if the parameter is an array then a list of types
 * is associated with the object.  If any of these types are not
 * legal and error message will be produced.
 * @param word the new type(s) to set for the object
 * @see query_type()
 */
void set_type( mixed word ) {
  int i;
  
   if(!stringp(word) && !pointerp(word))
      return log_bad_type(word);

   type = word;
   if(stringp(word)) {
     if(CLOTHING_HANDLER->query_equivilant_type(word))
       type = CLOTHING_HANDLER->query_equivilant_type(word);
     if(!CLOTHING_HANDLER->query_valid_type(word))
       log_bad_type( word );
     return;
   }
   
   for(i=0; i<sizeof(word); i++) {
     if(CLOTHING_HANDLER->query_equivilant_type(word[i]))
       type[i] = CLOTHING_HANDLER->query_equivilant_type(word[i]);
     if (!CLOTHING_HANDLER->query_valid_type(word[i]))
       log_bad_type( word );
     return;
   }
} /* set_type() */

/** @ignore yes */
int modify_value( int amount ) {
   return ( amount * ( 10 + ( 90 * query_cond() ) / query_max_cond() ) ) / 100;
} /* modify_value() */

/** @ignore yes */
void player_wear() {
   if ( !environment() ) {
      return;
   }
   environment()->wear_armour( this_object() );
} /* player_wear() */

/** @ignore yes */
void break_me() {
   if ( !worn_by ) {
      return condition::break_me();
   }
   tell_object( worn_by, "%^RED%^$C$"+ (string)this_object()->the_short() +
         " breaks!%^RESET%^\n" );
   tell_room( environment( worn_by ), (string)worn_by->the_short() +"'s "+
         this_object()->short( 0 ) +" breaks!\n", worn_by );
   worn_by->remove_armour( this_object() );

   if((int)this_object()->move("/room/rubbish") != MOVE_OK)
     move_object("/room/rubbish");
} /* break_me() */

/** @ignore yes */
mixed *stats() {
   int i;
   string *stuff;

   stuff = condition::stats() +
      ({
         ({ "type", type }),
      });
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         stuff += ({ ({ "wear effect", wear_effects[ i ] }) });
      }
   }
   for ( i = 0; i < sizeof( immune_to ); i++ ) {
      stuff += ({ ({ "immune to", immune_to[ i ] }) });
   }
   if (worn_by) {
      stuff += ({ ({ "worn by", worn_by->short() }) });
   }
   return stuff;
} /* stats() */

/** @ignore yes */
mapping query_static_auto_load() {
   return ([
      "condition" : condition::query_static_auto_load(),
      "type" : type,
      "wear remove func" : wear_remove_func
   ]);
} /* query_static_auto_load() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([
      "condition" : condition::query_dynamic_auto_load(),
      "wear effects" : wear_effects,
      "immune" : immune_to,
      "worn" : ( worn_by != 0 )
   ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_static_arg( mapping map ) {
   if ( map[ "type" ] )
      type = map[ "type" ];
   if ( map[ "wear remove func" ] )
      wear_remove_func = map[ "wear remove func" ];
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_static_arg( map[ "condition" ] );
   } 
#ifdef AFTER_1999_I_BELIEVE   
   else { /* if you read ths and it's 1999, remove this crap
             * and only keep the call above :)
             */
      if ( !undefinedp( map[ "max cond" ] ) )
         max_cond = map[ "max cond" ];
      if ( !undefinedp( map[ "damage chance" ] ) )
         damage_chance = map[ "damage chance" ];
   }
#endif
} /* init_static_arg() */

/** @ignore yes */
void init_dynamic_arg( mapping map, object ) {
   if ( map[ "effect" ] )
      wear_effects = ({ map[ "effect" ] });
   if ( pointerp( map[ "wear effects" ] ) )
      wear_effects = map[ "wear effects" ];
   if ( map[ "immune" ] )
      immune_to = map[ "immune" ];
   if ( map[ "worn" ] )
      call_out( "player_wear", 0 );
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_dynamic_arg( map[ "condition" ] );
   }
#ifdef AFTER_1999_I_BELIEVE
   } else { /* if you read this and it's 1999, remove this crap
             * and only keep the call above :) */
      cond = map[ "cond" ];
      lowest_cond = map[ "lowest cond" ];
   }
#endif
} /* init_dynamic_arg() */

/**
 * Unset the wear_remove func.
 */
void remove_wear_remove_func() {
    wear_remove_func = ({ }); 
}
// --- END [/mnt/home2/grok/lib/std/basic/wearable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/property.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/property.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630010   Available: 13577364
Inodes: Total: 5242880    Free: 4960136
8006 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/property.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630010   Available: 13577364
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: property.c,v 1.11 2003/05/18 12:28:46 taffyd Exp $
 */
/* /std/basic/property */
/**
 * The property handling system.  This handles all the stuff to do with
 * properties.
 *
 * @author Pinkfish
 * @change
 * Change by Pinkfish Tue Jun  3 23:32:27 WST 1997
 * to make timed properties.
 * @change
 * Change by Terano Thurs 15 October, 1998
 * Added some statistics
 */
//#define TRACK_PROPERTY_STATS 1

mapping map_prop;
mapping timed_properties;
mapping property_stats;

void create() {
  /* We don't init the mapping any more to save memory */
  //  map_prop = ([ ]);
} /* create() */

/**
 * Adds a property onto the object.  Allows you to add a property
 * onto the current object.  You can also set a time for the property
 * to last.

 * @param var the name of the property
 * @param val the value to give the property
 * @param tim the time before the property should time out
 *
 * @return 1 if it succeeded, 0 if it failed.
 */
varargs int add_property(string var, mixed val, int tim) {
  
  if (!stringp(var))
    return 0;
  
  if (!map_prop)
    map_prop = ([ ]);

  map_prop[var] = val;
  
  if (tim > 0) {
    if (!timed_properties)
      timed_properties = ([ ]);
    timed_properties[var] = tim + time();
  }
#ifdef TRACK_PROPERTY_STATS
  if (!property_stats)
    property_stats = ([ ]);

  if (previous_object())
    property_stats[var] = ({ file_name( previous_object() ), time(), tim });
  else
    property_stats[var] = ({ "No previous object.", time(), tim });
#endif  
  return 1;
} 

/**
 * Removes a property off the object.  This removes the named property
 * from the object.
 *
 * @param var the name of the property
 * @return always returns 1
 */
int remove_property(string var) {
  if (map_prop) 
    map_delete(map_prop, var);
  if (timed_properties)
    map_delete(timed_properties, var);
#ifdef TRACK_PROPERTY_STATS
  if (property_stats)
    map_delete(property_stats, var);
#endif  
  return 1;
} /* remove_property() */

/**
 * Returns the value of the property.  This will return the current value
 * of the named property.
 * 
 * @param str the property to find
 * @return the value of the property
 * @see query_property_exists(), query_is_timed_property(), 
 * query_property_time_left()
 */
mixed query_property(string str) {
  if (!map_prop)
    return ([ ])["bing"];
  
  if (timed_properties && timed_properties[str] &&
      timed_properties[str] < time()) {
    map_delete(timed_properties, str);
    map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
    if(property_stats)
      map_delete(property_stats, str);
#endif    
    return map_prop[str];
  }
  
  return map_prop[str];
} /* query_property() */

/**
 * Is this property value timed?
 *
 * @return 1 if it is, 0 if not
 * @param str the property to check
 */
int query_is_timed_property(string str) {
  if (timed_properties && timed_properties[str]) {
    if (timed_properties[str] < time()) {
      map_delete(timed_properties, str);
      map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS     
      map_delete(property_stats, str);
#endif      
      return 0;
    }
    return 1;
  }
  return 0;
} /* query_is_timed_property() */

/**
 * If this is a timed property it returns the amount of time left.
 *
 * @param str the property name
 * @return the amount ot time left
 */
int query_property_time_left(string str) {
  if (timed_properties &&
      timed_properties[str]) {
    if (timed_properties[str] < time()) {
      map_delete(timed_properties, str);
      map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS     
      map_delete(property_stats, str);
#endif      
      return 0;
    }
    return timed_properties[str] - time();
  }
  return 0;
} /* query_property_time_left() */

/**
 * Does this property exist?
 *
 * @param str the property to check
 * @return 1 if the property exists, 0 if it does not
 */
int query_property_exists(string str) {
  if (!map_prop)
    return 0;
  
  if (timed_properties &&
      timed_properties[str] &&
      timed_properties[str] < time()) {
    map_delete(timed_properties, str);
    map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
    map_delete(property_stats, str);
#endif    
    return map_prop[str];
  }
  
  return !undefinedp(map_prop[str]);
} /* query_property_exists() */

/**
 * returns a mapping with all the properties in it.
 *
 * @return a mapping of all the properties
 */
mapping query_properties() { 
  if (map_prop)
    return map_prop ;
  return ([ ]);
} /* query_properties() */

/**
 * Returns a mapping of all the timed properties.
 * @return a mapping of all the timed properties
 */
mapping query_timed_properties() {
  if (timed_properties)
    return timed_properties;
  return ([ ]);
} /* query_timed_properties() */

/**
 * Adds a mapping of properties in, instead of just one.
 * @param map the mapping of properties
 */
void add_properties(mapping map) {
  if (!map_prop)
    map_prop = map;
  else
    map_prop += map;
}

/**
 * Resets all properties
 * @param map the mapping of properties
 */
void set_properties(mapping map) {
  map_prop = map;
}

/**
 * Updates the timeouts and stuff before saving the player object.
 */
protected void save_player_properties() {
  string prop;

  if(timed_properties)
    foreach(prop in keys(timed_properties))
      if(timed_properties[prop] < time())
        map_delete(timed_properties, prop);
      else
        timed_properties[prop] -= time();
}

/**
 * Fixes the times back up again after it has been loaded.
 */
protected void reload_player_properties() {
  string prop;
  
  if (timed_properties)
    foreach(prop in keys(timed_properties))
      if(!map_prop[prop]) // This just does a little integrity check.
        map_delete(timed_properties, prop);
      else
        timed_properties[prop] += time();
}

/**
 * @ignore yes
 */
mixed stats() {
  int i, bing;
  mixed *k, *v, *res;
  mapping props;
  
  props = (mapping)this_object()->query_properties();
  if ( !props )
    return ({ });
  k = keys( props );
  v = values( props );
  res = ({ });
  for ( i = sizeof( k ) - 1; i > -1; i-- ) {
    
    bing = 0;
    
    if (timed_properties &&
        timed_properties[ k[ i ] ] &&
        timed_properties[ k[ i ] ] < time()) {
      map_delete(timed_properties, k[ i ]);
      map_delete(map_prop, k[ i ]);
#ifdef TRACK_PROPERTY_STATS
      if(property_stats)
        map_delete(property_stats, k[i]);
#endif      
      continue;
    }
    
    if (timed_properties &&
        timed_properties[ k[ i ] ]) {
      bing = timed_properties[ k[ i ] ] - time();
    }
    
    if ( !stringp( k[ i ] ) || k[ i ][ 0 .. 3 ] == "news" ||
         k[ i ] [ 0 ] == '.' )
      continue;
    if ( pointerp( v[ i ] ) ) {
      res += ({ ({ "(" + k[ i ] + (bing ? ":"+bing : "") + ")",
                     array_to_string( v[ i ] ) }) });
      continue;
    }
    if ( mapp( v[ i ] ) ) {
      res += ({ ({ "(" + k[ i ] + (bing ? ":"+bing : "") + ")",
                     mapping_to_string( v[ i ] ) }) });
      continue;
    }
    res += ({ ({ "("+ k[ i ] + ( bing ? ":"+ bing : "" ) +")",
                   v[ i ] }) });
  }
  return res;
} /* stats() */

#ifdef TRACK_PROPERTY_STATS
/**
 * Returns some facts about the property, in the format
 * ({ Filename of object which added stat, time added, time expiring })
 *
 * @param The property statistics are wanted on
 * @return That stuff just mentioned.
 */

mixed query_property_stats( string var ) {
  if (!property_stats || undefinedp( property_stats[var] ) ) 
    return ({ });
  return property_stats[ var ];
}

/**
 * Return all property statistics
 *
 * @return A mapping full of stats
 * @see query_property_stats
 */
mapping query_stats() {
  mixed property1, property2;

  if (!property_stats)
    return ([ ]);

  foreach( property1, property2 in property_stats ) 
    if(undefinedp(map_prop[property1]) &&
       undefinedp(timed_properties[property1]))
      map_delete(property_stats, property1);
  return property_stats;
}
#endif
// --- END [/mnt/home2/grok/lib/std/basic/property.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/club_listing.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/club_listing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630008   Available: 13577362
Inodes: Total: 5242880    Free: 4960136
29326 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/club_listing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630008   Available: 13577362
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is an inheritable for printing out different sorts of club
 * listings.
 * @author Pinkfish
 * @started Sat Oct 24 02:28:04 EDT 1998
 * @see /obj/handlers/club_handler.c
 * @see /std/room/club_control_room.c
 */

#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>

/**
 * This method will sort and capitalise the array of strings sent into
 * the method.
 * @param arr the array to sort and capitalise
 * @return the sorted and capitalised string
 * @see club_members()
 */
protected string sort_and_capitalise(string *arr) {
   return query_multiple_short(sort_array(map(arr, (: capitalize :)), 0));
} /* sort_and_capitalise() */

/**
 * This method returns the player in control of the item.
 * @param ob the item
 * @return the player in control
 * @see club_members()
 */
protected object person_in_control(object ob) {
   if (ob && environment(ob) &&
       !ob->query_channel_off()) {
      if (living(environment(ob))) {
         return environment(ob);
      }
      ob = environment(ob);
   }
   return 0;
} /* person_in_control() */

private string add_flags_to_name(string club, string name, string output_name) {
   if (CLUB_HANDLER->is_recruiter_of(club, name)) {
      return output_name + "(%^YELLOW%^r%^RESET%^)";
   }
   return output_name;
}

/**
 * This method prints out all the members of the club, or all the members
 * of the club online.  This method is designed to work with
 * add_command().
 * @param club_name the name of the club to print the members of
 * @param online print only the online members, 0 not online, 1 online, 2 online
 *  and listening to the club channel
 * @return 1 if successful, 0 if not
 */
protected int club_members(string club, int online, string person) {
   string *members;
   object *obs;
   string *bing;

   if (CLUB_HANDLER->query_club_secret(club)) {
      if (!CLUB_HANDLER->is_member_of(club, person)) {
         add_failed_mess("You must be a member of a secret club to get "
                         "the members of it.\n");
         return 0;
      }
   }

   members = CLUB_HANDLER->query_members(club);
   if (online == 1) {
      members = filter(members, (: find_player($1) && find_player($1)->query_cap_name() :) );
      write("The currently online members of " + club +
                            " are:\n$C$$I$5=" +
                      query_multiple_short(sort_array(map(members,
                    (: add_flags_to_name($(club), $1, find_player(lower_case($1))->query_cap_name()) :)), 0)) +
                      ".\n");
   } else if (online == 2) {
      obs = BROADCASTER->query_channel_members(lower_case(club));
      bing = map(filter(map(obs, (: person_in_control($1) :)),
                        (: $1 && reference_allowed($1, $(person)) :)),
                 (: $1?$1->query_name():0 :));
      bing = bing & members;
      write("The current members of " + club +
                            " listening are:\n$C$$I$5=" +
                      sort_and_capitalise(bing) + ".\n");
   } else {
      write("The current members of " + club +
                            " are:\n$C$$I$5=" +
                      sort_and_capitalise(
       map(members, (: add_flags_to_name($(club), $1, $1) :))) + ".\n");
   }
   return 1;
} /* club_members() */

/**
 * This method prints out a list of the current clubs.
 * @param person the person who is doing the listing
 * @param print_families 1 print the families, 0 print the clubs
 * @param check_list this function is called to see if the club should be listed
 * @return 0 on failure and 1 for success
 * @see club_info()
 * @see club_members()
 * @see www_club_list()
 * @see www_club_info()
 */
protected int club_list(string person,
                        int print_families,
                        function check_list) {
   string *clubs;
   string club;
   string stuff;
   int num;
   int found;

   clubs = CLUB_HANDLER->query_clubs();
   if (!sizeof(clubs)) {
       add_failed_mess("There are no clubs or families to list.\n");
       return 0;
   }
   if (print_families) {
      clubs = filter(clubs, (: CLUB_HANDLER->is_family($1) :));
      stuff = "Families:\n";
   } else {
      clubs = filter(clubs, (: !CLUB_HANDLER->is_family($1) :));
      stuff = "Clubs:\n";
   }
   clubs = sort_array(clubs, 1);
   foreach (club in clubs) {
      if (!check_list ||
          evaluate(check_list, club, person)) {
         found++;
         num = sizeof(CLUB_HANDLER->query_members(club));
         if (CLUB_HANDLER->is_family(club)) {
            stuff += "'" + CLUB_HANDLER->query_club_name(club) +
                     "' was founded by " +
               capitalize(CLUB_HANDLER->query_founder(club)) +
                     " with " + query_num(num) + " member" +
                     (num > 1?"s":"") + ".\n";
         } else if (!CLUB_HANDLER->query_club_secret(club) ||
             CLUB_HANDLER->is_member_of(club, person)) {
            stuff += "'" + CLUB_HANDLER->query_club_name(club) +
                     "' founded by " + 
                     capitalize(CLUB_HANDLER->query_founder(club)) +
                     " with " + query_num(num) + " member" +
                     (num > 1?"s":"") + ".\n";
          } else {
            stuff += "'" + CLUB_HANDLER->query_club_name(club) +
                     "' founded by " + 
                     capitalize(CLUB_HANDLER->query_founder(club)) +
                     " with an unknown number of members.\n";
          }
       }
    }

    if (!found) {
       return 0;
    }

    if (print_families) {
       write("$P$Family list$P$" + stuff);
    } else {
       write("$P$Club list$P$" + stuff);
    }
    return 1;
} /* club_list() */

/**
 * This method returns the club information as a string.
 * @param name the name of the club to show the information about
 * @param show_election if non-zero show the election information
 * @param person the person who is showing the information
 * @return the club information string, 0 if no information
 * @see club_info()
 */
protected string club_info_string(string name,
                                  int show_election,
                                  string person) {
   string *nominations;
   string *positions;
   string *online;
   string pos;
   string nom;
   string last;
   string ret;
   string desc;
   string status;
   int member;
   int min;

   if (!CLUB_HANDLER->is_club(name) ||
       CLUB_HANDLER->is_family(name)) {
      return 0;
   }

   ret = "";

   member = CLUB_HANDLER->is_member_of(name, person);
   if (CLUB_HANDLER->query_club_secret(name)) {
      if (!member) {
         return "This is a secret club and no information is shown "
                "about the club to non members.\n";
      } else {
         ret += "This is a secret club!  Information about members is not "
                "shown to people outside the club.\n";
      }
   }

   ret += "Information on club '" + name + "' with a founder of " +
         capitalize(CLUB_HANDLER->query_founder(name)) +
         " based in " +
         CLUB_HANDLER->query_club_region(name) +
         ".\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "$I$2=  " + desc + "\n%^RESET%^$I$0=";
   }

   online = filter(CLUB_HANDLER->query_members(name), (: find_player($1) :));
   if (sizeof(online)) {
      ret += "$I$5=The online members are: " +
          sort_and_capitalise(online) +
          ".$I$0=\n";
   }
   ret += "$I$5=The not currently online members are: " +
          sort_and_capitalise(CLUB_HANDLER->query_members(name) - online) +
          ".$I$0=\n";
   if (!CLUB_HANDLER->is_family(name)) {
      ret += "$I$5=The recruiters are: " +
            sort_and_capitalise(CLUB_HANDLER->query_recruiters(name)) +
            ".$I$0=\n";
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      ret += "This is an elected club type.\n";
      positions = CLUB_HANDLER->query_valid_positions(name);
      foreach (pos in positions) {
         ret += capitalize(pos) + ": " +
               capitalize(CLUB_HANDLER->query_position_members(name,
                                                     pos)) + "\n";
      }

      if (CLUB_HANDLER->is_nomination_in_progress(name) &&
          show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "\nThe player must nominate themselves to accept the "
               "nomination.  Until this point the nomination is not "
               "accepted.\n";
         if (status) {
            ret += status + "\n";
         }
         ret += "The club is currently accepting nominations for "
               "positions, the nomination period ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".  So far the following have been "
               "nominated:\n";
         foreach (pos in positions) {
            nominations = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(nominations)) {
               ret += capitalize(pos) + " has the following nominations:\n";
               foreach (nom in nominations) {
                  if (CLUB_HANDLER->is_nomination_accepted(name, pos, nom)) {
                     last = " (accepted).\n";
                  } else {
                     last = ".\n";
                  }
                  if (sizeof(CLUB_HANDLER->query_nominators_for(name, pos, nom))) {
                     ret += "$I$9=     " + capitalize(nom) + " nominated by " +
                           sort_and_capitalise(
                           CLUB_HANDLER->query_nominators_for(name, pos, nom)) +
                           last + "$I$0=";
                  } else {
                     ret += "$I$9=     " + capitalize(nom) + " nominated by " +
                           "noone" + last + "$I$0=";
                  }
               }
           } else {
               ret += "No nominations for the position of " + capitalize(pos) +
                     ".\n";
           }
         }
      } else if (CLUB_HANDLER->is_election_in_progress(name) &&
                 show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "\nThe club is currently electing new committee members, the "
               "vote ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".\n";
         if (status) {
            ret += status + "\n";
         }
         if (member) {
            ret += "You can vote for:\n";
         } else {
            ret += "Nominations for the positions are:\n";
         }
         foreach (pos in positions) {
            nominations = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(nominations)) {
               ret += capitalize(pos) + ": " +
                     sort_and_capitalise(nominations) +
                     ".";
               if (member) {
                  if (CLUB_HANDLER->has_person_voted(name,
                                                pos,
                                                this_player()->query_name())) {
                     ret += " (voted)\n";
                  } else {
                     ret += " (not voted)\n";
                  }
               } else {
                  ret += "\n";
               }
            } else {
               ret += capitalize(pos) + ": " +
                      capitalize(CLUB_HANDLER->query_position_members(name,
                                                           pos)) +
                      " elected with no opposition.\n";
            }
         }
      } else {
         min = CLUB_HANDLER->query_minimum_next_election(name);
         if (min < time()) {
            ret += "The next default election will be held at " +
                   ctime(CLUB_HANDLER->query_next_election(name)) + " and an "
                   "election can now be forced.\n";
         } else {
            ret += "The next default election will be held at " +
                   ctime(CLUB_HANDLER->query_next_election(name)) + " and an "
                   "election can be forced after " +
                   ctime(min) + ".\n";
         }
      }
   }
   return ret;
} /* club_info_string() */

/**
 * This method prints out the information associated with the club.
 * The stuff printed out here is directly lifted from the club control room.
 * This method is designed to work with add_command().
 * @param name the name of the club to show the information about
 * @param show_election if non-zero show the election information
 * @param person the person who is showing the information
 * @return 1 on success, 0 on failure
 */
protected int club_info(string name, int show_election, string person) {
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("There is no club called " + name + ".\n");
      return 0;
   }

   if (CLUB_HANDLER->query_club_secret(name)) {
      if (!CLUB_HANDLER->is_member_of(name, person)) {
         add_failed_mess("You must be a member of a secret club to "
                         "see information on it.\n");
         return 0;
      }
   }

   write("$P$" + CLUB_HANDLER->query_club_name(name) + "$P$" +
          club_info_string(name, show_election, person));
   return 1;
} /* club_info() */

/**
 * This method returns the relations that the specified player
 * has as a string.  It will return a blank string if the player
 * has no relationships.
 * @param player the player to check relationships for
 */
string player_relationships_string(string player) {
   string family;
   string ret;
   string region;
   class relationship_data *wombles;
   int gender;
   int i;

   family = PLAYER_HANDLER->test_family(player);
   if (!family) {
      return "";
   }

   if (!CLUB_HANDLER->is_family(family)) {
      return "";
   }

   ret = "";
   region = CLUB_HANDLER->query_club_region(family);
   wombles = CLUB_HANDLER->query_relationships(family,
                                               player);
   wombles = sort_array(wombles, 
                        (: strcmp($1->related_to, $2->related_to) :));
   gender = PLAYER_HANDLER->test_gender(player);
   if (gender) {
      gender -= 1;
   }
   if (sizeof(wombles)) {
      for (i = 0; i < sizeof(wombles); i++) {
         ret += CLUB_HANDLER->query_relationship_gender(wombles[i]->relationship, gender, region) +
             " of " + capitalize(wombles[i]->related_to);
         if (i == sizeof(wombles) - 2) {
            ret += " and ";
         } else if (i < sizeof(wombles) -2) {
            ret += "; ";
         }
      }
   }
   return ret;
} /* player_relationships_string() */

/**
 * This method returns the family information as a string.
 * @param name the name of the family to show the information about
 * @param show_election if non-zero show the election information
 * @param person the person who is showing the information
 * @return the family information string, 0 if no information
 * @see family_info()
 */
protected string family_info_string(string name,
                                    string person) {
   string ret;
   string desc;

   if (!CLUB_HANDLER->is_family(name)) {
      return 0;
   }

   ret = "";
   ret += "Information on family '" + name + "' with a founder of " +
         capitalize(CLUB_HANDLER->query_founder(name)) +
         " based in " +
         CLUB_HANDLER->query_club_region(name) + ".\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "$I$2=  " + desc + "\n%^RESET%^$I$0=";
   }
/*
   foreach (per in CLUB_HANDLER->query_members(name)) {
      ret += "$I$5=" + capitalize(per);
      wombles = CLUB_HANDLER->query_relationships(name,
                                                  per);
      wombles = sort_array(wombles, 
                           (: strcmp($1->related_to, $2->related_to) :));
      gender = PLAYER_HANDLER->test_gender(per);
      if (gender) {
         gender -= 1;
      }
      if (sizeof(wombles)) {
         ret += " is the ";
         for (i = 0; i < sizeof(wombles); i++) {
            //gender = PLAYER_HANDLER->test_gender(wombles[i]->related_to);
            //if (gender) {
               //gender -= 1;
            //}
            ret += CLUB_HANDLER->query_relationship_gender(wombles[i]->relationship, gender) +
                   " of " + capitalize(wombles[i]->related_to);
            if (i == sizeof(wombles) - 2) {
               ret += " and ";
            } else if (i < sizeof(wombles) -2) {
               ret += "; ";
            }
         }
         ret += "\n";
      } else {
         ret += " with no relationships.\n";
      }
   }
 */
      
   ret += "$I$5=The members are: " +
          sort_and_capitalise(CLUB_HANDLER->query_members(name)) +
          ".$I$0=\n";
   return ret;
} /* family_info_string() */

/**
 * This method prints out the information associated with the family.
 * The stuff printed out here is directly lifted from the family control room.
 * This method is designed to work with add_command().
 * @param name the name of the family to show the information about
 * @param show_election if non-zero show the election information
 * @param person the person who is showing the information
 * @return 1 on success, 0 on failure
 */
protected int family_info(string name, string person) {
   if (!CLUB_HANDLER->is_family(name)) {
      add_failed_mess("There is no family called " + name + ".\n");
      return 0;
   }

   write("$P$" + CLUB_HANDLER->query_club_name(name) + "$P$" +
          family_info_string(name, person));
   return 1;
} /* family_info() */

/**
 * This method turns a name into a fingerable name.
 * @param name the name to make fingerable
 * @return the htmlised name string
 */
protected string www_finger_name(string name) {
   return "<a href=\"finger.c?player=" + lower_case(name) + "\">" +
          name + "</a>";
} /* www_finger_name() */

/**
 * This method prints out a list of the current clubs into html.
 * @param person the person who is doing the listing
 * @param print_families 1 print the families, 0 print the clubs
 * @param start the index to start from
 * @param show how many to show
 * @return the club listing string
 * @see club_info()
 * @see club_members()
 * @see www_club_list()
 * @see www_club_info()
 */
protected string www_club_list(string person, int print_families, int start, int show) {
   string *clubs;
   string club;
   string stuff;
   int num;

   clubs = CLUB_HANDLER->query_clubs();
   if (!sizeof(clubs)) {
       return "There are no clubs or families to list.\n";
   }
   if (print_families) {
      clubs = filter(clubs, (: CLUB_HANDLER->is_family($1) :));
      stuff = "<h2>Current " + mud_name() + " Families</h2>\n";
   } else {
      clubs = filter(clubs, (: !CLUB_HANDLER->is_family($1) :));
      stuff = "<h2>Current " + mud_name() + " Clubs</h2>\n";
   }
   clubs = sort_array(clubs, 1);
   stuff += "<ul>";
   foreach (club in clubs[start..start+show]) {
      num = sizeof(CLUB_HANDLER->query_members(club));
      if (CLUB_HANDLER->is_family(club) ||
          !CLUB_HANDLER->query_club_secret(club) ||
          CLUB_HANDLER->is_member_of(club, person)) {
         stuff += "<li>'<a href=\"club_info.c?club_name=" + club + "\">" +
                  CLUB_HANDLER->query_club_name(club) +
                  "</a>' was founded by " +
            www_finger_name(capitalize(CLUB_HANDLER->query_founder(club))) +
                  " with " + query_num(num) + " member" +
                  (num > 1?"s":"") + ".<br>\n";
       } else {
         stuff += "<li>'<a href=\"club_info.c?club_name=" + club + "\">" +
                  CLUB_HANDLER->query_club_name(club) +
                  "</a>' was founded by " +
            www_finger_name(capitalize(CLUB_HANDLER->query_founder(club))) +
                  " with an unknown number of members.\n";
       }
   }
   if (print_families) {
      return stuff + "</ul>\n" +
           "There are currently " + query_num(sizeof(clubs)) + " "
           "families on " + mud_name() + " \n";
   } else {
       return stuff + "</ul>\n" +
           "There are currently " + query_num(sizeof(clubs)) + " "
           "clubs on " + mud_name() + " \n";
   }
} /* www_club_list() */

/**
 * This method returns the club information as a html string.
 * @param name the name of the club to show the information about
 * @param show_election if non-zero show the election information
 * @param person the person who is showing the information
 * @return the club information string, 0 if no information
 * @see club_info()
 */
protected string www_club_info_string(string name,
                                      int show_election,
                                      string person) {
   string *nominations;
   string *positions;
   string pos;
   string nom;
   string last;
   string ret;
   string desc;
   string status;
   string *stuff;
   int member;

   if (!CLUB_HANDLER->is_club(name) ||
       CLUB_HANDLER->is_family(name)) {
      return 0;
   }

   ret = "";

   member = CLUB_HANDLER->is_member_of(name, person);
   if (CLUB_HANDLER->query_club_secret(name)) {
      if (!member) {
         ret += "This is a secret club!  Information about members is not "
                "shown to people outside the club.<p>\n";
         // Still show them the description.
         desc = CLUB_HANDLER->query_club_description(name);
         if (desc) {
            ret += "<blockquote>" + desc + "\n</blockquote>";
         }
         return ret;
      } else {
         ret += "This is a secret club!  Information about members is not "
                "shown to people outside the club.<p>\n";
      }
   }

   ret += "<h4>Information on club '" +
          CLUB_HANDLER->query_club_name(name) +
          "' with a founder of "  +
          www_finger_name(CLUB_HANDLER->query_founder(name)) + 
          " based in " +
          CLUB_HANDLER->query_club_region(name) + ".</h4>\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "<blockquote>" + desc + "\n</blockquote>";
   }
   stuff = CLUB_HANDLER->query_members(name);
   stuff = sort_array(stuff, 0);
   stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
   ret += "<dl><dt><b>The members are:</b>\n<dd>" +
          query_multiple_short(stuff) +
          "</dl>\n";
   if (!CLUB_HANDLER->is_family(name)) {
      stuff = CLUB_HANDLER->query_recruiters(name);
      stuff = sort_array(stuff, 0);
      stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
      ret += "<dl><dt><b>The recruiters are:</b>\n<dd>" +
             query_multiple_short(stuff) +
             "</dl>\n";
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      ret += "This is an elected club type.<br>\n";

      if (CLUB_HANDLER->query_club_board(name)) {
         ret += "<a href=\"boards.c?board=" +
            replace_string(CLUB_HANDLER->query_club_board_name(name), 
                           " ", "%20") +
            "\">The club board</a><p>\n";
      }

      positions = CLUB_HANDLER->query_valid_positions(name);
      ret += "<ul>\n";
      foreach (pos in positions) {
         ret += "<li>" + capitalize(pos) + ": " +
               www_finger_name(capitalize(CLUB_HANDLER->query_position_members(name,
                                                     pos))) + "\n";
      }
      ret += "</ul>";
      if (CLUB_HANDLER->is_nomination_in_progress(name) &&
          show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "<p>The player must nominate themselves to accept the "
               "nomination.  Until this point the nomination is not "
               "accepted.\n";
         if (status) {
            ret += status + "<p>\n";
         }
         ret += "<p>The club is currently accepting nominations for "
               "positions, the nomination period ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".  So far the following have been "
               "nominated:\n<dl>";

         foreach (pos in positions) {
            nominations = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(nominations)) {
               ret += "<dt>" + capitalize(pos) +
                      " has the following nominations:\n";
               foreach (nom in nominations) {
                  if (CLUB_HANDLER->is_nomination_accepted(name, pos, nom)) {
                     last = " (accepted).\n";
                  } else {
                     last = ".\n";
                  }
                  stuff = CLUB_HANDLER->query_nominators_for(name, pos, nom);
                  stuff = sort_array(stuff, 0);
                  stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
                  ret += "<dd>" +
                         www_finger_name(capitalize(nom)) + " nominated by " +
                         query_multiple_short(stuff) + 
                         last;
               }
           } else {
               ret += "No nominations for the position of " + capitalize(pos) +
                     ".\n";
           }
           ret += "</dl>";
         }
      } else if (CLUB_HANDLER->is_election_in_progress(name) &&
                 show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "<p>The club is currently electing new committee members, the "
               "vote ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".<p>";
         if (status) {
            ret += status + "<p>\n";
         }
         ret += "You can vote for:\n<ul>";
         foreach (pos in positions) {
            stuff = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(stuff)) {
               stuff = sort_array(stuff, 0);
               stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
               ret += "<li>" + capitalize(pos) + ": " +
                      query_multiple_short(stuff) +
                     ".";
               if (member) {
                  if (CLUB_HANDLER->has_person_voted(name, pos,
                                     person)) {
                     ret += " (voted)\n";
                  } else {
                     ret += " (not voted)\n";
                  }
               } else {
                  ret += "\n";
               }
            } else {
               ret += "<li>" + capitalize(pos) + ": " +
                   www_finger_name(capitalize(CLUB_HANDLER->query_position_members(name,
                                                        pos))) +
                   " elected with no opposition.\n";
            }
         }
         ret += "</ul>\n";
      }  else {
         ret += "The next election will be held at " +
                ctime(CLUB_HANDLER->query_next_election(name)) + "\n<p>";
      }
   }
   return ret;
} /* www_club_info_string() */

/**
 * This method returns the family information as a string.
 * @param name the name of the family to show the information about
 * @param show_election if non-zero show the election information
 * @param person the person who is showing the information
 * @return the family information string, 0 if no information
 * @see family_info()
 */
protected string www_family_info_string(string name,
                                        string person) {
   string ret;
   string desc;
   string per;
   //class relationship_data *wombles;
   //int i;
   //int gender;
   string *stuff;

   if (!CLUB_HANDLER->is_family(name)) {
      return 0;
   }

   ret = "";
   ret += "<h4>Information on family '" +
         CLUB_HANDLER->query_club_name(name) + "' with a founder of " +
         www_finger_name(capitalize(CLUB_HANDLER->query_founder(name))) +
         " based in " +
         CLUB_HANDLER->query_club_region(name) + ".</h4>\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "<blockquote>" + desc + "</blockquote>\n";
   }
   ret += "<dl>";
   foreach (per in CLUB_HANDLER->query_members(name)) {
      ret += "<dt>" + www_finger_name(capitalize(per));
/* + " related to:\n";
      wombles = CLUB_HANDLER->query_relationships(name,
                                                  per);
      wombles = sort_array(wombles, 
                           (: strcmp($1->related_to, $2->related_to) :));
      ret += "<dd><ul>\n";
      gender = PLAYER_HANDLER->test_gender(per);
      if (gender) {
         gender -= 1;
      }
      if (sizeof(wombles)) {
         for (i = 0; i < sizeof(wombles); i++) {
            //gender = PLAYER_HANDLER->test_gender(wombles[i]->related_to);
            //if (gender) {
               //gender -= 1;
            //}
            ret += "<li>is the " +
                   CLUB_HANDLER->query_relationship_gender(wombles[i]->relationship, gender) +
                   " of " +
                   www_finger_name(capitalize(wombles[i]->related_to)) + 
                   "\n";
         }
         ret += "\n";
      } else {
         ret += "No one!\n";
      }
      ret += "</ul>\n";
 */
   }
   ret += "</dl>";

   stuff = CLUB_HANDLER->query_members(name);
   stuff = sort_array(stuff, 0);
   stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
   ret += "<dl><dt><b>The members are:</b>\n<dd>" +
          query_multiple_short(stuff) + "</dl>\n";
   return ret;
} /* family_info_string() */
// --- END [/mnt/home2/grok/lib/std/basic/club_listing.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/expressions.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/expressions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630001   Available: 13577355
Inodes: Total: 5242880    Free: 4960136
67222 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/expressions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14630001   Available: 13577355
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is an inheritable to handle certain sorts of expressions in stuff.
 * These expression can be setup by players (or creators) and then run
 * or evaluated.  It allows controlling the types usable by the expression
 * handlers, strings, arrays, mappings, integers and floats.
 * @author Pinkfish
 * @started Thu May  4 22:44:34 PDT 2000
 */
#include <money.h>
#include <expressions.h>

#define EXPRESSION_AND       -1
#define EXPRESSION_OR        -2
#define EXPRESSION_NOT       -3
#define EXPRESSION_FALSE     -4
#define EXPRESSION_TRUE      -5
#define EXPRESSION_GREATOR_THAN     -6
#define EXPRESSION_LESS_THAN        -7
#define EXPRESSION_EQUAL_TO         -8
#define EXPRESSION_GREATOR_OR_EQUAL -9
#define EXPRESSION_LESS_OR_EQUAL    -10
#define EXPRESSION_PLUS             -11
#define EXPRESSION_MINUS            -12
#define EXPRESSION_MULTIPLY         -13
#define EXPRESSION_DIVIDE           -14
#define EXPRESSION_IF               -15
#define EXPRESSION_NOT_EQUAL_TO     -16
#define EXPRESSION_ARRAY_DEREFERENCE -17
#define EXPRESSION_ARRAY_AGGREGATE   -18
#define EXPRESSION_AND_NEW          -19
#define EXPRESSION_OR_NEW           -20
#define EXPRESSION_IF_NEW           -21

#define EXPRESSION_TREE         0
#define EXPRESSION_PARSE_STRING 1
#define EXPRESSION_TYPE         2

#define EXPRESSION_FUNC_NAME    0
#define EXPRESSION_FUNC_NO_ARGS 1

#define EXPRESSION_FUNC_VAR_NAME 0
#define EXPRESSION_FUNC_VAR_POS  1

class variable_thing {
   int type;
   function value;
}

class func_variable_thing {
   int type;
   int arg_no;
}

class function_thing {
   int type;
   function value;
   int* args;
   int return_pos; // Only used if the return type is an array.
}

class user_function_thing {
   int type;
   class parse_node* expr;
   int* arg_types;
   string* arg_names;
}

private mixed* parse_operator(string str, string token);
string query_expression_string(class parse_node* expr, int brief);
class parse_node evaluate_expression(class parse_node* expr, mixed args ...);
void add_allowed_function(string name, int type, int* args, function value);
mixed query_property(string name);
protected int is_array_type(int type);
int sizeof_function(mixed args ...);
int filter_function(mixed args ...);

private mapping _user_functions;
private nosave mapping _func_variables;
private nosave mapping _variables;
private nosave mapping _functions;
private nosave string _error_string;
private nosave string _warning_string;

void create() {
   _variables = ([ ]);
   _functions = ([ ]);
   if (!_user_functions) {
      _user_functions = ([ ]);
   }
   _func_variables = ([ ]);
   _error_string = "no error";
   add_allowed_function("sizeof", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_ARRAY }), (: sizeof_function :) );
/*  Need to do some other evil things to support this...
   add_allowed_function("filter", EXPRESSION_TYPE_OBJECT +
                                  EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_ARRAY_OFFSET + EXPRESSION_TYPE_OBJECT,
                           EXPRESSION_TYPE_BOOLEAN }), (: filter_function :) );
 */
} /* create() */

/**
 * This method returns the last error if there was an error in the parsing.
 * @return the last error
 */
string query_last_expression_error() {
   return _error_string;
} /* query_last_expression_error() */

/**
 * This method returns the last warning if there was an warning in the parsing.
 * @return the last warning
 */
string query_last_expression_warning() {
   return _warning_string;
} /* query_last_expression_warning() */

/**
 * This method adds in an allowed variable and specifies it's type.
 * @param name the name of the variable
 * @param type the type of the variable
 * @param value the value of the variable
 */
void add_allowed_variable(string name, int type, function value) {
   class variable_thing bing;

   bing = new(class variable_thing);
   bing->type = type;
   bing->value = value;
   _variables[name] = bing;
} /* add_allowed_variable() */

/**
 * This method adds in an allowed function and specifies the types it
 * takes.
 * @param name the name of the function
 * @param type the return type of the function
 * @param args the types of the arguements (an array)
 * @param value the function to call to get the value
 */
void add_allowed_function(string name, int type, int* args, function value) {
   class function_thing bing;

   bing = new(class function_thing);
   bing->type = type;
   bing->args = args;
   bing->value = value;
   _functions[name] = bing;
} /* add_allowed_function() */

/**
 * This method returns the type of the function variable.
 * @param name the name of the function variable to check
 * @return the type of the variable, EXPRESSION_TYPE_ERROR if there is no
 * variable
 */
int query_function_variable_type(string name) {
   if (_func_variables[name]) {
      return ((class func_variable_thing)_func_variables[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
} /* query_function_variable_type() */

/**
 * This method returns the position of the function variable.
 * @param name the name of the function variable to check
 * @return the type of the variable, EXPRESSION_TYPE_ERROR if there is no
 * variable
 */
int query_function_variable_position(string name) {
   if (_func_variables[name]) {
      return ((class func_variable_thing)_func_variables[name])->arg_no;
   }
   return EXPRESSION_TYPE_ERROR;
} /* query_function_variable_position() */

/**
 * This method returns the names of all the variables.
 * @return all the variable names
 */
string *query_variable_names() {
   return keys(_variables);
} /* query_variable_type() */

/**
 * This method returns the type of the variable.
 * @param name the name of the variable to check
 * @return the type of the variable, EXPRESSION_TYPE_ERROR if there is no
 * variable
 */
int query_variable_type(string name) {
   if (_variables[name]) {
      return ((class variable_thing)_variables[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
} /* query_variable_type() */

/**
 * This method returns the value of the variable.
 * @param name the name of the variable to find
 * @return the value of the variable, 0 if not found
 */
function query_variable_value(string name) {
   if (_variables[name]) {
      return ((class variable_thing)_variables[name])->value;
   }
   return 0;
} /* query_variable_value() */

/**
 * This method returns all the function names defined in this expression
 * inheritable.
 * @return the function names
 */
string* query_function_names() {
   return keys(_functions);
} /* query_function_names() */

/**
 * This method returns the type of the function.
 * @param name the name of the function to check
 * @return the args of the function, null array is not found
 */
int* query_function_args_types(string name) {
   if (_functions[name]) {
      return ((class function_thing)_functions[name])->args;
   }
   return ({ });
} /* query_function_args_types() */

/**
 * This method returns the type of the function.
 * @param name the name of the function to check
 * @return the type of the function, EXPRESSION_TYPE_ERROR if there is no
 * function
 */
int query_function_type(string name) {
   if (_functions[name]) {
      return ((class function_thing)_functions[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
} /* query_function_type() */

/**
 * This method returns the value of the function.
 * @param name the name of the function to find
 * @return the value of the function, 0 if not found
 */
function query_function_value(string name) {
   if (_functions[name]) {
      return ((class function_thing)_functions[name])->value;
   }
   return 0;
} /* query_function_value() */

/**
 * This method returns the list of user defined functions in the
 * inheritable.
 * @return the list of user defined functions
 */
string* query_user_function_names() {
   return keys(_user_functions);
} /* query_user_function_names() */

/**
 * This method returns the argument names types of the user defined
 * function. 
 * @param name the name of the function to lookup
 * @return information on the arguments, 0 on failure
 */
mixed* query_user_function_arg_types(string name) {
   if (_user_functions[name]) {
      return _user_functions[name]->arg_types;
   }
   return 0;
} /* query_user_function_arg_types() */

/**
 * This method returns the argument names names of the user defined
 * function. 
 * @param name the name of the function to lookup
 * @return information on the arguments, 0 on failure
 */
mixed* query_user_function_arg_names(string name) {
   if (_user_functions[name]) {
      return _user_functions[name]->arg_names;
   }
   return 0;
} /* query_user_function_arg_names() */

/**
 * This method returns the argument names and types of the user defined
 * function.  It returns an array of two elements, the first is an
 * array of names and the second is an array of types.
 * @param args the arguments to return
 * @return information on the arguments, 0 on failure
 */
mixed* query_user_function_args(string name) {
   if (_user_functions[name]) {
      return ({ _user_functions[name]->arg_names,
                _user_functions[name]->arg_types });
   }
   return 0;
} /* query_user_function_args() */

/**
 * This method returns the return type of the user defined function.
 * @return the return type, EXPRESSION_TYPE_ERROR on error
 */
int query_user_function_return_type(string name) {
   if (_user_functions[name]) {
      return ((class user_function_thing)_user_functions[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
} /* query_user_function_return_type() */

/**
 * This method returns the expression of the user defined function.
 * @param name the name of the function to look up
 * @return the expression of the user defined function
 */
class parse_node* query_user_function_expression(string name) {
   if (_user_functions[name]) {
      return _user_functions[name]->expr;
   }
   return 0;
} /* query_user_function_expression() */

/**
 * This method removes the currently defined user expression.
 * @param name the expression to remove
 */
int remove_user_expression(string name) {
   if (_user_functions[name]) {
      map_delete(_user_functions, name);
      return 1;
   }
   return 0;
} /* remove_user_expression() */

/**
 * This method returns the value of the type.
 * @param type the type to get the integer value of
 * @return the integer value of the type
 */
int query_type_value(string type) {
   switch (lower_case(type)) {
   case "integer" :
   case "int"     :
      return EXPRESSION_TYPE_INTEGER;
   case "string"  :
      return EXPRESSION_TYPE_STRING;
   case "float"   :
      return EXPRESSION_TYPE_FLOAT;
   case "boolean" :
   case "bool"    :
      return EXPRESSION_TYPE_BOOLEAN;
   case "money" :
      return EXPRESSION_TYPE_MONEY;
   case "object" :
      return EXPRESSION_TYPE_OBJECT;
   case "array" :
      return EXPRESSION_TYPE_ARRAY;
   default :
      return EXPRESSION_TYPE_ERROR;
   }
} /* query_type_value() */

/**
 * This method returns the name of the type.
 * @param type the type to get the string name of
 * @return the string name of the type
 */
string query_type_name(int type) {
   if (is_array_type(type)) {
      return "array " + query_type_name(type - EXPRESSION_TYPE_ARRAY_OFFSET);
   }
   switch (type) {
   case EXPRESSION_TYPE_INTEGER  :
      return "integer";
   case EXPRESSION_TYPE_STRING   :
      return "string";
   case EXPRESSION_TYPE_ARRAY    :
      return "array";
   case EXPRESSION_TYPE_ARRAY_NULL :
      return "array null";
   case EXPRESSION_TYPE_MAPPING  :
      return "mapping";
   case EXPRESSION_TYPE_FLOAT    :
      return "float";
   case EXPRESSION_TYPE_BOOLEAN  :
      return "boolean";
   case EXPRESSION_TYPE_MONEY  :
      return "money";
   case EXPRESSION_TYPE_OBJECT :
      return "object";
   default :
      return "error";
   }
} /* query_type_name() */

/**
 * This method returns the string value of the operator name.
 * @param operator the operator name to return
 * @return the string name of the operator
 */
string query_operator_name(int operator) {
   switch (operator) {
   case EXPRESSION_AND_NEW   :
   case EXPRESSION_AND       :
      return "and";
   case EXPRESSION_OR_NEW    :
   case EXPRESSION_OR        :
      return "or";
   case EXPRESSION_NOT       :
      return "not";
   case EXPRESSION_FALSE     :
      return "false";
   case EXPRESSION_TRUE      :
      return "true";
   case EXPRESSION_GREATOR_THAN     :
      return ">";
   case EXPRESSION_LESS_THAN        :
      return "<";
   case EXPRESSION_EQUAL_TO         :
      return "=";
   case EXPRESSION_NOT_EQUAL_TO         :
      return "<>";
   case EXPRESSION_GREATOR_OR_EQUAL :
      return ">=";
   case EXPRESSION_LESS_OR_EQUAL    :
      return "<=";
   case EXPRESSION_PLUS             :
      return "+";
   case EXPRESSION_MINUS            :
      return "-";
   case EXPRESSION_MULTIPLY         :
      return "*";
   case EXPRESSION_DIVIDE           :
      return "/";
   case EXPRESSION_IF               :
      return "if";
   default :
      return "unknown";
   }
} /* query_operator_name() */

private class parse_node make_node(int type, mixed value, int* tree) {
   class parse_node bing;

   bing = new(class parse_node);
   bing->type = type;
   bing->value = value;
   bing->tree = tree;
   return bing;
} /* make_parse_node() */

/**
 * This method returns a null object of the specified type.
 * @param type the type to get the null object of
 * @return the null object
 */
class parse_node query_null_type(int type) {
   if (is_array_type(type)) {
      return make_node(type, ({ }), ({ }));
   }
   switch (type) {
   case EXPRESSION_TYPE_INTEGER  :
      return make_node(type, 0, ({ }));
   case EXPRESSION_TYPE_MONEY  :
      return make_node(type, 0, ({ }));
   case EXPRESSION_TYPE_STRING   :
      return make_node(type, "", ({ }));
   case EXPRESSION_TYPE_ARRAY    :
   case EXPRESSION_TYPE_ARRAY_NULL  :
      return make_node(type, ({ }), ({ }));
   case EXPRESSION_TYPE_MAPPING  :
      return make_node(type, ([ ]), ({ }));
   case EXPRESSION_TYPE_FLOAT    :
      return make_node(type, 0.0, ({ }));
   case EXPRESSION_TYPE_BOOLEAN  :
      return make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_FALSE, ({ }));
   case EXPRESSION_TYPE_OBJECT :
      return make_node(type, 0, ({ }));
   default :
      return 0;
   }
} /* query_null_type() */

/**
 * This method checks to see if the passed in character is an alpha
 * or not.
 * @param alpha the character to check
 * @return 1 if it alpha, 0 if not
 */
protected int is_alpha(int alpha) {
   if ((alpha >= 'a' && alpha <= 'z') ||
       (alpha >= 'A' && alpha <= 'Z')) {
      return 1;
   }
   return 0;
} /* isalpha() */

/**
 * This method checks to see if the passed in character is a number
 * or not.
 * @param number the character to check
 * @return 1 if it is a number, 0 if not
 */
protected int is_number(int number) {
   if (number >= '0' && number <= '9') {
      return 1;
   }
   return 0;
} /* is_number() */

/**
 * This method checks to see if the passed in character is a space or
 * a space equivilant.
 * @param space the character to check
 * @return 1 if it is a space, 0 if not
 */
protected int is_space(int space) {
   if (space == ' ' || space == '\t') {
      return 1;
   }
   return 0;
} /* is_space() */

/**
 * This checks to make sure that the type is a number based type.
 * This can be controlled to make sure that any added types are also
 * allowed to be treated as numbers.
 * @param type the type to check
 * @return 1 if it is a number, 0 if not
 */
protected int is_number_type(int type) {
   return type == EXPRESSION_TYPE_INTEGER ||
          type == EXPRESSION_TYPE_FLOAT ||
          type == EXPRESSION_TYPE_MONEY;
} /* is_number_type() */

/**
 * This checks to make sure that the type is an array.
 * @param type the type to check
 * @return 1 if it is an array, 0 if not
 */
protected int is_array_type(int type) {
   return type == EXPRESSION_TYPE_ARRAY ||
          type == EXPRESSION_TYPE_ARRAY_NULL ||
          type >= EXPRESSION_TYPE_ARRAY_OFFSET;
} /* is_number_type() */

/**
 * This checks to make sure that the type is a null array.
 * @param type the type to check
 * @return 1 if it is a null array, 0 if not
 */
protected int is_null_array_type(int type) {
   return type == EXPRESSION_TYPE_ARRAY_NULL;
} /* is_number_type() */

private int is_valid_variable_name(int type) {
   return type == '_' ||
          is_alpha(type) ||
          is_number(type);
} /* is_valid_variable_name() */

/**
 * This method find the next token.  It can be overrideen in higher things
 * to deal with special token types (ie: money).
 * @param str the input string
 * @return ({ token, rest })
 */
protected string* query_token(string str) {
   int i = 0;
   int j;

   while (strlen(str) > 1 && is_space(str[0])) {
      str = str[1..];
   }

   if (!strlen(str)) {
      return ({ "", str });
   }

   //
   // parse money as money...  Make them enclose money inside two $'s.
   // ie: $4 dollars$
   //
   if (str[0] == '$') {
      i = 1;
      while (strlen(str) > i &&
             (str[i] != '$')) {
             
         i++;
      }
      return ({ str[0..i], str[i+1..] });
   }

   if (str[0] == '-' || is_number(str[0])) {
      i = 0;
      while (strlen(str) > i + 1 &&
             is_number(str[i + 1])) {
         i++;
      }

      return ({ str[0..i], str[i+1..] });
   }

   if (is_alpha(str[0]) || str[0] == '_') {
      //
      // Zip through till we find a non-alpha, non-number.
      //
      while (strlen(str) > i + 1 &&
             is_valid_variable_name(str[i + 1])) {
         i++;
      }
      return ({ str[0..i], str[i+1..] });
   }

   if (str[0] == '"') {
      do {
         j = strsrch(str[i + 1..], "\"");
         if (j == -1) {
            _error_string = "Missing close \"\n";
            return 0;
         }
         i += j + 1;
      } while (str[i - 1] == '\\');
      return ({ str[0..i], str[i+1..] });
   }

   if (str[0] == '\'') {
      do {
         j = strsrch(str[i + 1..], "'");
         if (j == -1) {
            _error_string = "Missing close '\n";
            return 0;
         }
         i += j + 1;
      } while (str[i - 1] == '\\');
      return ({ str[0..i], str[i+1..] });
   }

   if (str[0] == '>' ||
       str[0] == '<') {
      if (strlen(str) > 1 &&
          str[1] == '=') {
         return ({ str[0..1], str[2..] });
      }
      return ({ str[0..0], str[1..] });
   }

   while (strlen(str) > i + 1 &&
          !is_alpha(str[i + 1]) &&
          !is_number(str[i + 1]) && 
          !is_space(str[i + 1]) &&
          member_array(str[i + 1], ({ '>', '<', '=', '!', '-', '$', '\'',
                                      '"', '_', '(', ')', '{', '}', ',' })) == -1)
   {
      i++;
   }

   if (i) {
      return ({ str[0..i], str[i+1..] });
   }

   return ({ str[0..0], str[1..] });
} /* query_token() */

private mixed* parse_node(string str, string token) {
   class parse_node num;
   int type;
   int bing;
   int pos;
   string place;
   string fname;
   string* token_ret;
   mixed *stuff;
   mixed *args;

   while (strlen(str) &&
          str[0] == ' ') {
      str = str[1..];
   }

   if (_functions[token]) {
      fname = token;
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != "(") {
         _error_string = "Expected (, got " + token_ret[0] + " rest: " +
                     token_ret[1];
         return 0;
      }
      str = token_ret[1];

      //
      // Get all the args...
      //
      args = ({ });
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != ")") {
         pos = 0;
         do {
            stuff = parse_operator(token_ret[1], token_ret[0]);
            if (!stuff) {
               return 0;
            }
            pos++;
            if (sizeof(_functions[fname]->args) < pos) {
               _error_string = "To many arguments to " + token + " expected " +
                              sizeof(_functions[fname]->args) + " got " +
                              pos;
               return 0;
            }
            //
            // We allow array to be a type to an internal function.
            // This means it works on all arrays.
            //
            if (_functions[fname]->args[pos - 1] != stuff[EXPRESSION_TYPE] &&
                !(_functions[fname]->args[pos - 1] == EXPRESSION_TYPE_ARRAY &&
                  is_array_type(stuff[EXPRESSION_TYPE])) &&
                !(is_array_type(stuff[EXPRESSION_TYPE]) &&
                  is_null_array_type(stuff[EXPRESSION_TYPE]))) {
               _error_string = "Expected arg " + pos + " to be " +
                        query_type_name(_functions[fname]->args[pos - 1]) +
                        " not " + query_type_name(stuff[EXPRESSION_TYPE]);
               return 0;
            }
            str = stuff[EXPRESSION_PARSE_STRING];
            args += stuff[EXPRESSION_TREE];
            token_ret = query_token(str);
            if (!token_ret) {
               return 0;
            }
            if (token_ret[0] == ",") {
               token_ret = query_token(token_ret[1]);
            }
         } while (token_ret[0] != ")");
         if (token_ret[0] != ")") {
            _error_string = "Expected ')' got " + token_ret[0];
            return 0;
         }
         if (pos != sizeof(_functions[fname]->args)) {
            _error_string = "To few arguments to " + token + " expected " +
                           sizeof(_functions[fname]->args);
            return 0;
         }
         // Jumps are pointless for functions.  We cannot skip anything anyway.
         return ({ args +
                  ({ make_node(EXPRESSION_TYPE_FUNCTION,
                               ({ fname, pos }), ({ })) }),
                  token_ret[1],
                  ((class function_thing)_functions[fname])->type });
      }
   } else if (_user_functions[token]) {
      fname = token;
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != "(") {
         _error_string = "Expected (, got " + token_ret[0] + " rest: " +
                     token_ret[1];
         return 0;
      }
      str = token_ret[1];

      //
      // Get all the args...
      //
      args = ({ });
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != ")") {
         do {
            stuff = parse_operator(token_ret[1], token_ret[0]);
            if (!stuff) {
               return 0;
            }
            pos = sizeof(args);
            if (sizeof(_user_functions[fname]->arg_types) <= pos) {
               _error_string = "To many arguments to " + token + " expected " +
                              sizeof(_user_functions[fname]->arg_types);
               return 0;
            }
            // Allow null arrays to pass as any array type.
            if (_user_functions[fname]->arg_types[pos] != stuff[EXPRESSION_TYPE] &&
                !(is_array_type(stuff[EXPRESSION_TYPE]) &&
                  is_null_array_type(stuff[EXPRESSION_TYPE]))) {
               _error_string = "Expected arg " + (pos + 1) + " to be " +
                        query_type_name(_user_functions[fname]->arg_types[pos]) +
                        " not " + query_type_name(stuff[EXPRESSION_TYPE]);
               return 0;
            }
            str = stuff[EXPRESSION_PARSE_STRING];
            args += stuff[EXPRESSION_TREE];
            token_ret = query_token(str);
            if (!token_ret) {
               return 0;
            }
            if (token_ret[0] != "," && token_ret[0] != ")") {
               _error_string = "Expected ')' or ',' got " + token_ret[0];
               return 0;
            }
            if (token_ret[0] == ",") {
               token_ret = query_token(token_ret[1]);
            }
         } while (token_ret[0] != ")");
         if (token_ret[0] != ")") {
            _error_string = "Expected ')' got " + token_ret[0];
            return 0;
         }
         if (sizeof(args) < sizeof(_user_functions[fname]->arg_types)) {
            _error_string = "To few arguments to " + token + " expected " +
                           sizeof(_user_functions[fname]->arg_types);
            return 0;
         }
         return ({ args +
                  ({ make_node(EXPRESSION_TYPE_USER_FUNCTION,
                               ({ fname, sizeof(args) }), ({ })) }),
                  token_ret[1],
                  ((class user_function_thing)_user_functions[fname])->type });
      }
   } else switch (token) {
   case "true" :
      num = make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_TRUE, ({ }));
      type = EXPRESSION_TYPE_BOOLEAN;
      break;
   case "false" :
      num = make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_FALSE, ({ }));
      type = EXPRESSION_TYPE_BOOLEAN;
      break;
   case "{" :
      // Array aggregation.
      token_ret = query_token(str);
      args = ({ });
      type = EXPRESSION_TYPE_ARRAY;
      pos = 0;
      while (token_ret[0] != "}") {
         stuff = parse_operator(token_ret[1], token_ret[0]);
         if (!stuff) {
            return 0;
         }
         if (sizeof(args)) {
            if (type != stuff[EXPRESSION_TYPE]) {
               _error_string = "Arrays must be of only one type.  " +
                      query_type_name(type) + " and " +
                      query_type_name(stuff[EXPRESSION_TYPE]) +
                      " do not match.";
               return 0;
            }
         } else {
            type = stuff[EXPRESSION_TYPE];
            if (is_array_type(type)) {
               _error_string = "Cannot have nested arrays.";
               return 0;
            }
         }
         str = stuff[EXPRESSION_PARSE_STRING];
         args += stuff[EXPRESSION_TREE];
         token_ret = query_token(str);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] != "," && token_ret[0] != "}") {
            _error_string = "Expected ')' or ',' got " + token_ret[0];
            return 0;
         }
         if (token_ret[0] == ",") {
            token_ret = query_token(token_ret[1]);
         }
         pos++;
      }

      //token_ret = query_token(token_ret[1]);
      if (type != EXPRESSION_TYPE_ARRAY) {
         type += EXPRESSION_TYPE_ARRAY_OFFSET;
         return ({ args +
                  ({ make_node(EXPRESSION_TYPE_INTEGER, pos, ({ })),
                     make_node(EXPRESSION_TYPE_OPERATOR,
                               EXPRESSION_ARRAY_AGGREGATE, ({ })) }),
                  token_ret[1],
                  type });
      } else {
         type = EXPRESSION_TYPE_ARRAY_NULL;
         num = make_node(EXPRESSION_TYPE_ARRAY_NULL, 0, ({ }));
         str = token_ret[1];
      }
      break;
   case "" :
      _error_string = "No token found at: " + token + " " + str;
      return 0;
   default :
      if (token[0] == '-' || is_number(token[0])) {
         sscanf(token, "%d", bing);
         num = make_node(EXPRESSION_TYPE_INTEGER, bing, ({ }));
         type = EXPRESSION_TYPE_INTEGER;
      } else if (token == "$0$") {
         num = make_node(EXPRESSION_TYPE_MONEY, 0, ({ }));
         type = EXPRESSION_TYPE_MONEY;
      } else if (token[0] == '$') {
         place = query_property("place");
         if (!place) {
            place = "default";
         }
         bing = MONEY_HAND->value_from_string(token[1..<2], place);
         if (!bing) {
            bing = MONEY_HAND->value_from_string(token[0..<2], place);
         }
         if (bing) {
            num = make_node(EXPRESSION_TYPE_MONEY, bing, ({ }));
            type = EXPRESSION_TYPE_MONEY;
         } else {
            _error_string = "Money value is invalid: " + token[1..<2] + " and " +
                            token[0..<2];
            return 0;
         }
      } else if (token[0] == '\"' || token[0] == '\'') {
         num = make_node(EXPRESSION_TYPE_STRING, token[1..<2], ({ }));
         type = EXPRESSION_TYPE_STRING;
      } else {
         type = query_variable_type(token);
         if (type == EXPRESSION_TYPE_ERROR) {
            type = query_function_variable_type(token);
            if (type == EXPRESSION_TYPE_ERROR) {
               _error_string = "No variable called '" + token + "' rest: '" +
                               str;
               return 0;
            }
            pos = query_function_variable_position(token);
            num = make_node(EXPRESSION_TYPE_FUNCTION_VARIABLE,
                            ({ token, pos }), ({ }));
         } else {
            num = make_node(EXPRESSION_TYPE_VARIABLE, token, ({ }));
         }
      }
      break;
   }
   return ({ ({ num }), str, type });
} /* parse_node() */

private mixed* parse_bracket(string str, string token) {
   mixed* stuff;
   string* token_ret;
   mixed* ret;

   switch (token) {
   case "(" :
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      stuff = parse_operator(token_ret[1], token_ret[0]);
      if (stuff) {
         str = stuff[EXPRESSION_PARSE_STRING];
         token_ret = query_token(str);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] !=  ")") {
            _error_string = "Could not find closing bracket at " + str;
            return 0;
         }
         str = token_ret[1];
         ret = ({ stuff[EXPRESSION_TREE], str,
                  stuff[EXPRESSION_TYPE] });
      } else {
         return 0;
      }
      break;
   default :
      stuff = parse_node(str, token);
      if (stuff) {
         ret = ({ stuff[EXPRESSION_TREE],
                   stuff[EXPRESSION_PARSE_STRING],
                   stuff[EXPRESSION_TYPE] });
      } else {
         return 0;
      }
      break;
   }

   //
   // Check for a array de-reference.
   //
   str = ret[EXPRESSION_PARSE_STRING];
   token_ret = query_token(str);
   if (token_ret && token_ret[0] == "[") {
      mixed *stuffy;

      if (!is_array_type(ret[EXPRESSION_TYPE])) {
         _error_string = "Cannot de-reference " +
                         query_type_name(stuff[EXPRESSION_TYPE]);
         return 0;
      }
      if (is_null_array_type(ret[EXPRESSION_TYPE])) {
         _error_string = "Cannot de-reference a null array, it has no "
                         "members!";
         return 0;
      }
      //
      // Get the index.
      //
      token_ret = query_token(token_ret[1]);
      stuffy = parse_operator(token_ret[1], token_ret[0]);
      if (!stuffy) {
         return 0;
      }
      if (stuffy[EXPRESSION_TYPE] != EXPRESSION_TYPE_INTEGER) {
         _error_string = "Can only dereference an array with an integer "
                         "not a " +
                         query_type_name(stuff[EXPRESSION_TYPE]);
         return 0;
      }
      str = stuffy[EXPRESSION_PARSE_STRING];
      token_ret = query_token(str);
      if (token_ret[0] != "]") {
         _error_string = "Could not find closing square bracket at " + str;
         return 0;
      }
      return ({ ret[EXPRESSION_TREE] + stuffy[EXPRESSION_TREE] +
             ({ make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_ARRAY_DEREFERENCE, ({ })) }),
                token_ret[1],
                ret[EXPRESSION_TYPE] - EXPRESSION_TYPE_ARRAY_OFFSET });
   }
   return ret;
} /* parse_bracket() */

private mixed* parse_plus(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   int type;
   string* token_ret;
   string blue;

   stuff = parse_bracket(str, token);
   if (!stuff) {
      return 0;
   }

   str = stuff[EXPRESSION_PARSE_STRING];

   token_ret = query_token(str);
   if (!token_ret) {
      return 0;
   }
 
   switch (token_ret[0]) {
   case "+" :
      type = EXPRESSION_PLUS;
      break;
   case "-" :
      type = EXPRESSION_MINUS;
      break;
   }
   blue = token_ret[0];
   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_plus(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if ((!is_number_type(stuff[EXPRESSION_TYPE]) ||
           !is_number_type(stuff2[EXPRESSION_TYPE])) &&
          type != EXPRESSION_PLUS) {
         _error_string = "Invalid types to " + blue +
                     " expected number got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] + stuff2[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, type, ({ })) }),
                stuff2[EXPRESSION_PARSE_STRING], stuff[EXPRESSION_TYPE] });
   } else {
      return stuff;
   }
} /* parse_plus() */

private mixed* parse_multiply(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   string* token_ret;
   int type;
   string blue;

   stuff = parse_plus(str, token);
   if (!stuff) {
      return 0;
   }

   str = stuff[EXPRESSION_PARSE_STRING];

   token_ret = query_token(str);   
   if (!token_ret) {
      return 0;
   }

   switch (token_ret[0]) {
   case "*" :
      type = EXPRESSION_MULTIPLY;
      break;
   case "/" :
      type = EXPRESSION_DIVIDE;
      break;
   }
   blue = token_ret[0];
   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_multiply(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if (!is_number_type(stuff[EXPRESSION_TYPE]) ||
           !is_number_type(stuff2[EXPRESSION_TYPE])) {
         _error_string = "Invalid types to " + blue +
                     " expected number got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] + stuff2[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, type, ({ })) }),
                stuff2[EXPRESSION_PARSE_STRING], stuff[EXPRESSION_TYPE] });
   } else {
      return stuff;
   }
} /* parse_multiply() */

private mixed* parse_compare(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   string* token_ret;
   int type;
   string blue;

   stuff = parse_multiply(str, token);
   if (!stuff) {
      return 0;
   }

   str = stuff[EXPRESSION_PARSE_STRING];

   token_ret = query_token(str);   
   if (!token_ret) {
      return 0;
   }

   switch (token_ret[0]) {
   case ">=" :
      type = EXPRESSION_GREATOR_OR_EQUAL;
      break;
   case "<=" :
      type = EXPRESSION_LESS_OR_EQUAL;
      break;
   case ">" :
      type = EXPRESSION_GREATOR_THAN;
      break;
   case "<" :
      type = EXPRESSION_LESS_THAN;
      break;
   case "<>" :
   case "!=" :
      type = EXPRESSION_NOT_EQUAL_TO;
      break;
   case "==" :
   case "=" :
      type = EXPRESSION_EQUAL_TO;
      break;
   }
   blue = token_ret[0];
   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_compare(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if ((!is_number_type(stuff[EXPRESSION_TYPE]) ||
           !is_number_type(stuff2[EXPRESSION_TYPE])) &&
          type != EXPRESSION_EQUAL_TO &&
          type != EXPRESSION_NOT_EQUAL_TO)
      {
         _error_string = "Invalid types to " + blue +
                     " expected number got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] + stuff2[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, type, ({ })) }),
                stuff2[EXPRESSION_PARSE_STRING],
                EXPRESSION_TYPE_BOOLEAN });
   } else {
      return stuff;
   }
} /* parse_compare() */

private mixed* parse_not(string str, string token) {
   mixed *stuff;

   if (token == "not") {
      stuff = query_token(str);
      if (!stuff) {
         return 0;
      }
      stuff = parse_not(stuff[1], stuff[0]);
      if (!stuff) {
         return 0;
      }
      if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
         _error_string = "Invalid type to not expected boolean got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_NOT, ({ }))  }),
                stuff[EXPRESSION_PARSE_STRING],
                EXPRESSION_TYPE_BOOLEAN });
   } else {
      return parse_compare(str, token);
   }
} /* parse_not() */

private mixed* parse_boolean(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   string* token_ret;
   string blue;
   int type;

   stuff = parse_not(str, token);
   if (!stuff) {
      return 0;
   }

   str = stuff[EXPRESSION_PARSE_STRING];

   token_ret = query_token(str);
   if (!token_ret) {
      return 0;
   }
   switch (token_ret[0]) {
   case "and" :
      type = EXPRESSION_AND_NEW;
      break;
   case "or" :
      type = EXPRESSION_OR_NEW;
      break;
   }

   blue = token_ret[0];

   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_boolean(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if (stuff[EXPRESSION_TYPE] != stuff2[EXPRESSION_TYPE] ||
          stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
         _error_string = "Invalid types to " + blue +
                     " expected boolean got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ ({ make_node(EXPRESSION_TYPE_OPERATOR, type,
                     ({ stuff[EXPRESSION_TREE], stuff2[EXPRESSION_TREE] }) ) }),
                stuff2[EXPRESSION_PARSE_STRING],
                stuff2[EXPRESSION_TYPE] });
   } else {
      return stuff;
   }
} /* parse_boolean() */

private mixed* parse_operator(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   mixed *stuff3;
   string* token_ret;

      switch (token) {
      case "if" :
         token_ret = query_token(str);
         if (!token_ret) {
            return 0;
         }
         stuff = parse_operator(token_ret[1], token_ret[0]);
         if (!stuff) {
            return 0;
         }

         if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
            _error_string = "Invalid type to if expected boolean got: " +
                        query_type_name(stuff[EXPRESSION_TYPE]);
            return 0;
         }
         token_ret = query_token(stuff[EXPRESSION_PARSE_STRING]);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] != "then") {
            _error_string = "Expected 'then' got " + token_ret[0];
            return 0;
         }

         token_ret = query_token(token_ret[1]);
         if (!token_ret) {
            return 0;
         }
         stuff2 = parse_operator(token_ret[1], token_ret[0]);
         if (!stuff2) {
            return 0;
         }
         token_ret = query_token(stuff2[EXPRESSION_PARSE_STRING]);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] == "else") {
            token_ret = query_token(token_ret[1]);
            if (!token_ret) {
               return 0;
            }
            stuff3 = parse_operator(token_ret[1], token_ret[0]);
            if (!stuff3) {
               return 0;
            }
            if (stuff2[EXPRESSION_TYPE] != stuff3[EXPRESSION_TYPE]) {
               // The types are equivilant if one of them is null.
               if (is_array_type(stuff2[EXPRESSION_TYPE]) &&
                   is_array_type(stuff3[EXPRESSION_TYPE]) &&
                   (is_null_array_type(stuff2[EXPRESSION_TYPE]) ||
                    is_null_array_type(stuff3[EXPRESSION_TYPE]))) {
                  //
                  // Move it in here to fix up the type stuff in the
                  // return information.
                  //
                  if (is_null_array_type(stuff2[EXPRESSION_TYPE])) {
                     stuff2[EXPRESSION_TYPE] = stuff3[EXPRESSION_TYPE];
                  }
               } else {
                  _error_string = "Types on both sides of an if must match: " +
                           query_type_name(stuff2[EXPRESSION_TYPE]) + " and " +
                           query_type_name(stuff3[EXPRESSION_TYPE]);
                  return 0;
               }
            }
            token_ret = query_token(stuff3[EXPRESSION_PARSE_STRING]);
            if (!token_ret) {
               return 0;
            }
         } else {
            stuff3 = ({ ({ query_null_type(stuff2[EXPRESSION_TYPE]) }) });
         }
         if (token_ret[0] != "endif") {
            _error_string = "Expected 'endif' got " + token_ret[0] + " (" +
                            token_ret[1];
            return 0;
         }
         // We always evaluate the expression, so leave that on the stack.
         return ({ stuff[EXPRESSION_TREE] +
                   ({ make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_IF_NEW,
                                ({ 
                                    stuff2[EXPRESSION_TREE],
                                    stuff3[EXPRESSION_TREE]
                                   }) ) }),
                   token_ret[1],
                   stuff2[EXPRESSION_TYPE] });
         break;
      default :
         stuff = parse_boolean(str, token);
         if (!stuff) {
            return 0;
         }
         return stuff;
      }
} /* parse_operator() */

/**
 * A very small recursive decent parser which must return a boolean
 * value.
 * @param str the input string
 * @return the array control structure
 */
class parse_node* parse_boolean_string(string str) {
   mixed* stuff;
   string* token_ret;

   _warning_string = "";
   _func_variables = ([ ]);
   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);

   if (!stuff) {
      return ({ });
   }

   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
      return ({ });
   }

   if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
      _error_string = "Invalid return type, expected boolean got " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
      return ({ });
   }

   return stuff[EXPRESSION_TREE];
} /* parse_boolean_string() */

/**
 * A very small recursive decent parser which must return a integer
 * value.
 * @param str the input string
 * @return the array control structure
 */
class parse_node* parse_integer_string(string str) {
   mixed* stuff;
   string* token_ret;

   _warning_string = "";
   _func_variables = ([ ]);
   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);


   if (!stuff) {
     //printf("%O", _error_string);
      return ({ });
   }

   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
     //printf("%O", _error_string);
      return ({ });
   }

   if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_INTEGER) {
      _error_string = "Invalid return type, expected integer got " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
//printf("%O", query_expression_string(stuff[EXPRESSION_TREE], 0));
//printf("%O", evaluate_expression(stuff[EXPRESSION_TREE]));
      return ({ });
   }

//printf("%O", query_expression_string(stuff[EXPRESSION_TREE], 0));
//printf("%O", evaluate_expression(stuff[EXPRESSION_TREE]));

   return stuff[EXPRESSION_TREE];
} /* parse_integer_string() */

/**
 * A very small recursive decent parser which must return a money
 * value.
 * @param str the input string
 * @return the array control structure
 */
class parse_node* parse_money_string(string str) {
   mixed* stuff;
   string* token_ret;

   _warning_string = "";
   _func_variables = ([ ]);
   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);


   if (!stuff) {
     //printf("%O", _error_string);
      return ({ });
   }

   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
     //printf("%O", _error_string);
      return ({ });
   }

   if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_MONEY) {
      _error_string = "Invalid return type, expected money got " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
//printf("%O", query_expression_string(stuff[EXPRESSION_TREE], 0));
//printf("%O", evaluate_expression(stuff[EXPRESSION_TREE]));
      return ({ });
   }

//printf("%O", stuff[EXPRESSION_TREE]);
//printf("%O", query_expression_string(stuff[EXPRESSION_TREE], 0));
//printf("%O", evaluate_expression(stuff[EXPRESSION_TREE]));

   return stuff[EXPRESSION_TREE];
} /* parse_integer_string() */

/**
 * This will pass the arguments to a user defined function and return
 * an array of three elements.  The first is the name of the function,
 * the second is the array of arguments types and the third is the array of
 * argument names.
 */
mixed* parse_user_expression_definition(string def) {
   mixed* token;
   string name;
   int* arg_types;
   int type;
   string* arg_names;

   token = query_token(def);
   name = token[0];
   def = token[1];
   if (!strlen(def)) {
      //
      // No arguments.
      //
      return ({ name, ({ }), ({ }) });
   }

   token = query_token(def);
   if (token[0] == "(") {
      //
      // Parse some arguments.
      //
      token = query_token(token[1]);
      arg_names = ({ });
      arg_types = ({ });
      while (token[0] != ")") {
         type = query_type_value(token[0]);
         if (type == EXPRESSION_TYPE_ARRAY) {
            // Try the next token for the type.
            token = query_token(token[1]);
            type = query_type_value(token[0]);
            if (type != EXPRESSION_TYPE_ERROR) {
               type += EXPRESSION_TYPE_ARRAY_OFFSET;
            }
         }

         if (type == EXPRESSION_TYPE_ERROR) {
            _error_string = "Invalid type " + token[0];
            return 0;
         } else {
            token = query_token(token[1]);
            if (member_array(token[0], arg_names) != -1) {
               _error_string = "Duplicate argument name " + token[0];
               return 0;
            }
            arg_types += ({ type });
            arg_names += ({ token[0] });
            token = query_token(token[1]);
            if (token[0] != "," && token[0] != ")") {
               _error_string = "Expected , or ) after " + arg_names[<1];
               return 0;
            }
            if (token[0] == ",") {
               token = query_token(token[1]);
            }
         }
      }
      if (strlen(token[1])) {
         _error_string = "Unable to parse the rest of " + token[1];
         return 0;
      }
      return ({ name, arg_types, arg_names });
   } else {
      _error_string = "Unable to parse rest of: " + def;
   }
} /* parse_user_expression_definition() */

/**
 * This method attempts to parse a user expression.
 * @param name the name of the function
 * @param args the name and types of the arguments
 * @param str the input string
 * @return the name of the function, 0 on failure
 */
string parse_user_expression(
   string def,
   string str)
{
   mixed* stuff;
   int i;
   string* token_ret;
   class user_function_thing old_fluff;
   class user_function_thing fluff;
   class func_variable_thing womble;
   int* arg_types;
   string* arg_names;
   string name;

   _warning_string = "";
   stuff = parse_user_expression_definition(def);
   if (!stuff) {
      return 0;
   }

   //
   // Pull the useful bits out of the return value.
   //
   name = stuff[0];
   arg_types = stuff[1];
   arg_names = stuff[2];

   //
   // Setup the function variables.
   //
   _func_variables = ([ ]);
   for (i = 0; i < sizeof(arg_types); i++) {
      womble = new(class func_variable_thing);
      womble->type = arg_types[i];
      womble->arg_no = i;
      _func_variables[arg_names[i]] = womble;
   }

   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);

   //
   // Zap them back to the default.
   //
   _func_variables = ([ ]);

   if (!stuff) {
     //printf("%O", _error_string);
      return 0;
   }

   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
     //printf("%O", _error_string);
      return 0;
   }

   fluff = new(class user_function_thing);
   fluff->type = stuff[EXPRESSION_TYPE];
   fluff->expr = stuff[EXPRESSION_TREE];
   fluff->arg_names = arg_names;
   fluff->arg_types = arg_types;

   //
   // Let us check to see if one exists current and if we have changed
   // any types.
   //
   old_fluff = _user_functions[name];
   if (old_fluff) {
      if (old_fluff->type != fluff->type) {
         _warning_string += "Warning: Return types have changed " +
                    query_type_name(old_fluff->type) + " to " +
                    query_type_name(fluff->type) + ".\n";
      }
      if (sizeof(old_fluff->arg_types) != sizeof(fluff->arg_types)) {
         _warning_string += "Warning: Number of arguments has changed.\n";
      }
      for (i = 0; i < sizeof(old_fluff->arg_types) && i < sizeof(fluff->arg_types); i++) {
         if (old_fluff->arg_types[i] != fluff->arg_types[i]) {
            _warning_string += "Warning: Argument number " + i +
                               " differs in type " +
                               query_type_name(old_fluff->arg_types[i]) +
                               " to " + query_type_name(fluff->arg_types[i]) +
                               ".\n";
         }
      }
   }
   _user_functions[name] = fluff;

   return name;
} /* parse_user_expression() */

/**
 * Does a sizeof an array.  Nifty...
 * @param arr the array to get the sizeof
 * @param args the rest of the arguments
 * @return the sizeof the array
 */
int sizeof_function(mixed* arr, mixed args ...) {
   return sizeof(arr);
} /* sizeof_function() */

/**
 * This method returns the expresion as a string.
 * @param expr the expression
 * @param brief don't expand the variable names
 * @return the expression as a string
 */
string query_expression_string(class parse_node* expr, int brief) {
   string str;
   int i;
   string* stack;
   int* thing;
   string tmp;
   string place;
   int value;
   string indent;

   if (!sizeof(expr)) {
      return "No expression set.";
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   indent = "";
   str = "";
   stack = ({ });
   thing = ({ });
   for (i = 0; i < sizeof(expr); i++) {
      if (!classp(expr[i])) {
         stack += ({ "Broken element" });
         thing += ({ 0 });
         continue;
      }

      switch (expr[i]->type) {
      case EXPRESSION_TYPE_OPERATOR :
         value = expr[i]->value;
         switch (expr[i]->value) {
         case EXPRESSION_NOT :
            str = " " + query_operator_name(expr[i]->value) + " ";
            if (thing[<1] && thing[<1] != expr[i]->value) {
               str += "(" + stack[<1] + ")";
            } else {
               str += stack[<1];
            }
            stack = stack[0..<2];
            thing = thing[0..<2];
            break;
         case EXPRESSION_AND_NEW :
         case EXPRESSION_OR_NEW :
            str += query_expression_string(expr[i]->tree[0], brief);
            str += " " + query_operator_name(expr[i]->value) + " ";
            str += query_expression_string(expr[i]->tree[1], brief);
            break;
         case EXPRESSION_AND :
         case EXPRESSION_OR :
         case EXPRESSION_PLUS :
         case EXPRESSION_MINUS :
         case EXPRESSION_DIVIDE :
         case EXPRESSION_MULTIPLY :
         case EXPRESSION_GREATOR_THAN     :
         case EXPRESSION_LESS_THAN        :
         case EXPRESSION_EQUAL_TO         :
         case EXPRESSION_GREATOR_OR_EQUAL :
         case EXPRESSION_LESS_OR_EQUAL    :
         case EXPRESSION_NOT_EQUAL_TO     :
            tmp = stack[<2];
            if (thing[<2] && thing[<2] != expr[i]->value) {
               str = "(" + stack[<2] + ")";
            } else {
               str = stack[<2];
            }
            str += " " + query_operator_name(expr[i]->value) + " ";
            if (thing[<1] && thing[<1] != expr[i]->value) {
               str += "(" + stack[<1] + ")";
            } else {
               str += stack[<1];
            }
            stack = stack[0..<3];
            thing = thing[0..<3];
            break;
         case EXPRESSION_TRUE :
            str = "true";
            value = 0;
            break;
         case EXPRESSION_FALSE :
            str = "false";
            value = 0;
            break;
         case EXPRESSION_IF_NEW :
            if (brief) {
               str = "if " + stack[<1] + " then " + 
                     query_expression_string(expr[i]->tree[0], brief) +
                     " else " +
                     query_expression_string(expr[i]->tree[1], brief) +
                     " endif";
            } else {
               str = "if " + stack[<1] + " then\n" +
                     "   " + replace_string(
                        query_expression_string(expr[i]->tree[0], brief),
                                     "\n", "\n   ") +
                     "\nelse\n" +
                     "   " + replace_string(
                        query_expression_string(expr[i]->tree[1], brief),
                                     "\n", "\n   ") +
                     "\nendif";
            }
            stack = stack[0..<2];
            thing = thing[0..<2];
            value = 0;
            break;
         case EXPRESSION_IF :
            if (brief) {
               str = "if " + stack[<3] + " then " + stack[<2] + " else " +
                     stack[<1] + " endif";
            } else {
               str = "if " + stack[<3] + " then\n" +
                     "   " + replace_string(stack[<2], "\n", "\n   ") +
                     "\nelse\n" +
                     "   " + replace_string(stack[<1], "\n", "\n   ") +
                     "\nendif";
            }
            stack = stack[0..<4];
            thing = thing[0..<4];
            value = 0;
            break;
         case EXPRESSION_ARRAY_DEREFERENCE :
            str = stack[<2] + "[" + stack[<1] + "]";
            stack = stack[0..<3];
            thing = thing[0..<3];
            value = 0;
            break;
         case EXPRESSION_ARRAY_AGGREGATE :
            str = "{ " +
                   implode(stack[<(expr[i - 1]->value+1)..<2],
                        ", ") + " }";
            thing = thing[0..<expr[i - 1]->value + 2];
            stack = stack[0..<expr[i - 1]->value + 2];
            value = 0;
            break;
         default :
            str = "Error!";
            break;
         }
         stack += ({ str });
         thing += ({ value });
         break;
      case EXPRESSION_TYPE_ARRAY_NULL :
         stack += ({ "{}" });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_MONEY :
         stack += ({ MONEY_HAND->money_value_string(expr[i]->value, place) });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_INTEGER :
         stack += ({ "" + expr[i]->value });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_STRING :
         stack += ({ "\"" + expr[i]->value + "\"" });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_VARIABLE :
         stack += ({ expr[i]->value });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_FUNCTION_VARIABLE :
         stack += ({ expr[i]->value[EXPRESSION_FUNC_VAR_NAME] });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_FUNCTION :
      case EXPRESSION_TYPE_USER_FUNCTION :
         str = expr[i]->value[EXPRESSION_FUNC_NAME] + "(";
         str += implode(stack[<expr[i]->value[EXPRESSION_FUNC_NO_ARGS]..],
                        ", ");
         str += ")";
         stack = stack[0..<expr[i]->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         thing = thing[0..<expr[i]->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         stack += ({ str });
         thing += ({ 0 });
         break;
      default :
         stack += ({ "Unknown: " + expr[i]->type + " (" + expr[i]->value + ")" });
         thing += ({ 0 });
         break;
      }
   }
   return stack[<1];
} /* query_expression_string() */

/**
 * This method makes a nice string representation of the user function.
 * @param func the name of the user function to get a string of
 * @return the user function string
 */
string query_user_function_string(string func) {
   class user_function_thing thing;
   int i;
   string ret;

   thing = _user_functions[func];
   ret = "";
   ret += query_type_name(thing->type) + " " + func + "(";
   for (i = 0; i < sizeof(thing->arg_types); i++) {
      ret += query_type_name(thing->arg_types[i]) + " " + thing->arg_names[i];
      if (i < sizeof(thing->arg_types) - 1) {
         ret += ", ";
      }
   }
   ret += ") {\n   ";
   ret += replace_string(query_expression_string(thing->expr, 0),
                         "\n", "\n   ") + "\n}\n";
   return ret;
} /* query_user_function_string() */

/**
 * This method evaluates the expression and creates a nice end result
 * thingy.
 * @param expr the exrpession to evaluate
 * @param args the optional args parsed into the various function calls
 * @return the type and value of the expression, 0 if failed
 */
class parse_node evaluate_expression(class parse_node* expr, mixed args ...) {
   class parse_node bing;
   class parse_node new_node;
   class parse_node* stack;
   string fname;
   mixed* fargs;
   int i;

   if (!sizeof(expr)) {
      return make_node(EXPRESSION_TYPE_BOOLEAN, 0, ({ }));
   }

   stack = ({ });
   foreach (bing in expr) {
      if (!classp(bing)) {
         continue;
      }
      switch (bing->type) {
      case EXPRESSION_TYPE_OPERATOR :
         switch (bing->value) {
         case EXPRESSION_NOT :
            stack[<1] = make_node(EXPRESSION_TYPE_BOOLEAN, !stack[<1]->value, 0);
            break;

         case EXPRESSION_AND_NEW :
            // First we evaluate one bit, then the other bit.
            new_node = evaluate_expression(bing->tree[0],
                   args + ({ sizeof(args) }) ...);
            if (!new_node->value) {
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 0, 0) });
            } else {
               new_node = evaluate_expression(bing->tree[1],
                       args ...);
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, new_node->value, 0) });
            }
            //stack = stack[0..<2];
            break;
         case EXPRESSION_OR_NEW :
            // First we evaluate one bit, then the other bit.
            new_node = evaluate_expression(bing->tree[0],
                   args...);
            if (new_node->value) {
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 1, 0) });
            } else {
               new_node = evaluate_expression(bing->tree[1],
                       args ...);
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, new_node->value, 0) });
            }
            //stack = stack[0..<2];
            break;
         case EXPRESSION_AND :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<1]->value &&
                                                           stack[<2]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_OR :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<1]->value ||
                                                           stack[<2]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_PLUS :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value +
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_MINUS :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value -
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_DIVIDE :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value /
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_MULTIPLY :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value *
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_GREATOR_THAN     :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value >
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_LESS_THAN        :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value <
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_EQUAL_TO         :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value ==
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_GREATOR_OR_EQUAL :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value >=
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_LESS_OR_EQUAL    :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value <=
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_NOT_EQUAL_TO     :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value !=
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_IF_NEW               :
            if (stack[<1]->value) {
               new_node = evaluate_expression(bing->tree[0],
                   args ...);
            } else {
               new_node = evaluate_expression(bing->tree[1],
                   args ...);
            }
            stack = stack[0..<2] + ({ new_node });
            break;
         case EXPRESSION_IF               :
            if (stack[<3]->value) {
               new_node = stack[<2];
            } else {
               new_node = stack[<1];
            }
            stack = stack[0..<4] + ({ new_node });
            break;
         case EXPRESSION_ARRAY_DEREFERENCE :
            if (stack[<1]->value < 0 ||
                stack[<1]->value >= sizeof(stack[<2]->value)) {
               printf("Warning!  Array out of bounds (" + 
                      query_expression_string(expr, 1) + ")\n");
               stack = stack[0..<3] + ({ query_null_type(EXPRESSION_TYPE_INTEGER) });
            } else {
               stack = stack[0..<3] +
                     ({ make_node(stack[<1]->type - EXPRESSION_TYPE_ARRAY_OFFSET,
                                  stack[<2]->value[stack[<1]->value], 0) });
            }
            break;
         case EXPRESSION_ARRAY_AGGREGATE :
            fargs = ({ });
            for (i = 0; i < stack[<1]->value; i++) {
               fargs += ({ stack[<i + 2]->value });
            }
            new_node = new(class parse_node,
                           type : stack[<2]->type + EXPRESSION_TYPE_ARRAY_OFFSET,
                           value : fargs);
            stack = stack[0..<stack[<1]->value+2] + ({ new_node });
            break;
         case EXPRESSION_TRUE             :
            stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 1, 0) });
            break;
         case EXPRESSION_FALSE            :
            stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 0, 0) });
            break;
         default :
            printf("Unknown operator %O\n", bing);
            break;
         }
         break;
      case EXPRESSION_TYPE_ARRAY_NULL :
         stack += ({ new(class parse_node, type : EXPRESSION_TYPE_ARRAY_NULL,
                         value : ({ }) ) });
         break;
      case EXPRESSION_TYPE_INTEGER :
         stack += ({ copy(bing) });
         break;
      case EXPRESSION_TYPE_STRING :
         stack += ({ copy(bing) });
         break;
      case EXPRESSION_TYPE_MONEY :
         stack += ({ copy(bing) });
         break;
      case EXPRESSION_TYPE_VARIABLE :
         stack += ({ make_node(query_variable_type(bing->value),
                               evaluate(query_variable_value(bing->value),
                                        args ...), 0) });
         break;
      case EXPRESSION_TYPE_FUNCTION_VARIABLE:
         stack += ({ args[bing->value[EXPRESSION_FUNC_VAR_POS] + args[<1]] });
         break;
      case EXPRESSION_TYPE_USER_FUNCTION:
         fname = bing->value[EXPRESSION_FUNC_NAME];
         fargs = stack[<bing->value[EXPRESSION_FUNC_NO_ARGS]..];
         stack = stack[0..<bing->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         if (!_user_functions[fname]) {
            printf("Unknown function %O\n", fname);
            break;
         }
         bing = evaluate_expression(_user_functions[fname]->expr,
                   args + fargs + ({ sizeof(args) }) ...);
         if (!bing) {
            printf("Broken return stuff.\n");
            break;
         }
         stack += ({ bing });
         break;
      case EXPRESSION_TYPE_FUNCTION :
         fname = bing->value[EXPRESSION_FUNC_NAME];
         fargs = stack[<bing->value[EXPRESSION_FUNC_NO_ARGS]..];
         stack = stack[0..<bing->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         stack += ({ make_node(query_function_type(fname),
                               evaluate(query_function_value(fname),
                                        map(fargs, (: $1->value :)) +
                                        args ...), 0) });
         break;
      default :
         printf("Unknown type %O\n", bing);
         break;
      }
//printf("%O: %O\n", bing, stack);
   }

   return stack[<1];
} /* evaluate_expression() */
// --- END [/mnt/home2/grok/lib/std/basic/expressions.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/item_chat.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/item_chat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629984   Available: 13577338
Inodes: Total: 5242880    Free: 4960136
7159 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/item_chat.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629984   Available: 13577338
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: item_chat.c,v 1.9 2002/04/19 20:51:06 aquilo Exp $
 * $Log: item_chat.c,v $
 * Revision 1.9  2002/04/19 20:51:06  aquilo
 * Added call to check_chat() in item_chat(), as per Sousjagne's suggestion.
 *
 * Revision 1.8  2001/11/05 21:03:50  pinkfish
 * Fix up a weird error with interactive and environments.
 *
 * Revision 1.7  2001/08/20 16:23:54  aquilo
 * Fixed up saving & restoring of chats
 *
 * Revision 1.6  2001/08/18 14:43:11  aquilo
 * Made the changes work this time. (didn't take into account environment() == 0 first
 * time)
 *
 * Revision 1.3  2000/03/28 21:23:46  ceres
 * Can't remember
 *
 * Revision 1.2  1999/09/14 05:08:27  shaggy
 * Made documentation more complete
 *
 * Revision 1.1  1998/01/06 03:59:10  ceres
 * Initial revision
 * 
*/
/** -*- LPC -*-
 * This class handles atmospheric chat messages.
 */
#include <room.h>

private nosave int _off, _already_added;
private nosave mixed *_chats;

void check_chat();

/**
 * @return The raw data telling us what to chat and when
 */
mixed *query_chats() { return _chats; }


/** @ignore yes */
void init() {
  check_chat();
} /* init() */


/**
 * This method adds atmospheric chat messages to the object.
 * The array which is passed into the object has three 
 * elements, the first element is the minimum time between chats, the second
 * parameter is the maximum time bewteen chats and the third parameter
 * is the list of actual chats.
 * <p>
 * Item chats are strings which are printed at (semi) random
 * intervals to living objects holding or in the same room as
 * someone holding the object. Currently they will not be
 * heard outside containers. They are used to add
 * atmosphere to an Item. A chat will be picked at random
 * from the array of chats with a frequency controlled by the
 * times min and max. ie. one will be picked every n seconds
 * where is varies between min and max seconds. Please
 * don't make the values for min and max too small or the
 * messages just become annoying! 
 * <p>
 * Currently, there's a maximum on the min/max values, every
 * value higher than 320 seconds is treated as that.
 * <p>
 * The chats can contain one of $a_short$, $the_short$ and
 * $poss_short$ which will be replaced with the
 * corresponding value. 
 * <p>
 * To call a function defined on the item in place of a chat message
 * use "#function_name" in place of a chat string.
 * <p>
 * To use item chats, the object needs to inherit
 * "/std/basic/item_chat" and if the object defines an init()
 * function, that function should also call ::init()
 * <p>
 * To make the chatting object save the values, it's necessary
 * to define a couple of supporting functions in the item: 
 * <pre>
 * mapping query_dynamic_auto_load() {
 *   mapping tmp;
 * 
 *   tmp = ([ "::" : object::query_dynamic_auto_load(),
 *            "chat" : item_chat::query_dynamic_auto_load(), ]);
 *   return tmp;
 * } \/\* query_dynamic_auto_load() *\/
 *
 * void init_dynamic_arg(mapping map) {
 *   if (map["::"])
 *     object::init_dynamic_arg(map["::"]);
 *   if (map["chat"])
 *     item_chat::init_dynamic_arg(map["chat"]);
 * } /\* init_dynamic_arg() *\/
 *
 * </pre>
 * Use object in the previous if the object is inheriting /std/object, if not,
 * then use whatever it's inheriting from instead. 
 * @example item_chat( ({ 120, 240,
 *            ({ "A revolting smell drifts from $the_short$.",
 *              "Something rustles in $the_short$." }) }) );
 */
void item_chat( mixed *args ) {
  if ( !args || sizeof(args) < 3 || !sizeof(args[2]) ){
    write( "Incorrect args to item_chat.\n" );
    return;
  }
 
  /* We save original version, not replaced one, as the a_short stuff will point
     to wrong obs when we next load */
//  _saved_version = args;
  args = args - ({ 0 });  
  args[2] = map( args[2], 
        (: replace( $1, ({ "$a_short$", this_object()->a_short(),
                           "$the_short$", this_object()->the_short(),
                           "$poss_short$", this_object()->poss_short() }) ) :) );

  _off = 0;
  _chats = args + ({ 0 });

  check_chat();

} /* item_chat() */

/**
 * This starts the object chatting.  This is done automaticly when entering
 * the presence of an interactive object
 * @see item_chat()
 * @see chat_off()
 */
void chat_on(){
   _off = 0; 
   check_chat();
} /* chat_on() */

/**
 * This stops the object chatting.  This is done automaticly when leaving
 * the prescence of all interactive objects.
 * @see chat_on()
 * @see item_chat()
 */
void chat_off(){
   _off = 1; 
} /* chat_off() */

/**
 * This method does the actual chat, it prints a message
 * and figures that stuff out.
 * @see item_chat()
 * @see chat_on()
 * @see chat_off()
 */
void make_chat(){
  int saying;
  string stuff;
  object env, *targets;

  _already_added = 0;

  if( !(env = environment()) || _off )
    return;

  saying = random( sizeof(_chats[ 2 ]) );

  if( saying == _chats[ 3 ] )
    saying = ( saying + 1 ) % sizeof( _chats[ 2 ] );

  _chats[ 3 ] = saying;
  stuff = _chats[ 2 ][ saying ];

  // Chat if i'm in a room, or in an environment one branch down from an (n)pc 
  // who is in a room

  if( env->query_is_room() || 
      ( interactive(env) && (env = environment(env)) && env->query_is_room() ) ){
    targets = filter( all_inventory(env), (: interactive($1) :) );
    if( !sizeof(targets) ) 
      // No one here. Don't chat and don't add ourself to chatter
      return;

    if( stuff[0..0] == "#" )
      call_other( this_object(), stuff[ 1 .. ] );
    else
      tell_room( env, stuff + "\n" );

    // Add ourselves, so we are called again
    _already_added = 1;
    ROOM_HANDLER->add_chatter( this_object(), _chats[ 0 ] +
                               random( _chats[ 1 ] - _chats[ 0 ] + 1 ) );
  }

} /* make_chat() */

/**
 * This method makes sure that we are chatting if we should be.
 * @see chat_on()
 * @see item_chat()
 * @see make_chat()
 */
void check_chat(){
  if( !_off && !_already_added && arrayp(_chats) && environment() ){
    if( interactive(environment()) || 
          ( environment(environment()) &&
            interactive(environment(environment()))
          ) 
       ){
           _already_added = 1;
           ROOM_HANDLER->add_chatter( this_object(), 
           ( _chats[ 0 ] + random( _chats[ 1 ] - _chats[ 0 ] + 1 ) ) / 2 );
        }
  }

} /* check_chat() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([ "_off"  : _off,
            "_chats" : _chats
          ]);
} /* query_dynamic_auto_load() */

/** Fixes saved chats
 */
string fix_saved_chat( string chat ){
  string old_ob;

  if( !chat )
    return 0;
  sscanf( chat, "%*s$%*s_short:%s$%*s", old_ob );
  if( old_ob )
    chat = replace( chat, old_ob, file_name(this_object()) );

  return chat;
}


/** @ignore yes */
void init_dynamic_arg( mapping map ) {
  mixed info;

  if( !map )
    return;
  if( (info = map["_chats"]) && arrayp(info) && sizeof(info) > 2 ){
    info[2] = map( info[2], "fix_saved_chat", this_object() );
    item_chat( info );
  }
  if( !(_off = map["_off"]) )
    chat_on();
  else
    chat_off();
} /* init_dynamic_arg() */

// --- END [/mnt/home2/grok/lib/std/basic/item_chat.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/cute_look.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/cute_look.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629982   Available: 13577336
Inodes: Total: 5242880    Free: 4960136
8158 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/cute_look.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629982   Available: 13577336
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 *
 * This object handles all the inventory listing for rooms, when long() is 
 * called.
 * It should convert like this: ({ /w/terano/womble#1234, /std/object#1324, 
 * /global/creator#2523 }) into "Lady Midnite is standing here.\nA key and a 
 * womble are floating happily.\n"
 *
 * @author Lynscar
 * @change Deutha
 * Added in support for the one_short, the_short stuff.  Also added
 * in the 'last' stuff I think.
 * @change Pinkfish
 * Added in support for positions.
 * @change Terano
 * Rewrote removing all the foreachs, and getting rid of chicken and last 
 * variables. Should be much nicer now.
 */

#include <position.h>

// Comment me out to use the old process_non_living() code.
#define NEW_PROCESS_NON_LIVING 1

mixed *process_living( object *int_livings );
string process_non_living( object *int_non_livings, int start );
void set_ignore_livings_in_inventory( int ignore );
int ignore_livings_in_inventory();

private nosave int _ignore_livings = 1; //It was decreed this be so.

/** @ignore yes */
int env_check(object ob) { return environment(ob) == this_object(); }
/** @ignore yes */
int living_check(object ob) { return living(ob); }
/** @ignore yes */
mixed there_check(object ob) { return ob->query_property("there"); }

/**
 * This method returns a string contents of description of the container.
 * NB: this_player() is _not_ included in the array if (s)he is present.
 * The ignore_living flag tells us if we should process living
 * objects as different or not.  If we do not process them as
 * different (as you do in room descriptions), then this flag should
 * be 0.  This is so that living objects can be kept an an
 * inventory of a player without stuff it up.  ie: Pets.
 * @param start the start message before the contents
 * @param things the things to give the message for
 * @param ignore_living treat livings differently
 * @return a string contents description
 */

varargs string query_contents( string start, object *things,
  int ignore_living) {

    object *livings = ({ }), *non_livings = ({ });
    mixed *bits;
    string return_string = "";
    int groups;

    //Sort into living and non-living

    if( undefinedp( ignore_living ) )
        ignore_living = ignore_livings_in_inventory();

    if ( stringp( start ) ) return_string = start;

    if ( !arrayp( things ) ) {
        things = this_object()->find_inv_match( "", this_player() );
        things -= ({ this_player() });
        things = filter_array( things, "env_check", this_object());
    }


    if ( !sizeof( things ) ) 
        return "";

    if (!ignore_living) {
        livings = filter(things, "living_check", this_object());
        non_livings = things - livings;
    } else non_livings = things;

    //Process the livings

    if ( sizeof( livings ) ) {
        bits = process_living( livings );
        return_string += bits[ 0 ];
        groups = bits[1];
    }

    //Process the non-livings

    if ( sizeof( non_livings ) ) {
        return_string += process_non_living( non_livings, groups );
    }

    //Return the built string - Yay!
    if(return_string == "")
        return return_string;
    else
        return  return_string = this_player()->colour_event("inventory", "") +
        return_string[0..<2] + "%^RESET%^\n";
}

/**
 * @ignore
 * Internally process living objects and return a string.
 */
mixed *process_living( object *int_livings ) {
  int i;
  mapping positions = ([ ]);
  object live_temp;
  string my_pos, int_ret_string = "", *all_positions, current_pos, ministring;
  
  foreach( live_temp in int_livings ) {
    if ( undefinedp( my_pos = live_temp->query_position_short() ) )
      my_pos = POSITION_DEFAULT;
    if ( undefinedp( positions[ my_pos ] ) )
      positions[ my_pos ] = ({ live_temp });
    else
      positions[ my_pos ] += ({ live_temp });
  }
  
  //Sort into positions
  //For each position, build a ministring and add it
  
  all_positions = keys( positions );
  i = 0;
  foreach( current_pos in all_positions ) {
    if(i==0) {
      ministring = "$C$$M$";
    } else {
      ministring = "$M$";
    }
    
    foreach( live_temp in positions[ current_pos ] ) {
      if ( !live_temp->query_visible( this_player() ) ) {
        continue;      
      }
      ministring += live_temp->a_short();
    }
    
    /* If more than one living */
    if (!positions[current_pos][0]->query_position_dont_use_is_are()) {
      if ( sizeof( positions[ current_pos ] ) > 1 || 
           positions[ current_pos ][0]->group_object() ) { 
        if ( positions[ current_pos ][0]->query_position_multiple() ) {
          ministring += "$M$ are each " + current_pos;
        } else {
          ministring += "$M$ are " + current_pos;
        }
      } else {
        ministring += "$M$ is " + current_pos;
      }
    } else {
      ministring += "$M$ " + current_pos;
    }
    
    switch( current_pos ) {
    case SITTING:
    case STANDING:
    case KNEELING:
    case SWIMMING:
    case LYING:
    case MEDITATING:
    case CROUCHING:
      ministring += " here";
    default:
      i++;
      if(i<sizeof(all_positions)-1)
        ministring += ", ";
      else if(i<sizeof(all_positions))
        ministring += " and ";
      else
        ministring += ".\n";
      int_ret_string += ministring;
      continue;
    }
  }
  return ({ int_ret_string, sizeof( all_positions ) }) ;
}

/**
 * @ignore
 */
string process_non_living( object *non_livings, int start ) {
  mapping positions;
  string position;
  object *items, item, *bulk;
  string here;
  string *room_items;
  int i;
  
  if(!sizeof(non_livings))
    return "";
  
  here = this_object()->query_property( "here" );
  
  if (!here)
    return query_multiple_short( non_livings ) + ".\n";

  positions = unique_mapping( non_livings, "there_check", this_object());
  
  if ( positions[ 0 ] ) {
    positions[ here ] = positions[ 0 ];
    map_delete( positions, 0 );        
  }
  
  i = start;
  
  room_items = ({ });
  
  foreach( position, items in positions ) {       
    bulk = ({ });    
    
    foreach( item in items ) {
      if( ( ( item->query_continuous() || item->query_collective() ) &&
         item->query_how_many() > 1 ) || item->query_are_override() )
      {
        // How do we make sure this all gets arranged properly...?
        if( item->query_short() == item->query_plural() )
          room_items += ({ item->a_short() + " is " + position });
        else
          room_items += ({ item->a_short() + " are " + position });
      } else {
        bulk += ({ item });
      }
    }
        
    if ( sizeof( bulk ) ) {
      room_items += ({ "$M$" + implode( bulk->a_short(), "" ) + 
                         "$M$ " + "$V$" + i + "=is,are$V$ " + position });
    }
        
    i++;
  }
  
  return "$C$" + query_multiple_short( room_items ) + ".\n";
}

/**
 * This method prints out the contents of the object matching.
 * @param word the string to match
 */
void list_contents( string words ) { write( query_contents( words ) ); }

/**
 * @ignore
 */
int query_last() {
    log_file( "CUTELAST", "(%s) %s called query_last.\n", 
      ctime( time() ), file_name( this_object() ) );
    return 0;
}

/**
 * @ignore
 */
void adjust_last( int wibble ) {
    log_file( "CUTELAST", "(%s) %s called adjust_last.\n", 
      ctime( time() ), file_name( this_object() ) );
    return;
}

/**
 * Sets the ignore_living flag.  Default is 1.
 * @param 1 to ignore livings, 0 not to
 * @see query_contents
 * @see ignore_livings_in_inventory
 **/
 
void set_ignore_livings_in_inventory( int ignore ) {
  _ignore_livings = !!ignore;
} /* set_ignore_livings_in_inventory() */

/**
 * Returns the ignore_living flag.  If livings are ignored, they are 
 * displayed the same way as non-livings, ie: by short alone.  If they are 
 * not ignored, livings are displayed on a separate line and show their
 * positions. NB: passing a value to the 'ignore_livings' parameter of 
 * query_contents overrides the ignore_living flag.
 *
 * @return 1 if livings are ignored, 0 if not.
 * @see set_ignore_livings_in_inventory
 * @see query_contents
 **/
 
int ignore_livings_in_inventory() { return _ignore_livings; }
// --- END [/mnt/home2/grok/lib/std/basic/cute_look.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/id.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/id.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629980   Available: 13577334
Inodes: Total: 5242880    Free: 4960136
19236 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/id.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629980   Available: 13577334
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming


/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: id.c,v 1.18 2002/03/15 21:59:19 tannah Exp $
*/
/**
 * This class keeps track of all the aliases, names and adjectives
 * which are used to match the object.
 * @see /global/player->add_command()
 * @see /std/basic/desc.c
 */
#include <parse_command.h>

inherit "/std/basic/id_match";

class Id {
  string name;
  string *alias;
  string *faux_alias;
  string *unique_faux_alias;
  string *adjectives;
  string *faux_adjectives;
  string *unique_faux_adjectives;
  string *plural_adjectives;
  string *plurals;
}

private nosave class Id _id;

int id_adjective(string);
int id_plural(string str);
int faux_id_allowed();

private void setup_id_class() {
   if (_id) {
      return ;
   }
   _id = new( class Id );
   _id->alias = ({ });
   _id->faux_alias = ({ });
   _id->unique_faux_alias = ({ });
   _id->plurals = ({ });
   _id->adjectives = ({ });
   _id->faux_adjectives = ({ });
   _id->unique_faux_adjectives = ({ });
   _id->plural_adjectives = ({ });
   _id->name = "object";
} /* setup_id_class() */

/* name handling stuff */
/**
 * This method sets the name of the object.   The name is the basic handle
 * used to reference the object.   It should not have any spaces
 * in it.
 * @example
 * set_name("rabbit");
 * @param str the name
 * @see query_name()
 * @see add_alias()
 * @see add_adjective()
 */
void set_name(string str) {
   _id->name = str;
}

/**
 * This method returns the name of the object.
 * @return the name of the object
 * @see set_name()
 * @see add_alias()
 * @see add_adjective()
 */
string query_name() {
   if (!_id) {
      return 0;
   }
   return _id->name;
}

/**
 * This method returns the capitalized name.   It calls the function
 * capitalize() on the name
 * @see query_name()
 * @see set_name()
 * @see efun::capitalize()
 */
string query_cap_name() {
   if (!_id->name) {
      return "Someone";
   }
   return capitalize(_id->name);
}

void create() {
   setup_id_class();
}

/* alias stuff */
/**
 * This method sets the entire alias array.   It overrides any current alias
 * definitions and sets the alias arry.   This should be used carefully
 * if at all.   Use add_alias instead.
 * @param str the new alias array
 */
void set_aliases(string *str) {
   _id->alias = str;
}

/**
 * This method adds an alias to the object.   An alias for the object is the
 * part used as the main noun for the object. ie in the case of a "green
 * bath tub", "bathtub" might be an alias for the object. and "green"
 * and "bath" would be adjectives. The value set with add_alias is also
 * used with present. This means you can make up an alias for an object
 * that players cannot normaly access but you can
 * get a handle on with present. For an exmple of this look at the money
 * object.
 * <p>
 * The function takes an array or a string as an argument.   If an array
 * is passed in each element of the array is added to the alias
 * array, if it is a string then the string elemnt is added to the
 * array.
 * @param str the alias(s) to add
 * @see set_name()
 * @see remove_alias()
 * @see set_aliases()
 * @see query_alias()
 * @example
 * set_name("tub");
 * set_short("green bath tub");
 * add_alias("bathtub");
 * add_adjective("green");
 * add_adjective("bath");
 */
void add_alias(mixed str) {
   if (pointerp(str)) {
      _id->alias += str;
      return;
   }
   if (member_array(str, _id->alias) == -1) {
      _id->alias += ({ str });
   }
}

/**
 * This method removes an alias from the object.
 * @see add_alias()
 * @see query_alias()
 * @param str the alias to remove
 * @return 1 if the alias is found, 0 if not
 */
int remove_alias(string str) {
   int i;

   i = member_array(str, _id->alias);
   if (i == -1) {
      return 0;
   }
   _id->alias = _id->alias[0..i - 1] + _id->alias[i + 1..];
   return 1;
}

/**
 * This method returns the current list of aliases.  If faux aliases are
 * allowed, they are included, unless the optional parameter is passed.
 * @param no_faux 1 to ignore faux aliases (optional)
 * @see add_alias()
 * @see add_faux_alias()
 * @see query_faux_alias()
 * @see query_unique_faux_alias()
 * @see remove_alias()
 * @return the array of aliases (array of strings)
 */
varargs string *query_alias( int no_faux ) {
  if( no_faux ||
      !sizeof( _id->unique_faux_alias ) ||
      !faux_id_allowed() )
    return _id->alias;
  else
    return _id->alias + _id->unique_faux_alias;
}

/**
 * This method adds a faux alias to the object.   Faux aliases are
 * ignored by objects that ignore identifiers.
 * <p>
 * The function takes an array or a string as an argument.   If an array
 * is passed in each element of the array is added to the faux alias
 * array, if it is a string then the string element is added to the
 * array.  Elements that are already real aliases of the object are ignored.
 * Duplication in this list is allowed; a separate list without duplicates
 * is maintained to improve performance.
 * @param str the alias(s) to add
 * @see query_faux_alias()
 * @see query_unique_faux_alias()
 * @see add_alias()
 * @see add_faux_adjective()
 * @see remove_faux_alias()
 * @see ignore_identifiers()
 * @see parse_command_id_list()
 * @example
 */
void add_faux_alias(mixed str) {
   if (pointerp(str)) {
      foreach( string aka in str )
        add_faux_alias( aka );
      return;
   }

   // don't duplicate real aliases
   if( member_array( str, _id->alias ) != -1 )
     return;

   // allowed duplication in the _faux_alias list is intentional
   _id->faux_alias += ({ str });

   // no duplication allowed in the unique list
   _id->unique_faux_alias = _id->unique_faux_alias | ({ str });
}

/**
 * This method removes a faux alias from the object.  Note that, if the
 * alias has been added more than once, only one instance is removed
 * from the array.  If the last instance of an alias is removed from the
 * list, it is also removed from the unique list.
 * @see add_faux_alias()
 * @see add_faux_adjective()
 * @see query_alias()
 * @see query_unique_faux_alias()
 * @param str the faux alias to remove
 * @return 1 if the alias is found, 0 if not
 */
int remove_faux_alias(string str) {
   int i;

   i = member_array(str, _id->faux_alias);
   if (i == -1) {
      return 0;
   }

   // only remove one instance from the faux list
   _id->faux_alias = _id->faux_alias[0..i - 1] +
                      _id->faux_alias[i + 1..];

   // only remove it from the unique list if there are no more instances
   // of it in the faux list.
   if( member_array(str, _id->faux_alias) == -1 ) {
      _id->unique_faux_alias -= ({ str });
   }

   return 1;
}

/**
 * This method returns the current list of faux aliases, with duplicates
 * included.
 * @see add_faux_alias()
 * @see remove_faux_alias()
 * @see query_unique_faux_alias()
 * @return the array of faux aliases (array of strings)
 */
string *query_faux_alias() {
  return _id->faux_alias;
}

/**
 * This method returns the unique list of faux aliases.  It is this list
 * that id() uses.
 * @see query_faux_alias()
 * @see id()
 * @return the array of faux aliases (array of strings) without duplication
 */
string *query_unique_faux_alias() {
  return _id->unique_faux_alias;
}

/**
 * This method is used by the id function.   It determines whether or
 * not an object in the calling list ignores identifiers.
 * If none do, then faux aliases may be used.
 * @return 1 if faux ids may be used
 * @see add_faux_alias
 * @see add_faux_adjective
 * @see ignore_identifiers
 */
int faux_id_allowed() {
  foreach( object ob in previous_object(-1) ) {
    if( objectp(ob) && ob->ignore_identifier() )
      return 0;
  }
  return 1;
}

/**
 * This method is used by the present efun.   It determines if the
 * passed in string is an alias or the name of the object.
 * @param str the value to check
 * @return 1 if the name matches
 */
int id(string str) {
   return (str == _id->name ||
          (member_array(str, query_alias()) != -1) );
}

/** @ignore yes */
int full_id(string str) {
   string *words;
   string name;
   string adjective;

   words = explode(str, " ") - ({ "" });

   name = words[<1];
   words = words[0.. < 2];

   if (!id(name)) {
      if (!id_plural(name)) {
         return 0;
      }
   }
   foreach(adjective in words) {
      if (!id_adjective(adjective)) {
         return 0;
      }
   }
   return 1;
}

/* plural stuff */
/**
 * This method sets the compete array of plurals.   This shod
 * not be used, use add_plural and remove_plural instead.
 * @see add_plural()
 * @see remove_plural()
 * @see query_plurals()
 */
void set_plurals(string *str) {
   _id->plurals = str;
}

/**
 * This method adds a plural onto the object.   The plurals will be
 * used in plural name matching by thje find_match simul_efun
 * @see /secure/simul_efun->find_match()
 * @see set_plurals()
 * @see remove_plural()
 * @see query_plurals()
 * @see add_plurals()
 */
void add_plural(mixed str) {
   if (pointerp(str)) {
      _id->plurals += str;
   } else if (_id->plurals) {
      if (member_array(str, _id->plurals) == -1) {
         _id->plurals += ({ str });
      }
   } else {
      _id->plurals = ({ str });
   }
}

/**
 * This method removes a plural from the object.
 * @param str the plural to remove
 * @see add_plural()
 * @see query_plurals()
 * @see set_plurals()
 */
void remove_plural(string str) {
   int i;

   i = member_array(str, _id->plurals);
   if (i != -1) {
      _id->plurals = _id->plurals[0..i - 1] + _id->plurals[i + 1..];
   }
}

/**
 * This method adds multiple plurals to the object.
 * @param str the array of plurals to add
 * @see add_plural()
 * @see remove_plural()
 * @see query_plurals()
 */
void add_plurals(string *str) {
   _id->plurals += str;
}

/**
 * This method returns the complete list of plurals for the
 * object.
 * @return the complete array of plurals
 */
string *query_plurals() {
   return _id->plurals;
}

/**
 * This method is similar to the id function, except this will check the
 * plural names instead of the aliases and the name.
 * @param str the name to check
 * @return 1 if the name matches one of the plurals, 0 otherwise
 * @see id()
 * @see id_adjective()
 */
int id_plural(string str) {
   return (member_array(str, _id->plurals) != -1);
}

/**
 * This method sets all the adjectives for the object.   This method
 * should not be used, please use add_adjective instead.
 * @see add_adjective()
 * @see remove_adjective()
 * @see query_adjectives()
 * @param str the array of adjectives
 */
void set_adjectives(string *str) {
   _id->adjectives = str;
}

/**
 * This method adds an adjective to the object.   The adjectives are used
 * for the object matching routines.    For example, if you have a "green
 * bath tun" then "green" and "bath" are adjectives.
 * @see add_alias()
 * @see remove_adjective()
 * @see query_adjectives()
 * @see set_adjectives()
 */
void add_adjective(mixed str) {
   int i;

   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         add_adjective(str[i]);
      }
      return;
   }
   if (stringp(str)) {
      str = explode(str, " ");
   }

   for (i = 0; i < sizeof(str); i++) {
      if (member_array(str[i], _id->adjectives) == -1) {
         _id->adjectives += ({ str[i] });
      }
   }
}

/**
 * This method will remove an adjective from the object.
 * @see add_alias()
 * @see add_adjective()
 * @see query_adjectives()
 * @param str the adective(s) to remove
 */
void remove_adjective(mixed str) {
   int i;

   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         remove_adjective(str[i]);
      }
   } else {
      if ((i = member_array(str, _id->adjectives)) != -1) {
         _id->adjectives = delete(_id->adjectives, i, 1);
      }
   }
}



/**
 * This method adds a faux adjective to the object.   Faux adjectives are
 * ignored by objects that ignore identifiers.
 * <p>
 * The function takes an array or a string as an argument.   If an array
 * is passed in each element of the array is added to the faux adjective
 * array, if it is a string then each word in the string element is added
 * to the array.  Elements that are already real adjectives of the object
 * are ignored.
 * @see add_adjective()
 * @see remove_faux_adjective()
 * @see ignore_identifiers()
 */
void add_faux_adjective(mixed str) {

   if (pointerp(str)) {
      foreach( string adj in str )
         add_faux_adjective( adj );
      return;
   }

   if( stringp( str ) ) {
      str = explode(str, " ");
   }

   // don't duplicate real adjectives
   str -= _id->adjectives;

   foreach( string adj in str ) {
      // duplication desired in faux list...
      _id->faux_adjectives += ({ adj });

      // ...but not in unique list.
      _id->unique_faux_adjectives = _id->unique_faux_adjectives |
                                    ({ adj });
   }
}

/**
 * This method will remove a faux adjective from the object.  Note that,
 * if the adjective has been added more than once, only one instance is
 * removed from the array.
 * @see add_faux_alias()
 * @see add_faux_adjective()
 * @see query_adjectives()
 * @param str the adective(s) to remove
 */
void remove_faux_adjective(mixed str) {
   int i;

   if (pointerp(str)) {
      foreach( string adj in str )
         remove_faux_adjective( adj );
      return;
   }

   i = member_array(str, _id->faux_adjectives);
   if( i == -1 )
     return;

   _id->faux_adjectives = _id->faux_adjectives[0..i-1] +
                          _id->faux_adjectives[i+1..];

   // if it's the last instance of this adjective, remove it from the
   // unique list, too.
   if( ( i = member_array( str, _id->faux_adjectives ) ) == -1 )
     _id->unique_faux_adjectives -= ({ str });
}

/**
 * This method returns the current list of faux adjectives, including
 * duplicates.
 * @see add_faux_adjective()
 * @see remove_faux_adjective()
 * @see query_adjectives()
 * @see query_unique_faux_adjectives()
 * @return the array of faux adjectives (array of strings)
 */
string *query_faux_adjectives() {
  return _id->faux_adjectives;
}

/**
 * This method returns a unique list of faux adjectives.
 * @see query_adjectives()
 * @see id_adjective()
 * @see remove_faux_adjective()
 * @return the array of faux adjectives (array of strings)
 */
string *query_unique_faux_adjectives() {
  return _id->unique_faux_adjectives;
}

/**
 * This method returns the current list of adjectives associated with
 * this object.  If faux ids are allowed, then faux adjectives are
 * included if the optional parameter is not 1.
 * @param no_faux 1 to ignore faux adjectives
 * @return the complete list of adjectives
 */
varargs string *query_adjectives( int no_faux ) {
  if( no_faux ||
      !sizeof( _id->unique_faux_adjectives ) ||
      !faux_id_allowed() )
    return _id->adjectives;
  else
    return _id->adjectives + _id->unique_faux_adjectives;
}

/**
 * This method is similar to the id function, except this will check the
 * adjectives instead of the aliases and the name.
 * @param str the adjective to check
 * @return 1 if the name matches one of the adjectives, 0 otherwise
 * @see id()
 * @see id_plural()
 */
int id_adjective(string word) {
   return (member_array(word, query_adjectives()) != -1);
}

/**
 * This method sets all the plural adjectives for the object.   This method
 * should not be used, please use add_plural_adjective instead.
 * @see add_plural_adjective()
 * @see remove_plural_adjective()
 * @see query_plural_adjectives()
 * @param str the array of plural adjectives
 */
void set_plural_adjectives(string *str) {
   _id->plural_adjectives = str;
}

/**
 * This method adds an plural adjective to the object.   The plural
 * adjectives are used for the
 * object matching routines.  Plural adjectives should be used very rarely,
 * they are used in cases where the plural of a name is determined by the
 * adjective rather than it's alias.  For example: pair of shoes, pairs
 * of shoes.
 * @see add_alias()
 * @see remove_plural_adjective()
 * @see query_plural_adjectives()
 * @see set_plural_adjectives()
 */
void add_plural_adjective(mixed str) {
   int i;

   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         add_plural_adjective(str[i]);
      }
      return;
   }
   if (stringp(str)) {
      str = explode(str, " ");
   }
   for (i = 0; i < sizeof(str); i++) {
      if (member_array(str[i], _id->plural_adjectives) == -1) {
         _id->plural_adjectives += ({ str[i] });
      }
   }
}

/**
 * This method will remove an plural adjective from the object.
 * @see add_alias()
 * @see add_plural_adjective()
 * @see query_plural_adjectives()
 * @param str the adective(s) to remove
 */
void remove_plural_adjective(mixed str) {
   int i;

   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         remove_plural_adjective(str[i]);
      }
   } else {
      if ((i = member_array(str, _id->plural_adjectives)) != -1) {
         _id->plural_adjectives = delete(_id->plural_adjectives, i, 1);
      }
   }
}

/**
 * This method returns the current list of plural adjectives associated with
 * this object.
 * @return the complete list of plural adjectives
 */
string *query_plural_adjectives() {
   return _id->plural_adjectives;
}

/**
 * This method is similar to the id function, except this will check the
 * plural adjectives instead of the aliases and the name.
 * @param str the name to check
 * @return 1 if the name matches one of the plurals, 0 otherwise
 * @see id()
 * @see id_plural()
 */
int id_plural_adjective(string word) {
   return (member_array(word, _id->plural_adjectives) != -1);
}

/* ok parse command stuff */
/** @ignore yes */
string *parse_command_id_list() {
   return ({ _id->name, file_name(this_object()) }) + query_alias();
}

/** @ignore yes */
string *parse_command_plural_id_list() {
   return query_plurals();
}

/** @ignore yes */
string *parse_command_adjectiv_id_list() {
   return query_adjectives();
}

/** @ignore yes */
string *parse_command_plural_adjectiv_id_list() {
   return query_plural_adjectives();
}

/** @ignore yes */
object query_parse_id(mixed *arr) {
   if (arr[P_THING] == 0) {
      return this_object();
   }
   if (arr[P_THING] < 0) {      /* specific object case */
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return this_object();
   }
   arr[P_THING]--;              /* lots of objects case */
   if (arr[P_THING] != 0) {
      return this_object();
   }
   arr[P_THING] = -10101;
   return this_object();
}

/** @ignore yes */
object query_frac_parse_id(mixed *arr) {
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10235;
      return 0;                 /* it refered to me and I am pretty
                                 * depressed about it.
                                 * I want to break free!
                                 */
   }
   if (arr[P_THING] == 0) {
      if ((arr[P_MAX_NUM] * arr[P_TOP]) / arr[P_BOT] > arr[P_CUR_NUM]++) {
         return this_object();
      } else {
         return 0;
      }
   }
   if ((arr[P_THING] * arr[P_TOP]) / arr[P_BOT] > arr[P_CUR_NUM]++) {
      return this_object();
   }
   return 0;
}
// --- END [/mnt/home2/grok/lib/std/basic/id.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/trap.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629975   Available: 13577329
Inodes: Total: 5242880    Free: 4960136
5014 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/trap.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629975   Available: 13577329
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: trap.c,v 1.5 2001/08/27 01:18:52 gototh Exp $
 * 
*/
/**
 * This is a basic trap system for adding traps to container type objects (or
 * anything that uses /std/basic/close_lock.
 *
 * To setup the trap use setup_trap(). Functions are available to find out
 * information about a trap on an object.
 *
 * If you wish to create a more advanced trap you can use the set_lock_trap and
 * set_open_trap functions in /std/basic/close_lock.
 *
 * @author ceres
 * @see /std/basic/close_lock
 * @see setup_trap
 */
#include <tasks.h>

#define SKILL "covert.lockpick.traps"

private nosave int _trap_difficulty;
private nosave string _trap_trigger;
private nosave string _trap_description;
private nosave mixed _trap_message;
private nosave mixed _trap_effect;
private nosave mixed _trap_armed;

/**
 * This sets up a basic trap on a lock.  The trap will be triggered when
 * someone locks/unlocks/picks the lock (depending on trigger). If
 * triggered the message will be displayed and the effect will be added
 * to the player.
 *
 * @param difficulty skill bonus needed to avoid triggering the trap
 * @param trigger "unlock", "pick, "open",  for which activities should
 * trigger the trap.
 * @param description a description of the trap for someone who looks at
   it.
 * @param message The message to be displayed to the player. If it's an array
 * the first index will be printed to the player the second
 * to the room.
 * @param effect the effect to be added to the trigerer. If the effect is an
 * int the players hps will be reduced by that amount. If it is
 * a string that effect will be added to the player, if it's an
 * array the first index will be treated as the effect the rest
 * as parameters to the effect.
 *
 * @example
 * setup_trap(300, "pick",
 *            "Hidden inside the lock is a small ampule which, if touched by "
 *            "an unwary tool would trigger a puff of poisonous gas.",
 *            ({"A small cloud of gas puffs out of the safe.\n",
 *                "A small cloud of gas puffs out of the safe.\n"}),
 *            ({"/std/effects/poisons/poison_gas", 600}));
 */
void setup_trap(int difficulty, string trigger, string description,
                     mixed message, mixed effect) {
  if(!trigger)
    return;
  
  if(trigger == "open")
    this_object()->set_open_trap(this_object(), "basic_trap");
  else
    this_object()->set_lock_trap(this_object(), "basic_trap");

  _trap_difficulty = difficulty;
  _trap_trigger = trigger;
  _trap_description = description;
  _trap_message = message;
  _trap_effect = effect;
}

/**
 * Get data on the basic lock trap. Data is returned as a mixed array of
 * stuff. This is really only used for the autoload. :)
 *
 * @return mixed array of trap data.
 */
mixed *query_trap_data() {
  return ({ _trap_difficulty, _trap_trigger, _trap_description,
              _trap_message, _trap_effect, _trap_armed });
}

/**
 * Find out the difficulty of this trap.
 *
 * @return int difficulty
 */
int query_trap_difficulty() { return _trap_difficulty; }

/**
 * Get the trigger condition for this trap.
 *
 * @return string the trigger condition.
 */
string query_trap_trigger() { return _trap_trigger; }

/**
 * Get the trap description text.
 *
 * @return string description of the trap.
 */
string query_trap_description() { return _trap_description; }

/**
 * Get the trap trigger messages
 *
 * @return mixed a string or array of messages
 */
mixed query_trap_message() { return _trap_message; }

/**
 * Get the trap effects.
 *
 * @return mixed either an int (for the damage) or a mixed variable for
 *   the effect to add to the triggerer.
 */
mixed query_trap_effect() { return _trap_effect; }

/**
 * Set the trap as armed or disarmed.
 */
void set_trap_armed(int i) { _trap_armed = i; }

/**
 * Get whether the trap is armed or not.
 */
int query_trap_armed() { return _trap_armed; }

/**
 * @ignore yes
 *
 * Internal function called to determine if the trap is triggered.
 */
int basic_trap(string action) {
  if(!_trap_armed || action != _trap_trigger)
    return 1;
  
  switch(TASKER->perform_task(this_player(), SKILL, _trap_difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about avoiding "
          "traps.%^RESET%^\n");
  case SUCCEED:
    return 1;
  default:
    if(arrayp(_trap_message)) {
      write(_trap_message[0]);
      say(_trap_message[1], this_player());
    } else
      write(_trap_message);
    
    if(intp(_trap_effect)) {
      if(_trap_effect > this_player()->query_hp())
        this_player()->do_death();
      else
        this_player()->adjust_hp(-(_trap_effect));
    } else if(arrayp(_trap_effect)) {
      if(sizeof(_trap_effect) == 2)
        this_player()->add_effect(_trap_effect[0], _trap_effect[1]);
      else
        this_player()->add_effect(_trap_effect[0], _trap_effect[1..]);
    } else
      this_player()->add_effect(_trap_effect);
    return 0;
  }
}
// --- END [/mnt/home2/grok/lib/std/basic/trap.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/misc.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/misc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629974   Available: 13577328
Inodes: Total: 5242880    Free: 4960136
13359 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/misc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629974   Available: 13577328
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: misc.c,v 1.16 2003/03/07 01:10:01 ceres Exp $
 * 
 */
/**
 * This class contains information relating to the value and the weight
 * of the object.
 * @author Pinkfish
 */
#include <money.h>
#include <move_failures.h>

#define WATCH_DEFINE "fluff'n'stuff"
#define PRICE_INDEX "/obj/handlers/cpi_handler"

inherit "/std/basic/light";
inherit "/std/basic/consecrate";
inherit "/std/basic/move";
/* this will also handle value... */

nosave int weight; // People have to ask explicitly for weightlessness
nosave int length = 1;
nosave int width = 1;                 
nosave int value;
nosave mapping value_info;
void check_log_status( object *parray );

void create() {
  weight = 1;
  light::create();
  
  if(this_object()->query_property(WATCH_DEFINE))
    call_out( "check_log_status", 1, previous_object(-1) );
  
  value_info = ([ ]);
}

/**
 * This method sets the width to the given amount.
 * @param w the amount to set the width to
 * @see query_width()
 */
void set_width(int w) { width = w; }

/**
 * This method queries the width of an object. The width should be the shorter
 * side of an object and the length its longer one. Sadly someone chose inches
 * as the size units. :(
 *
 * @param w the amount to set the width to
 * @see set_width()
 */
int query_width() { return width; }

/**
 * This method sets the length to the given amount. The length should be the
 * long side of an object, the width its shorter one. Sadly someone chose
 * inches as the size units. :(
 *
 * @param w the amount to set the length to.
 * @see query_length()
 */
void set_length(int l) { length = l; }

/**
 * This method queries the length of an object.
 * @param w the amount to set the length to
 * @see set_length()
 */
int query_length() { return length; }

/**
 * This method adjusts the weight by the given amount.
 * @param w the amount to change the weight by
 * @see set_weight()
 * @see query_weight()
 */
void adjust_weight(int w) {
    if (environment()) {
        environment()->add_weight(w);
    }
    weight += w;
} /* adjust_weight() */

/**
 * This method sets the weight of the object.  One weight unit
 * is 50 grams.
 * <p>
 * When setting the weights of weapons use the following guide:
 * <pre>
 * o===================o=====================o================o
 * | Weapon            | Approx. Weight (kg) |  Weight Units  |
 * o===================o=====================o================o
 * | Dagger            |        0.5          |       10       |
 * | War Hammer        |        1.1          |       22       |
 * | Mace              |        1.3          |       26       |
 * | Flail             |        1.5          |       30       |
 * | Pole Axe          |        2.3          |       46       |
 * | Short Sword       |        0.8          |       16       |
 * | Broad Sword       |        1.1          |       22       |
 * | Long Sword        |        1.4          |       28       |
 * | Bastard Sword     |        1.9          |       38       |
 * | Two-handed Sword  |        2.7          |       42       |
 * o===================o=====================o================o
 * </pre>
 * @param w the amount to change the weight by
 * @see adjust_weight()
 * @see query_weight()
 */
void set_weight(int w) {
    if (environment())
        environment()->add_weight(w-weight);
    weight = w;
} /* set_weight() */

/**
 * This method returns the current weight of the object.
 * @return the current weight of the object
 * @see set_weight()
 * @see adjust_weight()
 */
int query_weight() { return weight; }
/**
 * This method returns the current weight of the object. It does basicly
 * the same thing as the previous call.  NB: this_object()->query_weight()
 * is pretty much the same as query_weight(), except it takes shadows into
 * account.
 * @return the current weight of the object
 * @see set_weight()
 * @see adjust_weight()
 * @see query_weight()
 */
int query_complete_weight() { return (int)this_object()->query_weight(); }

/**
 * This method changes the value of the object by a certain number of
 * coins.  The coins can be any type.
 * @see /obj/handlers/money_handler->query_total_value()
 * @see adjust_value()
 * @see query_money_array()
 * @see set_value()
 * @return the new value
 */
varargs int adjust_money(mixed amt, string coin) {
    if (pointerp(amt)) {
        value += (int)MONEY_HAND->query_total_value(amt);
        if (value < 0) {
            value = 0;
        }
        return value;
    }
    amt = (int)MONEY_HAND->query_total_value( ({ coin, amt }) );
    value += amt;
    if (value < 0) {
        value = 0;
    }
    return value;
} /* adjust_money() */

/**
 * This method changes the current value of the object.
 * @param i the amount to change the value by
 * @return the new value of the object
 */
int adjust_value(int i) {
    value += i;
    return value;
} /* adjust_value() */

/**
 * This method returns the value of the object as a money array.  The
 * money array is a list oif coinages followed by a number of coins.
 * Eg: <code>({ "copper", 10, "silver", 12 }).</code>
 * @see /obj/handlers/money_handlers->create_money_array()
 * @see set_value()
 * @see adjust_value()
 * @see adjust_money()
 * @see query_value()
 */
mixed *query_money_array() { 
    return (mixed *)MONEY_HAND->create_money_array(value);
} /* query_money_array() */

/**
 * This method returns the number of coins of a certain
 * type that are in the value of the object.  This is not
 * a good estimate of value or anything, no idea why it is
 * here really.  I am sure I had a good reason
 * at the time :)
 * @param type the type of coin to look for
 * @return the number of coins of that type
 * @see /obj/handlers/money_handlers->create_money_array()
 * @see set_value()
 * @see adjust_value()
 * @see adjust money()
 * @see query_money_array()
 * @see query_value()
 */
int query_money(string type) { 
    int i;
    mixed *m_a;

    m_a = (mixed *)MONEY_HAND->create_money_array(value); 
    i = member_array(type, m_a);
    if (i == -1) {
        return 0;
    }
    return m_a[i+1];
} /* query_money() */

/**
 * This method sets the value of the object.  The actual value in
 * coins and so forth is worked out by the money handler based on the
 * value.
 * @param number the new value of the object
 * @see query_value()
 * @see adjust_value()
 * @see query_money_array()
 */
void set_value( int number ) { value = number; }

/**
 * This method sets the value information for a type of
 * special object.  This is the extra value information associated
 * with the "artifact", "enchantment" or "material" of the object.
 * @param word the type of value information
 * @param number the amount to set it to
 * @see query_value_at()
 * @see remove_value_info()
 * @see set_value()
 */
void set_value_info( string word, int number ) {
    value_info[ word ] = number;
} /* set_value_info */

/**
 * This method removes the value information for a type of
 * special object.  This is the extra value information associated
 * with the "artifact", "enchantment" or "material" of the object.
 * @param word the type of value information to remove
 * @see query_value_at()
 * @see set_value_info()
 * @see set_value()
 */
void remove_value_info( string word ) {
    if ( undefinedp( value_info[ word ] ) )
        return;
    value_info = m_delete( value_info, word );
} /* remove_value_info() */

/**
 * This method returns the current value of the object.
 * @return the current value of the object
 */
int query_value() { return value; }

/**
 * This method returns the vase value of the object.  This is before
 * any scaling from things like condition occurs.
 * @return the base value
 */
int query_base_value() {
   return value;
} /* query_base_value() */

/**
 * This method returns the information associated for all the special
 * bits of the object.  The value infor maping ihas keys which are
 * the type of value info and the value is the value of it.
 * @return the value info mapping
 * @see set_value_info()
 * @see query_value_at()
 * @see remove_value_info()
 */
mapping query_value_info() { return value_info; }

/**
 * This method figures out how much an object will cost in a certain
 * place.  For instance at a shop that does not handle artifcacts an
 * artifact will be bought and sold cheaply.  The current types
 * of "artifact", "enchantment" and "material" are recognised.
 * A property in the shop of the type "artifact valued" will
 * cause the values of that type to be taken into account.
 * @param place the object to find the value at
 * @return the value in the shop
 * @see query_value()
 * @see set_value_info()
 * @see adjust_value()
 */
int query_value_at( object place ) {
    int i, total;
    string *info;
    mixed how;

    if ( !value_info ) {
        value_info = ([ ]);
    }
    total = (int)this_object()->query_value();
    info = m_indices( value_info );
    for ( i = 0; i < sizeof( info ); i++ ) {
        how = (mixed)place->query_property( info[ i ] +" valued" );
        if ( how ) {
            switch ( info[ i ] ) {
            case "artifact" :
                total += ( value_info[ "artifact" ] * ( how[ 0 ] +
                    how[ 1 ] * (int)this_object()->query_charges() ) ) / how[ 2 ];
                break;
            case "enchantment" :
                if ( this_object()->query_max_enchant() )
                    total += ( value_info[ "enchantment" ] * how *
                      (int)this_object()->query_enchant() ) /
                    (int)this_object()->query_max_enchant();
                break;
            case "material" :
                total += (int)this_object()->query_weight() *
                (int)PRICE_INDEX->query_price( (string)this_object()->
                  query_material(), how );
                break;
            default :
                total += value_info[ info[ i ] ];
            }
        }
    }
    return total;
} /* query_value_at() */

/**
 * This method always returns the most expensive value of an item.
 * This should be used for things like theif quotas and anything which
 * requires the real actual value of an item.
 * @param place the place to find the values in
 */
int query_value_real(string place) {
   int i;
   int total;
   string *info;

   if ( !value_info ) {
      value_info = ([ ]);
   }
   total = (int)this_object()->query_value();
   info = m_indices( value_info );
   for ( i = 0; i < sizeof( info ); i++ ) {
      switch ( info[ i ] ) {
      case "artifact" :
         total += ( value_info[ "artifact" ] * ( 3 +
             1 * (int)this_object()->query_charges() ) ) / 1;
         break;
      case "enchantment" :
         if ( this_object()->query_max_enchant() )
             total += ( value_info[ "enchantment" ] * 10 *
               (int)this_object()->query_enchant() ) /
             (int)this_object()->query_max_enchant();
         break;
      case "material" :
         total += (int)this_object()->query_weight() *
         (int)PRICE_INDEX->query_price( (string)this_object()->
           query_material(), place );
         break;
      default :
         total += value_info[ info[ i ] ];
         break;
      }
   }
   return total;
} /* query_value_real() */

/** @ignore yes */
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;

  if( stringp(dest) ) {
   if ( strsrch( dest , "#") != -1 )
     dest = find_object(dest);
   else
     dest = load_object(dest);
  }
  if(!dest)
    return MOVE_INVALID_DEST;

  w = (int)this_object()->query_complete_weight();

  if(!(dest->add_weight(w)))
    return MOVE_TOO_HEAVY;

  from = environment();

  i = ::move(dest, messin, messout);

  if(i != MOVE_OK) {
    dest->add_weight(-w);
    return i;
  }

  if(from)
    from->add_weight(-w);
  
  if(query_light_needs_inform()) {
    if(from)
      inform_of_light_level_change(from);
    inform_of_light_level_change(dest);
  }
  
  return i;
} 

/** @ignore yes */
void dest_me() {
    if ( environment() ) {
        environment()->add_weight( -(int)this_object()->query_complete_weight() );
        if ( query_my_light() )
            adjust_light( -query_my_light() );
    }
    ::dest_me(); 
} /* dest_me() */

/** @ignore yes */
mixed *stats() {
    int i;
    string *info;
    mixed *guff;

    guff = ({ ({ "value", value }) });
    if ( !value_info )
        value_info = ([ ]);
    info = m_indices( value_info );
    for ( i = 0; i < sizeof( info ); i++ )
        guff += ({ ({ "(info) "+ info[ i ], value_info[ info[ i ] ] }) });
    return light::stats() + consecrate::stats() + guff;
} /* stats() */

/** @ignore yes */
// Monitor for people passing around items that they shouldn't be.
void check_log_status( object *parray ) {
  if ( this_object()->query_property( WATCH_DEFINE ) && 
       clonep( this_object() ) &&
       arrayp( parray ) && 
       member_array(load_object("/secure/cmds/creator/cl_one"), parray) != -1){
    log_file( "WATCH", "%s TO: %s. TP: %s.\n", ctime(time()),
              base_name( this_object() ), parray[2]->query_name() );
    this_object()->add_property( "CT", time() );
    user_event( "inform", sprintf( "[Restricted] %s cloned %s.",
                                   parray[2]->query_cap_name(), 
                                   base_name( this_object() ) ), "cheat" );
  }
}

 
// --- END [/mnt/home2/grok/lib/std/basic/misc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/auto_load.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/auto_load.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629970   Available: 13577324
Inodes: Total: 5242880    Free: 4960136
1977 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/auto_load.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629970   Available: 13577324
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file has generic methods of accessing auto load information.  This
 * will save memory and generaly be more useful than the previous version.
 * It shoudl also solve a lot of the container in container problems,
 * @author Pinkfish
 * @started Wed Feb 17 13:46:35 PST 1999
 */

/**
 * This method adds a value into the auto load mapping.
 * @param map the mapping to add to
 * @param file_name the file name tag of the object doing the adding
 * @param tag the tag name to be used
 * @param value the value to be stored with it.
 * @example
 * #define AUTO_LOAD_TAG "object"
 * 
 * mapping query_dynamic_auto_load() {
 *    mapping map;
 *
 *    map = ::query_dynamic_auto_load();
 *    map = add_auto_load_value(map, AUTO_LOAD_TAG, "name", name);
 * } /\* query_dynamic_auto_load() *\/
 */
mapping add_auto_load_value(mapping map,
                            string file_name,
                            string tag,
                            mixed value) {
   map[file_name + "  :  " + tag] = value;
   return map;
} /* add_auto_load_value() */

/**
 * This method will attempt to read the tag value for the given name out of
 * the auto load mapping.
 * <p>
 * This works backwards compatible with the old method of dealing with tags
 * and file names.
 * @param map the auto load mapping
 * @param file_name the file name tag to use
 * @param tag the tag to use in the file name
 * @example
 * #define AUTO_LOAD_TAG "object"
 * 
 * mapping init_dynamic_arg(mapping map) {
 *    mapping map;
 *
 *    map = ::query_dynamic_auto_load();
 *    map = add_auto_load_value(map, AUTO_LOAD_TAG, "name", name);
 * } /\* init_dynamic_arg() *\/
 */
mixed query_auto_load_value(mapping map,
                            string file_name,
                            string tag) {
   mixed tmp;

   if (tag == "::") {
      return map;
   }

   tmp = map[file_name + "  :  " + tag];
   if (tmp) {
      return tmp;
   }

   return map[tag];
} /* query_auto_load_value() */
// --- END [/mnt/home2/grok/lib/std/basic/auto_load.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/repeater.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/repeater.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629970   Available: 13577324
Inodes: Total: 5242880    Free: 4960136
5606 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/repeater.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629970   Available: 13577324
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is used to repeat all events onto the object that requested it
 * (excluding events from the object itself).  The methods it calls on
 * the repeater object are:
 * <ul>
 * <li>repeat_event_person_say
 * <li>repeat_event_emote
 * <li>repeat_event_say
 * <li>repeat_event_enter
 * <li>repeat_event_exit
 * </ul>
 * @author Pinkfish
 * @started Thu Sep 23 19:09:49 PDT 1999
 */

private nosave object _repeater;

/**
 * This method sets the owner of the repeater.
 * @param owner the object that owns the repeater
 */
void set_repeater_owner(object owner) {
   _repeater = owner;
} /* set_repeater_owner() */

/**
 * This method returns the owner of the repeater.
 * @return the object to inform of all events
 */
object query_repeater_owner() {
   return _repeater;
} /* query_repeater_owner() */

/*
 * Stuff to relay the messages from the environment to the person on the
 * horse and vica versa.
 */

/**
 * This is called on the repeater object to process the actual message
 * event_person_say message.
 * @param caller the repeater who sent the message
 * @param ob the object that did the say
 * @param start the start string
 * @param mess the message string
 * @param lang the language the message is in
 */
void repeat_event_person_say(object caller,
                             object ob,
                             string start,
                             string mess,
                             string lang) {
} /* repeat_event_person_say() */

/** @ignore yes */
void event_person_say(object ob, string start, string mess, string lang) {
   if (_repeater) {
      _repeater->repeat_event_person_say(this_object(), 
                                         ob,
                                         start, 
                                         mess, 
                                         lang);
   }
} /* event_person_say() */

/**
 * This is called on the repeater object to process the actual message
 * event_emote message.
 * @param caller the repeater who sent the message
 * @param ob the object that did the semote
 * @param mess the message string
 */
void repeat_event_emote(object caller,
                        object ob,
                        string mess) {
} /* repeat_event_emote() */

/** @ignore yes */
void event_emote( object ob, string mess ) {
   if (_repeater) {
   _repeater->repeat_event_emote(this_object(), 
                                 ob,
                                 mess);
   }
} /* event_emote() */

/**
 * This is called on the repeater object to process the actual message
 * event_say message.
 * @param caller the repeater who sent the message
 * @param ob the object that did the event_say
 * @param mess the message string
 * @param avoid the array of objects not to print the message
 */
void repeat_event_say(object caller,
                      object ob,
                      string mess,
                      object *avoid) {
} /* repeat_event_say() */

/** @ignore yes */
void event_say(object ob, string str, mixed avoid) {
   if (_repeater) {
      _repeater->repeat_event_say(this_object(), 
                                  ob,
                                  str,
                                  avoid);
   }
} /* event_say() */

/**
 * This is called on the repeater object to process the actual message
 * event_soul message.
 * @param caller the repeater who sent the message
 * @param ob the object that did the event_soul
 * @param mess the message string
 * @param avoid the array of objects not to print the message
 */
void repeat_event_soul(object caller,
                       object ob,
                       string mess,
                       object *avoid) {
} /* repeat_event_soul() */

/** @ignore yes */
void event_soul(object ob, string str, mixed avoid) {
   if (_repeater) {
      _repeater->repeat_event_soul(this_object(), 
                                  ob,
                                  str,
                                  avoid);
   }
} /* event_soul() */

/**
 * This is called on the repeater object to process the actual message
 * event_enter message.
 * @param caller the repeater who sent the message
 * @param ob the object that did the event_say
 * @param mess the message string
 * @param prev the last environment of the object
 */
void repeat_event_enter(object caller,
                        object ob,
                        string mess,
                        object prev) {
} /* repeat_event_enter() */

/** @ignore yes */
void event_enter( object thing, 
                  string mess, 
                  object prev ) {
   if (_repeater) {
      _repeater->repeat_event_enter(this_object(), 
                                    thing,
                                    mess,
                                    prev);
   }
} /* event_enter() */

/**
 * This is called on the repeater object to process the actual message
 * event_exit message.
 * @param caller the repeater who sent the message
 * @param ob the object that did the event_say
 * @param mess the message string
 * @param exit where the object is going to
 */
void repeat_event_exit(object caller,
                       object ob,
                       string mess,
                       object dest) {
} /* repeat_event_exit() */

/** @ignore yes */
void event_exit( object thing, 
                 string mess, 
                 object dest ) {
   if (_repeater) {
      _repeater->repeat_event_enter(this_object(), 
                                    thing,
                                    mess,
                                    dest);
   }
} /* event_exit() */
// --- END [/mnt/home2/grok/lib/std/basic/repeater.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/move.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629968   Available: 13577322
Inodes: Total: 5242880    Free: 4960136
6445 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/move.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629968   Available: 13577322
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: move.c,v 1.8 2001/07/27 20:59:09 tannah Exp $
 * $Log: move.c,v $
 * Revision 1.8  2001/07/27 20:59:09  tannah
 * removed "there" property in move()
 *
 * Revision 1.7  2000/03/28 10:15:52  shaggy
 *  Forcibly unlocked by ceres
 *
 * Revision 1.6  1999/12/14 23:28:13  turrican
 * Don't call event_enter when the destination is the rubbish room
 *
 * Revision 1.5  1999/09/21 03:12:56  pinkfish
 * Pretty it up a little and make the move_flag private.
 *
 * Revision 1.4  1999/07/20 08:47:28  wodan
 * don't move_object if we're already there, no need to do al those inits again.
 *
 * Revision 1.3  1999/03/16 15:23:57  wodan
 * change to disable event_enter in /room/virtual, them npcs shouldn't see eachother enter :)
 *
 * Revision 1.2  1998/08/20 08:44:43  pinkfish
 * *** empty log message ***
 *
 * Revision 1.1  1998/01/06 03:59:10  ceres
 * Initial revision
 *
*/
/**
 * This class defines the basic move function and support functions.
 * @author Pinkfish
 */
#include <move_failures.h>

#define DROP 1
#define GET 2

private int move_flag;

/**
 * The basic move method.  The destination can be an object or a string.
 * if it is neither of these then the failure MOVE_EMPTY_DEST is
 * returned.  If the function test_add() was called on the
 * destination and it returns 0 then MOVE_NO_GET is returned as
 * a failure.  If the destination is this_object() then
 * MOVE_INVALID_DEST is returned as the failure.  If the
 * function test_remove is called on the current environment and it
 * returns 0 then MOVE_NO_DROP is returned as the move failure.
 * <p>
 * The events "enter" and "exit" are generated as part of the
 * move process.  Both of these events are passed two
 * arguments.  The exit event is passed the exit message
 * and the destination.  The enter event is passed the
 * enter message and the place we came from.
 * <p>
 * The function event_move_object() is called (call_other)
 * on the object if the move was successful (MOVE_OK).
 * @param dest where to move to
 * @param messin the message to print when entering
 * @param messout the message to print when leaving
 * @see /include/move_failures.h
 * @return MOVE_OK on success, or a failure reason on failure
 * @see /secure/simul_efun->event()
 * @see event_move_object()
 * @example
 * move(find_player("pinkfish"));
 * @example
 * move("/d/am/am/mendeddrum");
 * @example
 * move (environment(find_player("ceres")),
 *          the_short()+" flaps in hopelessly.\n",
 *          the_short()+" flaps away hopelessly.\n");
 */
varargs int move( mixed dest, string messin, string messout ) {
   object prev;

   if ( !objectp( dest ) ) {
      if ( !stringp( dest ) || !( dest = find_object( dest ) ) ) {
         return MOVE_EMPTY_DEST;
      }
   }
   if ( !dest->test_add( this_object(), this_object()->get(dest) ) ) {
      return MOVE_NO_GET;
   }
   if(dest == this_object()) {
      return MOVE_INVALID_DEST;
   }
   prev = environment();
   if ( prev ) {
      if ( !prev->test_remove( this_object(),
                               this_object()->drop(dest),
                               dest ) ) {
         return MOVE_NO_DROP;
      } else if (prev != find_object("/room/virtual")) {
         event( prev, "exit", messout, dest );
      }
   }
   if (dest != environment()) {
      // remove the "there" property.  It can be readded in
      // event_move_object if desired.  Don't remove it if it's not
      // yet in an environment, however.

      if( environment() )
        this_object()->remove_property( "there" );

      move_object (dest);

      this_object()->event_move_object( prev, dest );
   }
   if (!(dest == find_object("/room/rubbish") || dest == find_object("/room/virtual"))) {
      event( dest, "enter", messin, prev );
   }
   this_object()->remove_hide_invis( "concealed" );
   this_object()->remove_hide_invis( "secreted" );
   return MOVE_OK;
} /* move() */

/**
 * Turns off the get flag.
 * @see move()
 * @see set_get()
 * @see get()
 */
void reset_get() { move_flag |= GET; }
/**
 * Turns on the get flag.
 * @see move()
 * @see reset_get()
 * @see get()
 */
void set_get() { move_flag &= ~GET; }
/**
 * Turns off the drop flag.
 * @see move()
 * @see set_drop()
 * @see drop()
 */
void reset_drop() { move_flag |= DROP; }
/**
 * Turns on the drop flag.
 * @see move()
 * @see reset_drop()
 * @see drop()
 */
void set_drop() { move_flag &= ~DROP; }

/**
 * This method destructs the object.  Zap us totally!  It generates
 * the event "dest_me", which is passed no arguments.
 * The function event_destruct() is called (call_other) on
 * the object for special last minute actions however
 * the destruct will not prevented.  If you need to prevent
 * the destruction mask dest_me() or do_death().
 * @see efun::destruct()
 * @see event_dest_me()
 * @see event_destruct()
 * @see do_death()
 * @see dwep()
 * @see /secure/simul_efun->event()
 */
void dest_me() {
   if ( environment() ) {
      event( environment(), "dest_me" );
   }
   this_object()->event_destruct();
   efun::destruct( this_object() );
} /* dest_me() */

/* Do not, I repeat, do not mask this function.
 * It is used when all else fails to destruct the object...
 * If we find you masking this function, we will cut you up
 * into many little bits... slowly.
 */

/**
 * Dest with extreme predejuce.  This is the last way to destruct an
 * object.  Used if all other methods fail.
 * @return a string "Destructed With Extreme Prejudice"
 */
nomask mixed dwep() {
   efun::destruct( this_object() );
   return "Destructed With Extreme Prejudice";
} /* dwep() */

/**
 * The current value of the drop flag. This function is called by the
 * test_remove() function in the living object.  So it allows you to
 * move the object out of inanimate objects, just not out of the
 * players.
 * @return 1 if it is set, 0 if it is reset
 * @see set_drop()
 * @see reset_drop()
 * @see get()
 */
int drop( mixed dest ) { return move_flag & DROP; }
/**
 * The current value of the get flag.  This function is called by the
 * test_add() function in the living object.  So it allows you to
 * move the object into innimate objects, just not into player
 * characters.
 * @return 1 if it is set, 0 if it is reset
 * @see set_get()
 * @see reset_get()
 * @see drop()
 */
int get( mixed dest ) { return move_flag & GET; }

/** @ignore yes  This is a debugging call. */
void set_move_flag( int i ) { move_flag = i; }
// --- END [/mnt/home2/grok/lib/std/basic/move.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/hide_invis.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/hide_invis.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629966   Available: 13577320
Inodes: Total: 5242880    Free: 4960136
4188 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/hide_invis.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629966   Available: 13577320
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#define SKILL "other.perception"

private nosave mapping _hide_invis;

void create() {
  _hide_invis = ([]);
} /* create() */

/**
 * This method returns the current hide/invisible states on the object.
 * The mapping is of the format:\n
 * <pre>
 * ([ <hide type name> :
 *     ({
 *        who,
 *        see,
 *        ({ obj, method }), // Remove method
 *      }),
 * ...
 * ])
 * </pre>
 * @return the hide invis mapping as above
 */
mapping query_hide_invis() {
  return copy( _hide_invis );
}

/**
 * This method adds a hide/invis state to the object.
 * @param type the name of the type of hiding
 * @param who no idea
 * @param see no idea
 * @param gone the method and object to call when the hiding is removed
 * @return 1 on success, 0 on failure
 */
int add_hide_invis( string type, object who, mixed see, string *gone ) {
  if( _hide_invis[type] ) {
    return 0;
  }

  _hide_invis[type] = ({ who, see, gone });

  if( environment( this_object() ) ) {
    event( environment( this_object() ), "hide_invis", 1, type, 0 );
  }

  return 1;
} /* add_hide_invis() */

/**
 * This method removed the hiding of the specified type off the object.
 * This method will call the function setup when the hiding was added
 * when the hiding is removed. If you pass 1 as the second argument, it
 * will send the 'quiet' flag to the callback function.
 * @param type the type of hiding to remove
 * @param quiet flag to pass along to the callback function
 * @return 1 on success, 0 on failure
 */
varargs int remove_hide_invis( string type, int quiet ) {
  mixed *gone;

  if( !_hide_invis[type] ) {
    return 0;
  }

  gone = _hide_invis[type][2];
  if( sizeof( gone ) == 2 && gone[0] )
    if( quiet )
      call_other( gone[0], gone[1], quiet );
    else
      call_other( gone[0], gone[1] );
  map_delete( _hide_invis, type );

  if( environment( this_object() ) ) {
    event( environment( this_object() ), "hide_invis", 0, type, quiet );
  }

  return 1;
} /* remove_hide_invis() */

/**
 * This does a perception check to see if the person can be seen.
 * This is variable on light level, amongst other things.
 * @param thing the person doing the looking
 */
int perception_check( object thing ) {
  int perception;

  perception = thing->query_skill_bonus( SKILL );

  if( !environment( thing ) || !perception )
    return perception;

  switch( thing->check_dark( (int)environment( thing )->query_light() ) ) {
    case -2:
    case 2:
      perception /= 4;
      break;
    case -1:
    case 1:
      perception /= 2;
      break;
    default:
      break;
  }

  return perception;
} /* perception_check() */

/**
 * This is the method called to check to see if the person is visible or
 * not.
 * This is masked in /global/wiz_file_comm to handle
 * creator invisibility.
 * @param thing the object doing the looking
 * @return 1 if visible, 0 if not
 */
int query_visible( object thing ) {
  int i;
  string *types;
  mixed see;

  if( thing == this_object() ) {
    return 1;
  }

  if( thing->query_creator() || thing->query_property( "demon" ) ) {
    return 1;
  }

  if( thing->query_blinded() ) {
    return 0;
  }

  types = keys( _hide_invis );
  if( !sizeof( types ) ) {
    return 1;
  }

  for( i = 0; i < sizeof( types ); i++ ) {

    if( _hide_invis[types[i]][0] == thing ) {
      continue;
    }

    see = _hide_invis[types[i]][1];
    if( intp( see ) ) {
      if( perception_check( thing ) > see ) {
        continue;
      }
      return 0;
    }

    if( stringp( see ) ) {
      if( call_other( thing, see ) ) {
        continue;
      }
      return 0;
    }

    /* Maybe other possibilities later. */
    return 0;
  }

  return 1;
} /* query_visible() */

/**
 * This method returns an extra bit to stick on the end of the players
 * name to show when they are hiding and so on.
 * @return the extra bit to stick after a person's name based on the state
 */
string hide_invis_string() {
  int i;
  string list;
  string *types;

  types = keys( _hide_invis );
  if( !sizeof( types ) ) {
    return "";
  }

  list = "";
  for( i = 0; i < sizeof( types ); i++ ) {
    list += " ("+ types[i] +")";
  }

  return list;
} /* hide_invis_string() */
// --- END [/mnt/home2/grok/lib/std/basic/hide_invis.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/read_desc.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/read_desc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629965   Available: 13577319
Inodes: Total: 5242880    Free: 4960136
8672 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/read_desc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629965   Available: 13577319
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: read_desc.c,v 1.13 2003/01/31 04:57:51 pinkfish Exp $
 * 
 */
/**
 * This method keeps track of all the messages on the object for
 * reading etc.  Keeps track of the language, the text and the
 * size.
 * @author Pinkfish
 */
#include <language.h>
#include <nroff.h>

inherit "/std/basic/desc";

/* this one also contians info on read_messages... */

private nosave mixed *_read_mess = ({ });
private nosave int _max_size = 100;
private nosave int _cur_size;

varargs mixed add_read_mess(mixed str, string type, string lang, int size);
mixed query_property(string name);

/**
 * This method sets the maximum amount of writing to be able
 * to be placed onto the object.
 * @param siz the maximum size
 * @see query_max_size()
 * @see add_read_mess()
 */
void set_max_size(int siz) { _max_size = siz; }
/**
 * This method returns the current maximum size of the object.
 * @return the current maximum size
 * @see set_max_size()
 * @see add_read_mess()
 */
int query_max_size() { return _max_size; }

/**
 * This method sets the current amount of writing size on
 * the object.
 * @see set_max_size()
 * @see add_read_mess()
 * @see query_cur_size()
 * @param siz the new current size
 */
void set_cur_size(int siz) { _cur_size = siz; }
/**
 * This method returns the current amount of wreiting size on the
 * object.
 * @see set_max_size()
 * @see add_read_mess()
 * @see set_cur_size()
 * @return the current amount of writing on the object
 */
int query_cur_size() { return _cur_size; }

/**
 * calling this is very rude unless you are createing the object as it
 * erases all of the writing off it.
 * @ignore yes
 */
varargs void set_read_mess(mixed str, string lang, int size) { 
   if ( pointerp( str ) ) {
      _read_mess = str;
      return;
   }
  if (!lang)
    return;
  
  if (!size)
    size = 1;
  if ( str )
    _read_mess = ({ ({ str, 0, lang, size }) });
  else
    _read_mess = ({ });
} /* set_read_mess() */

/**
 * This method returns the current read messae array on the object.
 * The returned array consists of an array of arrays.  The internal
 * array has 4 elements, the first is the text of the mnessage
 * the second is the type of the message,m the third is the languae
 * and the last element is the size of the wiritn .
 *<p>
 * The defines in the file /include/language.h should be used
 * for the indexes into this array.
 * @return the read message array
 * @see add_read_mess()
 * @see set_max_size()
 * @see /include/language.h
 */
mixed *query_read_mess() { return copy( _read_mess ); }

/***
 * This method adds a new read message onto the object. 
 * <p>
 * The str bit is the actual string to add, it is the message which
 * will get printed. The type is the type of the writing, like "spidery
 * writing" or "charcoal based letters". The language is the
 * language in which it is written and the size is the size of the
 * letters. The size is used to see if the writing can fit on the page.
 * <p>
 * If no type is
 * given, then no type bit is printed and if no size is specified a
 * size of 1 is the default. 
 * <p>
 * This also adjusts the size of stuff on the object.  If too much
 * is attemnpted to be written ont
 * the object, the remainer will be cut off.
 * @param str the text of the message
 * @param type the type of the message
 * @param lang the language the message is in
 * @param size the size of the message
 * @see query_read_mess()
 * @see set_max_size()
 * @see /obj/handlers/language->query_language_size()
 * @see /obj/handlers/language->squidge_text()
 */
varargs mixed add_read_mess(mixed str, string type, string lang, int size) { 
  int de_size;

/* fail! */
  if (_cur_size >= _max_size) {
     return "";
  }
  if (!size) {
    size = 1;
  }
  de_size = size*((int)LANGUAGE_HAND->query_language_size(lang, str));
  if (_cur_size+de_size > _max_size) {
/* Try and squidge the text on somehow... */
    str = (string)LANGUAGE_HAND->squidge_text(lang, str,
                                              (_max_size-_cur_size)/size);
    if (!strlen(str))
      return ;
    _cur_size += size*((int)LANGUAGE_HAND->query_language_size(lang, str));
  }
  _read_mess += ({ ({ str, type, lang, size }) });
  return str;
} /* add_read_mess() */

/**
 * This method removes a piece of writing off the object.
 * <p>
 * If you know the actual message or the language or the type you can remove
 * that message.
 *<p>
 * Using the type and or language is a very dodgy way of doing this.  Using
 * a combination is much better.
 * <p>
 * Any of the parameters set to a non-zero value will be used for the search.
 * @param str the text string
 * @see /obj/handlers/language->query_language_size()
 * @see add_read_mess()
 * @see query_read_mess()
 * @param type the type of the text
 * @param lang the language it is written in
 * @return 0 if the text was not found, 1 if it was
 */
int remove_read_mess(string str, string type, string lang) {
  int i;

  for (i=0;i<sizeof(_read_mess);i++) {
    if (str && _read_mess[i][READ_STR] != str)
      continue;
    if (type && _read_mess[i][READ_TYPE] != type)
      continue;
    if (lang && _read_mess[i][READ_LANG] != lang)
      continue;
    _cur_size -= _read_mess[i][READ_SIZE]
                *((int)LANGUAGE_HAND->query_language_size(lang,
                                                    _read_mess[i][READ_STR]));
    _read_mess = _read_mess[0..i - 1] + _read_mess[i + 1..];
    return 1;
  }
  /* Nup.  We traversed it all...  and there was nothing! */
  return 0;
} /* remove_read_mess() */

/**
 * This method returns the read message for the object.  This is what should
 * be displayed to the player if they attempt to read this object.
 * @return the read message, 0 if there is none
 */
string query_readable_message(object player, int ignore_labels) {
  string message;
  string file;
  string type;
  string lang;
  //string garbler;
  mixed mess;
  mixed *bit;
  mixed *read_mess;
  int pos;
  
  if(!player)
    player = this_player();
  
  read_mess = query_read_mess();
  if ( !sizeof( read_mess ) ) {
    return 0;
  }
  message = "";
  foreach ( bit in read_mess ) {
    mess = bit[ READ_MESS ];
    type = bit[ READ_TYPE ];
    lang = bit[ READ_LANG ];
    if ( functionp( mess ) ) {
      mess = evaluate( mess );
    }
    if ( stringp( mess ) ) {
      if ( sscanf( mess, "$$%s$$", file ) ) {
        mess = unguarded( (: read_file, file +".txt" :) );
        if ( !mess ) {
          mess = unguarded( (: NROFF_HAND->cat_file($(file)+"_nroff", 1) :) );
          if(!mess) {
            unguarded((: NROFF_HAND->create_nroff($(file),
                                                  $(file)+"_nroff") :));
            mess = unguarded((: NROFF_HAND->cat_file($(file)+"_nroff", 0) :));
            
            if(!mess)
              mess = "Warning: text file cannot be read!";
          }
        }
      }
    }
    mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
#ifdef DISABLED   
    if (stringp(mess)) {
      pos = strsrch(mess, "Written in ");
      while (pos != -1) {
        if ((pos == 0 && !type) || (pos > 0 && mess[pos-1] == '\n')) {
          mess = mess[0..pos-1] + "---> " + mess[pos..pos + 4] + " " +
            mess[pos + 5..];
        } else {
          mess = mess[0..pos + 4] + " " +
            mess[pos + 5..];
        }
        pos = strsrch(mess[pos + 5..], "Written in ");
      }
    }
#endif    
    if ( !LANGUAGES->query_language_magic( lang ) ) {
      if ( !type && player && (lang == player->query_default_language())) {
        mess += "\n";
      } else {
        if (stringp(lang)) {
          mess = "Written"+ ( type ? " in "+ type : "" ) +
            ( lang != "general" ? " in "+ capitalize(lang) : "" ) +
            ": "+ mess +"\n";
        } else {
          mess = "Written in some weird broken language: " + mess + "\n";
        }
      }
    }
    message += mess;
  }
  return message;
} /* query_readable_mesage() */

/**
 * This method returns the short description to use with the reading.
 * It will go: You read <read short>:
 * <p>
 * It will automaticly add a $name$ onto the end of the string for you.
 * This will be replaced with the correct a/the short for the message
 * which is printed.
 * @param player the player reading the message
 */
string query_read_short(object player, int ignore_labels) {
   string id;
   string *read_mess;

   read_mess = query_read_mess();
   if ( !arrayp(read_mess) || !sizeof( read_mess ) ) {
      return 0;
   }

   id = query_property("read id");
   if (id) {
      id += " $name$";
   } else {
      id = "$name$";
   }
   return id;
} /* query_read_short() */
// --- END [/mnt/home2/grok/lib/std/basic/read_desc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/close_lock_container.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/close_lock_container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629963   Available: 13577317
Inodes: Total: 5242880    Free: 4960136
1587 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/close_lock_container.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629963   Available: 13577317
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file should be used in containers that wish to notify the
 * above container that they are able to be registered or not.
 * The function we_moved(object from, object to) should be called
 * to allow the object to add and remove itself from the correct
 * places.
 * <p>
 * We only worry about the open/close state, if something is open and
 * locked we don't care.  (I guess stuff can be locked open
 * anyway).
 * @author Pinkfish
 * @started Thu Mar  5 16:20:10 CST 1998
 * @see we_moved()
 */
inherit "/std/basic/close_lock";
 
/** @ignore yes */
void set_closed() {
   ::set_closed();
   if (environment()) {
      environment()->remove_inventory_container(this_object());
   }
} /* set_closed() */

/** @ignore yes */
void reset_closed() {
   ::set_closed();
   if (environment()) {
      environment()->add_inventory_container(this_object());
   }
} /* reset_closed() */

/**
 * This method should be called when an object is moved.  This will
 * remove itself from the leaving container and add itself to the
 * new one.
 * @param from the object we came from
 * @param to the object we are going to
 */
void we_moved(object from, object to) {
   if (!query_closed()) {
      if (from) {
         from->remove_inventory_container(this_object());
      }
      if (to) {
         to->add_inventory_container(this_object());
      }
   }
} /* we_moved() */

/** @ignore yes */
void dest_me() {
   /* Please note, this is not designed to kill the object... */
   if (environment()) {
      environment()->remove_inventory_container(this_object());
   }
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/basic/close_lock_container.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/help_files.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/help_files.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629962   Available: 13577316
Inodes: Total: 5242880    Free: 4960136
3141 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/help_files.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629962   Available: 13577316
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This inheritable allows objects or rooms to have help attached to them.
 * @author Pinkfish
 */
#include <room.h>
#include <nroff.h>

mixed query_property(string name);
void add_property(string name, mixed value);

/**
 * This method sets up the help for the room.  All the help file names are
 * relative to /doc/room unless a complete path is specified.
 * @param help_file the help file name
 */
void add_help_file(string help_file) {
   string* help;

   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (help) {
      if (member_array(help_file, help) == -1) {
         help += ({ help_file });
      }
   } else {
      help = ({ help_file });
   }
   add_property(ROOM_HELP_FILE_PROPERTY, help);
} /* add_help_file() */

/**
 * This method removes the specified help file from the current ones.
 * @param help_file the help file name to remove
 */
void remove_help_file(string help_file) {
   string* help;

   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (help) {
      help -= ({ help_file });
      add_property(ROOM_HELP_FILE_PROPERTY, help);
   }
} /* remove_help_file() */

/**
 * This method returns the help files for the current room.
 * @return the array of help files
 */
string query_help_files() {
   return query_property(ROOM_HELP_FILE_PROPERTY);
} /* query_help_files() */

/**
 * This method is used to get the directory for the help files.
 * This should be overridden in higher up objects that use this object.
 */
string query_help_file_directory() {
   return "/doc/unknown/";
} /* query_help_file_directory() */

/*
 * Make a string from a nroff input...
 */
private string nroff_file(string name, int html) {
   string nroff_fn;
   string str;

   if (name[0] != '/') {
      name = query_help_file_directory() + name;
   }
   nroff_fn = NROFF_DIR + replace(name, "/", ".");
   if (html) {
      str = NROFF_HAND->html_file(nroff_fn, 1);
   } else {
      str = NROFF_HAND->cat_file(nroff_fn, 1);
   }
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      if (html) {
         str = NROFF_HAND->html_file(nroff_fn, 0);
      } else {
         str = NROFF_HAND->cat_file(nroff_fn, 0);
      }
   }
   return str;
} /* nroff_file() */

/**
 * This method returns the help data as a function pointer.
 * The function pointer needs to be evaluated to create the actual text.
 * @return the function pointer for the help text
 */
mixed* help_function() {
   string* help;
   string bing;
   string* ret;

   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (sizeof(help)) {
      ret = ({ });
      foreach (bing in help) {
         ret += ({ ({ replace_string(bing, "_", " "),
                   (: nroff_file($(bing), 0) :) }) });
      }
      return ret;
   }
   return 0;
} /* help_function() */

/**
 * This method returns the help as a string.
 * @return the help as a string
 */
string help_string() {
   string *help;
   string str;
   string bing;

   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (sizeof(help)) {
      str = "";
      foreach (bing in help) {
        str += nroff_file(bing, 0);
      }
      return str;
   }
   return 0;
} /* help() */
// --- END [/mnt/home2/grok/lib/std/basic/help_files.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/surface.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/surface.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629961   Available: 13577315
Inodes: Total: 5242880    Free: 4960136
2390 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/surface.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629961   Available: 13577315
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: surface.c,v 1.2 1998/03/03 05:24:41 pinkfish Exp $
 * $Log: surface.c,v $
 * Revision 1.2  1998/03/03 05:24:41  pinkfish
 * Added documentation.
 *
 * Revision 1.1  1998/01/06 03:59:10  ceres
 * Initial revision
 * 
*/
/**
 * This file contains the methods to handle surfaces, like book
 * shelves and stuff.
 * @see /std/shadows/misc/surface.c
 */
#include <surface.h>

nosave object *surface_shadows;

/**
 * This method returns the current set of surface shadows associated with
 * the object.
 * @return the current set of surface shadows
 * @see make_shadow()
 * @see check_shadows()
 */
object *query_surface_shadows() {
   return surface_shadows;
} /* query_surface_shadows() */

/**
 * This method makes a surface shadow which is attached to the given object.
 * @param thing the object to attach the shadow too
 */
void make_shadow( object thing ) {
  object shadow;

  shadow = clone_object( SURFACE_SHADOW );
  shadow->setup_shadow( thing, this_object() );
  if ( !surface_shadows ) surface_shadows = ({ });
  surface_shadows += ({ shadow });
} /* make_shadow() */

/**
 * This method checks to make sure all the shadows are currenly valid.  If
 * an invalid shadow is found it is removed.
 * <p>
 * The method check_environment() is called at the end of the function.
 * @see check_environment()
 */
void check_shadows() {
  int i;

  for ( i = 0; i < sizeof( surface_shadows ); i++ ) {
    if ( surface_shadows[ i ] ) {
      if ( environment() == (object)surface_shadows[ i ]->
          query_shadowed( surface_shadows[ i ] ) ) {
        surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] );
        surface_shadows = surface_shadows[0..i-1] + surface_shadows[i + 1..];
        i--;
      }
    } else {
      surface_shadows = surface_shadows[0..i-1] + surface_shadows[i + 1..];
      i--;
    }
  }
  call_out( "check_environment", 0 );
} /* check_shadows() */

/**
 * This method checks to make sure the environment has a shadow associated
 * with it.
 * @see check_shadows()
 */
void check_environment() {
  if ( environment() ) {
     make_shadow( environment() );
  }
} /* check_environment() */

/** @ignore yes */
void dest_me() {
  int i;

  for ( i = 0; i < sizeof( surface_shadows ); i++ )
    if ( surface_shadows[ i ] )
      surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] );
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/basic/surface.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/holdable.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/holdable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629961   Available: 13577315
Inodes: Total: 5242880    Free: 4960136
7172 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/holdable.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629961   Available: 13577315
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A nice file to allow you to setup an object as being holdable.  To deal
 * with this inheritable you only need to define the method held_this_item
 * if you wish to do anything when the item is held.
 * @author Pinkfish
 * @started Wed Feb  2 15:38:10 PST 2000
 */
#include <move_failures.h>

private int _my_limb;
private nosave int _no_limbs;
private object _holder;

int held_this_item(int held, object holder, mixed arg);
void set_no_limbs(int num);

void create() {
   _no_limbs = 1;
} /* create() */

/** @ignore yes */
mixed query_static_auto_load() {
  return ([ "no limbs" : _no_limbs
          ]);
} /* query_static_auto_load() */

/** @ignore yes */
void init_static_arg( mapping arg ) {
   if (!arg) {
      return ;
   }
   if (arg["no limbs"]) {
      set_no_limbs(arg["no limbs"]);
   }
} /* init_static_arg() */

/** @ignore yes */
mixed query_dynamic_auto_load() {
  return ([ "limb"       : (_holder ? _my_limb : -1),
            "limbs used" : (_holder ?
              sizeof(find_member(this_object(),
                                 _holder->query_holding())) : 0)
          ]);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg( mapping arg, mixed new_arg ) {
   if (!arg) {
      return ;
   }
   if (arg["limb"] != -1) {
      call_out( function( int pos, mapping arg, mixed new_arg ) {
         if ( environment() ) {
            environment()->set_hold(this_object(), pos,
                                    arg["limbs used"]);
         }
         held_this_item(2, environment(), new_arg);
      }, 0, arg["limb"], arg, new_arg);
   }
} /* init_dynamic_arg() */

/**
 * This method is called by the inheritable when the object is change from
 * being held to unheld, or vica versa.  This should be used to turn on 
 * and off light sources and so on.  The method will also be called with 
 * a 2 if the object was held and we are doing an initialisation sequence.
 * @param held 1 if the item is held, 0 if not, 2 if held on init
 * @param holder this is person already holding it when removed, new holder when held
 * @param arg an argument use in the autoloading, passed into init_dynamic_arg
 * @return 1 if the hold/remove was successful
 */
int held_this_item(int held, object holder, mixed arg) {
   return 1;
} /* held_this_item() */

/**
 * This method is called from the living object when we are held or
 * unheld.
 * @param ob the person holding us
 * @param limb the limb we are being held in
 */
int set_holder(object ob, int limb) {

   /* No!! We -unhold- items by setting ob to 0! */ 

   if (ob && environment() != ob) {
      // Only allow us to hold things in our environment.
      return 0;
   }
   this_object()->remove_hide_invis( "concealed" );
   if ( !ob ||
        ob != _holder) {
      if (!held_this_item(0, _holder, 0)) {
         return 0;
      }
   }
   if (ob) {
      if (!held_this_item(1, ob, 0)) {
         return 0;
      }
   }

   _holder = ob;
   _my_limb = limb;
   return 1;
} /* set_holder() */

/**
 * This method returns the current limb the object is being
 * held in.
 * @return the number limb the object is held in
 */
int query_my_limb() { return _my_limb; }

/**
 * This method returns the number of limbs that the object uses.
 * @return the number of limbs the object uses when held
 */
int query_no_limbs() { return _no_limbs; }

/**
 * This method sets the number of limbs the object uses when held.
 * @param num the number of limbs
 */
void set_no_limbs(int num) {
   if (num < 0) {
      return ;
   }
   _no_limbs = num;
} /* set_no_limbs() */

/**
 * This method should be called by the upper level moves.  The result
 * needs to be check, if it is not MOVE_OK then the move should be
 * stopped.
 * @param ob the object to move
 */
int move( mixed ob) {
   if ( ob != _holder && _holder ) {
      if ( !sizeof( _holder->set_unhold( this_object() ) ) ) {
         return MOVE_NO_UNHOLD;
      }
   }
   return MOVE_OK;
} /* move() */

/**
 * This method returns the person who is holding the object.
 * @return the person holding the object
 * @ignore yes
 */
object query_wielded() { return _holder; }

/**
 * This method returns the person who is holding the object.
 * @return the person holding the object
 */
object query_holder() { return _holder; }

/**
 * This method deals with removing ourselves as a holder when dested.
 * @ignore yes
 */
void dest_me() {
   if (_holder) {
      _holder->set_unhold(this_object());
   }
} /* dest_me() */

/** 
 *
 * Attempts to free up enough limbs for this_object to be held.  If
 * items are dropped to make this possible, who is notified.  If 
 * enough limbs are freed, attempts to hold this_object.  If the position
 * is undefined (ie: not specified) then it will try and choose a limb
 * by itself.
 * <p>
 * The return numbers are the limb numbers that were used by holding the
 * item.
 * <p>
 * hold_item: As designed by Tannah!
 * @param who The living object trying to hold this one.
 * @param pos the position to hold the item in
 * @return the an (int *) if successful or ({ }) if not enough limbs are freed
 */
varargs int *hold_item( object who, int pos ) {
   object ob;
   object *held_things;
   object *dropped_things = ({ });
   int num_limbs;

  /* If a particular position is specified, put that position at
   * the front of the queueueue, continue from it to the end, then
   * start at the beginning */

  if( !undefinedp( pos ) && pos != -1 ) {
    /* is the position number valid? */
    if( pos < 0 || pos >= sizeof( who->query_holding() ) )
      return ({});
    /* is there already something in that hand that can't be put down? */
    ob = who->query_holding()[ pos ];
    if( ob ) {
      if( !sizeof( who->set_unhold( ob ) ) )
        return ({});
      else dropped_things += ({ ob });
    }
    /* all is well...continue on */
    held_things = who->query_holding()[pos..] + 
                  who->query_holding()[0..pos-1];
  }

  /* Otherwise use the standard order */
  else {
    held_things = who->query_holding();
    pos = -1;
  }

  if (pos == -1)  num_limbs = this_object()->query_no_limbs();
  else num_limbs = 1;

  tell_creator( who, "FL: %d, NL: %d, ob: %O\n", who->query_free_limbs(),
      num_limbs, this_object() );
  tell_creator( who, "Dropped things: %O\n", dropped_things );      

  /* Try to put down enough things to hold this object */
  for( int i = 0; who->query_free_limbs() < 
      num_limbs && i < sizeof( held_things ); i++ ) {
    tell_creator( who, "freeing limbs\n" );
    ob = held_things[i]; 

    //We stopped holding something
    if( ob && sizeof( who->set_unhold( ob ) ) )  
      dropped_things += ({ ob });
  }
   
  /* Tell the player what he's put down: */
  if ( sizeof( dropped_things ) )
    tell_object( who, "You put down " + query_multiple_short( 
        dropped_things ) + ".\n" );

  /* Can he hold the item now? */
  if( who->query_free_limbs() >= num_limbs ) {
     //Excellent!
     return who->set_hold( this_object(), pos, num_limbs );
  }

   tell_object( who, "You can't free up enough limbs to use "+
       this_object()->a_short() + ".\n" );
   return ({ });  // Nope, he can't.
} /* hold_item() */
// --- END [/mnt/home2/grok/lib/std/basic/holdable.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/extra_look.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/extra_look.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629959   Available: 13577313
Inodes: Total: 5242880    Free: 4960136
2929 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/extra_look.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629959   Available: 13577313
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: extra_look.c,v 1.5 2001/09/16 14:27:45 wodan Exp $
 * $Log: extra_look.c,v $
 * Revision 1.5  2001/09/16 14:27:45  wodan
 * hope i fixed the type error, seems some code adds extra looks to strings, rather then objects.
 *
 * Revision 1.4  2001/07/15 03:25:42  ceres
 * Can't figure out the problem
 *
 * Revision 1.3  2001/01/28 18:40:13  drakkos
 * Updated the autodoc a leetle.
 *
 * Revision 1.2  2000/09/14 01:27:05  shrike
 * added a bit more documentation to add_extra_look.
 *
 * Revision 1.1  1998/01/06 03:59:10  ceres
 * Initial revision
 *
*/
/**
 * Handles adding bits to the long description of objects.
 * @author Pinkfish
 */
/* /std/basic/extra_looks */

private nosave object *extra_looks;

void create() {
  extra_looks = ({ });
} /* create() */

/**
 * This method creates the extra long stringsbased on the current list
 * of objects to use an extra_look on.  The function extra_look() is
 * called on every object with this_object() passed in as the first
 * (and only) parameter.  If the result is non-zero it is added onto
 * the output.
 * @see add_extra_look()
 * @see remove_extra_look()
 * @see query_extra_look_list()
 * @return the extra look string
 */
string calc_extra_look() {
  int i;
  string s1, s2;

  s1 = "";
  if (!extra_looks) {
    extra_looks = ({ });
  }
  for (i = 0; i < sizeof(extra_looks); i++) {
    if (extra_looks[i]) {
      s2 = (string)((extra_looks[i])->extra_look(this_object()));
      if(s2)
        s1 += s2;
    } else {
      extra_looks = delete(extra_looks, i, 1);
      i--;
    }
  }
  return s1;
} /* calc_extra_look() */

/**
 * This method adds an object into the list of extra look objects.
 * ob will need to have a string extra_look( object ) function defined on
 * it which will actually give the extra look string. ob->extra_look() is
 * called with the object to which you are adding the extra look.
 * @param ob the object to add
 * @see calc_extra_look()
 * @see remove_extra_look()
 * @see query_extra_look_list()
 */
void add_extra_look(object ob) {
  if(member_array(ob, extra_looks) != -1) {
    return;
  }
  if(stringp(ob))
    ob = find_object((string)ob);
  extra_looks += ({ ob });
} /* add_extra_look() */

/**
 * This method removes the object from the list of extra look objects.
 * @param ob the object to remove
 * @see calc_extra_look()
 * @see add_extra_look()
 * @see query_extra_look_list()
 */
void remove_extra_look(object ob) {
  int i;

  i = member_array(ob, extra_looks);
  if (i < 0) {
    return;
  }
  extra_looks = delete(extra_looks, i, 1);
} /* remove_extra_look() */

/**
 * This method returns the current list of objects to be used for
 * the extra look list.
 * @see add_extra_look()
 * @see remove_extra_look()
 * @see calc_extra_look()
 * @return the array of extra look objects
 */
object *query_extra_look_list() {
  return extra_looks;
} /* query_extra_look_list() */
// --- END [/mnt/home2/grok/lib/std/basic/extra_look.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/scroll_book_react.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/scroll_book_react.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629958   Available: 13577312
Inodes: Total: 5242880    Free: 4960136
3899 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/scroll_book_react.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629958   Available: 13577312
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: scroll_book_react.c,v 1.3 2002/08/08 02:08:52 ceres Exp $
 */
/**
 * This is the reaction handling code for both spell books and scrolls.
 */
#include <tasks.h>

#define SKILL "magic.items.scroll"
#define CONTROL_SKILL "magic.spells.special"

/**
 * This method is called to destroy the scroll.  This must be overridden
 * at a higher level.
 */
void destroy_this_scroll() {
} /* destry_this_scroll() */

/**
 * This method checks to see if the spell reacts with anything.
 * @param paper who to check (us hopefull)
 */
void check_react(object player) {
   object ob;
   int level;
   int ac;
   string check_spell;
   object paper;
   object *items;
   object env;

   if (!environment(player)) {
      return;
   }

   // First make sure we are in a player or a pet/fruitbat etc.
   env = environment(player);
   while (env && !living(env)) {
      env = environment(env);
   }

   // Check to see if they are owned by someone.
   if (env && !userp(env) && !env->query_owner()) {
      return ;
   }

   items = filter(deep_inventory(environment(player)),
                  (: $1->query_magic_scroll() ||
                     $1->query_spell_book() :));

   foreach (paper in items) {
      level += paper->query_spell_power_level();
   }

   // 
   // No need to do this since we should be included in the above list.
   //
   //level += _spell->query_power_level();

   if (random(sqrt(level)) <= 5 + random(5)) {
      return;
   }
  
   // find out who is carrying this object
   ob = environment(player);
   while(ob) {
      if(living(ob)) {
         break;
      } else {
         ob = environment(ob);
      }
   }

   if(!ob || !living(ob)) {
      return;
   }

   if(ob) {
      switch(TASKER->perform_task(ob, CONTROL_SKILL, level*2 + random(4),
                                  TM_FREE)) {
      case AWARD:
         tell_object(ob, "Suddenly the spell "+
                      this_object()->query_spell_name()+ " on the "+
                     player->the_short()+" gets out of control and tries to go "
                     "wild.\n");
         tell_room(environment(ob), "Suddenly " + ob->one_short() +
                   " looks very startled as the spell " +
                   this_object()->query_spell_name() +
                   " on "+player->the_short()+" gets out of control and "
                   "tries to go wild.\n", ob);
         
         write("%^YELLOW%^You feel you have a better grasp of controlling "
               "spells on scrolls.\n.%^RESET%^\n" );
      case SUCCEED:
      
         return;
      default:
         tell_object(ob, "Suddenly the spell " +
                     this_object()->query_spell_name() + " on the "+
                     player->the_short() +
                     " gets out of control and tries to go wild.\n");
         tell_room(environment(ob), "Suddenly " + ob->one_short() +
                   " looks very startled as the spell " + 
                   this_object()->query_spell_name() +
                   " on " + player->the_short() + " gets out of control and "
                   "tries to go wild.\n", ob);
       
         tell_object(ob, "Unfortunately you cannot get control of it and "
                     "before flying away into nowhere it tears wildly at "
                     "your mind.\n");
         tell_room(environment(ob), "Unfortunately "+ob->one_short()+" cannot "
                   "get control of it and it flies away to freedom.\n", ob);
   
   
         ac = (int)ob->query_ac("magic", level * 10);
         level -= ac;
   
         ob->adjust_hp(-level, this_object());
         ob->adjust_tmp_int(-2 + random(2));
   
         destroy_this_scroll();
         break;
      }
   }
} /* check_react() */

/** @ignore yes */
string query_death_reason() {
   return " a spell going wild and getting out of control.";
} /* query_death_reason() */
// --- END [/mnt/home2/grok/lib/std/basic/scroll_book_react.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/print_object.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/print_object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629957   Available: 13577311
Inodes: Total: 5242880    Free: 4960136
1457 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/print_object.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629957   Available: 13577311
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: print_object.c,v 1.1 1998/01/06 03:59:10 ceres Exp $
 * $Log: print_object.c,v $
 * Revision 1.1  1998/01/06 03:59:10  ceres
 * Initial revision
 * 
*/
/**
 * This class prints out an object in a useful format.
 * Mostly used for debugging.  The resuls of this can mostly be
 * acheived using <code>sprintf("%O", ob)</code>.
 */

/**
 * This method returns the value of the variable in 
 * useful format.  This can mostly be emulated with the
 * use of <code>sprintf("%O", ob)</code>.
 * @param ob the variable to print out info for
 * @param off the current depth offset
 * @return a nice string
 */
varargs string print_object(mixed ob, int off) {
  int i;

  write("                   "[0..off]);
  if (intp(ob)) {
    write(ob+"\n");
    return "int";
  }
  if (stringp(ob)) {
    write("\""+ob+"\"\n");
    return "string";
  }
  if (objectp(ob)) {
    write(file_name(ob)+"  ");
    if (ob->short())
      write("(short) "+ob->short()+"\n");
    else if (ob->query_name())
      write("(name)  "+ob->query_name()+"\n");
    else
      write("(Argghhhh)\n");
    return "object";
  }
  if (pointerp(ob)) {
    if (!sizeof(ob))
      write("({ })\n");
    else {
      write("({  -- size "+sizeof(ob)+"\n");
      for (i=0;i<sizeof(ob);i++)
        print_object(ob[i], off+3);
      write("                       "[0..off]+"})\n");
    }
    return "pointer";
  }
  return "oh dear";
} /* print_object() */
// --- END [/mnt/home2/grok/lib/std/basic/print_object.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/consecrate.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/consecrate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629956   Available: 13577310
Inodes: Total: 5242880    Free: 4960136
1240 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/consecrate.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629956   Available: 13577310
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Inheritable to handle basic consecration things.
 * We can consecrate any item without using shadows or properties.
 * Hooray!
 * @author Terano
 * @started 6/6/2001
 */

private string _god;

/**
 * @ignore
 */
void set_god( string deity ) {
  if ( stringp( deity ) ) 
    deity = lower_case( deity );
  _god =  deity;
  return;
}

/**
 * Consecrates an item
 */
void set_deity( string deity ) {
  if ( stringp( deity ) ) 
    deity = lower_case( deity );
  _god = deity;
  return;
}

/**
 * @ignore
 */
string query_god() { return _god; }

/**
 * @ignore
 */
string query_deity() { return _god; }

/**
 * Returns 1 if an item is queried to a particular god.
 * @arg God Name of the God to check.
 */
int query_consecrated( string god ) { 
  if ( !stringp( god ) ) 
    return 0;

  god = lower_case( god );

  if ( _god )
    return god == _god; 

  return this_object()->query_property( god );
}

/**
 * @ignore
 */
mixed *stats() {
   return 
      ({
         ({ "consecrated", _god }),
      });
} 

/**
 * @ignore
 */
mapping query_static_auto_load() {
   return ([
      "god" : _god      
   ]);
}

/**
 * @ignore
 */
void init_static_arg( mapping map ) {
   if ( !undefinedp( map[ "god" ] ) )
      _god = map[ "god" ];
}

// --- END [/mnt/home2/grok/lib/std/basic/consecrate.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/virtual_quit_control.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/virtual_quit_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629955   Available: 13577309
Inodes: Total: 5242880    Free: 4960136
4035 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/virtual_quit_control.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629955   Available: 13577309
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This method handles problems where players log out in places which are
 * virtually controlled.  It does the effort to put them back in, but does
 * it in a way that is recursive.  So if they are on a horse in a
 * terrain it will work properly.
 * @author Pinkfish
 * @started Wed Sep 22 18:24:40 PDT 1999
 * @example
 * inherit "/std/basic/virtual_quit_control";
 *
 * void player_quitting(object player, object place) {
 *    string pos;
 *
 *    pos = check_start_pos(environment(place));
 *    // Doesn't need to last long since we save immediately.
 *    player->add_property(START_PLACE, pos, 10);
 *    ::player_quitting(player, environment(place));
 * } /\* player_quitting() *\/
 *
 * // Move the player to the right spot when they login.
 * void event_enter(object player) {
 *    player->move(player->query_property(START_PLACE));
 * } /\* move_player_to_real_location() *\/
 */

/**
 * This method is called on the quit handler when a player quits.
 * @param player the player
 * @param place the place they quit from
 * @return the last position (if that needs to be saved).
 */
protected string find_start_pos(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char; 

   if ( place ) {
      // query_quit_handler() can return a string, or a two-element
      // array ({ last_pos, saved_co_ords })

      //15-06-02 - Terano changed it to pass the player quitting as well.
      quit_env = place->query_quit_handler( player );
      if (arrayp(quit_env)) {
         last_pos = quit_env[0];
      } else {
         last_pos = (string)quit_env;
      }
      if ( last_pos ) {
         last_pos->player_quitting( player, place );
      } else {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }

   // Check and make sure they are not somewhere they shouldn't be.
   if (last_pos && last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {

      // cres and their test chars may start in their own rooms

      test_char = player->query_property( "test character" );

      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }

      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if (!player->query_creator() ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }

   return last_pos;
} /* find_start_pos() */

/**
 * This method is called on the quit handler when a player quits.
 * @param player the player
 * @param place the place they quit from
 * @return the last position (if that needs to be saved).
 */
protected int * find_start_coord(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char;

   if ( place ) {
      // query_quit_handler() can return a string, or a two-element
      // array ({ last_pos, saved_co_ords })
      quit_env = place->query_quit_handler();
      if (arrayp(quit_env)) {
         return quit_env[1];
      } else {
         last_pos = (string)quit_env;
      }
      if ( !last_pos ) {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }

   // Check and make sure they are not somewhere they shouldn't be.
   if (last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {

      // cres and their test chars may start in their own rooms
      test_char = player->query_property( "test character" );

      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }

      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if( !( player->query_creator() ||
                player->query_property( "test character" ) ) ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }

   return last_pos->query_co_ord();
} /* find_start_coord() */
// --- END [/mnt/home2/grok/lib/std/basic/virtual_quit_control.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/close_lock.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/close_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629954   Available: 13577308
Inodes: Total: 5242880    Free: 4960136
24015 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/close_lock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629954   Available: 13577308
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// /std/basic/close_lock
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: close_lock.c,v 1.39 2003/03/06 11:04:14 runtime Exp $
 *
 */
/**
 * This class keeps track of whether things are open or closed,
 * locked or unlocked.  Trap functions that are triggered when
 * an object is opened or unlocked are also handled.  When
 * you need an object that is locked you should remember to
 * use set_key() and set_difficulty().  When cloning an object
 * and moving other objects inside it you should remember to
 * make sure the object is open before moving things into it,
 * and then close it if neccessary.
 *
 * @author Gototh
 */
#include <move_failures.h>
#include <tasks.h>
#include <clothing.h>

#define MAX_INVENT 40
#define C_CLOSED 1
#define C_TRANS 2
#define C_OPAQUE 1

#define LOCKED        1
#define CLOSED        2
#define CLOSED_LOCKED 3

#define SKILL "covert.manipulation.sleight-of-hand"

#define STEALTH_NONE        0
#define STEALTH_FAILED      1
#define STEALTH_SUCCEEDED   2

#define TP this_player()
#define TO this_object()

int do_open();
int do_close();
int do_lock(object *keys);
int do_unlock(object *keys);

private int _locked;
private int _closed;

private string _pick_skill;

private nosave int _stuck;
private nosave int _trans;
private nosave int _difficulty;
private nosave int _autolock;

private nosave string _trap_open_func;
private nosave string _trap_lock_func;

private nosave object _trap_open_ob;
private nosave object _trap_lock_ob;

private nosave mixed _key;

/**
 * @ignore yes
 */
void create() {
  _difficulty = 5;
  _pick_skill = "covert.lockpick.doors";
} /* create() */

/**
 * This sets the object as being open.  Note that to find out
 * if an object is open we use query_closed() which will return
 * 0 if the object is open.
 *
 * @see set_closed()
 * @see query_closed()
 */

void set_open() {
    if (!_closed)
        return;
    _closed = 0;
    _locked = 0;
    if (environment()) {
      event( ({ environment(), TO, }), "open", TP);
    } else if (TO->query_my_room()) {
      event( ({ TO->query_my_room(), TO, }), "open", TP);
    }
} /* set_open() */

/**
 * This sets the object as being closed.  If you are moving
 * objects into the object, make sure that you do not set
 * the object as closed and then try to move the objects in.
 * Move the objects in and then close the object.
 *
 * @see set_open()
 * @see query_closed()
 */

void set_closed() {
    if (_closed)
        return;
    _closed = 1;
    if (environment()) {
      event( ({ environment(), TO, }), "close", TP);
    } else if (TO->query_my_room()) {
      event( ({ TO->query_my_room(), TO, }), "close", TP);
    }
} /* set_closed() */

/**
 * This function tells you whether an object is open or closed.
 * It returns 1 if the object is closed, and 0 if the object is open.
 *
 * @return Return 1 if closed, 0 if open.
 * @see set_open()
 * @see set_closed()
 */
int query_closed() {
  return _closed;
} /* query_closed() */

/**
 * This function tells you whether an object is open or closed.
 * It returns 1 if the object is open and 0 if the object is closed.
 *
 * @return Return 1 if open, 0 if closed.
 * @see set_open()
 * @see set_closed()
 */
int query_open() {
  return !_closed;
}

/**
 * This sets the object as being locked.  Remember to set the
 * object as being closed before using this.  In most cases you
 * should probably use set_key() to set the key which opens the
 * lock and use set_difficulty() to set the skill level required
 * to pick the lock.
 *
 * @see set_open()
 * @see set_closed()
 * @see set_key()
 * @see set_difficulty()
 */
void set_locked() {
    if (!_closed)
        return;
    if (_locked)
        return;
    _locked = 1;
    if (environment()) {
        event( ({ environment(), TO, }), "lock", TP);
    } else if (TO->query_my_room()) {
        event( ({ TO->query_my_room(), TO, }), "lock", TP);
    }
} /* set_locked() */

/**
 * This sets the object as being unlocked.
 *
 * @see set_locked()
 */
void set_unlocked() {
    if (!_locked)
        return;
    _locked = 0;
    if (environment()) {
        event( ({ environment(), TO, }), "unlock", TP);
    } else if (TO->query_my_room()) {
        event( ({ TO->query_my_room(), TO, }), "unlock", TP);
    }
} /* set_unlocked() */

/**
 * This tells us whether an object is locked.  It returns 1 if
 * the object is locked and 0 is the object is unlocked.
 *
 * @see set_locked()
 * @see set_unlocked()
 * @return Return 1 if locked and 0 if unlocked.
 */

int query_locked() {
  return _locked;
} /* query_locked() */

/**
 * This tells us whether an object is unlocked.  It returns 1 if
 * the object is unlocked and 0 is the object is locked.
 *
 * @see set_locked()
 * @see set_unlocked()
 * @return Return 1 if unlocked and 0 if locked.
 */

int query_unlocked() {
  return !_locked;
} /* query_unlocked() */

/**
 * This sets the object so that it will lock automatically when closed.
 *
 * @param number 1 for autolock, 0 for no autolock.
 */
void set_autolock(int number) { _autolock = number; }

/**
 * This tells us whether an object will lock automatically when closed.
 *
 * @see set_autolock()
 * @return 1 for true 0 for false;
 */
int query_autolock() { return _autolock; }

/**
 * This sets the property of the key that will unlock the object. This can
 * be a string, or a function pointer which will evaluate to a string.
 *
 * @see set_locked()
 * @param val The property the key must have to unlock the object.
 */
void set_key(mixed val) {
    if (!stringp(val) && !functionp(val))
        return;
    _key = val;
} /* set_key() */

/**
 * This returns the property of the key that will unlock the
 * object.
 *
 * @see set_key()
 */
string query_key() {
    if (stringp(_key))
        return _key;
    if (functionp(_key))
        return evaluate(_key);
    return 0;
} /* query_key() */

/**
 * This sets the skill that will be used when attempting to
 * pick the lock.  By default it is set to "covert.lockpick.safes"
 * so it need only be changed if you want to check a different
 * skill.
 *
 * @see query_pick_skill()
 * @see set_difficulty()
 * @param str The skill to use when picking the lock.
 */

void set_pick_skill(string str) {
  _pick_skill = str;
} /* set_pick_skill() */

/**
 * This returns the name of the skill which is used when
 * determining if the object can be unlocked.
 *
 * @see set_pick_skill()
 */

string query_pick_skill() {
  return _pick_skill;
} /* query_pick_skill() */

/**
 * This sets how difficult the lock on an object is to pick.
 * By default it is set to 200.
 *
 * @see query_difficulty()
 * @param i The difficulty of the lock to pick.
 */

void set_difficulty(int i) {
  _difficulty = i;
} /* set_difficulty() */

/**
 * This returns the difficulty picking the lock on the object.
 * By default it is set to 200 unless it has been changed with
 * set_difficulty().
 *
 * @see set_difficulty()
 */

int query_difficulty() {
  return _difficulty;
} /* query_difficulty() */

/**
 * This can set an object as being stuck, or make it unstuck.
 * Stuck objects cannot be opened, closed, locked or unlocked.
 * Using set_stuck(1) will make the object stuck, and set_stuck(0)
 * will unstick it.
 *
 * @see query_stuck()
 * @param i Use 1 to make the object stuck, and 0 to unstick it.
 */

void set_stuck(int i) {
  _stuck = i;
} /* set_stuck() */

/**
 * This tells you whether an object is stuck or not.  It will
 * return 1 if the object is stuck, and 0 if the object is not
 * stuck.
 *
 * @see set_stuck()
 * @return Return 1 if the object is stuck, and 0 if it is not.
 */

int query_stuck() {
  return _stuck;
} /* query_stuck() */

/**
 * This sets the object as being transparent.
 * A transparent object is one in which you can see the
 * inventory even if it is closed.
 *
 * @see reset_transparent()
 * @see query_transparent()
 */

void set_transparent() {
  _trans = C_TRANS;
} /* set_transparent() */

/**
 * This method removes the current objects transparent
 * status.
 * A transparent object is one in which you can see the
 * inventory even if it is closed.  This is also
 * used for light propogration.
 *
 * @see set_transparent()
 * @see query_transparent()
 */

void reset_transparent() {
  _trans = 0;
} /* reset_transparent() */

/**
 * This method returns the current transparent
 * value of the object.
 * A transparent object is one in which you can see the
 * inventory even if it is closed.  This is also
 * used for light propogration.
 *
 * @see reset_transparent()
 * @see query_transparent()
 * @return 1 if the object is transparent
 */

int query_transparent() {
  return _trans;
} /* query_transparent() */

/**
 * This sets the function to be called when someone attempts to
 * open the object.  The function does not have to be in the
 * object's file, and can be specified using the 'ob' paramater.
 * In most cases the function will be stored in the same file,
 * so use this_object() in these cases.
 *
 * The function will be called with a single string parameter of "open" or
 * "close"
 *
 * @param ob The object in which the function is stored.
 * @param func The function to be called.
 * @see query_open_trap_func()
 * @see query_open_trap_ob()
 */

void set_open_trap(object ob, string func) {
  _trap_open_func =  func;
  _trap_open_ob = ob;
} /* set_open_trap() */

/**
 * This returns the name of the function to be called when
 * someone tries to open the object.
 *
 * @return The function to be called when the object is opened.
 * @see set_open_trap()
 * @see query_open_trap_ob()
 */

string query_open_trap_func() {
  return _trap_open_func;
} /* query_open_trap_func() */

/**
 * This returns the object on which the trap function is stored.
 * The trap function is called when someone tries to open the
 * the object.
 *
 * @return The function to be called when the object is opened.
 * @see set_open_trap()
 * @see query_open_trap_func()
 */

object query_open_trap_ob() {
  return _trap_open_ob;
} /* query_open_trap_ob() */

/**
 * This sets the function to be called when someone attempts to
 * unlock the object.  The function does not have to be in the
 * object's file, and can be specified using the 'ob' paramater.
 * In most cases the function will be stored in the same file,
 * so use this_object() in these cases.
 *
 * The function will be called with a single string parameter of "lock",
 * "unlock" or "pick"
 *
 * @param ob The object in which the function is stored.
 * @param func The function to be called.
 * @see query_lock_trap_func()
 * @see query_lock_trap_ob()
 */
void set_lock_trap(object ob, string func) {
  _trap_lock_func = func;
  _trap_lock_ob = ob;
} /* set_unlock_trap() */

/**
 * This returns the name of the function to be called when
 * some attempts to unlock the object.
 *
 * @return The function to be called when someone attempts
 * to unlock the object.
 * @see set_open_trap()
 * @see query_open_trap_ob()
 */

string query_lock_trap_func() {
  return _trap_lock_func;
} /* query_lock_trap_func() */

/**
 * This returns the object on which the trap function is stored.
 * The trap function is called when someone tries to unlock the
 * the object.
 *
 * @return The function to be called when the object is opened.
 * @see set_open_trap()
 * @see query_open_trap_func()
 */

object query_lock_trap_ob() {
  return _trap_lock_ob;
} /* query_lock_trap_ob() */

/**
 * This method returns the closed and locked status.  The status is
 * 0 if open and unlocked, 1 if locked, 2 if closed and 3 if closed
 * and locked.
 * @return closed and locked status
 */
int query_closed_locked_status() {
    if (_closed && _locked) {
        return CLOSED_LOCKED;
    }
    if (_closed) {
        return CLOSED;
    }
    if (_locked) {

        return LOCKED;
    }
    return 0;
} /* query_closed_locked_status() */

/**
 * This method adds the lock commands to the specified player.
 * It's been abstracted out of init() to make it easier for some
 * odd situations (like the t-shop).
 */
void add_close_lock_commands(object player) {
  if(!player)
    return;

    player->add_command("open", TO,
        "<direct:object:me-here>",
        (: do_open() :) );
    player->add_command("close", TO,
        "<direct:object:me-here>",
        (: do_close() :) );
    if (TO->query_key()) {
        player->add_command("lock", TO,
            "<direct:object:me-here>",
            (: do_lock(0) :) );
        player->add_command("lock", TO,
            "<direct:object:me-here> with <indirect:object:me>",
            (: do_lock($1) :) );
        player->add_command("unlock", TO,
            "<direct:object:me-here>",
            (: do_unlock(0) :) );
        player->add_command("unlock", TO,
            "<direct:object:me-here> with <indirect:object:me>",
            (: do_unlock($1) :) );
    }
} /* add_close_lock_commands() */

/**
 * @ignore yes
 */

void init() {
    add_close_lock_commands(this_player());
} /* init() */

/**
 * @ignore yes
 */
string short_status() {
    return "";
} /* short_status() */

/**
 * @ignore yes
 */
string long_status() {
    // If it is stuck in one state don't bother telling us the state.
    if (TO->query_stuck())
        return "";

    switch (query_closed_locked_status()) {
        case CLOSED_LOCKED:
            return "It is closed and locked.\n";
        case CLOSED:
            return "It is closed.\n";
        default:
            return "It is open.\n";
    }
} /* long_status() */

/**
 * @ignore yes
 */
int check_stealth() {
    mapping hide_invis;
    int hiding, sneaking, difficulty, light, my_light, items_blocking;

    hide_invis = (mapping) TP->query_hide_invis();
    hiding = undefinedp(hide_invis["hiding"]) ? 0 : 1;
    sneaking = TP->query_sneak_level() ? 1 : 0;

    if (!hiding && !sneaking)
        return STEALTH_NONE;

    my_light = TP->query_light();
    light = environment(TP)->query_light();

    difficulty = light + (4 * my_light) / (light + 1);

    items_blocking = sizeof(CLOTHING_HANDLER->query_items_blocking(TO, TP));

    if (items_blocking) {
        difficulty += 50 * items_blocking;
    }

    debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                  difficulty, SKILL, TP->query_skill_bonus( SKILL ) );
    switch (TASKER->perform_task(TP, SKILL, difficulty, TM_FREE)) {
        case AWARD:
            write("%^YELLOW%^" + ({
                "You discover something that lets your fingers move more nimbly.",
                "You find yourself capable of deceiving the eye with greater ease "
                "than before.",
                "You realise how to deceive the eye more effectively."
                })[ random(3) ] + "%^RESET%^\n" );
        case SUCCEED :
            return STEALTH_SUCCEEDED;
        default :
            return STEALTH_FAILED;
    }
} /* check_stealth() */

/**
 * @ignore yes
 */
int do_unlock(object *keys) {
    object *gkeys = ({ });
    string key = TO->query_key();
    int inv = 0;
    if (!_locked) {
        TP->add_failed_mess(TO,
            "$D $V$0=isn't,aren't$V$ locked.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (!_closed) {
        TP->add_failed_mess(TO,
            "$D $V$0=isn't,aren't$V$ closed.\n",
            ({ }) );
        return 0;
    }
    if (!key) {
        TP->add_failed_mess(TO,
            "$D $V$0=doesn't,don't$V$ have a lock.\n",
            ({ }) );
        return 0;
    }

    if (key != "by hand") {
        if (!keys || !sizeof(keys)) {
            keys = all_inventory(TP);
            inv = 1;
        }
        gkeys = filter(keys, (: $1->query_property( $(key) ) :) );
        if (!sizeof(gkeys)) {
            if (!inv) {
                TP->add_failed_mess(TO,
                    "You cannot $V $D with $I.\n",
                        keys);
                return 0;
            }
            TP->add_failed_mess(TO,
                "You cannot $V $D.\n",
                ({ }) );
            return 0;
        }
        gkeys[0]->use_key(TO);
    }

    if (_trap_lock_func && _trap_lock_ob) {
        if (!call_other(_trap_lock_ob, _trap_lock_func, "unlock", TO, TP)) {
            return 0;
        }
    }

    set_unlocked();
    switch (check_stealth()) {
        case STEALTH_SUCCEEDED:
          if (sizeof (gkeys)) {
            TP->add_succeeded_mess(TO, ({
                "$N $V $D with $I, managing to stay unnoticed.\n",
                "", }),
                ({ ( gkeys[0] ) }) );
          } else {
            TP->add_succeeded_mess(TO, ({
                "$N $V $D, managing to stay unnoticed.\n",
                "", }),
                ({ }) );
          }

            break;
        case STEALTH_FAILED:
            TP->add_succeeded_mess(TO,
                "$N unsuccessfully tr$y to " + query_verb() + " $D while "
                "staying unnoticed.\n", ({ }) );
            break;
        default:
            if (sizeof (gkeys)) {
              TP->add_succeeded_mess(TO,
                 "$N $V $D with $I.\n", ({ gkeys[0] }) );
            } else {
              TP->add_succeeded_mess (TO, "$N $V $D.\n", ({ }));
            }
            break;
    }
    return 1;
} /* do_unlock() */

/**
 * @ignore yes
 */
int do_lock(object *keys) {
    object *gkeys = ({ });
    string key = TO->query_key();
    int inv = 0;
    if (_locked) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already locked.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (!_closed && !do_close()) {
        TP->add_failed_mess(TO,
            "$D $V$0=isn't,aren't$V$ closed.\n",
            ({ }) );
        return 0;
    }
    if (!key) {
        TP->add_failed_mess(TO,
            "$D $V$0=doesn't,don't$V$ have a lock.\n",
            ({ }) );
        return 0;
    }

    if (key != "by hand") {
        if (!keys || !sizeof(keys)) {
            keys = all_inventory(TP);
            inv = 1;
        }
        gkeys = filter(keys, (: $1->query_property( $(key) ) :) );
        if (!sizeof(gkeys)) {
            if (!inv) {
                TP->add_failed_mess(TO, "You cannot lock $D with $I.\n", keys);
                return 0;
            }
            TP->add_failed_mess(TO, "You cannot lock $D.\n", ({ }) );
            return 0;
        }
        gkeys[0]->use_key(TO);
    }

    if (_trap_lock_func && _trap_lock_ob) {
        if (!call_other(_trap_lock_ob, _trap_lock_func, "lock", TO, TP)) {
            return 0;
        }
    }

    set_locked();
    switch (check_stealth()) {
    case STEALTH_SUCCEEDED:
          if (sizeof (gkeys)) {
            TP->add_succeeded_mess(TO, ({
                "$N lock$s $D with $I, managing to stay unnoticed.\n",
                "", }),
                ({ ( gkeys[0] ) }) );
          } else {
            TP->add_succeeded_mess(TO, ({
                "$N lock$s $D, managing to stay unnoticed.\n",
                "", }),
                ({ }) );
          }
        break;
      case STEALTH_FAILED:
        TP->add_succeeded_mess(TO, "$N unsuccessfully tr$y to " +
                               "lock $D while staying unnoticed.\n",
                               ({ }) );
        break;
      default:
        if (sizeof (gkeys)) {
          TP->add_succeeded_mess(TO,
                                 "$N lock$s $D with $I.\n", ({ gkeys[0] }) );
        } else {
          TP->add_succeeded_mess (TO, "$N lock$s $D.\n", ({ }));
        }
        break;
    }
    return 1;
} /* do_lock() */

/**
 * @ignore yes
 */
int pick_lock(object player) {
    if (_trap_lock_ob
     && !call_other(_trap_lock_ob, _trap_lock_func, "pick", TO, player)) {
        return 0;
    }
    set_locked();
    return 1;
} /* pick_lock() */

/**
 * This is called when someone successfully unlocks the object.
 * If there is a trap, and the trap function returns true, the
 * object will not be opened.  If the trap function returns
 * false, the object will still be opened even if the trap is
 * sprung.
 *
 * @param player The player who is unlocking the object.
 *
 * @return Returns 1 if the object was unlocked, and 0 otherwise.
 */
int pick_unlock(object player) {
    if (_trap_lock_ob
     && !call_other(_trap_lock_ob, _trap_lock_func, "pick", TO, player)) {
        return 0;
    }
    set_unlocked();
    return 1;
} /* pick_unlock() */

/**
 * @ignore yes
 */
int do_open() {
    if (!_closed) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already open.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (_locked && !do_unlock(0)) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ locked.\n",
            ({ }) );
        return 0;
    }

    if (_trap_open_func && _trap_open_ob) {
        if (!call_other(_trap_open_ob, _trap_open_func, "open", TO, TP)) {
            return 0;
        }
    }

    set_open();
    if (!TO->query_door_name()) {
        switch (check_stealth()) {
            case STEALTH_SUCCEEDED:
                TP->add_succeeded_mess(TO, ({
                    "$N $V $D, managing to stay unnoticed.\n",
                    "", }),
                    ({ }) );
                break;
            case STEALTH_FAILED:
                TP->add_succeeded_mess(TO,
                    "$N unsuccessfully tr$y to " + query_verb() + " $D while "
                    "staying unnoticed.\n", ({ }) );
                break;
            default:
                TP->add_succeeded_mess(TO,
                    "$N $V $D.\n",
                    ({ }) );
                break;
        }
    }
    return 1;
} /* do_open() */

/**
 * @ignore yes
 */
int do_close() {
    if (_closed) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already closed.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (_trap_open_func && _trap_open_ob) {
        if (!call_other(_trap_open_ob, _trap_open_func, "close", TO,TP)) {
            return 0;
        }
    }

    set_closed();
    if (_autolock)
        set_locked();
    if (!TO->query_door_name()) {
        switch (check_stealth()) {
            case STEALTH_SUCCEEDED:
                TP->add_succeeded_mess(TO, ({
                    "$N $V $D, managing to stay unnoticed.\n",
                    "", }),
                    ({ }) );
                break;
            case STEALTH_FAILED:
                TP->add_succeeded_mess(TO,
                    "$N unsuccessfully tr$y to " + query_verb() + " $D while "
                    "staying unnoticed.\n", ({ }) );
                break;
            default:
                TP->add_succeeded_mess(TO,
                    "$N $V $D.\n",
                    ({ }) );
                break;
        }
    }
    return 1;
} /* do_close() */

/**
 * @ignore yes
 */
string *parse_command_adjectiv_id_list() {
    switch( query_closed_locked_status() ) {
        case CLOSED_LOCKED:
            return ({ "closed", "locked" });
        case CLOSED:
            return ({ "closed", "unlocked" });
        case LOCKED:
            return ({ "open", "locked" });
        default:
            return ({ "open", "unlocked" });
    }
} /* parse_command_adjectiv_id_list() */

/**
 * @ignore yes
 */
mixed *stats() {
  return ({
    ({"closed", query_closed()}),
    ({"transparent", query_transparent()}),
    ({"key", query_key()}),
    ({"difficulty", query_difficulty()}),
    ({"locked", query_locked()}),
    ({"stuck", query_stuck()}),
    ({"open trapped", _trap_open_func != 0}),
    ({"lock trapped", _trap_lock_func != 0}),
    ({"pick skill", query_pick_skill()}),});
} /* stats() */
/* EOF */
// --- END [/mnt/home2/grok/lib/std/basic/close_lock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/version.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/version.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629948   Available: 13577302
Inodes: Total: 5242880    Free: 4960136
621 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/version.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629948   Available: 13577302
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Version Control Inheritable.
 * @author Terano
 * @started 16/7/00
 * Making things fun!
 */

nosave mapping version_control = ([ ]); 

void create() {
  version_control[ base_name( this_object() ) ] = ctime( time() );

  foreach( object temp in inherit_list( this_object() ) ) 
    version_control[ base_name( temp ) ] = temp->query_version();
}

void query_version_control() {
  write( "File:\tTime:\n" );
  foreach( string temp in keys( version_control ) ) 
    printf( "%s\t%s.\n", temp, version_control[ temp ] );
  return;
}

string query_version() {
  return version_control[ base_name( this_object() ) ];
}// --- END [/mnt/home2/grok/lib/std/basic/version.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/virtual_update.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/virtual_update.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629948   Available: 13577302
Inodes: Total: 5242880    Free: 4960136
2579 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/virtual_update.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629948   Available: 13577302
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the inherit used to update virtual objects from their base files
 * if something changes.  This will call the method init_static_arg with
 * any updated data.
 * @author Dragonkin
 * @changes Pinkfish Fri Apr  6 13:53:28 PDT 2001
 * Turned into an inherit
 */
#include <virtual.h>

mixed query_property(string name);
void add_property(string name, mixed prop);
void init_static_arg(mapping data);

/**
 * This method turns the current object into a missing item
 * receipt.
 */
void replace_me()
{
   object receipt;
   mixed als;

   receipt = clone_object("/obj/misc/al_receipt");
   receipt->set_name("receipt");
   receipt->set_object(file_name(this_object()));
   receipt->set_virtobname(query_property(VIRTUAL_NAME_PROP));
   receipt->set_value(this_object()->query_value());
   als = "/global/auto_load"->fragile_auto_str_ob(this_object());
   als[0] = 1;
   receipt->set_static_save(als);
   receipt->set_short("destructed item receipt");
   receipt->add_adjective(({ "destructed", "item" }));
   receipt->set_long("This seems to be a small piece of paper.\n");
   receipt->set_read_mess("According to our sources, your " +
                          this_object()->query_short() +
                          " was not " "allowed to exist.  Have a nice day.");
   receipt->move(environment());
   receipt->set_weight(1);
   destruct(this_object());
}

/**
 * THis method should be called in the inheritable to deal with virtual
 * objects.  It will check to see if the data has changed and update the
 * object to reflect any of the changes.
 */
void init_virtual_object()
{
   mapping stat_temp;
   string virt_name;
   string new_name;

   virt_name = query_property(VIRTUAL_NAME_PROP);
   if (virt_name) {
      if (file_size(virt_name) == -1) {
         new_name = (CLONER)->other_file(virt_name);
         if (stringp(new_name) && (new_name != virt_name)) {
            add_property(VIRTUAL_NAME_PROP, new_name);
            virt_name = new_name;
         } else {
            if (VIRTUAL_HANDLER->query_forbidden(virt_name)) {
               call_out("replace_me", 1);
            } else {
               VIRTUAL_HANDLER->add_missing(virt_name);
            }
         }
      }
      if (file_size(virt_name) != -1 &&
          query_property("virtual time") < stat(virt_name)[1]) {
         stat_temp = (VIRTUAL_HANDLER)->new_data(virt_name);
         if (mapp(stat_temp)) {
            init_static_arg(stat_temp);
            add_property("virtual time", time());
         }
      }
   }

}                               /* init_virtual_object() */
// --- END [/mnt/home2/grok/lib/std/basic/virtual_update.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/artifact.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/artifact.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629947   Available: 13577301
Inodes: Total: 5242880    Free: 4960136
2765 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/artifact.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629947   Available: 13577301
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: artifact.c,v 1.1 1998/01/06 03:59:10 ceres Exp $
 * $Log: artifact.c,v $
 * Revision 1.1  1998/01/06 03:59:10  ceres
 * Initial revision
 * 
*/
#include <artifacts.h>

int charges, level, total_charges;
string type, zapper;

string query_artifact_type() { return type; }

void set_artifact_type( string word ) { type = word; }

int query_charges() { return charges; }

void set_charges( int number ) { charges = number; }

int adjust_charges( int number ) {
  charges += number;
  if ( number > 0 )
    total_charges += number;
  if ( charges < 0 )
    charges = 0;
  return charges;
} /* adjust_charges() */

int query_total_charges() { return total_charges; }

void set_total_charges( int number ) { total_charges = number; }

int query_level() { return level; }

void set_level( int number ) { level = number; }

string query_zapper() { return zapper; }

void set_zapper( string word ) {
   zapper = word;
   call_out( "zapper_init", 1, this_object() );
} /* set_zapper() */

void zapper_init( object thing ) {
   if ( !thing )
      return;
   zapper->init_artifact( thing );
} /* zapper_init() */

int break_on_charging() {
  int top, chance;
  top = 1000 / ( 32 + level );
  if ( total_charges > top )
    chance = 6 * ( total_charges - top ) * ( total_charges - top );
  top = 14 - level / 7;
  if ( top < 0 )
    top = 0;
  if ( charges > top )
    chance += 3 * ( charges - top ) * ( charges - top );
  chance += 1;
  if ( random( 100 ) < chance )
    return 1;
  return 0;
} /* break_on_charging() */

string long( int word, int dark ) {
  string a_name, start;
  a_name = (string)call_other( zapper, "query_"+ type +"_name" );
  if ( !ARTIFACT_HAND->query_known( (string)this_player()->query_name(),
      a_name ) )
    return "";
   start = "You recognise "+ this_object()->the_short() +" to be ";
  if ( a_name[ 0 .. 0 ] == lower_case( a_name[ 0 .. 0 ] ) )
    return start + add_a( a_name ) +".  ";
  return start + a_name +".  ";
} /* long() */

mixed *stats() {
  return ({
    ({ "charges", charges +" ("+ total_charges +")", }),
    ({ "level", level, }),
    ({ "zapper", zapper, }),
  });
} /* stats() */

mapping query_dynamic_auto_load() {
  return ([
    "charges" : charges,
    "total charges" : total_charges,
  ]);
} /* query_dynamic_auto_load() */

mapping query_static_auto_load() {
  return ([
    "level" : level,
    "zapper" : zapper,
  ]);
} /* query_static_auto_load() */

void init_dynamic_arg( mapping map ) {
  charges = map[ "charges" ];
  total_charges = map[ "total charges" ];
} /* init_dynamic_arg() */

void init_static_arg( mapping map ) {
  if ( map[ "level" ] )
    level = map[ "level" ];
  if ( map[ "zapper" ] )
    zapper = map[ "zapper" ];
} /* init_static_arg() */
// --- END [/mnt/home2/grok/lib/std/basic/artifact.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/effects.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629946   Available: 13577300
Inodes: Total: 5242880    Free: 4960136
36416 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/effects.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629946   Available: 13577300
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: effects.c,v 1.24 2003/07/20 06:59:27 ceres Exp $
 */
/* -*- LPC -*-
 */
/**
 * Basic effects module.
 * Extracted from Ember's living effects code by Deutha.
 * @change 4-6-1997, Turrican
 * to use arrays of classes, and to allow function pointers.
 * @change 17-10-1997 Olorin
 * fix a bug then adding an effect
 * in the end() function of another effect.
 * @see help::effects
 */

#include <effect.h>

class effect_shadow {
   object shad_ob;
   int idnum;
}

class effect_event {
   int inctime;
   mixed func;
   int eff_ob_num;
   mixed interval;
   int flags;
   mixed eff_ev_args;
}

#undef DEBUG
#ifdef DEBUG
nosave int logging_effects;
void set_logging_effects(int i) { logging_effects = i; }
int query_logging_effects() { return logging_effects; }
#endif

/**
 * This class stores all the data for the effects inheritable.
 * @member current_enum used to keep track of the effect being called;
 *         beginning/end etc.
 * @member next_id the next id to assign to an effect
 * @member next_event_time when the next effect is due to go off
 * @member shadows the shaodws on the object
 */
class effect_data {
   int current_enum;
   int next_id;
   int next_event_time;
   class effect_shadow* shadows;
}

void delete_effect(int i);

private nosave class effect_data _data;

private class effect *effs;
/* this stores effects currently active on player as ...
 * "effect_ob_name", arg
 */

private class effect_event *eeq;
/* effect event queue
 *
 *    This stores all effect events going to be happening...
 *
 *    time_from_previous_event, "function", eff_ob_num, interval, flags
 *
 * where flags can be
 *
 *   EE_REMOVE
 *   EE_CONTINUOUS
 *   EE_ONCE
 *
 * and interval can be
 *   number_of_secs
 *   ({ min_secs, max_secs })  ; "1" dice roll
 *   ({ min_secs, max_secs, n })   ; "n" dice rolls
 *
 * ee are added with
 *   submit_ee("function", interval, flags, event_args );
 *
 */

protected void create() {
  effs = ({ });
  eeq = ({ });
  _data = new(class effect_data);
  _data->shadows = ({ });
  _data->next_id = 0;
  _data->current_enum = -1;
  _data->next_event_time = 0;
#ifdef DEBUG
  logging_effects = 0;
#endif
} /* create() */


/**
 * This method removes all the current effects off the object
 * and sets everything back to the initial state.
 * @see add_effect()
 */
void reset_effects() {
   effs = ({ });
   eeq = ({ });
   _data->shadows = ({ });
   _data->current_enum = -1;
   _data->next_event_time = 0;
   remove_call_out("effect_timer");
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) reset_effects:remove_call_out( \"effect_timer\" )\n",
               time() % 1000,
               this_object()->query_name(),
               _data->current_enum);
#endif
} /* reset_effects() */

/**
 * This method returns the outer most shadow on this object.  This is useful
 * for making sure functions get calklked right through the shadow
 * list.  If there are no objects being shadows, this_object()
 * is returned.
 * @return the outermost shadow object
 */
object affected_object() {
   object this, other;

   other = this_object();
   this = other;
   while (objectp(other)) {
      this = other;
      other = query_shadowing(this);
   }
   return this;
} /* affected_object() */

/**
 * This method freezes all the current effects so that they do
 * not continue to be processed.  Basicly it removes the call_out
 * for the effect_timer().  It also ensures the intrval for the
 * immediately pending effect
 * is correct.
 * @see effect_timer()
 * @see add_effect()
 */
void effect_freeze() {
   /* stop effect_timer call_out and put the remaining
    * time value into EEQ_INCTIME of first element */
   remove_call_out( "effect_timer" );
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) effect_freeze:remove_call_out( \"effect_timer\" )=%d\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,timeleft);
#endif
   if ( sizeof( eeq ) && _data->next_event_time) {
      if (_data->next_event_time <= time()) {
         eeq[ 0 ]->inctime = 1;
      } else {
         eeq[ 0 ]->inctime = _data->next_event_time - time(); //timeleft;
      }
   }
} /* effect_freeze() */

/**
 * Called when a player actually saves.  Calls the quitting method on
 * all the effects.
 * @ignore yes
 */
void effects_saving() {
   int i, neffs;
   string effn;
   mixed arg;

   neffs = sizeof( effs );
   for ( i = 0; i < neffs; i++ ) {
      effn = effs[ i ]->ob_name;
      arg = effs[ i ]->arg;
      if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
          ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
         arg = arg[ 1 ];
      }
      if ( effn ) {
         catch( (void)effn->saving( affected_object(), arg, i ) );
      }
   }
} /* effects_saving() */

/**
 * Called when a player actually quits.  Calls the quitting method on
 * all the effects.
 */
void effects_quiting() {
   int i, neffs;
   string effn;
   mixed arg;

   neffs = sizeof( effs );
   for ( i = 0; i < neffs; i++ ) {
      effn = effs[ i ]->ob_name;
      arg = effs[ i ]->arg;
      if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
          ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
         arg = arg[ 1 ];
      }
      if ( effn ) {
         catch( (void)effn->quiting( affected_object(), arg, i ) );
      }
   }
} /* effects_quiting() */

/**
 * Called when an object is dested.  Calls the desting method on
 * all the effects.
 */
void effects_desting() {
   int i, neffs;
   string effn;
   mixed arg;

   neffs = sizeof( effs );
   for ( i = 0; i < neffs; i++ ) {
      effn = effs[ i ]->ob_name;
      arg = effs[ i ]->arg;
      if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
          ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
         arg = arg[ 1 ];
      }
      if ( effn ) {
         catch( (void)effn->desting( affected_object(), arg, i ) );
      }
   }
}

/**
 * This restarts the internal call_out.
 * @see effects_freeze()
 * @see add_effect()
 */
void effect_unfreeze() {
   /* restart the timer, checking that it hasn't been restarted
    * already by a nested unfreeze
    */
   if ( sizeof( eeq ) ) {
#ifdef DEBUG
      if ( logging_effects )
         log_file( "EFFECT_WOBBLE",
                  "%d:%s(%d) effect_unfreeze:call_out( \"effect_timer\", %d)\n",
                  time() % 1000,this_object()->query_name(),_data->current_enum,eeq[ 0 ]->inctime);
#endif
      //time = find_call_out( "effect_timer" );
      //if ( time != -1 )
      remove_call_out( "effect_timer" );
      _data->next_event_time = time() + eeq[ 0 ]->inctime;
      call_out( "effect_timer", eeq[ 0 ]->inctime );
   }
} /* effect_unfreeze() */

/** @ignore yes */
protected int int_submit_ee( int eff_ob_num, mixed fun, mixed
      interval, int flags, mixed event_args ) {
/*
 * this calculates next occurence of this ee and inserts it into the eeq ...
 * note that it can only be called sandwiched between freeze and unfreeze calls
*/
   int i, ntime;

#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) int_submit_ee:( %d, %O, %O, %s, %O )\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,
               eff_ob_num, fun, interval,
               ({"once","remove","continuous"})[flags], event_args );
#endif
   if (intp(interval))
      ntime = interval;
   else if (pointerp(interval)) {
      switch (sizeof(interval)) {
       case 0:
         return -1; /* bletch */
       case 1:
         ntime = interval[0];
         break;
       case 2:
         ntime = interval[0] + random(interval[1] - interval[0] + 1);
         break;
       case 3:
         ntime = 0;
         for (i = 0; i < interval[2]; i++) {
            ntime += interval[0] + random(interval[1] - interval[0] + 1);
         }
         ntime += (interval[2]/2);
         ntime /= interval[2];
         break;
       default:
         return -1;
      }
   } else return -1;

   /* if the flag is EE_REMOVE, and one exists for EEQ_EFF_OB already,
    * remove the old one.  This is for occasions when an EE_REMOVE is
    * called from merge_effect() */
   if (flags == EE_REMOVE) {
      for(i = 0; i < sizeof(eeq); i++) {
         if ((eeq[i]->eff_ob_num == eff_ob_num) &&
             (eeq[i]->flags == EE_REMOVE)) {
            eeq = eeq[0..i-1] + eeq[i+1..];
            /*
             for( j = i; j < sizeof( eeq ); j += EEQ_SIZE )
             eeq[j] += eeq[i];
             */
            break;
         }
      }
   }
   /*
    * This traps cases of negative scheduled times and, more
    * importantly, allows the removal of an EE_REMOVE without
    * submitting a new one.
    */
   if ( ntime < 0 ) {
      return 0;
   }

   for (i = 0; i < sizeof(eeq); i++) {
      if (ntime < eeq[i]->inctime) { /* goes in here! */
         eeq[i]->inctime -= ntime;
         eeq = eeq[0..i-1] +
            ({ new(class effect_event, inctime : ntime, func : fun,
                   eff_ob_num : eff_ob_num, interval : interval,
                   flags : flags, eff_ev_args : event_args ) }) + eeq[i..];
         break;
      }
      ntime -= eeq[i]->inctime;
   }
   if ((i == sizeof(eeq)) && eeq) {
      eeq += ({ new(class effect_event, inctime : ntime, func : fun,
                    eff_ob_num : eff_ob_num, interval : interval,
                    flags : flags, eff_ev_args : event_args ) });
   } else if ( !sizeof(eeq) ) {
     /* This shouldn't happen, but it does sometimes!
      * Note from Olorin: without testing for !sizeof(eeq), this
      * code mangles the cases where the queue exists and the event
      * already inserted by the for loop.
      */
      eeq = ({ new(class effect_event, inctime : ntime, func : fun,
                   eff_ob_num : eff_ob_num, interval : interval,
                   flags : flags, eff_ev_args : event_args ) });
   }
   return i;
} /* int_submit_ee() */

/**
 * This submits an effect event schedule.  It will call "function name" in your
 * effect object after the interval specified in interval_spec, with behaviour
 * modified by flags.  Addtional args may optionally be sent to "function name"
 * as well.  If none are passed, args == 0.
 * interval_spec can be one of:
 * <dl><dt>n
 * <dd>time in seconds
 * <dt>({ m, n })
 * <dd>minimum time m seconds, maximum time n seconds, simple random
 *     distribution
 * <dt>({ m, n, r })
 * <dd>as for the ({ m, n }) case, except the random factor is effectively
 *     "rolled" r times ... the higher r is, the more likely the interval
 *     is to be close to (m + n)/2.
 * </dl>
 * flags may be:
 * <dl>
 * <dt>EE_REMOVE
 * <dd> remove the effect from the player aftert the function call
 * <dt>EE_CONTINUOUS
 * <dd>do it repeatedly.  Default (EE_ONCE) is only do it once.
 * <dt>EE_ONCE
 * <dd>do it once
 * </dl>
 * These are defined in /include/effect.h
 * <p>
 * Only one EE_REMOVE can be in place at a time.  Subsequent EE_REMOVEs
 * will wipe previous ones.
 * <p>
 * NB:  submit_ee can ONLY be called from the effect object itself in the
 * course of a beginning/handler/end call, or from the effect shadow.
 * @see submit_ee2()
 * @see /include/effect.h
 * @see add_effect()
 * @param fun the function to call
 * @param interval the interval specifier
 * @param flags the flags for the event
 * @param event_args additional (optional) args passed to fun
 */
varargs void submit_ee(mixed fun, mixed interval, int flags, mixed
    event_args ) {
  /* public access point for int_submit_ee ... it uses current_enum or
     previous_object (for shadows) to determine what effect it refers to */
  int enumb;

  if( undefinedp( event_args ) )
     event_args = 0;

#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) submit_ee:( %O, %O, %s, %O )\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,
               fun, interval, ({"once","remove","continuous"})[flags],
               event_args );
#endif
  enumb = _data->current_enum;
  if (enumb < 0) {
    enumb = member_array(1,
        map(_data->shadows, (: $1 && (((class effect_shadow)$1)->shad_ob == previous_object()) :)));
    if (enumb < 0) {
      error("Can not submit from that object");
    }
  }

  effect_freeze();
  int_submit_ee(enumb, fun, interval, flags, event_args );
  effect_unfreeze();
} /* submit_ee() */

/**
 * This submits an effect event for a specific effect.
 * Apart from this it is the same as submit_ee()
 * @param enum the enum of the effecrt
 * @param fun the function to call
 * @param interval the interval specifier
 * @param flags the flagds associated with the event
 * @param event_args additional (optional) args passed to fun
 */
varargs void submit_ee2(int enum, mixed fun, mixed interval, int flags,
    mixed event_args ) {
  /* public access point for int_submit_ee ... it uses enum
   * to determine what effect it refers to (for those cases where
   * current_enum isn't defined) */

  if( undefinedp( event_args ) )
    event_args = 0;

#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) int_submit_ee:( %d, %O, %O, %s, %O )\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,
               enum, fun, interval, ({"once","remove","continuous"})[flags],
               event_args );
#endif
  if (enum < 0)
    error("Can't submit from that object");

  effect_freeze();
  int_submit_ee(enum, fun, interval, flags, event_args );
  effect_unfreeze();
} /* submit_ee() */

/**
 * This method returns the time until any EE_REMOVE effect
 * is expected to occur.  It will return --1 if no remove
 * event is scheduled.  If the flag is not
 * set to true, the the current enum is checked, otherwise
 * the new_enum is checked.
 * @param flag itrue, use new_enum not current_enum
 * @return the time until the remove event will occur
 * @see submit_ee()
 * @see add_effect()
 * @see expected_ee()
 * @see all_expected_ees()
 */
int expected_tt(int flag, int new_enum) {
  /* If -1 is returned, no EE_REMOVE for this effect is expected. */

  /* This is a little kludgy, but if flag is true, it uses new_enum
   * instead of current_enum (current_enum is unchanged).  I did it
   * like this for backwards compatibility -- Jeremy, 31-May-96
   */
  int i, timeleft, enum;

  if (flag)
    enum = new_enum;
  else
    enum = _data->current_enum;
  if (enum < 0)
    return -1;
  if (!sizeof(eeq))
    return -1;
  effect_freeze();   /* stop the event timer */
  /* Add up the incremental times in the queue until you get to the
   * EE_REMOVE for the one your asking about */
  for (i = 0; i < sizeof(eeq); i++) {
    timeleft += eeq[i]->inctime;
    if ((eeq[i]->eff_ob_num == enum) &&
        (eeq[i]->flags == EE_REMOVE)) {
      effect_unfreeze();   /* restart the event timer */
      return timeleft;
    }
  }
  effect_unfreeze();  /* restart the event timer */
  return -1;
} /* expected_tt() */

/**
* Returns the time until the next event that will call func_name.
* If enum is undefined, the event is searched for in this effect,
* otherwise the event is searched for in the specified effect.
*
* If no outstanding calls to the function are found, -1 is returned.
*
* @param func_name - the name of the function the ee will call.
* @param enum - the enum of the effect to check in.
* @return time - the seconds until the next call to func_name for
* the effect specified.
* @see all_expected_ees()
* @see expected_tt()
* @see submit_ee()
**/

varargs int expected_ee( string func_name, int enum ) {
  int timeleft = 0;          /* time left until func_name is called */

  /* If enum hasn't been passed, look for the current effect */
  if( undefinedp( enum ) ) {
    enum = _data->current_enum;
  }

  /* If there's still no enum, never mind */
  if( !enum ) {
    return -1;
  }

  /* If the function name isn't valid, don't bother */
  if( !stringp( func_name ) ) {
    return -1;
  }

  /* Ditto if there's no queueue */
  if( !sizeof( eeq ) ) {
    return -1;
  }

  effect_freeze();   /* stop the event timer */

  /* Add up the incremental times in the queue until you get to the
   * function in question for the effect in question. Return the
   * time left. */

  for( int i = 0; i < sizeof( eeq ); i++) {
    timeleft += eeq[i]->inctime;

    if( eeq[i]->eff_ob_num == enum &&
        eeq[i]->func == func_name ) {
      effect_unfreeze();  /* restart the event timer */
      return timeleft;
    }
  }

  /* No event for the give function was found in the given in the
   * given enum. */

  effect_unfreeze();  /* restart the event timer */
  return -1;          /* wasn't found */
} /* expected_ee() */

/**
* Returns the time until the next event that will call func_name.
* If enums is undefined, the event is searched for in this effect,
* otherwise the event is searched for in the specified effect(s).
*
* This returns the a list of the time in seconds until the function
* will be called in the effect(s) specified.  NB: this is not the
* time *between* calls, but the time from Right Now until each call.
* If no outstanding calls to the function are found, an empty array
* is returned.
*
* @param func_name - the name of the function the ee will call.
* @param enum - the enums of the effect to check in.
* @return time - array containing the seconds until each outstanding
* call to func_name for the effect(s) specified.
* @see expected_ee()
* @see expected_tt()
* @see submit_ee()
**/

varargs int *all_expected_ees( string func_name, int *enums ) {
  int timeleft = 0;          /* time left until func_name is called */
  int *alltimesleft = ({});  /* timeleft for all outstanding calls */

  /* If enum hasn't been passed, look for the current effect */
  if( undefinedp( enums ) ) {
    enums = ({ _data->current_enum });
  }

  /* if it's a single int, make it a pointer */
  if( intp( enums ) ) {
    enums = ({ enums });
  }

  /* If there's still no enums, never mind */
  if( !enums ) {
    return ({});
  }

  /* If the function name isn't valid, don't bother */
  if( !stringp( func_name ) ) {
    return ({});
  }

  /* Ditto if there's no queueue */
  if( !sizeof( eeq ) ) {
    return ({});
  }

  effect_freeze();   /* stop the event timer */

  /* Add up the incremental times in the queue until you get to the
   * function in question for the effect(s) in question, add the
   * time to the array, then keep looking for the next one. */

  for( int i = 0; i < sizeof( eeq ); i++) {
    timeleft += eeq[i]->inctime;

    if( member_array( eeq[i]->eff_ob_num , enums ) != -1 &&
        eeq[i]->func == func_name ) {
      alltimesleft += ({ timeleft });
    }
  }
  effect_unfreeze();  /* restart the event timer */
  return alltimesleft;
} /* all_expected_ees() */

/**
 * This method adds an effect onto the object.  RThe arg is passed
 * directly onto the function 'begining' on the effect
 * object.  If the result is non-zero then the return
 * value of the begining function is used instead of the
 * arg and stored away.  If an effect of the same
 * type is already on the object then the function 'merge_effects'
 * will be called.  If it returns a non-zero value then the arg for the
 * initial effect will be updated to the new value, otherwise both effects
 * will run
 * with different arguments.
 * @see help::effects
 * @see submit_ee()
 */
void add_effect(string eff, mixed arg) {
  string shad;
  object ob, effob;
  mixed hbf, res;
  int i;
  int old_current_enum;
  int enum;

#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) add_effect:(%s,%O)\n",
               time() % 1000,this_object()->query_name(),current_enum,eff,arg);
#endif
  hbf = (mixed)eff->query_secs_between_hb();
  if (!hbf) {
    hbf = (mixed) eff->query_heart_beat_frequency();
    if (hbf) {
      if (intp(hbf)) hbf *= 60;
    }
  }

  old_current_enum = _data->current_enum;

  effob = find_object(eff);
  if (!effob)
    error("bad effect object");

  for (i=0; i<sizeof(effs); i++) {
    if (effs[i]->ob_name == eff) {
      /*
       * Hmm.  Well. if they have a function on them we join up, otherwise we
       * add it again.
       */
      if (function_exists("merge_effect", effob)) {
        _data->current_enum = i;
        if (hbf) {  /* old fudged system */
          res = (mixed) effob->merge_effect(affected_object(),
                                            effs[i]->arg[1], arg);
          if (res)
            effs[i]->arg[1] = res;
        } else {
          res = (mixed) effob->merge_effect(affected_object(),
                                            effs[i]->arg, arg);
          if (res)
            effs[i]->arg = res;
        }
        _data->current_enum = old_current_enum;
        return ;
      }
    }
  }

  shad = effob->query_shadow_ob();
  if (shad) {
    ob = clone_object(shad);
    if(!ob) {
      error("Failed to clone shadow object " + shad + ".\n");
      _data->shadows += ({ new(class effect_shadow, shad_ob : 0, idnum : _data->next_id) });
    } else {
      _data->shadows += ({ new(class effect_shadow, shad_ob : ob, idnum : _data->next_id) });
      ob->attach_to_player(affected_object(), _data->next_id);
    }
  } else {
    _data->shadows += ({ new(class effect_shadow, shad_ob : 0, idnum : _data->next_id) });
  }
  _data->current_enum = sizeof(effs);
  enum = _data->current_enum;

  if(!effs)
    effs = ({ });
  
  effs += ({ new(class effect, ob_name : eff, arg : arg) });

  if (function_exists("beginning", effob)) {
    res = (mixed) effob->beginning(affected_object(), arg, _data->next_id);
    if (res) {
      effs[enum]->arg = res;
    }
  }

  _data->next_id++;

  if (hbf) {
    submit_ee("effect_heart_beat", hbf, EE_CONTINUOUS | EE_OLD);
    effs[enum]->arg = ({ 0, effs[<1]->arg, BOGUS_OLD_ARG });
  }

  _data->current_enum = old_current_enum;
} /* add_effect() */

#define EFF_OB_NAME 0
#define EFF_ARG 1

#define EEQ_INCTIME 0
#define EEQ_FUNC 1
#define EEQ_EFF_OB 2
#define EEQ_INTERVAL 3
#define EEQ_FLAGS 4
#define EEQ_ARGS 5

#define EFF_SIZE 2
#define EEQ_SIZE 5

/** @ignore yes */
protected void convert_arrays() {
  int i, neffs, neeq;
  mixed *old;

  if (sizeof(effs) && !classp(effs[0])) {
    old = effs;
    neffs = sizeof(old) / EFF_SIZE;
    effs = allocate(neffs);
    for (i = 0; i < neffs; i++)
      effs[i] = new(class effect,
                    ob_name : old[i*EFF_SIZE+EFF_OB_NAME],
                    arg : old[i*EFF_SIZE+EFF_ARG]);
  }
  if (sizeof(eeq) && !classp(eeq[0])) {
    old = eeq;
    neeq = sizeof(eeq) / EEQ_SIZE;
    eeq = allocate(neeq);
    for (i = 0; i < neeq; i++)
      eeq[i] = new(class effect_event,
                   inctime : old[ i * EEQ_SIZE + EEQ_INCTIME ],
                   func : old[ i * EEQ_SIZE + EEQ_FUNC ],
                   eff_ob_num : old[ i * EEQ_SIZE + EEQ_EFF_OB ],
                   interval : old[ i * EEQ_SIZE + EEQ_INTERVAL ],
                   flags : old[ i * EEQ_SIZE + EEQ_FLAGS ],
                   eff_ev_args : old[ i * EEQ_SIZE + EEQ_ARGS ] );
  }
} /* convert_arrays() */

/** @ignore yes */
void init_after_save() {
  /* called after the restore_object is done to init shadows etc */
  int i;
  int neffs;
  string shad;
  string effn;
  object ob;
  mixed arg;
  int *ee_exists;

  convert_arrays();

  /* convert old size == 5 classes into the new size == 6 ones */

  for( i = 0; i < sizeof( eeq ); i++ ) {
    if( classp( eeq[i] ) && sizeof( eeq[i] ) < 6 ) {
      eeq[i] = new( class effect_event,
                    inctime : eeq[i]->inctime ,
                    func : eeq[i]->func ,
                    eff_ob_num : eeq[i]->eff_ob_num ,
                    interval : eeq[i]->interval ,
                    flags : eeq[i]->flags ,
                    eff_ev_args : 0 );
    }
  }

  neffs = sizeof(effs);

  _data->shadows = allocate(neffs);

  for (i = 0; i < neffs; i++) {
    effn = effs[i]->ob_name;
    _data->shadows[i] = new(class effect_shadow, idnum : _data->next_id);
    if (catch(shad = (string)
              effn->query_shadow_ob())) {
      continue;
    }
    if (shad) {
      ob = clone_object(shad);
      _data->shadows[i]->shad_ob = ob;
      ob->attach_to_player(affected_object(), _data->next_id);
    }

    _data->current_enum = i;
    arg = effs[i]->arg;
    if (pointerp(arg) && sizeof(arg) == 3 && arg[2] == BOGUS_OLD_ARG) {
      arg = arg[1];
    }
    catch(effn->restart(affected_object(), arg, _data->next_id++));
  }

  ee_exists = allocate(sizeof(effs));
  for (i = 0; i < sizeof(eeq); i++) {
    ee_exists[eeq[i]->eff_ob_num] = 1;
  }
  for (i = sizeof(ee_exists) - 1; i >= 0; i--) {
    if (catch(ob = load_object(effs[i]->ob_name)) || !ob) {
      delete_effect(i);
      continue;
    }
    if (!ee_exists[i] && !ob->query_indefinite()) {
      delete_effect(i);
    }
  }
  _data->current_enum = -1;

  effect_unfreeze();
} /* init_after_save() */

/**
 * This method returns an array of effects matching the
 * classification.  The start part of the classification is
 * used to match, so passing "npc." into this function will
 * match all the effects which modify how an
 * npc functions.
 * @param eff the classification to match
 * @return the array of enums corresponding to the effects
 * @see add_effect()
 */
int *effects_matching(string eff) {
  /* return an array of all effect indexes matching the partial string 'eff' */
  int i, neffs;
  int *match;
  string clas;
  object ob;

  match = ({ });

  neffs = sizeof(effs);
  for (i = 0; i < neffs; i++) {
    if (catch(ob = load_object(effs[i]->ob_name)) || !ob) {
      continue;
    }
    clas = (string)ob->query_classification();
    if (!stringp(clas)) {
      continue; /* bleccch */
    }
    if (clas[0..strlen(eff)-1] == eff) {
      match += ({ i });
    }
  }
  return match;
} /* effects_matching() */

/**
 * This removes an effect from the player.  It uses the enum as
 * returned from sid to enum.  This is the number you see in
 * the stat of the object next to the effect.
 * @param i the enum to remove
 * @see add_effect()
 */
void delete_effect(int i) {
   /* delete shadow and remove effect from arrays */
   int id, j;
   object effect_object, shadow_object;
   string effect_file;
   mixed arg;

#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) delete_effect:(%d) sizeof(eeq)=%d\n",time() % 1000,
               this_object()->query_name(),current_enum,i, sizeof(eeq));
#endif
   if ((i < 0) || (i >= sizeof( effs ))) {
      return;
   }

   id = _data->shadows[i]->idnum;
   arg = effs[i]->arg;

   effect_freeze();
   for (j = 0; j < sizeof(eeq); j++) {
      if (eeq[j]->eff_ob_num == i) {
         if (sizeof(eeq)-1 > j)
            eeq[j+1]->inctime += eeq[j]->inctime;
         eeq = delete(eeq, j--, 1);
      } else {
         if (eeq[j]->eff_ob_num > i)
            eeq[j]->eff_ob_num--;
      }
   }
   effect_file = effs[i]->ob_name;
   effs = delete(effs, i, 1);

   shadow_object = _data->shadows[i]->shad_ob;
   _data->shadows = delete(_data->shadows, i, 1);

   effect_unfreeze();

   /* once all bookkeeping's done, it's safe to call end(), since we're
    * essentially outside the effects system.
    */
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) delete_effect: before end\n",time() % 1000,
               this_object()->query_name(),current_enum);
#endif
   effect_object = find_object(effect_file);
   if (!effect_object)
      catch(effect_object = load_object(effect_file));

   if (effect_object)
      if (pointerp(arg) && (sizeof(arg) == 3) &&
          (arg[2] == BOGUS_OLD_ARG))
         effect_object->end(affected_object(), arg[1], id);
   else
      effect_object->end(affected_object(), arg, id);
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) delete_effect: after end\n",time() % 1000,
               this_object()->query_name(),_data->current_enum);
#endif
   /* kill the shadow if it exists */
   if (objectp(shadow_object))
      shadow_object->remove_effect_shadow(id);

} /* delete_effect() */

/**
 * This method returns the effect number for the given effect id.  The
 * effect number is an internal nhandle used by delete_effect()
 * arg_of() set_arg_of() functions.  "id" is passed into the
 * begining/end etc functions on the effect object.
 * @param sid the effect id
 * @return the effect number
 * @see submit_ee2()
 * @see delete_effect()
 * @see add_effect()
 * @see arg_of()
 * @see set_arg_of()
 */
int sid_to_enum(int sid) {
   return member_array(1,
      map(_data->shadows, (: classp($1) &&
                      ((class effect_shadow)$1)->idnum == $(sid) :)));
} /* sid_to_enum() */

/**
 * This method turns an effect number into an effect id.
 * @see sid_to_enum()
 * @see add_effect()
 * @param enum the effect number
 * @return the effect id
 */
int enum_to_sid(int enum) {
  return _data->shadows[enum]->idnum;
} /* enum_to_sid() */

/**
 * This method returns the effect object for the given effect number.
 * @param enum the effect number
 * @return the effect object
 * @see arg_of()
 * @see add_effect()
 * @see sid_to_enum()
 */
string eff_of(int enum) {
  return effs[enum]->ob_name;
} /* eff_of() */

/**
 * This method returns the current argument associated with the
 * given effect number.
 * @param enum the effect number
 * @return the argument associated with the effect
 * @see add_effect()
 * @see set_arg_of()
 * @see sid_to_enum()
 */
mixed arg_of(int enum) {
  mixed arg;

  if (sizeof(effs) <= enum)
    return 0;

  arg = effs[enum]->arg;
  if (arrayp(arg) && sizeof(arg) == 3)
    if (arg[2] == BOGUS_OLD_ARG)
      return copy(arg[1]);
  return copy(arg);
} /* arg_of() */

/**
 * This sets the argument of the given effect to a new value.
 * @param enum the effect number to change
 * @param newarg the new argument value
 * @see sid_to_enum()
 * @see arg_of()
 * @see add_effect()
 */
void set_arg_of(int enum, mixed newarg) {
  effs[enum]->arg = newarg;
} /* set_arg_of */

/** @ignore yes */
class effect *query_effs() { return effs; }
/** @ignore yes */
class effect_shadow *query_effect_shadows() { return _data->shadows; }
/** @ignore yes */
class effect_event *query_eeq() { return eeq; }

/** @ignore yes */
void effect_timer() {
   int enum;
   object effect_object;
   mixed res, last_flags;
   class effect_event thisee;

#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) effect_timer:() sizeof(eeq)=%d\n",time() % 1000,
               this_object()->query_name(),current_enum,sizeof(eeq));
#endif
   _data->next_event_time = 0;
   if (!sizeof(eeq)) {
      return;
   }

   thisee = eeq[0];
   eeq = eeq[1..];

   enum = _data->current_enum = thisee->eff_ob_num;
   if (enum >= sizeof(effs)) {
      effect_unfreeze();
      if (this_object()->query_creator()) {
         tell_object(this_object(), "Effect number out of range, "
                     "ignoring.\n");
      }
      return;
   }

   if (thisee->flags & EE_CANCELLED) {
      effect_unfreeze();
      return;
   }

   if (thisee->flags & EE_CONTINUOUS) {
      last_flags = int_submit_ee(enum, thisee->func, thisee->interval,
                                 thisee->flags, thisee->eff_ev_args );
   }

   effect_unfreeze(); /* restart timer */

   effect_object = find_object(effs[enum]->ob_name);
   if (!effect_object) {
      catch {
         effect_object = load_object(effs[enum]->ob_name);
      };
   }
   if (!effect_object) {
      if (this_object()->query_creator() ) {
         tell_object( this_object(), "Non-existent effect "+
                     effs[enum]->ob_name +", deleting.\n" );
      }
      delete_effect(enum);
      _data->current_enum = -1;
      return;
   }

/*
   if (this_object()->query_name() == "pinkfish") {
      tell_creator("pinkfish", "%O %O %O", effect_object, enum, thisee);
   }
*/

   if (thisee->flags & EE_OLD) {
      res = (mixed)effect_object->
         effect_heart_beat(this_object(), ++effs[enum]->arg[0],
                           effs[enum]->arg[1], _data->shadows[enum]->idnum);
      if (res == REMOVE_THIS_EFFECT) {
         delete_effect(enum);
      } else {
         effs[enum]->arg[1] = res;
      }
   } else {
      if (stringp(thisee->func)) {
         res = call_other(effect_object, thisee->func, affected_object(),
                          effs[enum]->arg, _data->shadows[enum]->idnum, enum,
                          thisee->eff_ev_args );

         if (res == REMOVE_THIS_EFFECT) {
            delete_effect(enum);
         } else {
            if (res == CANCEL_THIS_EE) {
               eeq[last_flags]->flags |= EE_CANCELLED;
            }
         }
      } else if (functionp(thisee->func)) {
         res = evaluate(thisee->func, affected_object(), effs[enum]->arg,
                     _data->shadows[enum]->idnum, enum, thisee->eff_ev_args );
         if (res == REMOVE_THIS_EFFECT) {
            delete_effect(enum);
         } else if (res == CANCEL_THIS_EE) {
               eeq[last_flags]->flags |= EE_CANCELLED;
         }
      }
   }
   if (thisee->flags & EE_REMOVE)
      delete_effect(enum);

   _data->current_enum = -1;
} /* effect_timer() */

/** @ignore yes */
mixed *stats() {
   mixed *sr;
   int i;
   object ob;

   sr = ({ });

   for (i = 0; i < sizeof(effs); i++) {
      if (catch(ob = load_object(effs[i]->ob_name)) || !ob) {
         sr += ({ ({ "effect#" + i, " (buggered)" }) });
         continue;
      }
      if (intp(effs[i]->arg) || stringp(effs[i]->arg)) {
         sr += ({ ({ "effect#" + i, 
                       effs[i]->ob_name->query_classification() +
                       " (" + effs[i]->ob_name + ") (" + 
                       effs[i]->arg + ")" }) });
      } else {
         sr += ({ ({ "effect#"+i, effs[i]->ob_name->query_classification() +
               " (complex)" }) });
      }
   }
   return sr;
} /* stats() */

/**
 * This method removes all the effects as we die.  It calls the function
 * survive_death() on the effect objects themselves to determine if
 * they should be kept when the living dies.
 */
void effects_thru_death() {
   int i;
   int id; 
   object ob;

   i = sizeof( effs );

   while ( i-- ) {
      id = _data->shadows[i]->idnum;

      if ( catch( ob = load_object(effs[i]->ob_name)) || !ob ||
          !ob->survive_death( affected_object(), effs[i]->arg, id) ) { 
         delete_effect(i);
      } 
   }
} /* effects_thru_death() */

/**
 * This method returns the current enum.
 */
int query_current_effect_enum() {
   return _data->current_enum;
} /* query_current_effect_enum() */

/**
 * This method is used to force the effects setup in the object to be a
 * specified value.  THis is used in the effects effect which sets up
 * effects on someone using a shadow.  This should only be used on startup.
 * @param args the effects array to overwrite the old one with.
 */
protected void set_effs( mixed *args ) {
  int i, neffs;

  if ( sizeof( args ) && !classp( args[ 0 ] ) ) {
    neffs = sizeof( args ) / EFF_SIZE;
    effs = allocate( neffs );
    for (i = 0; i < neffs; i++) {
      effs[ i ] = new( class effect,
                       ob_name : args[ i * EFF_SIZE + EFF_OB_NAME ],
                       arg : args[ i * EFF_SIZE + EFF_ARG ] );
    }
  } else {
    effs = args;
  }
} /* set_effs() */

/**
 * This method is used to force the effects setup in the object to be a
 * specified value.  THis is used in the effects effect which sets up
 * effects on someone using a shadow.  This should only be used on startup.
 * @param args the effects array to overwrite the old one with.
 */
protected void set_eeq( mixed *args ) {
  int i, neeq;

  if ( sizeof( args ) && !classp( args[ 0 ] ) ) {
    neeq = sizeof( args ) / EEQ_SIZE;
    eeq = allocate( neeq );
    for (i = 0; i < neeq; i++) {
      eeq[ i ] = new( class effect_event,
                      inctime : args[ i * EEQ_SIZE + EEQ_INCTIME ],
                      func : args[ i * EEQ_SIZE + EEQ_FUNC ],
                      eff_ob_num : args[ i * EEQ_SIZE + EEQ_EFF_OB ],
                      interval : args[ i * EEQ_SIZE + EEQ_INTERVAL ],
                      flags : args[ i * EEQ_SIZE + EEQ_FLAGS ],
                      eff_ev_args : args[ i * EEQ_SIZE + EEQ_ARGS ] );
    }
  } else {
    eeq = args;
  }
} /* set_eeq() */
// --- END [/mnt/home2/grok/lib/std/basic/effects.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/desc.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/desc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629937   Available: 13577291
Inodes: Total: 5242880    Free: 4960136
15654 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/desc.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629937   Available: 13577291
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: desc.c,v 1.11 2003/01/30 16:44:28 taffyd Exp $
 * 
*/
/**
 * The main description handling class.  Keeps track of the longs short
 * etc.
 * @author Pinkfish
 * @change sometime Deutha
 * Added all the a_short(), the_short() etc stuff.
 */
inherit "/std/basic/hide_invis";

nosave mixed short_d;
nosave mixed plural_d;
nosave mixed long_d;
private nosave string short_desc;

/**
 * This method sets the short description for the object.  Be careful
 * with using function pointers here, as they do not save when
 * players log out.
 * <p>
 * The short description is the description seen in peoples inventorys and
 * in brief mode when you enter rooms. This should be only a few words
 * long and should contain a fairly good description of the
 * object. Colour processing is done on basicly all of discworlds output,
 * so that will work in the short.
 * @param words the short description
 * @example
 * set_short("red rose");
 * @see short()
 * @see query_short()
 * @see a_short()
 * @see the_short()
 * @see poss_short()
 * @see one_short()
 */
void set_short(mixed words) {
  if (functionp(words)) {
    if (!short_d)
      plural_d = (: pluralize(evaluate(short_d)) :);
  } else {
     if ( !short_d && words && ( words != "" ) )
        plural_d = pluralize( words );
  }
   short_d = words;
} /* set_short() */

/**
 * This method sets the long description for the object.  The long description
 * is what the player sees with they 'look' at the object.  Please make sure
 * tht you use sentances in your long description.  Something like
 * 'The red box' is not a sentance.  You can use colour codes in your
 * long description to make it look cool.
 * @see help::look
 * @see long()
 * @see query_long()
 * @see help::colours
 * @param str the long description
 * @example
 * set_long("Picture perfect and glowing with an internal radience the "
 *          "Red Rose is simply wonderful.\n");
 */
void set_long(mixed str) { long_d = str; }
/**
 * This method sets the main plural for the object.  The main plural
 * is like the short description for the pluralised object.  If this
 * is not set then the short will attempt to be pluralised to
 * figure it out.
 * @see efun::pluralize()
 * @see query_plural()
 * @see query_main_plural()
 * @see set_short()
 * @see add_plural()
 * @param str the main plural
 * @example
 * set_main_plural("green wombles");
 */
void set_main_plural(mixed str) { plural_d = str; }
/**
 * This method returns the current value of the main plural.
 * @return the main plural
 */
mixed query_main_plural() { return plural_d; }

/**
 * This method returns the unadulterated short description.  The other
 * short calls might modify the output to display some status information.
 * @return the short description
 * @see short()
 * @see set_short()
 * @see a_short()
 * @see the_short()
 * @see poss_short()
 * @see one_short()
 */
mixed query_short() {
   if ( functionp( short_d ) )  {
      return evaluate(short_d);
   }
   else return short_d;
}

/** 
 * This method creates a simple short description for players based on their
 * stats, gender and guild.
 */
string query_short_desc() {
  string tmp;
  
  if(!short_desc) {
    short_desc = "";
    if(this_object()->query_str() > 16)
      short_desc += "strapping ";
    else if(this_object()->query_dex() > 16)
      short_desc += "nimble ";
    else if(this_object()->query_int() > 16)
      short_desc += "studious ";
    else if(this_object()->query_wis() > 16)
      short_desc += "pious ";

    short_desc += "young ";
    switch(this_object()->query_guild_ob()) {
    case "/std/guilds/warrior":
      short_desc += (this_object()->query_gender() == 2? "female " : "male ") +
        "warrior";
      break;
    case "/std/guilds/thief":
      tmp = "/std/guilds/thief"->query_guild_data();
      if(tmp)
        short_desc += (this_object()->query_gender() == 2? "female ": "male ")+
          tmp;
      else
        short_desc += (this_object()->query_gender() == 2? "female ": "male ")+
          "thief";
      break;
    case "/std/guilds/wizard":
      short_desc += (this_object()->query_gender() == 2? "female " : "male ") +
        "wizard";
      break;
    case "/std/guilds/witch":
      short_desc += "witch";
      break;
    case "/std/guilds/assassin":
      short_desc += (this_object()->query_gender() == 2? "female " : "male ") +
        "assassin";
      break;
    default:
      short_desc += (this_object()->query_gender() == 2? "lass" : "lad");
    }
  }

  return short_desc;
}

/**
 * This method returns the pluralized version of query_short_desc(). 
 * @see query_short_desc()
 */
string query_plural_desc() {
    // a strapping young thief -> two strapping young thieves. 
    // the standard pluralize() function will be fine for now.
    return pluralize( query_short_desc() ); 
} /* query_plural_desc() */ 

/**
 * This method returns the unadulterated long description.  The other
 * long calls might modify the output to display some status information.
 * @return the long description
 * @see long()
 * @see set_long()
 */
varargs mixed query_long(string str, int dark) {
  if (functionp(long_d))
    return evaluate(long_d);
  return long_d;
} /* query_long() */

/**
 * This method returns extra details about the object that should be
 * known above the basic long.  This is printed to people who do not
 * own the object in question (long() is used if you own it).
 * @param arg the argument the look was called with
 * @param dark how dark the place is
 * @param looker the person looking at the object
 */
string query_long_details(string arg, int dark, object looker) {
   return 0;
} /* query_long_details() */

/**
 * This method returns the current short description.  This is often
 * overridden to return status information about the object.
 * @return the short description string
 * @param dark if it is dark when viewing
 */
varargs string short(int dark) {
  if (functionp(short_d))
    return (string)evaluate(short_d);
  return short_d; 
} /* short() */

/**
 * This method returns the current long description.  This is
 * often overriden to display other information.
 * @return the current long descriptions
 * @param str the string which matched us
 * @param dark is it dark when viewing
 * @see set_long()
 */
string long(string str, int dark) {
  if (!long_d)
    return "You see nothing particularly interesting.\n";
  if (functionp(long_d))
    return (string)evaluate(long_d);
  return long_d;
} /* long() */

/**
 * This method returns the current plural string.  This is often overridden
 * to display extra information about the object, like the short and
 * long calls.  There is always an exception to a naming scheme :)
 * @see set_main_plural()
 * @see query_main_plural()
 * @return the plural string
 * @param dark if it was dark when viewing
 */
varargs string query_plural( int dark ) {
  if (!plural_d)
    if (!short( dark ))
      return 0;
    else
      return pluralize(short( dark ));
  if (functionp(plural_d))
    return (string)evaluate(plural_d);
  return plural_d;
} /* query_plural() */

/**
 * This returns the determinate for the object.  The determinate is
 * something like 'the'.  You set the derterminate by setting
 * the "determinate" property.  The viewer is check to see if
 * they can see the object as well, if it cannot be seen
 * "' is returned.
 * @example
 * // Set the determinate property
 * add_property("determinate", "the");
 * @see /std/basic/property->add_property()
 * @param thing the thing to check for visibility
 */
string query_determinate(object thing) {
  if(query_visible(thing)) {
#ifdef USE_ROLE_PLAYING_SHORTS
    if(interactive(this_object()) &&
      thing->query_role_playing() &&
       !thing->is_friend(this_object()->query_name()))
      return "a ";
#endif
    return (string)this_object()->query_property( "determinate" );
  }
  return "";
} /* query_determinate() */

/**
 * This method does weird stuff.  Pretty much it just calls the
 * short() function with the dark parameter...  This should not be
 * used to generate output.  Use a_short(), the_short(), or
 * one_short or poss_short() instead.
 * @see short()
 * @see /global/player->check_dark()
 * @return the string being the short
 * @param thing the viewer
 * @see a_short()
 * @see the_short()
 * @see poss_short()
 * @see one_short()
 */
varargs string pretty_short( object thing ) {
   int dark, verbose;

   if ( objectp( thing ) ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() ); 
      if(userp(thing))
        verbose = thing->query_verbose("names");
   }
     
   return (string)this_object()->short( dark, verbose );
} /* pretty_short() */

/**
 * The observer dependant plural.  It was specifical written to
 * handle money that needed to be displayed over several lines but
 * only be one object. The way this was achived was if pretty_plural
 * returns an array then each of the elements of the array is considered
 * to be a seperate object and displayed accordingly. 
 * @see set_main_plural()
 * @see /obj/money->pretty_plural()
 * @param thing the observer
 * @return the plural string
 */
varargs string pretty_plural( object thing ) {
   int dark;
   if ( objectp( thing ) )
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   return (string)this_object()->query_plural( dark );
} /* pretty_plural() */

/**
 * This method returns the "indeterminate" short.  This function returns a
 * string that the message system replaces, when messages are printed, by the
 * determinate of the object and its short as given by pretty_short. The
 * string should not be stored, since the object to which it refers may
 * not later exist; it can be processed with convert_message.
 * <p>
 * The return of this function needs more processing before the player
 * sees it.  In general you will not need to worry about this.
 * @param flag If this flag is set, do not bring the player out of hiding.
 * @see set_short()
 * @see short()
 * @see the_short()
 * @see poss_short()
 * @see one_short()
 * @see /global/events->convert_message()
 * @example
 * "a poor beggar"
 * "the Weasel"
 * "Detritus"
 */
varargs string a_short( int flag ) {
/*
   if ( objectp( thing ) ) {
      log_file( "SHORT", "a_short from "+ implode( map_array( previous_object( -1 ) + ({ this_object() }), (: file_name( $1 ) :) ), ", " ) +"\n" );
      return (string)thing->a_short();
   }
*/
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$a_short:"+ file_name( this_object() ) +"$";
} /* a_short() */

/**
 * This method returns an "out-of-a-group" short.
 * This function returns a string that the message system replaces, when
 * messages are printed, by a string dependent on the determinate of
 * the object and its short as given by pretty_short. If the viewer
 * is not in the same environment as the object or if the determinate is
 * defined and is not "a " or "an ", that string is the determinate. If
 * there is more than one object with the same plural as that object in its
 * environment, then that string is "one of the "; otherwise the
 * string is "the ". The output from from one_short should not be
 * stored, since the object to which it refers may not later exist; it can be
 * processed with convert_message. One_short is mostly used for
 * referring to a living object when it performs an action independent
 * of any previous actions. 
 * <p>
 * The return of this function needs more processing before the player
 * sees it.  In general you will not need to worry about this.
 * @param flag If this flag is set, do not bring the player out of hiding.
 * @see set_short()
 * @see short()
 * @see a_short()
 * @see the_short()
 * @see poss_short()
 * @see /global/events->convert_message()
 * @example
 * "one of the poor beggars"
 * "the Weasel"
 * "Detritus"
 * "One of the sailors falls over"
 */
varargs string one_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$one_short:"+ file_name( this_object() ) +"$";
} /* one_short() */

/**
 * This method returns the "possessed" short.  This function returns a
 * string that the message system replaces, when messages are printed, by a
 * string dependent on the possessor of the object and its short as
 * given by pretty_short. If the object has no environment or is not in a
 * living object or corpse, that string is the determinate. If the
 * environment of the object is the viewer of the message, that string
 * is "your". If the determinate is defined and is not "a " or "an ",
 * or, if it is not defined or is "a " or "an " but it is the only thing in its
 * environment with its plural, that string is the possessive of the owner, if
 * the owner has already been mentioned in constructing a sentence, or the
 * owner's the_short plus "'s "; otherwise, the string is "one
 * of the " plus the possessive bit as described in the previous part of
 * this sentence. Got all that? Good :) The string should not be stored,
 * since the object to which it refers may not later exist; it can be
 * processed with convert_message. Poss_short is mostly used for referring
 * to an object when a person has just used it to do something.
 * <p>
 * The return of this function needs more processing before the player
 * sees it.  In general you will not need to worry about this.
 * @param flag If this flag is set, do not bring the player out of hiding.
 * @see set_short()
 * @see short()
 * @see a_short()
 * @see the_short()
 * @see one_short()
 * @see /global/events->convert_message()
 * @example
 * "one of Wombat's knives".
 * "one of his wands".
 * "her Wyrm Sword".
 * "Frenkel twists one of his rings."
 */
varargs string poss_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$poss_short:"+ file_name( this_object() ) +"$";
} /* poss_short() */

/**
 * Just like poss_short() but returning a definite article.
 * @see poss_short()
 */
varargs string the_poss_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$the_poss_short:"+ file_name( this_object() ) +"$";
} /* poss_short() */

/**
 * This method returns the "determinate" short.  This function returns a
 * string that the message system replaces, when messages are printed, by the
 * determinate of the object (or "the" if the determinate is "a", "an" or
 * undefined) and its short as given by pretty_short. The string
 * should not be stored, since the object to which it refers may not later
 * exist; it can be processed with convert_message.
 * <p>
 * The return of this function needs more processing before the player
 * sees it.  In general you will not need to worry about this.
 * @param flag If this flag is set, do not bring the player out of hiding.
 * @see set_short()
 * @see short()
 * @see a_short()
 * @see poss_short()
 * @see one_short()
 * @see /global/events->convert_message()
 * @example
 * "the poor beggar"
 * "the Weasel"
 * "Detritus"
 */
varargs string the_short( int flag ) {
/*
   if ( objectp( thing ) ) {
      log_file( "SHORT", "the_short from "+ implode( map_array( previous_object( -1 ) + ({ this_object() }), (: file_name( $1 ) :) ), ", " ) +"\n" );
      return (string)thing->the_short();
   }
*/
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$the_short:"+ file_name( this_object() ) +"$";
} /* the_short() */
// --- END [/mnt/home2/grok/lib/std/basic/desc.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/theft_callback.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/theft_callback.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629933   Available: 13577287
Inodes: Total: 5242880    Free: 4960136
1806 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/theft_callback.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629933   Available: 13577287
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Theft callback system!
 * @author Terano
 * @started 5/04/2003
 */

class theft_callback {
     string func_name; //Function to call!
     string path;     //Object to call func_name on.
}

class theft_callback *calls = ({ });

void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {

  if ( !sizeof( calls ) )
    return;

  //If it's us getting stolen!
  if ( !stolen ) {
    foreach( class theft_callback temp in calls ) {
      if ( stringp( temp->path ) && stringp( temp->func_name ) )
        call_other( temp->path, temp->func_name, this_object(), thief, victim );
    }
  }
  return;
}

/** 
 * Add a new theft callback!
 * @arg string func_name to call.
 * @arg string Path to call func_name on.
 * @return int -1 if failed, otherwise the ID of the callback.
 */

int add_theft_callback( string func_name, string path ) {
class theft_callback temp = new( class theft_callback, func_name: func_name,
  path: path );

  if ( !stringp( func_name ) || !stringp( path ) ) 
    return -1;

  debug_printf( "Added theft callback: %s %s.\n", func_name, path );

  calls += ({ temp });
  return sizeof( calls ) - 1;
}

/** 
 * Delete a theft callback!
 * @arg int ID to remove!
 * @return int -1 if failed, 1 otherwise
 */

int remove_theft_callback( int id ) {

  if ( id >= sizeof( calls ) || id < 0 ) 
    return -1;

  debug_printf( "Deleting callback: %s %s.\n", calls[id]->func_name, 
    calls[id]->path );

  calls -= ({ calls[id] });
  return 1;
}

string query_theft_callbacks() {
string ret = "";
int count = 0;

  if ( !sizeof( calls ) ) 
    return "No theft callbacks found!\n";

  foreach( class theft_callback temp in calls ) {
    ret += sprintf( "%d. %s: %s.\n", count, temp->func_name, temp->path );
    count++;
  }

  return ret;
}// --- END [/mnt/home2/grok/lib/std/basic/theft_callback.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/stat_adjustments.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/stat_adjustments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629932   Available: 13577286
Inodes: Total: 5242880    Free: 4960136
1779 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/stat_adjustments.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629932   Available: 13577286
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the stat adjustment inheritable will add stat
 * adjustments to the player.  It will also keep track of who they are added to
 * so they can be removed correctly.
 * @author Pinkfish
 * @started Sun May  7 14:41:09 PDT 2000
 */
#include <effects/stat_adjustment.h>

private nosave mapping _adjs;

void create() {
   _adjs = ([ ]);
} /* create() */

/**
 * This method adds a set of stat adjustments to a specified player
 * <pre>
 *  ([
 *     "str" : 1,
 *     "dex" : -1,
 *     "wis" : 3
 *  ])
 * </pre>
 * @param player the player to add the adjustments too
 * @param adjs the adjustments to add
 */
void set_stat_adjustment(object player, mapping adjs) {
   _adjs[player] = adjs;
   player->add_effect(STAT_ADJUSTMENT_EFFECT, ({ this_object(), adjs }));
} /* add_stat_adjustment() */

/**
 * This method removes the stat adjustments from the specified player
 * @param player the player to remove the stat adjustments from
 */
void remove_stat_adjustment(object player) {
   STAT_ADJUSTMENT_EFFECT->remove_stat_adjustment_ob(player, this_object());
   map_delete(_adjs, player);
} /* remove_stat_adjustment() */

/**
 * This method removes all the stat adjusments currently setup on
 * the object.
 */
void remove_all_stat_adjustments() {
   mapping adj;
   object play;

   foreach (play, adj in _adjs) {
      STAT_ADJUSTMENT_EFFECT->remove_stat_adjustment_ob(play, this_object());
      map_delete(_adjs, play);
   }
   _adjs = ([ ]);
} /* remove_all_stat_adjustments() */

/**
 * This method returns the current stat adjustments on the specified
 * player.
 * @param play the player to find the stat adjustments for
 * @return the stat adjustments
 */
mapping query_stat_adjustments(object play) {
   return _adjs[play];
} /* query_stat_adjustments() */
// --- END [/mnt/home2/grok/lib/std/basic/stat_adjustments.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/condition.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/condition.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629932   Available: 13577286
Inodes: Total: 5242880    Free: 4960136
11117 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/condition.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629932   Available: 13577286
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: condition.c,v 1.14 2003/05/13 21:20:48 ceres Exp $
 */
/**
 * This class keeps track of the condition of a particular object.  It
 * handles damaging the object when it is hit and the lowest conditon to
 * which the object has been damaged.  The lowest conditon keeps track of
 * how hard the object is to fix.  If an object has been reduced to really
 * shaggy condition at one point, it will be a lot harder to fix from then
 * on.
 * @author Pinkfish
 */
#include <armoury.h>
#include <move_failures.h>

#define DAMAGE_NORM 200

private nosave int cond, max_cond, lowest_cond, damage_chance, hide_cond;

void create() {
   max_cond = 1;
} /* create() */

/* This should be masked. */
/**
 * This method breaks the object.  This moves it into the recycled
 * object section of the armoury or dests itself if this is not
 * possible.
 */
void break_me() {
  if(environment(this_object())) {
    if(living(environment(this_object())))
      tell_object(environment(this_object()),
                  capitalize(this_object()->the_short()) + " breaks!\n");
    else
      tell_room(environment(this_object()),
                capitalize(this_object()->the_short()) + " breaks!\n");
  }
  
  if((int)this_object()->move("/room/rubbish") != MOVE_OK)
    move_object("/room/rubbish");
}

/**
 * This method returns the current condition as a string.
 * @return the string value of the condition
 */
string cond_string() {
   string pronoun;
   string verb;

   if ( cond > max_cond ) {
      cond = max_cond;
   }
   if ( hide_cond )
      return "";

   pronoun = capitalize(this_object()->query_pronoun());
   verb = this_object()->query_is_pair() ? " are" : " is";
   switch ( ( 100 * cond ) / max_cond ) {
      case 91 .. 100 :
         return pronoun + verb + " in excellent condition.\n";
      case 81 .. 90 :
         return pronoun + verb + " in very good condition.\n";
      case 71 .. 80 :
         return pronoun + verb + " in good condition.\n";
      case 61 .. 70 :
         return pronoun + verb + " in decent condition.\n";
      case 51 .. 60 :
         return pronoun + verb + " in fairly good condition.\n";
      case 41 .. 50 :
         return pronoun + verb + " in fairly poor condition.\n";
      case 31 .. 40 :
         return pronoun + verb + " in poor condition.\n";
      case 21 .. 30 :
         return pronoun + verb + " in really poor condition.\n";
      case 11 .. 20 :
         return pronoun + verb + " in very poor condition.\n";
      case 1 .. 10 :
         return pronoun + verb + " in atrocious condition.\n";
      default :
         return pronoun + verb + " a complete wreck.\n";
   }
} /* cond_string() */

/**
 * This sets up how much damage an object can take before it 
 * breaks.  This should not be used in the actual object files
 * unless under special circumstances.  In weapon files, use 
 * new_weapon().  In armour files use setup_armour().  In 
 * clothing files, use setup_clothing().  Use ::Setup:: in 
 * clo, arm, and wep files.
 * <p>
 * The values may seem strange, as cloth can take more damage 
 * per unit weight than steel.  This is because steel weighs
 * so much, and cloth weighs so little.
 * <br><br>
 * o==================o=====================o<br>
 * |     Material     |  Maximum Condition  |<br>
 * |                  |   per unit weight   |<br>
 * o==================o=====================o<br>
 * | Cloth            |         90          |<br>
 * | Hide             |         80          |<br>
 * | Leather          |         70          |<br>
 * | Wood             |         60          |<br>
 * | Bone             |         45          |<br>
 * o==================o=====================o<br>
 * | Copper           |         30          |<br>
 * | Stone            |         40          |<br>
 * | Bronze           |         40          |<br>
 * | Iron             |         50          |<br>
 * | Steel            |         60          |<br>
 * | Klatchian Steel  |         70          |<br>
 * | Octiron          |         80          |<br>
 * o==================o=====================o
 * 
 * @see new_weapon
 * @see setup_armour
 * @see setup_clothing
 * @see set_weight
 * @see set_damage_chance
 */
void set_max_cond(int i) { max_cond = i; }

/**
 * This method sets the current condition of the object.  If this is lower
 * than the current lowest conditon, then the lowest condition will be modified
 * to be this.
 * @param i the new condition
 * @see adjust_condition
 */
void set_cond(int i) {
   cond = i;
   if (cond < 0) {
      cond = 0;
   }
   if (cond < lowest_cond) {
      lowest_cond = cond;
   }
   if ( cond <= 0 ) {
      if ( environment( this_object() ) &&
          !environment( this_object() )->query_property("don't break contents")) {
         this_object()->break_me();
      }
      return 0;
   }
} /* set_cond() */

/**
 * This method adjust the current condition by the given amount.  If
 * resultant condition is less than the lowest condition, then the lowest
 * condition is set to this value.  If it is greater than the maximum
 * condition.  Then the condition is set to the maximum condition.  If the
 * condition is less than or equal to 0, then the object is attempted to
 * be broken.
 * @param i the amount to adjust the condition by
 * @return the new condition
 * @see set_cond()
 */
int adjust_cond( int i ) {
   cond += i;
   if (cond < 0)
      cond = 0;
   if ( cond < lowest_cond )
      lowest_cond = cond;
   if ( cond > max_cond )
      cond = max_cond;
   if ( cond <= 0 ) {
      if ( !environment()->query_property( "don't break contents" ) )
         this_object()->break_me();
      return 0;
   }
   return cond;
} /* adjust_cond() */

/**
 * This sets the lowest condition for the object.  The lowest cond
 * variable is used for repairing the armour...
 * See where it was repaired to last time, this determines how difficult
 * repairs will be...
 * @param i the new lowest condition
 * @see adjust_cond()
 * @see set_cond()
 */
void set_lowest_cond(int i) { lowest_cond = i; }

/**
 * This sets whether the condition string should be returned or not.  This
 * is for objects what indicate their condition with different long
 * descriptions instead of the default condition string.
 * @param i set it to 1 to hide the condition string.
 */
void set_hide_cond(int i) { hide_cond = i; }

/**
 * This method returns the current conditon.
 * @return the current condition
 */
int query_cond() {
  if ( cond > max_cond ) {
    cond = max_cond;
  }
  return cond;
}

/**
 * This method returns the current maximum conditon.
 * @return the current maximum condition
 */
int query_max_cond() { return max_cond; }

/**
 * This method returns the current lowest conditon.
 * @return the current lowest condition
 */
int query_lowest_cond() { return lowest_cond; }

/**
 * This method returns whether the condition string returns "" or something 
 * meaning full.
 * @return the current lowest condition
 */
int query_hide_cond() { return hide_cond; }

/**
 * This method is used to setup the objects condition.  Once the maximum
 * condition has been set, this is used to set the maximum condition to
 * this percentage of the maximum condition.
 * It sets the lowest conditon a random value from 70-100% of the
 * current condition.
 * @param i the percentage condiion
 * @see /obj/handlers/armoury.c
 * @see set_cond()
 * @see set_lowest_cond()
 * @see query_max_cond()
 */
void set_percentage(int i) {
   if (i > 100) {
      i = 100;
   }
   set_cond((query_max_cond() * i) / 100);
   set_lowest_cond((query_cond()*(random(30) + 70)) / 100);
} /* set_percentage() */

/** 
 * This method returns the percentage of the damage which is done to the
 * object which will be carried through.
 * @return the damage chance
 * @see do_damage()
 */
int query_damage_chance() { return damage_chance; }

/**
 * This method sets the percentage of the damage which is done to the
 * object which will be carried through.
 * <p>
 * Use the following chart to set the damage chance.
 * <br><br>
 * o==================o=====================o<br>
 * |     Material     |    Damage Chance    |<br>
 * o==================o=====================o<br>
 * | Cloth            |         20          |<br>
 * | Hide             |         17          |<br>
 * | Bone             |         16          |<br>
 * | Leather          |         15          |<br>
 * | Wood             |         12          |<br>
 * | Copper           |         10          |<br>
 * | Bronze           |          8          |<br>
 * | Iron             |          6          |<br>
 * | Steel            |          5          |<br>
 * | Klatchian Steel  |          3          |<br>
 * | Stone            |          3          |<br>
 * | Octiron          |          0          |<br>
 * o==================o=====================o
 *
 * @see new_weapon
 * @see setup_armour
 * @see setup_clothing
 * @see set_weight
 * @see set_max_cond
 * @see query_damage_chance()
 * @see do_damage()
 * @param number the new damage chance
 */
void set_damage_chance( int number ) { damage_chance = number; }

/**
 * This method damages the object.  The conditon is reduced by
 * the amount multiplied by 1 + 2 * random(damage_chance) ewhic
 * is then divided by 100.  This means it does approximately
 * the percentage of of the damage done to the object to its condition.
 * @see set_damage_chance()
 * See query_damage_chance()
 */
void do_damage( string type, int amount ) {
   int wholes, parts;

   wholes = amount * ( 1 + random( damage_chance ) + random( damage_chance ) );
   parts = wholes % DAMAGE_NORM;
   wholes /= DAMAGE_NORM;
   if ( random( DAMAGE_NORM ) < parts )
      wholes++;
   adjust_cond( -wholes );
} /* do_damage() */

/**
 * @ignore
 */
mixed *stats() {
   return 
      ({
         ({ "condition", cond }),
         ({ "max cond", max_cond }),
         ({ "lowest cond", lowest_cond }),
         ({ "damage chance", damage_chance }),
         ({ "hide cond", hide_cond }),
      });
} /* stats() */

/**
 * @ignore
 */
mapping query_static_auto_load() {
   return ([
      "max cond" : max_cond,
      "damage chance" : damage_chance,
      "hide cond" : hide_cond
   ]);
} /* query_static_auto_load */

/**
 * @ignore
 */
void init_static_arg( mapping map ) {
   if ( !undefinedp( map[ "max cond" ] ) )
      max_cond = map[ "max cond" ];
   if ( !undefinedp( map[ "damage chance" ] ) )
      damage_chance = map[ "damage chance" ];
   if ( !undefinedp( map[ "hide cond" ] ) )
      hide_cond = map[ "hide cond" ];
} /* init_static_arg() */

/**
 * @ignore
 */
mapping query_dynamic_auto_load() {
   if ( cond > max_cond ) {
      cond = max_cond;
   }

   if ( lowest_cond > cond ) {
      lowest_cond = cond;
   }

   return ([
      "cond" : cond,
      "lowest cond" : lowest_cond
   ]);
} /* query_dynamic_auto_load */

/**
 * @ignore
 */
void init_dynamic_arg( mapping map, object ) {
   if ( !undefinedp( map[ "cond" ] ) )
      cond = map[ "cond" ];
   if ( !undefinedp( map[ "lowest cond" ] ) )
      lowest_cond = map[ "lowest cond" ];
} /* init_dynamic_arg() */

// --- END [/mnt/home2/grok/lib/std/basic/condition.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/light.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/light.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629929   Available: 13577283
Inodes: Total: 5242880    Free: 4960136
6371 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/light.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629929   Available: 13577283
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*   -*- LPC -*-   */
/*
 * $Locker:  $
 * $Id: light.c,v 1.9 2002/01/04 02:45:06 presto Exp $
 * $Log: light.c,v $
 * Revision 1.9  2002/01/04 02:45:06  presto
 * Changed to handle negative light values correctly.  Also might be a bit faster
 * since I eliminated some redudant call_others
 *
 * Revision 1.8  2000/04/21 17:13:50  taffyd
 * Fixes so that opaque containers don't let light escape.
 *
 * Revision 1.7  1998/10/30 08:48:08  pinkfish
 * Stuff and stuff!
 *
 * Revision 1.6  1998/08/21 23:56:41  pinkfish
 * Whoops.  Made it do the wrong thing for propogating light changs through
 * non-opaque objects.
 *
 * Revision 1.5  1998/08/21 00:48:24  pinkfish
 * Handling for opaque objects.
 *
 * Revision 1.4  1998/08/20 12:29:14  pinkfish
 * Changes for the new light code.
 *
 * Revision 1.2   1998/05/23 15:16:49   gototh
 * Added a table of light levels to the help for set_light.
 *
 * Revision 1.1   1998/01/06 03:59:10   ceres
 * Initial revision
 * 
*/
/**
 * This method handles the light changing and control.
 * @author Pinkfish
 * @change Many
 *    Lots and lots of changes :)
 */
private nosave int _light;
private nosave int _my_light;
private nosave int _need_recalculate;
private nosave object *_inform_of_change;

void new_recalc_light();
mixed query_property(string name);
void add_property(string name, mixed value);
void remove_property(string name);

void create() {
    _inform_of_change = ({ });
} /* create() */

/**
 * This returns the total light level of the object.   This includes the
 * light levels of anything that happens to be inside us.
 * @return current light level
 * @see query_my_light()
 * @see set_light()
 */
int query_light() {
    if (_need_recalculate) {
        _need_recalculate = 0;
        new_recalc_light();
    }
    return _light;
} /* query_light() */

int query_light_needs_inform() {
    return _light || _need_recalculate;
} /* query__light_needs_inform() */

/**
 * This method returns the light associated with this object.   This does
 * not count the light levels of anything inside us.
 */
int query_my_light() { return _my_light; }

/**
 * This method forces a recalculation of the current light level in this
 * object.
 */
varargs void new_recalc_light() {
    object *obs;
    object ob;
    int tmp_light;

    _need_recalculate = 0;
    /* How do we do this...? */
    /*
     * Use the square root of the squares to make the differences not so wild.
     */
    _light = _my_light * _my_light;
    if (_my_light < 0)  _light = -_light;
    if ( !this_object()->query_opaque() ) {
        obs = all_inventory(this_object());
        foreach (ob in obs) {
            // If it is opaque, we do not count the light of the contents.
            if (ob->query_opaque()) {
                tmp_light = ob->query_my_light();
            } else {
                tmp_light = ob->query_light();
            }
            if (tmp_light >= 0)  _light += tmp_light * tmp_light;
            else  _light -= tmp_light * tmp_light;
        }
    }
    if (_light >= 0)  _light = sqrt(_light);
    else  _light = -sqrt(-_light);
    _inform_of_change->event_light_change(this_object(), 0, _light);
} /* new_recalc_light() */

/**
 * This method tells us that the light levels have changed and should
 * be recalculated when queried.
 * @see inform_of_light_level_change()
 */
void light_level_changed() {
    _need_recalculate = 1;
} /* light_level_changed() */

/**
 * This method tells all our environments that the light level has
 * changed.
 * @param ob the object whose environment we should tell about the change
 * @see light_level_changed()
 */
void inform_of_light_level_change(object ob) {
    if (ob) {
        ob->light_level_changed();
    }
    while (ob && !ob->query_opaque()) {
        ob->light_level_changed();
        ob = environment(ob);
    }
} /* inform_of_light_level_change() */

/**
 * This method adds an object to be informed of light change events.
 * @param ob the object to be informed of light change events
 */
void add_inform_light_change(object ob) {
    _inform_of_change += ({ ob });
} /* add_inform_lifht_change() */

/**
 * This method removes an object from the current list of things to
 * be informed of a light change.
 * @param ob the object to remove from the inform list
 */
void remove_inform_light_change(object ob) {
    _inform_of_change -= ({ ob });
} /* remove_inform_light_change() */

/**
 * This method makes this object opaque.   This means that light does not
 * escpae from it.
 * @see not_obscured_object()
 * @see set_light()
 */
void set_opaque() {
    add_property( "opaque", 1 );
} /* set_opaque() */

/**
 * This method makes the object transparent (default).   This means that the
 * light from items inside does escape.
 * @see set_opaque()
 * @see set_light()
 */
void reset_opaque() {
    remove_property( "opaque" );
} /* reset_opaque() */

/**
 * This method checks to see if the object is opaque or not.
 * @return 1 if it is opaque, 0 if not
 */
int query_opaque() {
    return query_property("opaque");
} /* query_opaque() */

/**
 * This changes the current light level. 
 * @param number the amount to chage it by
 * @see set_light()
 * @see query_my_light()
 * @see query_light()
 */
int adjust_light( int number ) {
    if (number) {
        _my_light += number;
        inform_of_light_level_change(this_object());
    }
    return _light;
} /* adjust_light() */

/**
 * This sets the current light level.   This method calls adjust_light() 
 * with the correct value to set the light level.
 * <BR><BR>
 * Light Levels:
 * <BR>
 *    Magically Darkened Room   0-
 * <BR>
 *    Absolutely Dark Room      0
 * <BR>
 *    Standard Dark Room        5
 * <BR>
 *    Dimly Lit Room            20
 * <BR>
 *    Mine Shaft with Candles   30
 * <BR>
 *    Partially Lit Room        50
 * <BR>
 *    Well Lit Room             60
 * <BR>
 *    Shaded Forest             60
 * <BR>
 *    Brightly Lit Room         80
 * <BR>
 *    Direct Sunlight           100
 * <BR>
 *    Explosion or flash        200+
 * <BR>
 * @param number The new light level.
 * @see query_my_light()
 * @see query_light()
 */

int set_light(int number) {
    return adjust_light(number - _my_light);
} /* set_light() */

/** @ignore yes */
mixed *stats() {
    return ({
      ({ "light", _light, }),
      ({ "my light", _my_light, }),
    });
} /* stats() */

// --- END [/mnt/home2/grok/lib/std/basic/light.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/scroll_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/scroll_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629927   Available: 13577281
Inodes: Total: 5242880    Free: 4960136
5282 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/scroll_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629927   Available: 13577281
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: scroll_base.c,v 1.4 2000/06/28 05:09:39 pinkfish Exp $
 * $Log: scroll_base.c,v $
 * Revision 1.4  2000/06/28 05:09:39  pinkfish
 * Fix up the scroll base to work with the new spells.
 *
 * Revision 1.3  1999/12/01 06:19:53  pinkfish
 * Fix up some bugs.
 *
 * Revision 1.2  1999/11/08 22:39:49  pinkfish
 * Move the reaction code into a seperate file.
 *
 * Revision 1.1  1999/11/04 01:51:34  pinkfish
 * Initial revision
 *
 * 
 */
/**
 * This is the basic control file for scrolls.  It contains all the common
 * scroll handling stuff that goes into both the object and the shadow.
 */
#include <tasks.h>

inherit "/std/basic/scroll_book_react";

#define SKILL "magic.items.scroll"
#define CONTROL_SKILL "magic.spells.special"

private string _spell;

/** @ignore yes */
string long( string word, int dark ) {
   int i;
   int j;
   int chance;
   int level;
   int width;
   string spell_name;

   level = 2 * (int)_spell->query_power_level();
   width = sqrt( level );
   chance = (int)this_player()->query_skill_bonus( SKILL ) - ( level - width );
   chance = ( 100 * chance ) / ( 2 * width + 1 );
   spell_name = "$"+ (string)_spell->query_name() +"$";
   j = strlen( spell_name ) - 1;
   for ( i = 1; i < j; i++ ) {
      if ( random( 100 ) > chance ) {
         switch ( spell_name[ i ] ) {
            case 32 :
               break;
            case 65 .. 90 :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     sprintf( "%c", 65 + random( 26 ) ) +
                     spell_name[ i + 1 .. j ];
               break;
            case 97 .. 122 :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     sprintf( "%c", 97 + random( 26 ) ) +
                     spell_name[ i + 1 .. j ];
               break;
            default :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     spell_name[ i + 1 .. j ];
               j--;
         }
      }
   }
   spell_name = spell_name[ 1 .. j - 1 ];
   return spell_name;
} /* long() */

/**
 * This method returns always returns 1 for a magic scroll.
 * @return always returns 1
 */
int query_magic_scroll() { return 1; }

/**
 * This method returns the current binding force of the scroll.  This is
 * the amount of force the paper exerts to try and keep the spell on the
 * paper.
 * @return the scrolls binding force
 */
int query_binding_force() { return 5; }

/**
 * This method returns the spell associated with the scroll.
 * @return the spell associated with the scroll
 */
string query_spell() { return _spell; }

/**
 * This method returns the power level of the spell current associated
 * with the object.
 */
int query_spell_power_level() {
   if (_spell) {
      return _spell->query_power_level();
   }
} /* query_spell_power_level() */

/**
 * This method sets the spell associated with the scroll.
 * @param word the spells path
 */
void set_spell( string word ) { _spell = word; }

/**
 * This method returns the name o fthe spell on the scroll.
 * @return the name of the spell
 */
string query_spell_name() { return (string)_spell->query_name(); }

/**
 * This method tests the skill needed to cast the spell on the scroll.
 * @return the skill needed to cast
 */
int test_skill() {
   int level;

   level = 2 * (int)( _spell->query_power_level() ) + 1;
   return (int)TASKER->perform_task(this_player(), SKILL, level, TM_FREE);
} /* test_spell() */

/**
 * This method clears the spell off the scroll and turns it back into
 * a normal piece of paper.
 * @param award a tm was awarded on the way
 */
void clear_spell( int award ) {
   if ( award ) {
     write( "%^YELLOW%^"+ ({ "A piece of lore concerning scrolls becomes "
             "clearer for you", "You manage to grasp one of the principles "
             "of magic scrolls more firmly", "A sudden flash of insight "
             "allows you to understand process of casting a spell from a "
             "scroll a little better" })[ random( 3 ) ] +".%^RESET%^\n" );
   }
} /* clear_spell() */

/**
 * This method clears the spell off the scroll and turns it back into
 * a normal piece of paper.
 * @param award a tm was awarded on the way
 */
int cast_spell( string words ) {
   int outcome;

   if ( !words ) {
      words = "";
   }
   outcome = test_skill();
   if ( outcome == FAIL ) {
      return notify_fail( "You can't figure out how to use the scroll.\n" );
   }
   if ( !( _spell->cast_spell( words, 1 ) ) ) {
      return 0;
   }
   clear_spell( outcome == AWARD );
   return 1;
} /* cast_spell() */

/**
 * This method clears the spell off the scroll and turns it back into
 * a normal piece of paper.
 * @param award a tm was awarded on the way
 */
int cast_spell_new( string words , object* targets, object* using ) {
   int outcome;

   if ( !words ) {
      words = "";
   }
   outcome = test_skill();
   if ( outcome == FAIL ) {
      return notify_fail( "You can't figure out how to use the scroll.\n" );
   }
   if ( !( _spell->cast_spell_new( words, 1, targets, using ) ) ) {
      return 0;
   }
   clear_spell( outcome == AWARD );
   return 1;
} /* cast_spell() */

/** @ignore yes */
string query_death_reason() {
   return " a spell going wild and getting out of control.";
} /* query_death_reason() */
// --- END [/mnt/home2/grok/lib/std/basic/scroll_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/enchant.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/enchant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629926   Available: 13577280
Inodes: Total: 5242880    Free: 4960136
8566 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/enchant.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629926   Available: 13577280
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: enchant.c,v 1.16 2002/06/05 21:19:11 ohdamn Exp $
 * $Log: enchant.c,v $
 * Revision 1.16  2002/06/05 21:19:11  ohdamn
 * Fixed typo
 *
 * Revision 1.15  2002/02/21 19:53:53  tannah
 * added some call_others so that query_max_enchant() and
 * query_degrade_enchant() could be shadowed... (and then didn't shadow
 * them after all).
 *
 * Revision 1.14  2001/04/13 00:04:07  pinkfish
 * Add in a degrade enchantment cutoff.
 *
 * Revision 1.13  2000/05/24 02:16:22  pinkfish
 * Make the rounds up even more generous.
 *
 * Revision 1.12  2000/05/24 02:12:46  pinkfish
 * It should round up the enchant values a little more generously.
 *
 * Revision 1.11  2000/05/19 19:36:06  pinkfish
 * Fix up a typo that caused add_enchant not to work.
 *
 * Revision 1.9  2000/05/19 06:46:41  pinkfish
 * Make enchantment degrade.
 *
 * Revision 1.8  2000/04/21 18:03:47  tannah
 * Fixed another bug.  Hat. Hat. Ernkgh.
 *
 * Revision 1.7  2000/04/20 21:14:17  tannah
 * Fixed a tiny leetle bugge in enchant_string(). Hat. Hat. Hat.
 *
 * Revision 1.6  2000/04/20 20:16:09  pinkfish
 * Add in talisman messages.
 *
 * Revision 1.5  1999/10/04 22:01:42  pinkfish
 * Fix up enchant to be more useful in how it handles enchantment.  Make the
 * variable private.
 *
 * Revision 1.4  1999/05/20 17:04:45  dragonkin
 * Added extra check in enchant_string() for enchants over max enchant
 *
 * Revision 1.3  1999/02/16 20:19:52  ceres
 * Minor tweaks
 *
 * Revision 1.2  1998/03/23 21:29:58  olorin
 * made query_max_enchant() maskable
 *
 * Revision 1.1  1998/01/06 03:59:10  ceres
 * Initial revision
 * 
*/
/**
 * Module to handle the amount of magical charge (enchantment) of an
 * object has.  The maximum enchantment of an item is determined by
 * by its weight - the material of composition is not yet taken into
 * account.
 * <p>
 * Enchanting an object will add to its value, and, if the object
 * is an item of armour, will improve its armour class.
 *
 * @change 20th May 1994 Deutha
 *    added a function to calculate the maximum
 *                 enchantment based on weight.
 * @author Pinkfish
 */

nosave private int _enchanted;
nosave private int _set_enchant_time;
nosave private int _degrade_enchant;

#define ENCHANT_DEGRADE_TIME (8 * 7 * 24 * 60 * 60)

/**
 * This method returns the maximum possible enchantment for the
 * object.  This is based on its weight.
 * @return the maximum enchantment
 */
int query_max_enchant()
{
   return 5 + (int) this_object()->query_weight() / 4;
}                               /* query_max_enchant() */

/**
 * This method returns the maximum enchantment before the enchantment
 * starts to degrade.
 * @return the enchantment level which enchantment degrades to
 */
int query_degrade_enchant() {
   if (!_degrade_enchant) {
      return this_object()->query_max_enchant() / 2;
   }
   return _degrade_enchant;
} /* query_degrade_enchant() */

/**
 * This method sets the enchantment at which things start to degrade.
 * @param enchant the enchantment level to set it at
 */
void set_degrade_enchant(int enchant) {
   if (enchant > this_object()->query_max_enchant()) {
      enchant = this_object()->query_max_enchant();
   }
   _degrade_enchant = enchant;
} /* set_degreade_enchant() */

/**
 * This method returns the current enchantment string for the object.  The 
 * string is created from the percentage of the max enchantment that it is 
 * enchanted to.  If the object is also a talisman, an identifying string is 
 * appended to the enchantment message.
 * <p>
 * These messages are only visible to creators and players who can see
 * octarine.
 * <p>
 * If the property "octarine_mess" is set, then this will be printed instead 
 * of the automatically generated enchantment message.
 * <p>
 * If the property "talisman_mess" is set, then this will be printed instead
 * of the automatically generated talisman message if appropriate.
 * @return the enchantment string and talisman string
 * @see set_enchant()
 * @see add_enchant()
 * @see query_max_enchant()
 * @see query_enchant()
 */
string enchant_string()
{
   string tal_msg;
   string ench_msg;

   if (this_object()->query_property("talisman")) {
      tal_msg = (string) this_object()->query_property("talisman_mess");
      if (!tal_msg)
         tal_msg = "It has the hazy octarine sparkle of a magical talisman.";
      tal_msg += "\n";
   } else {
      tal_msg = "";
   }

   if (this_object()->query_property("octarine_mess")) {
      ench_msg = (string) this_object()->query_property("octarine_mess")
         + "\n";
   } else {
      switch ((this_object()->query_enchant() * 100) /
              this_object()->query_max_enchant()) {
      case 1..10:
         ench_msg = "It occasionally pulses with octarine light.\n";
         break;
      case 11..20:
         ench_msg = "It emits a slight octarine glow.\n";
         break;
      case 21..30:
         ench_msg = "It softly pulses in dull octarine shades.\n";
         break;
      case 31..40:
         ench_msg = "It gives off a steady but dull octarine glow.\n";
         break;
      case 41..50:
         ench_msg = "It gives off a steady octarine glow.\n";
         break;
      case 51..60:
         ench_msg = "It glows an intense octarine.\n";
         break;
      case 61..70:
         ench_msg = "It emits a bright octarine colour.\n";
         break;
      case 71..80:
         ench_msg = "It brightly pulses octarine.\n";
         break;
      case 81..90:
         ench_msg = "It glows brilliant octarine shades.\n";
         break;
      case 91..100:
         ench_msg = "It radiates pure octarine brilliance.\n";
         break;
      default:
         ench_msg = "";
      }
   }
   return ench_msg + tal_msg;
}                               /* enchant_string() */

/**
 * This method sets the current enchantment level.   If it is greator than
 * the max enchantment level then it will be set to the maximum
 * enchantment level.
 * @param number the new enchantment level
 * @see enchant_string()
 * @see query_enchant()
 * @see query_max_enchant()
 * @see add_enchant()
 */
void set_enchant(int number)
{
   if (number > this_object()->query_max_enchant()) {
      number = this_object()->query_max_enchant();
   }
   _set_enchant_time = time();
   _enchanted = number;
}                               /* set_enchant() */

/**
 * This method changes the current enchanment level.
 * @param numnber the amount to chant the enchantment level by
 * @see enchant_string()
 * @see query_enchant()
 * @see set_enchant()
 * @see query_max_enchant()
 */
int add_enchant(int number)
{
   set_enchant(this_object()->query_enchant() + number);
   return _enchanted;
}                               /* add_enchant() */

/**
 * This method queries the current enchantment level. 
 * @param number the new enchantment level
 * @see enchant_string()
 * @see set_enchant()
 * @see query_max_enchant()
 * @see add_enchant()
 */
int query_enchant()
{
   int max;
   int tmp;
   int tmp2;
   int degrade;

   max = this_object()->query_max_enchant();
   if (_enchanted > max) {
      _enchanted = max;
   }

   degrade = this_object()->query_degrade_enchant();
   if (_enchanted > degrade) {
      if (!_set_enchant_time) {
         _set_enchant_time = time();
      }
      if (time() - _set_enchant_time >= ENCHANT_DEGRADE_TIME) {
         _enchanted = degrade;
      } else {
         tmp2 = tmp = (_enchanted - degrade) * 100 + 99;
         tmp *= 100 - (((time() - _set_enchant_time) * 100) /
                       ENCHANT_DEGRADE_TIME);
/*
if (this_player() && this_player()->query_name() == "pinkfish") {
tell_creator("pinkfish", "Max %d start %d tmp %d enchant %d\n", max, tmp2, tmp, _enchanted);
}
 */
         return degrade + (tmp / 10000);
      }
   }
   return _enchanted;
}                               /* query_enchant() */

/**
 * This method returns the actual enchant of the object.
 * @return the actual enchant value
 */
int query_real_enchant()
{
   return _enchanted;
}                               /* query_real_enchant() */

/**
 * This method returns the time the time the enchantment was set.
 * @return the time the enchantment was set
 */
int query_enchant_set_time()
{
   return _set_enchant_time;
}                               /* query_enchant_set_time() */

/**
 * This method sets the time at which the enchant level was set.
 * @param tim the time to set it to
 */
protected void set_enchant_set_time(int tim)
{
   _set_enchant_time = tim;
}                               /* set_enchant_time() */
// --- END [/mnt/home2/grok/lib/std/basic/enchant.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/id_match.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/id_match.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629923   Available: 13577277
Inodes: Total: 5242880    Free: 4960136
6212 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/id_match.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629923   Available: 13577277
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This inheritable contains all the code to deal with matching objects in
 * the parser.
 * @author Pinkfish.
 */

#include <obj_parser.h>

private int _no_all;

/**
 * This sets the no all flag.  If this flag is set to true then the object
 * will not respond to 'all' requests and must be accessed with it's real
 * name.
 * @param no_all the no all flag value
 */
protected void set_no_all(int no_all) {
   _no_all = no_all;
} /* set_no_all() */

/**
 * This method returns the no all flag's current value.
 * If this flag is set to true then the object
 * will not respond to 'all' requests and must be accessed with it's real
 * name.
 * @return the current value of the flag
 */
int query_no_all() {
   return _no_all;
} /* query_no_all() */

/**
 * This method is used by upper objects that only wish to match the
 * ids and not mess with all the context stuff.  This method will
 * return a combination of OBJ_PARSER_MATCH_SINGULAR and
 * OBJ_PARSER_MATCH_PLURAL.
 * @param input the input string
 * @param viewer the person viewing the object
 * @param context the contex this is to be taken in
 * @return the singular/plural match flags
 */
protected int is_matching_object(string* input,
                          object viewer,
                          class obj_match_context context )
{
   string *adj;
   string *padj;
   string *names;
   string *pnames;
   int n;
   int ret;

   /* context */
   if( this_object() == context->him &&
       input[<1] == "him" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->her &&
              input[<1] == "her" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->it &&
              input[<1] == "it" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( context->plural &&
              input[<1] == "them" &&
              member_array( this_object(), context->plural ) != -1 ) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if( this_object() == viewer &&
              input[<1] == "me" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if (!_no_all && input[<1] == "all") {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "things" || input[<1] == "ones")) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "thing" || input[<1] == "one")) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   }

   if (!ret) {
      //
      // Strip off the here if it is the right place for it.
      //
      if (input[<1] == "here" &&
          viewer != environment() &&
          sizeof(input) > 1) {
         input = input[0..<2];
      }
   
      //
      // CHeck to see if we match the noun first.
      //
      names = this_object()->parse_command_id_list();
      pnames = this_object()->parse_command_plural_id_list();

      if( member_array( input[<1], pnames ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_PLURAL;
      }
      if( member_array( input[<1], names ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_SINGULAR;
      }

      if (!ret) {
         return 0;
      }
   }

   //
   // Check and make sure we match all the adjectives.
   //
   adj = this_object()->parse_command_adjectiv_id_list();
   padj = this_object()->parse_command_plural_adjectiv_id_list();
   if( environment() == context->him ) {
      adj += ({ "his" });
   } else if( environment() == context->her ) {
      adj += ({ "her" });
   } else if( environment() == context->it ) {
      adj += ({ "its" });
   } else if( environment() == viewer ) {
      adj += ({ "my" });
   } else if( context->plural &&
                   member_array( environment(), context->plural ) != -1 ) {
      adj += ({ "their" });
   }
   
   for( n = 0; n < sizeof( input ) - 1; n++ )
   {
      if( member_array( input[n], adj ) == -1 ) {
         if (!padj || member_array(input[n], padj) == -1) {
            return 0;
         } else {
            ret &= ~OBJ_PARSER_MATCH_SINGULAR;
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }

   return ret;
} /* is_matching_object() */

/**
 * This method updates the context.  It returns the number of the objects
 * we match, and you pass in the number of objects that we are.
 * @param context the context to update
 * @param num the number of objects
 * @param singular return from is_matching_object
 * @return the number of matched objects
 */
protected int update_parse_match_context(class obj_match_context context,
                                         int num,
                                         int singular) {
   if (context->ordinal) {
      if (context->ordinal == -1) {
         return 1;
      }
      if (context->ordinal > num) {
         context->ordinal -= num;
         return 0;
      }
      context->ignore_rest = 1;
      return 1;
   } else if (context->number_included) {
      if (context->number_included <= num) {
         context->ignore_rest = 1;
         num = context->number_included;
         context->number_included = 0;
         return num;
      }
      context->number_included -= num;
      return num;
   } else {
      //
      // Just a singular reference.
      //
      if (num > 0 && (singular & OBJ_PARSER_MATCH_SINGULAR)) {
         return 1;
      }

      //
      // All state.
      //
      return num;
   }
} /* update_parse_match_context() */

/**
 * This code is for the new parser...  It returns an array which contains
 * two elements.  The first is the type of the match, plural or singular,
 * and the second is the object it matched.  Usualy this_object() but
 * it can be used to swap new objects.
 * @param input the input string
 * @param viewer the person viewing the object
 * @param context the contex this is to be taken in
 * @return ({ type, ob }), 0 on failure
 */
mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   int ret;

   ret = is_matching_object(input, viewer, context);
   if (!ret) {
      return 0;
   }

   //
   // We matched, so see if we should have.
   //
   if (!update_parse_match_context(context, 1, ret)) {
      return 0;
   }

   return ({ ret, ({ this_object() }) });
} /* parse_match_object() */
// --- END [/mnt/home2/grok/lib/std/basic/id_match.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/club_insignia.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/club_insignia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629922   Available: 13577276
Inodes: Total: 5242880    Free: 4960136
29382 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/club_insignia.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629922   Available: 13577276
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The club insignia inheritable thingy.
 * @author Pinkfish
 * @started Sun Oct  4 04:23:52 EDT 1998
 */
#include <clubs.h>
inherit "/std/basic/club_listing";
inherit "/std/basic/club_discuss";

#include <broadcaster.h>

#define SAVE_START "club_insignia"

#define NOMINATION_STATE 1
#define ELECTION_STATE   2

private nosave string _club;
private nosave int _channel_off;
private nosave int _last_state;
private nosave int _last_club_time;
private nosave int _callout_id;
private nosave string _brief_string;
private nosave int _brief_mode;

private string *query_not_voted_for(string name);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int do_history();
protected int do_channel_off(int new_value);
protected int do_resign();
protected int do_resign_position(string name);
protected int do_disbar(string name);
protected int do_brief_mode(int mode);
protected int do_brief_string(string str);
private int query_has_nominated_someone(string name);
private void check_announce(object player);
protected int do_announcement();
string query_club();

private void add_broadcaster() {
   if (query_club()) {
      BROADCASTER->add_object_to_channel(lower_case(query_club()),
                                         this_object());
   }
} /* add_broadcaster() */

/**
 * This method sets the club associated with the badge.
 * @param club the name of the club
 * @see query_club()
 */
void set_club(string club) {
   if (_club) {
      BROADCASTER->remove_object_from_channel(lower_case(_club),
                                              this_object());
   }
   if (club) {
      _club = CLUB_HANDLER->query_club_name(club);
      add_broadcaster();
   } else {
      _club = 0;
   }
} /* set_club() */

/**
 * This method returns the club associated with the badge.
 * @return the club associated with the badge
 * @see set_club()
 */
string query_club() {
   return _club;
} /* query_club() */

/**
 * This method will add the club commands from the player.
 */
protected void add_elected_commands(object per) {
   string tmp_name;
   string *not_voted;
   int announce;

   if (!query_club()) {
      return ;
   }
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command(tmp_name, this_object(), "announcement",
               (: do_announcement() :));
   per->add_command(tmp_name,
                    this_object(),
                    "resign as <string'position'>",
                    (: do_resign_position($4[0]) :) );
   if (CLUB_HANDLER->is_nomination_in_progress(query_club())) {
      if (_last_state != NOMINATION_STATE ||
           _last_club_time + 24 * 60 * 60 < time()) {
         _last_state = NOMINATION_STATE;
         _last_club_time = time();
         if (!query_has_nominated_someone(this_player()->query_name())) {
            call_out((: tell_object($1,
                "%^YELLOW%^The club '" + query_club() + "' is currently accepting "
                "nominations for positions.%^RESET%^\n") :), 2, this_player());
         }
      }
   } else if (CLUB_HANDLER->is_voting_in_progress(query_club())) {
      if (_last_state != ELECTION_STATE ||
          _last_club_time + 24 * 60 * 60 < time()) {
         _last_state = ELECTION_STATE;
         _last_club_time = time();
         not_voted = query_not_voted_for(this_player()->query_name());
         if (sizeof(not_voted)) {
            call_out((: tell_object($1,
                "%^YELLOW%^You have not voted for " +
                query_multiple_short($(not_voted)) + " in '" + query_club() +
                "'.%^RESET%^\n") :), 2, this_player());
         }
      }
   } else {
      _last_state = 0;
   }

   // Check for an announcement.
   announce = CLUB_HANDLER->query_announcement_time(query_club());
   if (announce &&
       announce != this_player()->query_property(_club + " announce time")) {
      remove_call_out(_callout_id);
      _callout_id = call_out((: check_announce :), 0, this_player());
   }
   // Give the property 4 weeks to time out.
   this_player()->add_property(_club + " announce time", 
              this_player()->query_property(_club + " announce time"),
                                  4 * 7 * (24 * 60 * 60));

   club_discuss::add_elected_commands(per);
} /* add_elected_commands() */

/**
 * This method will add the club commands from the player.
 */
protected void add_club_commands(object per) {
   string tmp_name;

   if (!query_club()) {
      return ;
   }
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command("recruit",
                    this_object(),
                    "<indirect:living'player'> into <string'club'>",
                  (: do_recruit($1, $4[1]) :) );
   per->add_command(tmp_name,
                    this_object(),
                    "members",
                         (: club_members(query_club(), 0, this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "recruit <indirect:living'player'>",
                         (: do_recruit($1, query_club()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "members {online|listening}",
                         (: club_members(query_club(), ($4[0]=="online"?1:2),
                                         this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "info",
                         (: club_info(query_club(), 1,
                                      this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "talk <string>", (: club_chat($4[0], 0) :));
   per->add_command(tmp_name,
                    this_object(),
                    "emote <string>", (: club_chat($4[0], 1) :));
   per->add_command(tmp_name,
                    this_object(),
                    "history", (: do_history() :));
   per->add_command(tmp_name,
                    this_object(),
                    "resign", (: do_resign() :));
   per->add_command(tmp_name,
                    this_object(),
                    "disbar <string'member'>", (: do_disbar($4[0]) :));
   per->add_command(tmp_name,
                    this_object(),
                    "mute {on|off}",
                    (: do_channel_off($4[0] == "on") :));
   per->add_command(tmp_name,
                    this_object(),
                    "brief {on|off}",
                    (: do_brief_mode($4[0] == "on") :));
   per->add_command(tmp_name,
                    this_object(),
                    "brief name <string'brief name'>",
                    (: do_brief_string($4[0]) :));


   // Add in the discussion commands.
   club_discuss::add_club_commands(per);

   if (CLUB_HANDLER->is_elected_club(query_club())) {
      add_elected_commands(this_player());
   }
} /* add_club_commands() */

/**
 * @ignore yes
 */
void init() {

   if (query_club() &&
       this_player() == environment() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      this_player()->add_player_club(query_club());
      add_club_commands(this_player());
   } else {
      this_player()->remove_player_club(query_club());
   }
} /* init() */

private void check_announce(object player) {
   int announce;

   if (!query_club()) {
      return ;
   }
   // Every 15 minutes.
   announce = CLUB_HANDLER->query_announcement_time(query_club());
   if (this_player() &&
       announce &&
       announce != this_player()->query_property(_club + " announce time")) {
      remove_call_out(_callout_id);
      call_out((: check_announce :), 15 * 60, player);
      tell_object(player,
                  "\n%^YELLOW%^The club '" +
                  CLUB_HANDLER->query_club_name(query_club()) +
                  "' has a new announcement.\n%^RESET%^\n");
   }
} /* check_announce() */

/**
 * This method checks to see if the person has nomiated anyone for
 * the club.
 */
private int query_has_nominated_someone(string name) {
   string *positions;
   string pos;
   string *people;
   string person;

   positions = CLUB_HANDLER->query_valid_positions(query_club());
   foreach (pos in positions) {
      people = CLUB_HANDLER->query_nominated_for(query_club(), pos);
      foreach (person in people) {
         if (member_array(name,
                 CLUB_HANDLER->query_nominators_for(query_club(), pos, person)) != -1) {
            return 1;
         }
      }
   }
   return 0;
} /* query_has_nominated_someone() */

/**
 * This method returns the list of positions that have not been voted for.
 */
private string *query_not_voted_for(string name) {
   string *positions;

   positions = CLUB_HANDLER->query_valid_positions(query_club());
   positions = filter(positions,
         (: !CLUB_HANDLER->has_person_voted(query_club(), $1, $(name)) &&
            sizeof(CLUB_HANDLER->query_nominated_for(query_club(), $1)) > 1 :));
   return positions;
} /* query_not_voted_for() */

/**
 * This method returns the status of the channel off flag.
 * @return the current value of the channel off flag
 * @see club_chat()
 * @see event_channel_message()
 */
int query_channel_off() {
   return _channel_off;
} /* query_channel_off() */

/**
 * This method tells us if the badge is in brief mode or not.
 * @return the current brief mode
 */
int query_brief_mode() {
   return _brief_mode;
} /* query_brief_mode() */

/**
 * This method returns the short name for the channel string.
 * @return the short name for the channel
 */
string query_brief_string() {
   return _brief_string;
} /* query_brief_string() */

/**
 * The says something wonderful and exciting to all the other club members.
 * @param str the exciting comment I know they will say
 */
protected int club_chat(string str, int emote) {
   string player_name;
   string channel_name;
   string colour;

   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You can only chat to clubs you are a member of.\n");
      return 0;
   }

   if (_channel_off) {
      add_failed_mess("You have your club channel turned off.\n");
      return 0;
   }

   player_name = this_player()->query_cap_name();
   if (this_player()->query_family_name()) {
      player_name += " " + this_player()->query_family_name();
   }
   BROADCASTER->broadcast_to_channel(this_player(),
                                     lower_case(query_club()),
                                     ({ str, emote }));
   if (_brief_mode) {
      channel_name = _brief_string;
   } else {
      channel_name = query_club();
   }
   colour = this_player()->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
   if (emote) {
      write("$I$5=(" + colour + channel_name +
            "%^RESET%^) " + player_name +
            " " + str + "\n");
   } else {
      write("$I$5=(" + colour + channel_name +
            "%^RESET%^) " + player_name +
            ": " + str + "\n");
   }
   if (!this_player()->query_hide_invis()["hiding"] &&
       !this_player()->query_invis()) {
      add_succeeded_mess(({ "",
                            "$N stare$s intently into space for a bit.\n" }));
   }
   return 1;
} /* club_chat() */

/**
 * The method is called when the channel is triggered.
 * @param ob the person who talked
 * @param channel the name of the channel
 * @param message the pmessage top print
 * @see club_chat()
 * @see do_history()
 */
void event_channel_message(object ob, string channel, mixed *data) {
   object our_player;
   int emote;
   string message;
   string player_name;
   string channel_name;
   string colour;

   if (channel != lower_case(query_club())) {
      return ;
   }
   our_player = environment();

   // Found em!
   if (our_player &&
       userp(our_player) &&
       our_player != this_player()) {

      // See if we are ignoreing them.
      if (sizeof(our_player->query_ignoring( ({ ob }) ))) {
          return ;
      }

      emote = data[CLUB_MESSAGE_EMOTE_INDEX];
      message = data[CLUB_MESSAGE_MESSAGE_INDEX];

      // Make sure they really are a member of the club.
      if (CLUB_HANDLER->is_member_of(query_club(), our_player->query_name()) &&
          !_channel_off) {
         player_name = ob->query_cap_name();
         if (ob->query_family_name()) {
            player_name += " " + ob->query_family_name();
         }
         if (_brief_mode) {
            channel_name = _brief_string;
         } else {
            channel_name = query_club();
         }
         colour = our_player->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
         if (emote) {
            our_player->add_message("$I$5=(" + colour + channel_name +
                                    "%^RESET%^) " +
                                    player_name + " " + message + 
                                    "\n%^RESET%^", ({ }));
         } else {
            our_player->add_message("$I$5=(" + colour + channel_name +
                                    "%^RESET%^) " +
                                    player_name + ": " + message + 
                                    "\n%^RESET%^", ({ }));
         }
      }
   }
} /* event_channel_message() */

/** @ignore yes */
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      map = ([ ]);
   }
   map[SAVE_START + "club"] =  query_club();
   map[SAVE_START + "channel off"] =  _channel_off;
   map[SAVE_START + "last state"] = _last_state;
   map[SAVE_START + "last time"] = _last_club_time;
   map[SAVE_START + "brief mode"] = _brief_mode;
   map[SAVE_START + "brief string"] = _brief_string;
   return club_discuss::query_dynamic_auto_load(map);
} /* query_dynamic_auto_load() */

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   string fluff;

   set_club(map[SAVE_START + "club"]);
   _channel_off = map[SAVE_START + "channel off"];
   _last_state = map[SAVE_START + "last state"];
   _last_club_time = map[SAVE_START + "last time"];
   _brief_mode = map[SAVE_START + "brief mode"];
   _brief_string = map[SAVE_START + "brief string"];

   if (query_club()) {
      fluff = CLUB_HANDLER->query_club_name(query_club());
   }
   if (fluff) {
      _club = fluff;
   }

   club_discuss::init_dynamic_arg(map);
} /* init_dynamic_arg() */

/**
 * This is the method to use when recruiting people.
 * @param obs the people to recruit
 * @return 1 on success, 0 on failure
 * @see /obj/handlers/club_handler.c
 */
protected int do_recruit(object *obs, string club) {
   object ob;
   object *already;
   object *invites;
   object *not_player;

   if (!query_club()) {
      add_failed_mess("The club associated with this badge appears to "
                      "have evaporated.\n");
      return 0;
   }
   if (lower_case(club) != lower_case(query_club())) {
      add_failed_mess("You can only recruit people to club '" + query_club() + "', "
                      "not '" + club  + "'.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_recruiter_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a recruiter to recruit people to "
                      "the club.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_personal_club(query_club()) &&
       sizeof(CLUB_HANDLER->query_members(query_club())) >= CLUB_MAXIMUM_ELECTED_MEMBERS) {
      add_failed_mess("Your club has more than " +
                      query_num(CLUB_MAXIMUM_ELECTED_MEMBERS) + " members, so it "
                      "must change into an elected club before more "
                      "can be added.\n");
      return 0;
   }

   invites = ({ });
   already = ({ });
   not_player = ({ });
   foreach (ob in obs) {
      if (!userp(ob)) {
         not_player += ({ ob });
      } else if (!CLUB_HANDLER->is_member_of(query_club(), ob->query_name())) {
         invites += ({ ob });
         tell_object(ob, this_player()->the_short() + " invites you to "
                         "join the club '" + query_club() + "'.\nUse the command "
                         "'accept invite from " +
                         this_player()->query_name() +
                         " to " + query_club() + "'.\n");
         ob->add_respond_command(CLUB_RESPOND_TYPE, this_player(),
                                 query_club());
      } else {
         already += ({ ob });
      }
   }

   if (!sizeof(invites)) {
      if (sizeof(already)) {
         if (sizeof(already) > 1) {
            add_failed_mess("$I are already members of the club '" + 
                         query_club() + "'.\n", already);
         } else {
            add_failed_mess("$I is already a member of the club '" + 
                         query_club() + "'.\n", already);
         }
      }
      if (sizeof(not_player)) {
         add_failed_mess("You can only recruit players into the club, $I " +
                         (sizeof(not_player) > 1?"are not players":
                                                  "is not a player"),
                         not_player);
      }
   } else {
      add_succeeded_mess(({
        "$N invite $I to join the club '" + query_club() + "'.\n",
        "$N invites $I to join the club '" + query_club() + "'.\n" }),
                         invites);
   }
   return sizeof(invites) > 0;
} /* do_recruit() */

/**
 * This method prints out the history of the channel.
 * @see club_chat()
 * @see event_channel_message()
 */
protected int do_history() {
   mixed *history;
   mixed *data;
   int emote;
   string message;
   string name;
   string colour;
   string tim;

   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the club to get a "
                      "history of its channel.\n");
      return 0;
   }

   history = BROADCASTER->query_channel_history(lower_case(query_club()));
   if (!history ||
       !sizeof(history)) {
      add_failed_mess("No history for this channel.\n");
      return 0;
   }

   colour = this_player()->colour_event("club_" + 
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
   foreach (data in history) {
      name = data[0];
      emote = data[1][CLUB_MESSAGE_EMOTE_INDEX];
      message = data[1][CLUB_MESSAGE_MESSAGE_INDEX];
      if (sizeof(data) > 2) {
         tim = ctime(data[2])[4..15];
      } else {
         tim = "";
      }
      if (emote) {
         this_player()->add_message("$I$5=(" + colour +
                         CLUB_HANDLER->query_club_name(query_club()) + 
                         "%^RESET%^ " + tim + ") " +
                     name + " " + message + "\n", ({ }));
      } else {
         this_player()->add_message("$I$5=(" + colour +
                         CLUB_HANDLER->query_club_name(query_club()) + 
                         "%^RESET%^ " + tim + ") " +
                     name + ": " + message + "\n", ({ }));
      }
   }

   write("History for the '" + query_club() + "' club channel.\n");
   return 1;
} /* do_history() */

/**
 * This method handles setting the flag and printing all the happy success
 * messages.
 * @param flag the new flag
 */
protected int do_channel_off(int flag) {
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the channel to turn it off.\n");
      return 0;
   }

   if (_channel_off == flag) {
      if (_channel_off) {
         add_failed_mess("The channel is already muted.\n");
      } else {
         add_failed_mess("You are already listening to the channel.\n");
      }
      return 0;
   }

   _channel_off = flag;
   if (_channel_off) {
      add_succeeded_mess(({ "Muting the channel '" + query_club() + "'.\n", "" }));
   } else {
      add_succeeded_mess(({ "Removing the mute from the channel '" + query_club() +
                            "'.\n", "" }));
   }
   return 1;
} /* do_channel_off() */

/**
 * This method sets the brief mode of the badge.
 * @param mode the brief mode]
 * @return 1 on success, 0 on failure
 */
protected int do_brief_mode(int mode) {
   if (!_brief_string) {
      add_failed_mess("You need to set a brief string for '" +
                      query_club() + "' before you can change the brief "
                      "mode.\n");
      return 0;
   }

   _brief_mode = mode;
   if (_brief_mode) {
      write("Set the channel '" + query_club() + "' into brief mode "
            "(using '" + _brief_string + "' as the channel name).\n");
   } else {
      write("Set the channel '" + query_club() + "' into verbose mode,\n");
   }
   return 1;
} /* do_brief_mode() */

/**
 * This method sets the brief message to use for the channel messages.
 * @param str the channel message short
 * @return 1 on success, 0 on failure
 */
protected int do_brief_string(string str) {
   if (strlen(str) > strlen(query_club())) {
      add_failed_mess("Cannot set the channel name brief to longer than it "
                      "already is!\n");
      return 0;
   }

   write("Setting the brief channel name for '" + query_club() +
         "' to '" + str + "'.\n");
   _brief_string = str;
   return 1;
} /* do_brief_string() */

/**
 * This method resigns as a position in the club.
 * @return 1 on succes, 0 on failure
 * @see confirm_resign()
 */
protected int do_resign_position(string position) {
   if (!query_club()) {
      add_failed_mess("This badge is not associated with any clubs!\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(query_club(),
                                   this_player()->query_name())) {
      add_failed_mess("You need to be a member of a club before you can "
                      "resign from it.\n");
      return 0;
   }

   if (!CLUB_HANDLER->holds_position_of(query_club(),
                                        position,
                                        this_player()->query_name())) {
      add_failed_mess("You need to hold a position before you can "
                      "resign from it.\n");
      return 0;
   }

   write("Are you sure you wish to resign from the position " + position +
         " in the club '" + query_club() + "'? ");
   input_to("confirm_resign", 0, position);
   add_succeeded_mess("");
   return 1;
} /* do_resign() */

/**
 * This method starts the resignation process.
 * @return 1 on succes, 0 on failure
 * @see confirm_resign()
 */
protected int do_resign() {
   if (!query_club()) {
      add_failed_mess("This badge is not associated with any clubs!\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(query_club(),
                                   this_player()->query_name())) {
      add_failed_mess("You need to be a member of a club before you can "
                      "resign from it.\n");
      return 0;
   }

   write("Are you sure you wish to resign from the club '" +
         query_club() + "'? ");
   input_to("confirm_resign");
   add_succeeded_mess("");
   return 1;
} /* do_resign() */

private void do_fixup_badges(string club_name) {
   object ob;
   string club;

   foreach (ob in all_inventory(this_player())) {
      club = ob->query_club();
      if (club &&
          ob->query_club_insignia()) {
         if (CLUB_HANDLER->query_club_name(club) ==
             CLUB_HANDLER->query_club_name(query_club())) {
            set_club(0);
         }
      }
   }
} /* do_fixup_badges() */

/**
 * This method checks to make sure they really wish to resign.
 * @param str the response
 * @see do_resign()
 */
protected void confirm_resign(string str, string position) {
   string club;

   str = lower_case(str);
   if (!strlen(str) ||
       str[0] == 'n') {
      write("Aborted resignation.\n");
      return 0;
   }

   if (str[0] == 'y') {
      if (!position) {
         if (CLUB_HANDLER->remove_member(query_club(),
                                         this_player()->query_name())) {
            write("You have resigned from the club '" + query_club() + "'.\n");
            club = query_club();
            set_club(0);
            call_out( (: do_fixup_badges :), 0, club);
         } else {
            write("You were unable to resign from the club '" + query_club() +
                  "'.\n");
         }
      } else {
         if (CLUB_HANDLER->set_position_holder(query_club(),
                                              position,
                                              CLUB_UNKNOWN_MEMBER)) {
            write("You have resigned from the position " + position + 
                  " in the club '" + query_club() + "'.\n");
         } else {
            write("You were unable to resign from the position " + position + 
                  " in the club '" + query_club() + "'.\n");
         }
      }
   } else {
      write("You need to answer yes or no.\n");
      if (!position) {
         write("Are you sure you wish to resign from the club '" +
                         query_club() + "'? ");
      } else {
         write("Are you sure you wish to resign from the position " + position +
               " in the club '" + query_club() + "'? ");
      }
      input_to("confirm_resign", 0, position);
   }
} /* confirm_resign() */

/**
 * This method allows the founders and presidents/vice presidents to disbar
 * people from the club.
 * @param name the name of the person to disbar
 */
protected int do_disbar(string name) {
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the club before you can "
          "disbar people from it.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_elected_club(query_club())) {
      if (!CLUB_HANDLER->is_president_of(query_club(), this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(query_club(), this_player()->query_name())) {
         add_failed_mess("You must be the president or the vice president to "
                         "disbar someone.\n");
         return 0;
      }
   } else if (!CLUB_HANDLER->is_founder_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to disbar "
                      "someone.\n");
      return 0;
   }

   name = lower_case(name);
   if (name == this_player()->query_name()) {
      add_failed_mess("You cannot disbar yourself.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(query_club(), name)) {
      add_failed_mess("You must disbar someone who is a member of the "
                      "club.\n");
      return 0;
   }

   write("Do you want to disbar " + capitalize(name) + " from the club '" +
                   query_club() + "'? ");
   add_succeeded_mess("");
   input_to("confirm_disbar", 0, name);
   return 1;
} /* do_disbar() */

/**
 * THis method confirms the disbar request from the player.
 * @param str the response string
 * @param name the name of the person to disbar
 * @see do_disbar()
 */
protected void confirm_disbar(string str, string name) {
   if (str == "" ||
       str[0] == 'q' ||
       str[0] == 'n') {
      write("Aborting disbar.\n");
      return ;
   }

   if (str[0] == 'y') {
      if (CLUB_HANDLER->remove_member(query_club(), name)) {
         write("Disbarred " + capitalize(name) +
               " from the club '" + query_club() + "'.\n");
      } else {
         write("You were unable to disbar " + capitalize(name) +
               " from the club '" + query_club() + "'.\n");
      }
   } else {
      write("You must type yes or no.\n");
      write("Do you want to disbar " + capitalize(name) + " from the club '" +
                      query_club() + "'? ");
      input_to("confirm_disbar", 0, name);
   }
} /* confirm_disbar() */

/**
 * This method will print out any announcements associated with the club.
 * @return 1 on success
 */
protected int do_announcement() {
   string announce;

   announce = CLUB_HANDLER->query_announcement(query_club());
   if (!strlen(announce)) {
      add_failed_mess("There is no announcement to read.\n");
      return 0;
   }
   write("$P$Announcement$P$Added by the president or secretary at " +
         ctime(CLUB_HANDLER->query_announcement_time(query_club())) + "\n" +
         announce + "\n");
   // Give the property 4 weeks to time out.
   this_player()->add_property(_club + " announce time",
                               CLUB_HANDLER->query_announcement_time(query_club()),
                               4 * 7 * (24 * 60 * 60));
   return 1;
} /* do_announcement() */

/**
 * This is the event generated when the person joins the club.
 * @param person the person doing the joining
 * @param club_name the name of the club being joined
 */
void event_joined_club(object person, string club_name) {
   if (CLUB_HANDLER->query_club_name(query_club()) ==
       CLUB_HANDLER->query_club_name(club_name)) {
      add_club_commands(environment());
   }
} /* event_club_join() */

/**
 * This method is called when the club type is changed.  It will add on
 * the elected club commands, if that is what we have changed too.
 */
void event_club_changed(object person,
                        string club_name) {
   if (CLUB_HANDLER->is_elected_club(club_name)) {
      call_out( (: add_elected_commands(environment()) :), 0);
   }
} /* event_club_changed() */

mixed * stats()
{
  return ({
    ({ "club name", _club })
    });
}
// --- END [/mnt/home2/grok/lib/std/basic/club_insignia.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/basic/club_discuss.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/basic/club_discuss.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629914   Available: 13577268
Inodes: Total: 5242880    Free: 4960136
16746 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/basic/club_discuss.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629914   Available: 13577268
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file is for handling discussion items and clubs.
 * @author Pinkfish
 * @started April 21st 1999
 * @see /obj/handlers/club_handler.c
 */
#include <clubs.h>
#include <player_handler.h>
#include <player_handler.h>

//inherit "/std/room/inherit/club_discuss";

#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 20
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"

string query_club();
int do_vote(int id, string choice);
int do_nominate(int id, string person);
int do_withdraw(int id);
int do_list_all();
int do_list_item(int id);
int do_list_archives();
int do_archive(int num);

private nosave int _last_time;

/**
 * This method will return the listing of discussion items as a nice
 * string.
 * @param player the player who is doing the listing
 * @return the discussion items as a listing
 */
string discussion_item_list(string player) {
   class discussion_idea* ideas;
   class discussion_idea bing;
   string ret;
   int no;

   ideas = CLUB_HANDLER->query_all_discussion_items(query_club());
   ret = "";
   no = 0;
   if (sizeof(ideas)) {
      foreach (bing in ideas) {
         if (CLUB_HANDLER->is_discussion_item_finished(query_club(),
                                                       bing->id)) {
            CLUB_HANDLER->complete_discussion_item(query_club(),
                                                   bing->id);
         } else {

            if (CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                            bing->id,
                                                            player)) {
               ret += bing->id + ") " +
                  CLUB_HANDLER->query_discussion_item_short_description(query_club(),
                                                                        bing->id);
               if (CLUB_HANDLER->is_discussion_item_quorum(query_club(),
                                                           bing->id)) {
                  ret += " (quorum)";
               }
               if (CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                                               bing->id,
                                                               player)) {
                  ret += " (voted)\n";
               } else {
                  ret += "\n";
               }
               no++;
            }
         }
      }
   }
   if (no == 0) {
      ret += "No items up for discussion.\n";
   }
   return ret;
} /* discussion_item_list() */

/**
 * This method returns information on the specified discussion item.
 * @param id the id of the discussion item to get information on
 * @param player the player retreiving the information
 * @return a string which is the information on the discussion item
 */
string discussion_item(int id,
                       string player) {
   string ret;

   if (CLUB_HANDLER->query_discussion_item(query_club(), id) &&
       CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                   id,
                                                   player)) {
      ret = "Discussion item #" + id + " by " +
         CLUB_HANDLER->query_discussion_added_by(query_club(), id) +
         " (Finish: " +
         ctime(CLUB_HANDLER->query_discussion_time_finish(query_club(),
                                                          id)) + ")\n" +
         CLUB_HANDLER->query_discussion_item_long_description(query_club(),
                                                              id) +
         "\n\nWith voting choices of " +
         query_multiple_short(CLUB_HANDLER->query_discussion_choices(query_club(),
                                                                     id)) + 
         ".\n";
      if (CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                                      id,
                                                      player)) {
         ret += "You have voted for the discussion item.\n";
      }
      if (CLUB_HANDLER->is_no_quorum_discussion_item(query_club(), id)) {
         ret += "The discussion item does not require a quorum to carry.\n";
      } else if (CLUB_HANDLER->is_discussion_item_quorum(query_club(), id)) {
         ret += "The discussion item has reached a quorum, so any result "
            "will be final.\n";
         ret += "The discussion item needed " +
                CLUB_HANDLER->query_discussion_item_quorum_number(query_club(),
                                                                  id) +
                " to vote for quorum and so far " +
                CLUB_HANDLER->query_discussion_item_number_voted(query_club(),
                                                                 id) +
                " people have voted.\n";
      } else {
         ret += "The discussion item needs " +
                CLUB_HANDLER->query_discussion_item_quorum_number(query_club(),
                                                                  id) +
                " to vote for quorum and so far " +
                CLUB_HANDLER->query_discussion_item_number_voted(query_club(),
                                                                 id) +
                " people have voted.\n";
      }
      if (CLUB_HANDLER->is_committee_discussion_item(query_club(), id)) {
         ret += "This is a committee only discussion item.\n";
      }
      return ret;
   }
   return "Lost discussion item of the far west.\n";
} /* discussion_item() */

/** 
 * This method adds the elected club specific commands to the
 * player.
 */
protected void add_elected_commands(object per) {
   string tmp_name;
   class discussion_idea* ideas;

   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command(tmp_name,
               this_object(),
               "vote for <string'choice'> in <number'id'>",
               (: do_vote($4[1], $4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "nominate <string'person'> in <number'id'>",
               (: do_nominate($4[1], $4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "withdraw from <number'id'>",
               (: do_withdraw($4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "list all [discussion items]", 
               (: do_list_all() :));
   per->add_command(tmp_name,
               this_object(),
               "list [discussion item] <number'id'>", 
               (: do_list_item($4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "archives",
               (: do_list_archives() :));
   per->add_command(tmp_name,
               this_object(),
               "archives [list] <number>",
               (: do_archive($4[0]) :));


   if (_last_time + 24 * 60 * 60 < time()) {
      _last_time = time();
      ideas = CLUB_HANDLER->query_all_discussion_items(query_club());
      ideas = filter(ideas,  (:
                   CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                        $1->id,
                                        this_player()->query_name()) :) );
      ideas = filter(ideas, (:
                   !CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                        $1->id,
                                        this_player()->query_name()) :) );
      if (sizeof(ideas)) {
         write("%^YELLOW%^There are discussion items you have not voted "
               "for, use '" + tmp_name +
               " list all' for a list.\n%^RESET%^");
      }
   }
} /* add_elected_commands() */

protected void add_club_commands(object per) {
} /* add_club_commands() */

/**
 * @ignore yes
 */
int do_list_all() {
   string ret;

   ret = discussion_item_list(this_player()->query_name());
   write("$P$Discussion items$P$" + ret);
   return 1;
} /* do_list_all() */

/**
 * @ignore yes
 */
int do_list_item(int id) {
   string ret;

   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }

   ret = discussion_item(id, this_player()->query_name());
   write("$P$Discussion item$P$" + ret);
   return 1;
} /* do_list_item() */

/**
 * This method is the default voting method for the discussion items.  It
 * is called by the add_command() patterns to do the voting.
 * @param id the id of the discussion item to vote for
 * @param choice the choice to vote for
 * @ignore yes
 */
int do_vote(int id,
            string choice) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_discuss_votable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be voted for.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_valid_discussion_choice(query_club(),
                                                 id,
                                                 choice)) {
      add_failed_mess("Invalid choice to the discussion item, the allowed "
                      "choices are " +
                      query_multiple_short(
                        CLUB_HANDLER->query_discussion_choices(query_club(),
                                                               id)) +
                      ".\n");
      return 0;
   }

   if (CLUB_HANDLER->vote_for_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              choice)) {
      add_succeeded_mess(({ "Voted '" + choice + "' for discussion item #" +
                            id + ".\n",
                            "$N voted for a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to vote for the discussion item for "
                      "some reason.\n");
      return 0;
   }
} /* do_vote() */

/**
 * A special entry point for nominating people to discussion items, this
 * only works with the nomination discussion item.
 * @param id the id of the discussion item
 * @param person the person to nominate
 * @return 1 for success, 0 for failure
 */
int do_nominate(int id, string person) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_discuss_nominateable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be nominated for.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_discuss_person_nominated(query_club(),
                                                 id,
                                                 person,
                                                 this_player()->query_name())) {
      add_failed_mess("The person " + person + " has already been nominated "
                      "for that position.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_creator_club(query_club()) &&
       PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You can only nominated creators to positions in "
                      "creator clubs.\n");
      return 0;
   }

   if (CLUB_HANDLER->nominate_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              person)) {
      add_succeeded_mess(({ "Nominated '" + person + 
                            "' for discussion item #" + id + ".\n",
                            "$N nominated someone in a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to nominate " + person + " for "
                      "some reason.\n");
      return 0;
   }   
} /* do_nominate() */

/**
 * A special entry point for withdrawing from a nominated discussion item, this
 * only works with the nomination discussion item.
 * @param id the id of the discussion item
 * @return 1 for success, 0 for failure
 */
int do_withdraw(int id) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_discuss_nominateable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be nominated for (and therefor withdrawn from).\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_discuss_person_nominated(query_club(),
                                                 id,
                                                 this_player()->query_name(),
                                                 this_player()->query_name())) {
      add_failed_mess("You have not been nominated for this position.\n");
      return 0;
   }

   if (CLUB_HANDLER->withdraw_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              this_player()->query_name())) {
      add_succeeded_mess(({ "Withdrew from discussion item #" + id + ".\n",
                            "$N withdrew from a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to withdraw from the discussion item for "
                      "some reason.\n");
      return 0;
   }   
} /* do_withdraw() */

/**
 * This method prints out the archives.
 * @return 1 on success, 0 on failure
 */
int do_list_archives() {
   class club_archive* archives;
   string bing;
   class club_archive fluff;
   int num;

   archives = CLUB_HANDLER->query_archives(query_club());
   if (!sizeof(archives)) {
      add_failed_mess("This club has no archives currently.\n");
      return 0;
   }

   bing = "";
   num = 1;
   foreach (fluff in archives) {
      bing += "#" + num + " finished at " + ctime(fluff->archive_date) + " " +
              fluff->subject + "\n";
      num++;
   }
   write("$P$Club Archives$P$" + bing);
   return 1;
} /* do_list_archive() */

/**
 * This method prints out the specific archive in more detail.
 * @param num the number of the archive to print out
 * @return 1 on success, 0 on failure
 */
int do_archive(int num) {
   string bing;
   class club_archive fluff;
   class club_archive* archives;

   archives = CLUB_HANDLER->query_archives(query_club());
   if (!sizeof(archives)) {
      add_failed_mess("This club has no archives currently.\n");
      return 0;
   }

   if (num < 1 || num > sizeof(archives)) {
      add_failed_mess("The number must be between 1 and " +
                      sizeof(archives) + ".\n");
      return 0;
   }

   fluff = archives[num - 1];
   bing = "Archive #" + num + " finished at " +
           ctime(fluff->archive_date) + " " +
           fluff->subject + "\n" + fluff->matter + "\n";
   write("$P$Club Archives$P$" + bing);
   return 1;
} /* do_archive() */

/**
 * @ignore yes
 */
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      map = ([ ]);
   }
   map[SAVE_START + "last time"] = _last_time;
   return map;
} /* query_dynamic_auto_load() */

/**
 * @ignore yes
 */
void init_dynamic_arg(mapping map) {
   _last_time = map[SAVE_START + "last time"];
} /* init_dynamic_arg() */
// --- END [/mnt/home2/grok/lib/std/basic/club_discuss.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/skills.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629910   Available: 13577264
Inodes: Total: 5242880    Free: 4960136
15432 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/skills.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629910   Available: 13577264
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the skills handler.  It controls all the skills currently in
 * the game and keeps track of their various properties.
 * @author Pinkfish
 */
#include <skills.h>
#include <language.h>

#define SKILL_BONUS 0

private mapping _stat_bonus;
private mixed *_skills;
private mapping _reg_skills;
private mapping _skill_tree;
private mapping _immediate_children;
private mapping _only_leaf;
private mapping _not_allowed_to_teach;
private mapping _only_show_if_non_zero;
private mapping _no_bonus;
private mapping _ignore_bits;

private mapping flatten(mixed *arr, string bit);
mixed *add_skill_rec(mixed *skill, string *path);
mixed *del_skill_rec(mixed *skill, string *path);
int query_skill_cost_int(string str);

void create() {
  string *languages, *lang_tree;
  int i;
  mixed *rabbit;
  string skill_written;
  string skill_spoken;
  string *skill_bits;

  _skills = STD_SKILLS;
  _skill_tree = ([ ]);
  _immediate_children = ([ ]);
  _not_allowed_to_teach = ([ ]);
  _only_show_if_non_zero = ([ ]);
  _no_bonus = ([ ]);
  lang_tree = ({ });
  languages = LANGUAGE_HAND->query_languages();
  for (i=0;i<sizeof(languages);i++) {
     rabbit = ({ });
     if (LANGUAGE_HAND->query_language_spoken(languages[i])) {
        rabbit += ({ SPOKEN_SKILL, 0, 0, ({ }), });
     }
     if (LANGUAGE_HAND->query_language_written(languages[i]) ||
         LANGUAGE_HAND->query_language_magic(languages[i])) {
        rabbit += ({ WRITTEN_SKILL, 0, 0, ({ }) });
     }
     skill_written = LANGUAGE_HAND->query_language_written_skill(languages[i]);
     skill_spoken = LANGUAGE_HAND->query_language_spoken_skill(languages[i]);
     languages[i] = replace(languages[i], " ", "_");
     lang_tree += ({ languages[i], 0, 0, rabbit });
     _not_allowed_to_teach[LANGUAGE_SKILL_START + languages[i]] = 1;
     _not_allowed_to_teach[skill_spoken] = 1;
     _not_allowed_to_teach[skill_written] = 1;
     _only_show_if_non_zero[skill_spoken] = 1;
     _only_show_if_non_zero[skill_written] = 1;
     _no_bonus[skill_spoken] = 1;
     _no_bonus[skill_written] = 1;
  }

  /* We make an assumption here that the skill is only two levels deep...  */
  skill_bits = explode(LANGUAGE_SKILL_START, ".");
  _not_allowed_to_teach["other.language"] = 1;
  i = member_array(skill_bits[0], _skills);
  if (i != -1) {
     _skills[i+SKILL_BIT] += ({ skill_bits[1], 0, 0, lang_tree });
  }
  _only_leaf = ([ "other" : 1 ]);
  _ignore_bits = ([ "crafts" : 1 ]);
  _reg_skills = flatten( _skills, "" );
  _stat_bonus = ([
"covert"                            : ({ "DDDII" }),
  "covert.stealth"                  : ({ "DDDIS" }),
  "covert.hiding"                   : ({ "DDIIS" }),
  "covert.lockpick"                 : ({ "DDDDI" }),
  "covert.manipulation"             : ({ "DDISS" }),
  "covert.casing"                   : ({ "DIIWW" }),
  "covert.items"                    : ({ "DIIII" }),
  "covert.points"                   : ({ "DDIIC" }),

"crafts"                            : ({ "DDIIW" }),
  "crafts.smithing"                 : ({ "DDIIS" }),
  "crafts.mining"                   : ({ "DIISS" }),
  "crafts.hunting"                  : ({ "DDIII" }),
  "crafts.carpentry"                : ({ "DDIIS" }),
  "crafts.pottery"                  : ({ "DDDII" }),
  "crafts.materials"                : ({ "DDIIS" }),
  "crafts.husbandry"                : ({ "IIIWW" }),
  "crafts.culinary"                 : ({ "DDIII" }),
  "crafts.arts"                     : ({ "DIIII" }),
  "crafts.music"                    : ({ "DIIII" }),
  "crafts.points"                   : ({ "DDIIW" }),

"faith"                             : ({ "ISWWW" }),
  "faith.rituals.offensive"         : ({ "ISSWW" }),
  "faith.rituals.defensive"         : ({ "IDDWW" }),
  "faith.rituals.curing"            : ({ "ICCWW" }),
  "faith.rituals.misc"              : ({ "IIWWW" }),
  "faith.items"                     : ({ "IIDWW" }),
  "faith.points"                    : ({ "IICWW" }),

"fighting"                          : ({ "DDSSI" }),
  "fighting.combat.melee"           : ({ "DSSSW" }),
  "fighting.combat.melee.sharp"     : ({ "DDSSS" }),
  "fighting.combat.melee.pierce"    : ({ "DDDSS" }),
  "fighting.combat.melee.blunt"     : ({ "DSSSS" }),
  "fighting.combat.melee.unarmed"   : ({ "DDDSW" }),
  "fighting.combat.range"           : ({ "DDDSS" }),
  "fighting.combat.parry"           : ({ "DDSSW" }),
  "fighting.combat.dodging"         : ({ "DDDSW" }),
  "fighting.combat.special.weapon"  : ({ "SDIII" }),
  "fighting.combat.special.unarmed" : ({ "DDIII" }),
  "fighting.combat.special.tactics" : ({ "WWIII" }),
  "fighting.points"                 : ({ "DSSCC" }),

"magic"                             : ({ "IIIDW" }),
  "magic.spells"                    : ({ "IIDWW" }),
  "magic.spells.offensive"          : ({ "WSSII" }),
  "magic.spells.defensive"          : ({ "WCCII" }),
  "magic.spells.misc"               : ({ "WDDII" }),
  "magic.spells.special"            : ({ "WWWII" }),
  "magic.methods.elemental"         : ({ "IICCC" }),
  "magic.methods.mental"            : ({ "IIIII" }),
  "magic.methods.spiritual"         : ({ "IIWWW" }),
  "magic.methods.physical"          : ({ "IIDDD" }),
  "magic.items"                     : ({ "IIDWW" }),
  "magic.items.held"                : ({ "IIDWW" }),
  "magic.points"                    : ({ "IISWW" }),

"other"                             : ({ "DDISS" }),
   "other.trading"                  : ({ "IIIIW" }),
   "other.movement"                 : ({ "CCDDS" }),
   "other.acrobatics"               : ({ "CDDSS" }),
   "other.evaluating"               : ({ "IIIIW" }),
   "other.perception"               : ({ "IIWWW" }),
   "other.direction"                : ({ "DDIIW" }),
   "other.health"                   : ({ "CCCCS" }),
   "other.points"                   : ({ "CDISW" }),
   "other.language"                 : ({ "IIIWW" }),
   "other.culture"                  : ({ "IIIWW" }),
  ]);
}

/**
 * This method returns the all of the skills with their children and the
 * number of children in a nice mapping.  The key of the mapping is the name
 * of the skill, the value is an array of two elements.  The first is an
 * array of all the children and the second is the number of children
 * of the skill.
 * @return the mapping as described above
 */
mapping query_reg_skills() { return _reg_skills; }
/**
 * This method returns the raw unfluffed skill array.  This is the same
 * as the skill array defined in /include/skills.h plus the language skills
 * and other dynamic skills added.
 * @return the skills array
 * @see /include/skills.h
 */
mixed *query_skills() { return _skills; }

/**
 * This method returns the path to skill.  This is essentially the skill
 * name broken up on '.'s and returned as an array.
 * @return the skill path, or 0 if the skill does not exist
 */
string *query_skill_path(string skill) {
   if (skill[0] == '.') {
      skill = skill[1..1090];
   }
   if (!_reg_skills[skill]) {
      return 0;
   }
   return explode(skill, ".");
} /* query_skill_path() */

/**
 * This method returns the skill and all of its parents leading up to
 * it.
 * @example
 * query_skill_tree("magic.methods.physical.binding")
 * Returns: ({
 *  "magic.methods.physical.binding",
 *  "magic.methods.physical",
 *  "magic.methods",
 *  "magic"
 * })
 * @param skill the skill to get the tree of
 * @return the skill tree of the skill
 */
string *query_skill_tree(string skill) {
   return _skill_tree[skill];
} /* query_skill_tree() */

/**
 * This method returns the stats that effect the skill.
 * @param skill the skill to check
 * @return the stats that effect the skill
 */
string query_skill_stat(string skill) {
   int i;
   string *bit, s;

   bit = explode(skill, ".");
   i = sizeof(bit);
   while (i >= 0) {
      s = implode(bit[0..i], ".");
      if (_stat_bonus[s])
         return _stat_bonus[s][SKILL_BONUS];
      else
         i--;
   }
   return "";
} /* query_skill_stat() */

private int add_stat_bonus(string skill, string bonus) {
   if (_stat_bonus[skill]) {
      return 0;
   }
   _stat_bonus[skill] = ({ bonus });
   return 1;
} /* add_stat_bonus() */

private int remove_stat_bonus(string skill) {
   if (!_stat_bonus[skill]) {
      return 0;
   }
   _stat_bonus = m_delete(_stat_bonus, skill);
   return 1;
} /* remove_stat_bonus() */

/**
 * This method returns the children of the specified skill chunk.
 * You need to pass into this array a skill chunk as taken from the
 * skill array.  It is recursive and returns all the internal children
 * as well.
 * @param arr the skill chunk
 * @param path the skill bit leading up to this section
 * @return the children of the skill chunk
 */
string *query_children(mixed *arr, string path) {
   string *ret;
   int i;

   ret = ({ });
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      ret += ({ path+arr[i] }) +
           query_children(arr[i+SKILL_BIT], path+arr[i]+".");
   }
   return ret;
} /* query_children() */

/**
 * This method returns the immediate children of the specified skill.
 * @param skill the skill to get the children of
 * @return the immediate children of the skill
 */
string *query_immediate_children(string skill) {
   return _immediate_children[skill];
} /* query_immediate_childen() */

/**
 * This method returns all the children of the specified skill.
 * This does a deep children finding exercise, returing all the children
 * as it goes lower and lower into the array.
 * @param skill the skill to get the children of
 * @return all the children
 * @see query_related_skills()
 */
string *query_all_children(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][0];
   }
   return 0;
} /* query_all_children() */

private string *query_imm_children(mixed *arr, string path) {
   string *ret;
   int i;

   ret = ({ });
   for (i = 0; i < sizeof(arr); i+= SKILL_ARR_SIZE) {
      ret += ({ path+arr[i] });
   }
   return ret;
} /* query_imm_children() */

private string *create_skill_tree(string skill) {
   string *ret, *bits;
   int i;

   ret = ({ });
   bits = explode(skill, ".");
   /* For the only leaf heirachy, only count the upper level... */
   if (_only_leaf[bits[0]]) {
      return ({ skill });
   }
   for (i = sizeof(bits) - 1; i >= 0; i--) {
      ret += ({ implode(bits[0..i], ".") });
   }
   return ret;
} /* create_skill_tree() */

private mapping flatten(mixed *arr, string bit) {
   int i;
   mapping ret;

   if (!bit) {
      bit = "";
   }
   ret = ([ ]);
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      reset_eval_cost();
      if (sizeof(arr[i+SKILL_BIT]) == 0) {
         ret[(bit+arr[i])] = ({ ({ bit+arr[i] }), 1 });
      } else {
         ret[bit + arr[i]] = ({ query_children(arr[i+SKILL_BIT], bit+arr[i]+".") +
                              ({ bit + arr[i] }),
                              query_skill_cost_int(bit+arr[i]) });
         ret += flatten(arr[i+SKILL_BIT], bit+arr[i]+".");
      }
      _skill_tree[(bit+arr[i])] = create_skill_tree(bit+arr[i]);
      _immediate_children[(bit+arr[i])] = query_imm_children(arr[i+SKILL_BIT],bit+arr[i]+".");
   }
   return ret;
} /* flatten() */


private int query_skill_cost_rec(mixed *arr) {
   int i, tmp;

   if (!sizeof(arr)) {
      return 1;
   }
   for (i=0;i<sizeof(arr);i+=SKILL_ARR_SIZE) {
      tmp += query_skill_cost_rec(arr[i+SKILL_BIT]);
   }
   return tmp;
} /* query_skill_cost_rec() */

private int query_skill_cost_int(string str) {
   int i;
   mixed *arr;
   string *path;

   path = explode(str, ".");
   arr = _skills;
   while (sizeof(path)) {
      i = member_array(path[0], arr);
      if (i == -1) {
         return -1;
      } else {
         path = path[1..sizeof(path)];
         arr = arr[i+SKILL_BIT];
      }
   }
   return query_skill_cost_rec(arr);
} /* query_skill_cost_int() */

/**
 * This method also returns all the children of a skill.  It preforms
 * exactly the same action as query_all_children()
 * @param skill the skill to get the children of
 * @return the children of the skill
 */
string *query_related_skills(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][0];
   }
   return 0;
} /* query_related_skills() */

/**
 * This method returns the cost of the specified skill.  This is the
 * the number of children it has.
 * @param skill the skill to check the cost of
 * @return the costof the skill
 */
int query_skill_cost(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][1];
   }
   return -1;
} /* query_skill_cost() */

/**
 * This method attempts to figure out the path of a skill from an array
 * of bits.  It verifies that the skill actually exists on the way.
 * @param bits the skill to check
 * @return the path of the skill
 */
string query_skill(string *bits) {
   mixed *arr;
   int i;
   string path, s1;

   if( !bits || !sizeof(bits) ) {
      return 0;
   }

   path = "";
   arr = _skills;
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      if (sscanf(arr[i], bits[0]+"%s", s1) == 1) {
         path += "."+arr[i];
         arr = arr[i+SKILL_BIT];
         i = -SKILL_ARR_SIZE;
         bits = bits[1..sizeof(bits)];
         if (!sizeof(bits))
            return path[1..strlen(path)];
      }
   }
   if (i<sizeof(arr)) {
      return path[1..strlen(path)];
   }
   return 0;
} /* query_skill() */

/**
 * This method determines if only leaf skills can be increased in this
 * skill tree.  This is used for the other skill tree, to avoid increasing
 * all the other skills at the same time.
 * @param str the skill tree to check
 * @return 1 if the tree is only leaf, 0 if not
 */
int query_only_leaf(string str) {
   string *bits;

   bits = explode(str, ".");
   return _only_leaf[bits[0]];
} /* query_only_leaf() */

/**
 * This method checks to see if this particular skill is allowed to be
 * taught to people.
 * @param str the skill to check
 * @return 1 if they are not allowed to teach it, 0 if they are
 */
int query_allowed_to_teach(string str) {
   return !_not_allowed_to_teach[str];
} /* query_allowed_to_teach() */

/**
 * This method checks to see if the skill should only be shown on the
 * skill list if it is non-zero.
 * @param str the skill to check
 * @return 1 if should only show non-zero skills, 0 if show any skill
 */
int query_only_show_if_non_zero(string str) {
   return _only_show_if_non_zero[str];
} /* query_only_show_if_non_zero() */

/**
 * This method checks to see if the specified skill has no bonus associated
 * with it.
 * @param str the skill to check
 * @return 1 if there is no bonus, 0 if there is a bonus
 */
int query_no_bonus(string str) {
   return _no_bonus[str] || _ignore_bits[str];
} /* query_no_bonus() */

/**
 * This method returns 1 if the skill being asked about should be ignored.
 * An ignored skill means that up to this point the fact it is this deep
 * is ignored.  For example,if 'crafts' is ignored then 'crafts.smithing'
 * would count as if it was a top level skill.
 * @param skill the skill to check
 */
int is_skill_ignored(string skill) {
   return _ignore_bits[skill];
}

/**
 * This method returns the skill depth for teaching calculations.
 * @param skill the skill to get the depth of
 * @return the skill depth
 */
int query_skill_depth(string* skill) {
   int depth;
   int i;

   depth = 0;
   for (i = 0; i < sizeof(skill) - 1; i++) {
      if (!is_skill_ignored(implode(skill[0..i], "."))) {
         depth++;
      }
   }
   return depth;
}
// --- END [/mnt/home2/grok/lib/std/skills.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/delivery.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/delivery.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629906   Available: 13577260
Inodes: Total: 5242880    Free: 4960136
16459 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/delivery.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629906   Available: 13577260
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: delivery.c,v 1.2 2003/03/21 01:49:47 ceres Exp $
 *
 *
 */

/**
 * Inheritable Delivery System
 * <p>
 * This object provides a way of storing and sending objects to 
 * players while they are not online.  It is roughly based on
 * the concepts found in Post Offices that support parcel
 * depositing, and also Bernita's Flower Shop. (Which delivers
 * flowers to people when they log on.)
 * <p>
 * This object is easy to use, and can be combined with most
 * other objects on the Disc. (ie, /obj/monster and /std/room).
 * See delivery_room.c for a pre-made room which handles the 
 * delivery of objects.
 * <p>
 * Note that this system uses static login calls.  These 
 * must be configured first and turned on manually in order for
 * the delivery system to work.
 * <p>
 * In order to use this inheritable the following things must be
 * done:
 * <ul>
 * <li>The object that uses it created, and this object inherited.
 * <li>The save file set using set_save_file().
 * <li>Any extra settings such as delivery message and delay configured.
 * <li>setup_delivery() called on the object to finalize setup.
 * </ul>
 * @author Taffyd
 */
 
#include <player_handler.h>
#include <login.h>
#include <move_failures.h>
 
inherit "/global/auto_load";

class delivery_item {
    object delivery_ob;
    string sent_by;
    int submit_time;
    int delay_time;
}

protected void set_delivery_delay(int new_time);
protected int valid_delivery(class delivery_item delivery, string person);
protected void deliver_item(string who, object ob, string sent_by);
protected void set_burdened_mess(string s);
protected void set_delivery(mapping x);
protected void set_delivery_mess(string s);
protected void set_save_file(string str);
public int query_delivery_delay();
public string query_burdened_mess();
public string query_delivery_mess();
public string query_save_file();
public varargs mixed query_delivery(string person);
public void add_delivery(mixed who, mixed sender, object item, int delay);
public void check_delivery(mixed person, string type);
public void clear_delivery();
public void setup_delivery();
public void load_file();
public void save_file();

private mapping _delivery;
private mixed _item_save;

private nosave string _save_file;
private nosave object _cont;
private nosave string _delivery_mess;
private nosave string _burdened_mess;
private nosave int _delivery_delay;

/** @ignore yes */
void create() {   
    _delivery = ([ ]);
    _save_file = "";
    _delivery_delay = 5;
    _delivery_mess = "\nA small womble wearing a bright green hat "
        "strides up to you confidently and hands you $N.  She "
        "mutters something about \"delivery\" and \"$S\", before "
        "scurrying away.\n";
    _burdened_mess = "\nA small womble wearing a bright purple "
        "hat strides up to you, and places \"$N\" on the ground.  She "
        "mutters something about a gift from \"$S\", and the runs off.\n";
    _cont = clone_object("/std/container");
    call_out("tidy_up", 30 + random(30));
} /* create() */        

/** 
 * This method adds the object into the login handler's static login calls 
 * list.  It only ever needs to be called _once_, and doesn't need to be 
 * called every time the object loads. 
 * <p>
 * Once this is done, the object will automatically be loaded whenever 
 * someone logs on.
 * <p> 
 * This must be called in order for the delivery system to work at all.
 */
public void setup_delivery() {   
    LOGIN_HANDLER->add_static_login_call("all", "check_delivery", 
        base_name(this_object()));
} /* setup_delivery() */

/** 
 * This method is used to query the save file in which the delivery data
 * is stored.
 *
 * @return  the path of the save file used to store delivery details.
 */
public string query_save_file() {
    return _save_file;    
} /* query_save_file() */

/** 
 * This method sets the save file to a file name so that auto loading and 
 * delivery details can be successfully saved.
 * @param str the new path.
 */
protected void set_save_file(string str) {
    _save_file = str;       
} /* set_save_file() */

/** 
 * This method is used to remove all deliveries currently stored within the 
 * delivery system.
 * <p>
 * Be very careful when using this function! It will save the cleared
 * delivery mapping after it has been called. 
 */
public void clear_delivery() {
    _delivery = ([ ]);
    save_file();    
} /* clear_delivery() */

/**
 * This is used to set all of the delivery mapping manually.  You should 
 * not use this method.  
 *
 * @param x the new delivery mapping.
 * @see add_delivery()
 */
protected void set_delivery(mapping x) {
    _delivery = x;
    save_file();      
} /* set_delivery() */

/**
 * This method adds a new item to the delivery mapping for the specified 
 * recipient.  This should always be used instead of set_delivery(), as it
 * makes sure that all the data structures have been configured correctly.
 *
 * @param who the person to receive the item. 
 * @param sender the person sending the file. 
 * @param item the item to be sent
 * @param delay how many seconds to wait before delivering item on the next
 * login.
 *
 * @example
 *      add_delivery(this_player(), "taffyd", frog, 360);
 * @see check_delivery()
 */
void add_delivery(mixed who, mixed sender, object item, int delay) {   
    string name, from;
    class delivery_item parcel;
    
    if (objectp(who))    
        name = who->query_name();
    else
        name = who;
        
    if (objectp(sender))    
        from = sender->query_cap_name();
    else
        from = sender;
    
    /* Create the new delivery item, configuriung the class and
       add it to the delivery mapping. */
           
    parcel = new(class delivery_item,
        delivery_ob : item, submit_time : time(), sent_by : from,
        delay_time : delay);
    
    if (undefinedp(_delivery[name]))
        _delivery[name] = ({ parcel });
    else         
        _delivery[name] += ({ parcel });
    
    log_file("DELIVERY", "%s added a new delivery item for %s, %s sent "
        "by %s.\n", previous_object()->short(), name, item->short(), 
        from);
    item->move(_cont);        
    save_file();
} /* add_delivery() */

/** 
 * This method is called by the check_delivery() function when it validates 
 * someone's deliveries.  It is used to determine whether or not it's time
 * for a delivery to be delivered, and whether or not to remove it.
 * <p>
 * @param delivery the delivery item to be tested
 * @param person the person to deliver the item to.
 * <p>
 * @return 1 if the delivery is not ready, 0 if it is. (yes, this is kind
 * of backwards.)
 */
protected int valid_delivery(class delivery_item delivery, string person) {
    
  if (delivery->submit_time + delivery->delay_time > time())
    return 1;
  
  if (!objectp(delivery->delivery_ob))
    return 0;
  
  call_out( (: deliver_item :), _delivery_delay, person, delivery->delivery_ob,
            delivery->sent_by);
  
  return 0;
} /* valid_delivery() */

/** 
 * This method is called by the login handler every time someone logs 
 * on to the Disc.  It handles the delivery of items and all sorts of 
 * nifty things.
 * <p>
 * @param person the name of the person logging on
 * @param type the type of login event
 *
 */
public void check_delivery(mixed person, string type) {    
    if (type != LOGIN && type != RECONNECT) 
        return;
    
    if (!_delivery[person])
        return;
        
    _delivery[person] = filter(_delivery[person], 
        (: valid_delivery($1, $(person)) :));
   
    if (!sizeof(_delivery[person]))
        map_delete(_delivery, person);
                
    save_file();    
} /* check_delivery() */

/**
 * This method is called when an item is being delivered to a player.  The 
 * delivery message or the burdened mess is used depending on how the item
 * is delivered, and then it is removed from the delivery mapping.
 * <p>
 * Note that this routine uses add_message() to display movement messages
 * to the player, instead of tell_object() or a traditional move message. This
 * is so that the messages can be 'clumped' together properly, otherwise 
 * it just doesn't work.
 * <p>
 * @param who the person to deliver to
 * @param ob the object to deliver
 * @param sent_by the person that send the parcel
 * @param position its location in the recepient's delivery mapping.
 */
protected void deliver_item(string who, object ob, string sent_by) {
    string new_mess;
    object player;
       
    player = find_player(who);
    
    /* Something has gone wrong... the player must have logged out before 
       they received their message. We'll just trash the item, since its
       already been removed from the delivery inheritable and placing it 
       back in is messy. (and rather pointless) */
       
    if (!player)
        ob->move("/room/rubbish");    
    
    if (ob->move(player) != MOVE_OK) {

        /* If we can't move the item into the player, then we should move it 
           into their environment... */
           
        if (environment(player)) {
            new_mess = replace(_burdened_mess, ({ "$S", sent_by, "$N", 
                "$0$" }));
            player->add_message(new_mess,  ({ ({ "my_a_short:" + 
            file_name(ob) }) }));

            ob->move(environment(player), );
        }        
        else {
            /* Eep, no environment. Trash the item, and log it. */
            ob->move("/room/rubbish", "$N appear$s in a puff of smoke.");
            log_file("DELIVERY", "%s: %s sent to the rubbish room, %s has "
                "no environment.\n", ctime(time()), ob->short(), 
                player->short());
        }
    }    
    else {
        /* Deliver everything happily. */
        new_mess = replace(_delivery_mess, ({ "$S", sent_by, "$N", "$0$" }));       
        
        player->add_message(new_mess,  ({ ({ "my_a_short:" + 
            file_name(ob) }) }));
        
        log_file("DELIVERY", "%s: %s delivered to %s.\n", ctime(time()), 
            ob->short(), who);
    }        
} /* deliver_item() */

/** @ignore yes */
int query_theft_command() {
    return -1;
} /* query_theft_command() */

void clean_delivery_mapping() {
    string *people, person;
    
    people = keys(_delivery);
    
    foreach (person in people) {
        _delivery[person] = filter(_delivery[person], 
            (: objectp($1->delivery_ob) :));
    }
    
    _delivery = filter(_delivery, (: sizeof($2) :));
} /* check_valid_delivery() */


/**
 * This method saves all of the delivery data into the save file, handling 
 * saving of the auto loading as well.
 */
public void save_file() {
  mixed *tmp;
  string player;
  class delivery_item *values;
  
  // no save file, cant save.
  if(_save_file == "")
    return;
  
  _item_save = ({ });
  
  clean_delivery_mapping();
  
  foreach (player, values in _delivery) {           
    tmp = map(values, (: $1->delivery_ob :));
        
    if (!arrayp(tmp))
      continue;
    
    _item_save += ({ player, create_auto_load(tmp, 0) });
  }
  
  tell_creator("ceres", "Saving: %s\n", _save_file);
  unguarded((: save_object, _save_file :));
  _item_save = 0;
} /* save_file() */

/**
 * This method loads retrieves data from the save file, and handles the 
 * autoloading of the items.
 */
void load_file() {
  int i, j, size;
  mixed *tmp;
  string who;
  mixed *items;

  if(_save_file == "")
    return;
  
  log_file("DELIVERY", "Attempting to load save file at %s.\n",
           ctime(time()));

  tell_creator("ceres", "Loading: %s\n", _save_file);
  if (file_size(_save_file + ".o") > -1) {
    unguarded((: restore_object, _save_file :));
    
    if (!_cont)
      _cont = clone_object("/std/container");
    
    all_inventory(_cont)->move("/room/rubbish");
    
    for (i = 0; i < sizeof(_item_save); i = i + 2) {
      who = _item_save[i];
      items = _item_save[i + 1];
      
      if (!_delivery[who])
        return;
      
      tmp = load_auto_load_to_array(items, this_player());
      
      /* This places the stored items back into the delivery
         mapping... items are stored in tmp backwards,
         which is why we do the size-i-1 thing.  */
      
      size = sizeof(tmp);
      
      for (j = 0; j < size; j++) {
        _delivery[who][j]->delivery_ob = tmp[size - j - 1];
        tmp[j]->move(_cont);
      }
    }
    
    _item_save = 0;                       
  }
} /* load_file() */

/** 
 * This returns the current delivery message that is displayed to the 
 * recipient of a delivery.
 *
 * @see set_delivery_mess()
 * @return the delivery message
 */
public string query_delivery_mess() {
    return _delivery_mess;
} /* query_delivery_mess() */


/** 
 * This method returns how long after the login an item is delivered
 * to the recipient.
 * @return the number of seconds unt    
 *
 */
public int query_delivery_delay() {
    return _delivery_delay;
} /* query_delivery_time() */


/**
 * This method is used to specify how many seconds to wait after login 
 * until the item is delivered.  Note that if this is too long, then the
 * receipient may log out before you can give them the item.  If the 
 * receipient logs out, then the item will be destroyed.
 * <p>
 * This is set to 5 by default.
 * <p>
 * @param new_time the time in seconds after log in to deliver the message.
 */
protected void set_delivery_delay(int new_time) {
    _delivery_delay = new_time;
} /* set_delivery_time() */

/** 
 * This method sets the delivery message that is displayed to the player 
 * when they log on. $S is substituted in the string with the name of 
 * the player who sent the message, $N is replaced with the a_short()
 * of the item being sent. 
 * @param s the new delivery string
 * @see query_delivery_mess()
 * @see /std/basic/desc->a_short()
 * @example
 *     set_delivery_mess("A small frog hops up to you, and thrusts $N "
 *         "into your arms.  He holds up a large sign that reads: \""
 *         "From $S\", and then runs away.\n");
 *
 * // Recipient sees:
 * A small frog hops up to you, and thrusts a large blue box into your
 * arms.  He holds up a large sign that reads: \"From Taffyd!\", and then
 * runs away.
 */
protected void set_delivery_mess(string s) {
    _delivery_mess = s;
} /* set_delivery_mess() */

/** 
 * This method sets the message that is displayed when an item is too 
 * heavy to be placed in the victim's inventory. This uses the same format
 * as the normal delivery message.
 * <p>
 * @param s message to display
 * @see set_delivery_mess()
 * @see query_burdened_mess()
 */
protected void set_burdened_mess(string s) {
    _burdened_mess = s;    
} /* set_burdened_mess() */

/** 
 * This returns the current delivery message that is displayed to the 
 * recipient of a delivery, if it is too heavy go to in their inventory.
 * <p>
 * @see set_burdened_mess()
 * @see query_delivery_mess()
 * @return the delivery message
 */
public string query_burdened_mess() {
    return _burdened_mess;
} /* query_burdened_mess() */

/**
 * This method returns the delivery details for a particular person, or
 * the entire delivery mapping of one doesn't exist.
 * <p>
 * @param person the person's delivery details to query. 
 */
public varargs mixed query_delivery(string person) {
    if (undefinedp(_delivery[person])) {
        return copy(_delivery);
    }
    else {
        return copy(_delivery[person]);
    }
} /* query_delivery() */

/** @ignore yes */  
void dest_me() {
    if (_cont) 
        _cont->dest_me();
} /* dest_me() */

/** @ignore yes */
object query_cont() {
  return _cont;
}

/**
 * @ignore yes
 */
void tidy_up() {
  string person;
  
  foreach(person in keys(_delivery)) {
    if(!PLAYER_HANDLER->test_user(person) || !PLAYER_HANDLER->test_active(person)) {
      log_file("DELIVERY", "%s Removing delivery for %s (inactive).\n",
               this_object()->query_short(), person);
      map_delete(_delivery, person);
    }
  }
  save_file();
}

/** @ignore yes */
mixed *stats() {
    return ({
        ({ "delivery mess", replace(_delivery_mess, ({ "\n",  "" }) ) }),
        ({ "burdened mess", replace(_burdened_mess, ({ "\n",  "" }) ) }),        
        ({ "delivery delay", _delivery_delay, }),
        ({ "delivery save file", _save_file, }),
        ({ "undelivered items", _cont ? sizeof(all_inventory(_cont)) : 0 }),
    });
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/delivery.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/armour_logic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/armour_logic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629902   Available: 13577256
Inodes: Total: 5242880    Free: 4960136
3199 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/armour_logic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629902   Available: 13577256
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Ok armour...
 * This will be nasty...
 */
#include "weapon_old.h"
nosave mapping ac;
nosave mixed armour_types;

void create() {
  ac = ([ ]);
  armour_types = ({ });
} /* create() */
 
/* set the ac for the type directly.... */
int add_ac(string name, string type, mixed a_c) {
  int i;
 
  if (!stringp(type))
    return 0;
 
  if (!ac) ac = ([ ]);

  if (ac[name])
    return 0;

  ac[name] = ({ a_c, type });

  if ((i=member_array(type, armour_types)) == -1)
    armour_types += ({ type, ({ name }) });
  else
    armour_types[i+1] += ({ name });
  return 1;
} /* add_ac() */

int remove_ac(string name) {
  int j, k;

  if (!ac[name])
    return 0;

  j = member_array(ac[name][1], armour_types);

  k = member_array(name, armour_types[j+1]);
  armour_types[j+1] = delete(armour_types[j+1], k, 1);
  if (!sizeof(armour_types[j+1]))
    armour_types = delete(armour_types, j, 2);

  map_delete(ac, name);
  return 1;
} /* remove_ac() */

int calc_value(mixed arr) {
  int i, val;
 
  if (intp(arr)) {
    // this means you're more likely to find an armours weak point
    // the lower its condition. Full condition armour gives a 10%
    // chance and it rises from there.
    //if(random(100) < 140 - ((this_object()->query_cond() /
    //                  this_object()->query_max_cond()) * 50))
    if(!random(10))
      return random(arr);
    else
      return arr;
  }
  if (!pointerp(arr))
    return 0;
  if (sizeof(arr) == 1)
    return arr[F_FIXED];
  if (sizeof(arr) == 2)
    return arr[F_FIXED]+random(arr[F_RAND]);
  for (i=0;i<arr[F_NUM];i++)
    val += random(arr[F_DIE]);
  return val + arr[F_FIXED];
} /* calc_value() */
 
/* ok this gets our ac... ;) */
varargs int query_ac( string type, int dam, string zone ) {
  int val, i, j;
  
  /* No armour types defined. */ 
  if ( !armour_types )
    return 0;
  
  /* Find our armour type list in the array */
  if ((i=member_array(type, armour_types)) != -1) {
    for ( j = 0; j < sizeof( armour_types[ i + 1 ] ); j++ )

      /* Does the armour name exist? */
      if ( ac[ armour_types[ i + 1 ][ j ]])
        /* Is it the correct size? */
        if ( sizeof( ac[ armour_types[ i + 1 ][ j ] ] ) == A_ARRAY_SIZE )
          val += calc_value( ac[ armour_types[ i + 1 ][ j ] ][ A_AC ] );
  }

  val -= (val / 4);
  
  return val;
} /* query_ac() */

mapping query_armour_class() { return ac; }

string calc_string(mixed b) {
  if (intp(b))
    return "rand("+b+")";
  if (!pointerp(b))
    return "Dead";
  switch (sizeof(b)) {
    case 1 :
      return ""+b[0];
    case 2 :
      return ""+b[0]+"+rand("+b[1]+")";
    case 3 :
      return ""+b[0]+"+"+b[1]+"d"+b[2];
    default :
      return "Oh hell";
  }
} /* calc_string() */

mixed *stats() {
  int i;
  mixed *ret;
  mixed *stuff;

  ret = ({ });
  stuff = keys(ac);
  for (i=0;i<sizeof(stuff);i++)
    ret += ({ ({ "ARM"+ i +" name", stuff[ i ], }),
              ({ "     type", ac[stuff[i]][A_TYPE], }),
              ({ "    class", calc_string(ac[stuff[i]][A_AC]) }),
          });
  return ret;
} /* stats() */

void set_ac(mixed *bing) {
  int i;

  for (i=0;i<sizeof(ac);i+=A_ARRAY_SIZE)
    add_ac(ac[i], ac[i+1][A_TYPE], ac[i+1][A_AC]);
} /* set_ac() */
// --- END [/mnt/home2/grok/lib/std/armour_logic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/map.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629901   Available: 13577255
Inodes: Total: 5242880    Free: 4960136
6547 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/map.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629901   Available: 13577255
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit "/std/object";

#define WORLD_MAP TERRAIN_MAP_WORLD_MAP

private nosave int *_area;
private nosave int _detail;
private nosave string *_features;
private nosave mapping _locations;

private nosave object _env, _pl;
private nosave int *_co_ords;
private nosave int _fudge;

/** @ignore yes */
void create() {
  do_setup++;
  ::create();
  do_setup--;

  add_alias("map");
  add_plural("maps");
  _locations = ([ ]);
  add_extra_look(this_object());
  
  if(!do_setup) {
    this_object()->setup();
  }
}

/** @ignore yes */
string extra_look() {
  return "Marked on the map are " +
    query_multiple_short(_features->query_base_description() +
                         keys(_locations)) + ".";
}

/** @ignore yes
 * Function to remove features that should not be shown on maps with
 * this level of detail.
 */
int filter_features(string feature) {
#ifdef DEBUG
  debug_printf("%s %d %d", feature,
               feature->query_max_range() / TERRAIN_MAP_ONE_MILE,
               _detail / TERRAIN_MAP_ONE_MILE);
#endif
  return (!feature->query_max_range() ||
          feature->query_max_range() >= _detail);
}

/**
 * Function to setup the details of the map.
 * The first two params give the coordinates of the top left corner
 * of the map and the second two the coordinates of the lower right corner.
 * The detail indicates the level of detail. This is given in terms of the
 * distance from which objects are visible. For example a low-detail map
 * might show objects that are visible from 200 miles or more whereas a
 * more detailed map may show items down to 50 miles visibility.
 *
 * @param x1 x part of the top left corner
 * @param y1 y part of the top left corner
 * @param x2 x part of the lower right corner
 * @param y2 y part of the lower right corner
 */
void setup_map(int x1, int y1, int x2, int y2, int detail) {
  _area = ({ x1, y1, x2, y2 });
  _detail = detail;
  _features = WORLD_MAP->query_features_in_region(x1, y1, x2, y2);
  _features = filter(_features, "filter_features", this_object());
}

/**
 * Function to set the map to one of the standard areas.  If you wish to
 * have the map cover a custom area use setup_map.
 *
 * @param area the area of Discworld the map should cover.
 */
void set_map(string area) {
  int width, height, detail, x1, y1, x2, y2;
  
  switch(area) {
  case "sur":
    width = (TERRAIN_MAP_ONE_MILE * 300);
    height = (TERRAIN_MAP_ONE_MILE * 200);
    x1 = -150575040 - width;
    y1 = -2173248 - height;
    x2 = -150575040 + width;
    y2 = -2173248 + height;
    detail = (TERRAIN_MAP_ONE_MILE * 50);
    break;
    
  case "world":
    x1 = TERRAIN_MAP_WORLD_LOW_X / 10;
    y1 = TERRAIN_MAP_WORLD_LOW_Y / 10;
    x2 = TERRAIN_MAP_WORLD_HIGH_X / 10;
    y2 = TERRAIN_MAP_WORLD_HIGH_Y / 10;
    detail = (TERRAIN_MAP_ONE_MILE * 200);
    break;
  }

  setup_map(x1, y1, x2, y2, detail);
}

/** @ignore yes
 * Recalc our current position.
 */
void recalc_coords() {
  int accuracy;
  
  if(!_co_ords || this_player() != _pl || environment(this_player()) != _env) {
    _pl = this_player();
    _env = environment(_pl);
    _co_ords = _env->query_co_ord();

    accuracy = 500 - _pl->query_skill_bonus("other.direction");
    if(accuracy < 1)
      accuracy = 1;

    _fudge = TERRAIN_MAP_ONE_MILE * accuracy;
    
    // Where we _think_ we are.
    _co_ords[0] += -(_fudge/2) + random(_fudge);
    _co_ords[1] += -(_fudge/2) + random(_fudge);
    _co_ords[2] += -(_fudge/2) + random(_fudge);
  }
}

/** @ignore yes */
int do_consult(string find) {
  string feature, *res;
  object ob;
  mapping direcs;
  
  if(this_player()->check_dark(environment(this_player())->query_light()))
    return notify_fail("Sorry the light levels are not conducive to "
                       "reading a map.\n");
  recalc_coords();
  
  if(_co_ords[0] < _area[0] || _co_ords[1] < _area[1] ||
     _co_ords[0] > _area[2] || _co_ords[1] > _area[3])
    return notify_fail("Sorry, you do not appear to be anywhere on this "
                       "map.\n");

  res = ({ });
  foreach(feature in _features) {
    ob = feature->query_region_ob();
    if(ob) {
#ifdef DEBUG
      debug_printf("%O max range %d", feature,
                   feature->query_max_range()/TERRAIN_MAP_ONE_MILE);
#endif
      direcs = ob->query_feature_desc_from(_co_ords[0], _co_ords[1],
                                           _co_ords[2], 1);

      if(direcs) {
        if(find == "" || strsrch(lower_case(feature->query_base_description()),
                   lower_case(find)) != -1)
          res += ({ feature->calc_map_feature_desc(direcs, _fudge) });
      }
    }
  }

  if(res == ({ })) {
    if(find != "")
      return notify_fail("You cannot find " + find + " on your map.\n");
    else
      return notify_fail("You cannot find anything on your map.\n");
  }
  write("You consult your map and estimate that " +
        query_multiple_short(res) + "\n");
  this_player()->add_succeeded_mess(this_object(), "");
  return 1;
}

/** @ignore yes */
int do_add(string location) {
  if(member_array(lower_case(location), keys(_locations)) != -1)
    return notify_fail("A location with the name " + location +
                       " already exists on this map.\n");
  _locations[lower_case(location)] = _co_ords;
  this_player()->add_succeeded_mess(this_object(), "$N $V a new location "
                                    "to $D.\n");
  return 1;
}

/** @ignore yes */
void init() {
  this_player()->add_command("consult", this_object(), "<direct:object>",
                             (: do_consult("") :));
  this_player()->add_command("find", this_object(),
                             "<string'place'> on <direct:object>",
                             (: do_consult($4[0]) :));
  this_player()->add_command("add", this_object(),
                             "<string'description'> to <direct:object>",
                             (: do_add($4[0]) :));
}

/** @ignore yes */
mapping int_query_static_auto_load() {
  return ([
    "::": ::int_query_static_auto_load(),
    "features": _features,
    "detail": _detail,
    "area": _area,
  ]);
}

/** @ignore yes */
mixed query_static_auto_load() {
  if((file_name(this_object()))[0..7] != "/std/map" )
    return 0;
  return int_query_static_auto_load();
}

/** @ignore yes */
void init_static_arg(mapping args) {
  if(args["::"])
    ::init_static_arg(args["::"]);
  if(args["features"])
    _features = args["features"];
  if(args["detail"])
    _detail = args["detail"];
  if(args["area"])
    _area = args["area"];
}

// --- END [/mnt/home2/grok/lib/std/map.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/race.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/race.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629899   Available: 13577253
Inodes: Total: 5242880    Free: 4960136
10486 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/race.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629899   Available: 13577253
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is called off of the monster to set up a race and
 * profession...   Race should be first then profession..
 * @author Pinkfish
 * @started Sometime in 1991
 */

#include "race.h"

inherit "/std/basic/print_object";

private mapping _races;
private mapping _guilds;
private mapping _race_obs;
private mapping _guild_obs;

void create() {
  string tmp;
  
  _races = ([
      0                  : "/std/races/human", /* first the null race */
      "ape"              : "/std/races/ape",
      "arachnid"         : "/std/races/arachnid",
      "baboon"           : "/std/races/baboon",
      "basilisk"         : "/std/races/basilisk",
      "badger"           : "/std/races/badger",
      "bat"              : "/std/races/bat",
      "bear"             : "/std/races/bear",
      "beetle"           : "/std/races/beetle",
      "bird"             : "/std/races/bird",
      "blowfish"         : "/std/races/blowfish",
      "bufonid"          : "/std/races/bufonid",
      "cabbage"          : "/std/races/cabbage",
      "camel"            : "/std/races/camel",
      "cat"              : "/std/races/cat",
      "caterpillar"      : "/std/races/caterpillar",
      "chicken"          : "/std/races/chicken",
      "chimera"          : "/std/races/chimera",
      "cockroach"        : "/std/races/cockroach",
      "cow"              : "/std/races/cow",
      "crab"             : "/std/races/crab",
      "crocodile"        : "/std/races/crocodile",
      "deer"             : "/std/races/deer",
      "demon"            : "/std/races/demon",
      "dog"              : "/std/races/dog",
      "dryad"            : "/std/races/dryad",
      "duck"             : "/std/races/duck",
      "dwarf"            : "/std/races/dwarf",
      "duckling"         : "/std/races/duckling",
      "eagle"            : "/std/races/chicken",
      "elemental"        : "/std/races/elemental",
      "elephant"         : "/std/races/elephant",
      "elf"              : "/std/races/elf",
      "ferret"           : "/std/races/ferret",
      "fish"             : "/std/races/fish",
      "fox"              : "/std/races/fox",
      "frog"             : "/std/races/frog",
      "gargoyle"         : "/std/races/gargoyle",
      "giant"            : "/std/races/giant",
      "giant bat"        : "/std/races/giant_bat",
      "giant spider"     : "/std/races/giant_spider",
      "gnoll"            : "/std/races/gnoll",
      "gnome"            : "/std/races/gnome",
      "goat"             : "/std/races/goat",
      "golem"            : "/std/races/golem",
      "grflx"            : "/std/races/grflx",
      "guppy"            : "/std/races/guppy",
      "half elf"         : "/std/races/half_elf",
      "hare"             : "/std/races/hare",
      "hedgehog"         : "/std/races/hedgehog",
      "hengeyokai"       : "/std/races/hengeyokai",
      "horse"            : "/std/races/horse",
      "human"            : "/std/races/human",
      "igor"             : "/std/races/igor",
      "imp"              : "/std/races/imp",
      "insect"           : "/std/races/insect",
      "light"            : "/std/races/light",
      "lion"             : "/std/races/lion",
      "lobster"          : "/std/races/lobster",
      "luggage"          : "/std/races/luggage",
      "jellyfish"        : "/std/races/jellyfish",
      "mole"             : "/std/races/mole",
      "moose"            : "/std/races/moose",
      "mouse"            : "/std/races/mouse",
      "mustelidae"       : "/std/races/mustelidae",
      "newt"             : "/std/races/newt",
      "noble dragon"     : "/std/races/noble_dragon",
      "nymph"            : "/std/races/nymph",
      "peacock"          : "/std/races/peacock",
      "penguin"          : "/std/races/penguin",
      "panda"            : "/std/races/panda",
      "parrot"           : "/std/races/parrot",
      "pig"              : "/std/races/pig",
      "rabbit"           : "/std/races/rabbit",
      "raptor"           : "/std/races/raptor",
      "rat"              : "/std/races/rat",
      "rodent"           : "/std/races/rodent",
      "sargassum"        : "/std/races/sargassum",
      "satyr"            : "/std/races/satyr",
      "scorpion"         : "/std/races/scorpion",
      "sektarian demon"  : "/std/races/sektarian_demon",
      "shark"            : "/std/races/shark",
      "sprite"           : "/std/races/sprite",
      "sheep"            : "/std/races/sheep",
      "skunk"            : "/std/races/skunk",
      "slice human"      : "/std/races/slice_human",
      "snake"            : "/std/races/snake",
      "sphinx"           : "/std/races/sphinx",
      "spider"           : "/std/races/spider",
      "squirrel"         : "/std/races/squirrel",
      "stoat"            : "/std/races/stoat",
      "stone giant"      : "/std/races/stone_giant",
      "stone palm"       : "/std/races/stone_palm",
      "strange"          : "/std/races/strange",
      "swamp dragon"     : "/std/races/swamp_dragon",
      "toad"             : "/std/races/toad", 
      "tortoise"         : "/std/races/tortoise",
      "tree"             : "/std/races/tree",
      "troll"            : "/std/races/troll",
      "vulture"          : "/std/races/vulture",
      "unicorn"          : "/std/races/unicorn",
      "vampire"          : "/std/races/vampire",
      "vorpal bunny"     : "/std/races/vorpal_bunny",
      "weasel"           : "/std/races/weasel",
      "werewolf"         : "/std/races/werewolf",
      "wolf"             : "/std/races/wolf",
      "wombat"           : "/std/races/wombat",
      "wererat"          : "/std/races/wererat",
      "giant rat"        : "/std/races/giant_rat",
    ]);
    _guilds = ([
      0                  : "/std/guilds/standard",
      "fighter"          : "/std/guilds/warrior",
      "warrior"          : "/std/guilds/warrior",
      "cleric"           : "/std/guilds/priest",
      "priest"           : "/std/guilds/priest",
      "witch"            : "/std/guilds/witch",
      "wizard"           : "/std/guilds/wizard",
      "cat burglar"      : "/std/guilds/thief",
      "cut throat"       : "/std/guilds/thief",
      "thief"            : "/std/guilds/thief",
      "pickpocket"       : "/std/guilds/thief",
      "swashbuckler"     : "/std/guilds/thief",
      "monk"             : "/std/guilds/monk",
      "assassin"         : "/std/guilds/assassin",
    ]);

    _race_obs = ([ ]);
    // Cache the loaded race & guild objects.
    foreach(tmp in values(_races))
      _race_obs[tmp] = load_object(tmp);

    _guild_obs = ([ ]);
    foreach(tmp in values(_guilds))
      catch(_guild_obs[tmp] = load_object(tmp));

}

/**
 * This method checks to see if the specified race is valid or not.
 * @param race the race to check for validity
 * @return 1 if it exists, 0 if it does not
 */ 
int query_valid_race( string race ) {
    return !undefinedp(_races[race]);
} /* query_valid_race() */

/**
 * This method sets the level of the npc with the specified attributes.
 * @param lvl the level to set the npc at
 * @param race the race to set the npc with
 * @param guild the guild to set the npc with
 */
void set_level( int lvl, string race, string guild ) {
    object ob;
    string race_ob, guild_ob;

    if (_races[race]) {
        race_ob = _races[race];
    } else {
        race_ob = _races[0];
    }
    if (_guilds[guild]) {
        guild_ob = _guilds[guild];
    } else {
        guild_ob = _guilds[0];
    }
    ob = previous_object();
    ob->set_no_check(1);
    ob->set_race_ob(race_ob);
    /* Done in /global/guild-race
       race_ob->start_player(ob);
    */
    race_ob->set_level(ob, lvl);
    ob->set_guild_ob(guild_ob);
    /* Done in /global/guild-race
       guild_ob->start_player(ob);
    */
    guild_ob->set_level(ob, lvl, guild);
    ob->race_guild_commands();
} /* set_level() */

private int add_race( string name, mixed ob ) {
    if (_races[name]) {
        return 0;
    }
    _races[name] = ob;
    return 1;
} /* add_race() */

private int remove_race( string name ) {
    if (!_races[name]) {
        return 0;
    }
    _races[name] = 0;
    return 1;
} /* remove_race() */

/**
 * This method returns all the current races in the race object.  It is a
 * mapping with matches between the name of the race and race object.
 * @return the race mapping
 */ 
mapping query_races() {
    return copy(_races);
} /* query_racs() */

/**
 * This method returns the path associated with the specified race.
 * @param race_name the name of the race
 * @return the path of the race
 */
string query_race_path( string race_name ) {
    return _races[race_name];
} /* query_race_path() */

private int add_guild( string name, mixed ob ) {
    if (_guilds[name]) {
        return 0;
    }
    _guilds[name] = ob;
    return 1;
} /* add_guild() */

private int remove_guild( string name ) {
    if (!_guilds[name]) {
        return 0;
    }
    _guilds[name] = 0;
    return 1;
} /* remove_guild() */

/**
 * This method returns all the current guilds in the race object.  It is a
 * mapping with matches between the name of the guild and guild object.
 * @return the race mapping
 */ 
mapping query_guilds() {
    return copy(_guilds);
} /* query_guilds() */

/**
 * This method returns the path associated with the specified guild.
 * @param guild_name the name of the guild
 * @return the path of the guild
 */
string query_guild_path(string guild_name) {
    return _guilds[guild_name];
} /* query_guild_path() */

/**
 * This method is called from inside the npc to do the heartbeat on the
 * guild and race objects.
 * @param race the race to do a heart beat on
 * @param guild the guild to do a heart beat on
 * @param race_ob the object to use for the race
 * @param guild_ob the object to use for the guild
 */ 
void monster_heart_beat(string race,  string guild, mixed race_ob,
                        mixed guild_ob) {
  object tmp;
  
  if(stringp(race_ob)) {
    if(!_race_obs[race_ob])
      _race_obs[race_ob] = find_object(race_ob);
    tmp = _race_obs[race_ob];
  } else if(objectp(race_ob))
    tmp = race_ob;
  if(tmp)
    tmp->player_heart_beat( race, previous_object() );

  if(stringp(guild_ob)) {
    if(!_guild_obs)
      _guild_obs = ([ ]);
    if(!_guild_obs[guild_ob]) {
      _guild_obs[guild_ob] = find_object(guild_ob);
    }
    tmp = _guild_obs[guild_ob];
  } else if(objectp(guild_ob))
    tmp = guild_ob;

  if(tmp)
    tmp->player_heart_beat(guild, previous_object());
} /* monster_heart_beat() */
// --- END [/mnt/home2/grok/lib/std/race.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/socket/telnet.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/socket/telnet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629896   Available: 13577250
Inodes: Total: 5242880    Free: 4960136
4989 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/socket/telnet.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629896   Available: 13577250
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* 
 * written by Dwayne Fontenot (Jacques)
 * last modified: 1992 October 19 (runs on the Basis mudlib)
 *
 * This object implements a telnet client (providing a subset of the telnet
 * protocol) using STREAM mode of MudOS 0.9 LPC sockets.  See the init()
 * function // to find out the commands this terminal understands.
 * This object may be used from within a MudOS mud to connect to any
 * networked server that understands the telnet protocol (including
 * another LPmud).
 */

#include <socket.h>
#include <socket_errors.h>

#define WRITE_WAIT_CALLBACK 0
#define WRITE_GO_AHEAD      1

#define DISCONNECTED "an internet terminal"
#define CONNECTED "an internet terminal (connected)"

#define IAC  255
#define DONT 254
#define DO   253
#define WONT 252
#define WILL 251

#define TELOPT_ECHO   1
#define TELOPT_SGA    3
#define TELOPT_TTYPE 24
#define TELOPT_NAWS  31

nosave string *telopts = ({"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD",
			"NAME", "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
		    "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
		    "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
		    "DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
		    "SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
		    "TACACS UID", "OUTPUT MARKING", "TTYLOC",
		    "3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
		    "LINEMODE"});

nosave string s_iac_dont_echo;
nosave string s_iac_do_echo;
nosave string s_iac_wont_echo;
nosave string s_iac_will_echo;
nosave string s_iac_dont_sga;
nosave string s_iac_do_sga;
nosave string s_iac_wont_sga;
nosave string s_iac_will_sga;
nosave string s_iac_wont_ttype;
nosave string s_iac_wont_naws;
nosave string s_iac;
nosave string s_dont_echo;
nosave string s_do_echo;

private string callback;

private int conn_fd;
private int connected;
private int verbose;

private int write_state = WRITE_WAIT_CALLBACK;
private string write_message = "";

protected void init_tel_neg()
{
  s_iac_dont_echo  = sprintf("%c%c%c",IAC,DONT,TELOPT_ECHO);
  s_iac_do_echo    = sprintf("%c%c%c",IAC,DO  ,TELOPT_ECHO);
  s_iac_wont_echo  = sprintf("%c%c%c",IAC,WONT,TELOPT_ECHO);
  s_iac_will_echo  = sprintf("%c%c%c",IAC,WILL,TELOPT_ECHO);
  s_iac_dont_sga   = sprintf("%c%c%c",IAC,DONT,TELOPT_SGA);
  s_iac_do_sga     = sprintf("%c%c%c",IAC,DO  ,TELOPT_SGA);
  s_iac_wont_sga   = sprintf("%c%c%c",IAC,WONT,TELOPT_SGA);
  s_iac_will_sga   = sprintf("%c%c%c",IAC,WILL,TELOPT_SGA);
  s_iac_wont_ttype = sprintf("%c%c%c",IAC,WONT,TELOPT_TTYPE);
  s_iac_wont_naws  = sprintf("%c%c%c",IAC,WONT,TELOPT_NAWS);
  s_iac            = sprintf("%c",    IAC);
  s_dont_echo      = sprintf("%c%c",  DONT,TELOPT_ECHO);
  s_do_echo        = sprintf("%c%c",  DO,  TELOPT_ECHO);
}

void
set_callback(string arg)
{
	callback = arg;
}

void create()
{
  init_tel_neg();
  connected = 0;
  verbose = 0;
  set_callback("handler");
}

void
set_verbosity(int v)
{
	verbose = v;
}

int
query_connected()
{
	return connected;
}

void disconnected()
{
  call_other(this_object(), callback, "close");
  connected = 0;
}

int connected()
{
  call_other(this_object(), callback, "open");
  connected = 1;
}

void my_socket_write(int fd, string message)
{
  int ret;

  write_message = write_message + message;
  if(write_state == WRITE_GO_AHEAD){
    ret = socket_write(fd, write_message);
    write_message = "";
    if(ret == EESUCCESS) write_state = WRITE_GO_AHEAD;
    else if(ret == EECALLBACK) write_state = WRITE_WAIT_CALLBACK;
  }
}

int line(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_dont_sga+s_iac_dont_echo);
    write("SENT dont SUPPRESS GO AHEAD\nSENT dont ECHO\n");
    return(1);
  }
  return(0);
}

int char(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_do_sga+s_iac_do_echo);
    write("SENT do SUPPRESS GO AHEAD\nSENT do ECHO\n");
    return(1);
  }
  return(0);
}

int connect(string str)
{
  int ret;

  if(!str) return(0);
  conn_fd = socket_create(STREAM,"socket_shutdown");
  ret = socket_connect(conn_fd,str,"receive_data","write_data");
  if(ret != EESUCCESS){
    notify_fail("unable to connect: " + socket_error(ret) + "\n");
    return(0);
  }
  connected();
  return(1);
}

int send(string str)
{
  if(connected){
    if(!str){
      write("Sending CR.\n");
      my_socket_write(conn_fd,"\n");
      return(1);
    }
    my_socket_write(conn_fd,str + "\n");
    return(1);
  }
  return(0);
}

int disconnect(string str)
{
  int ret;

  ret = socket_close(conn_fd);
  if(ret <= 0){
    notify_fail("unable to disconnect.\n");
    return(0);
  }
  disconnected();
  return(1);
}

void receive_data(int rec_fd, string msg) {
  string *chunks;
  int i;
  object hearer;

  this_object()->recieve_message(msg);
} /* recieve_message() */

void write_data(int fd) {
  write_state = WRITE_GO_AHEAD;
  my_socket_write(fd,"");
} /* write_data() */

void socket_shutdown(int fd)
{
  object hearer;

  if(fd == conn_fd){
    hearer = environment(this_object());
    disconnected();
    return;
  }
}
// --- END [/mnt/home2/grok/lib/std/socket/telnet.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/nationality/pumpkin.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/nationality/pumpkin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629895   Available: 13577249
Inodes: Total: 5242880    Free: 4960136
893 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/nationality/pumpkin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629895   Available: 13577249
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/nationality/basic";

void setup() {
   set_name( "pumpkin" );
   set_information( "Pumpkin is a large orange ball shaped town.\n");
   add_region( "round",
               "Pumpkins which are round.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/round");

   add_region( "square",
               "Sto Lat is the second biggest city in the Morporkian kingdom, "
               "it sits on the river Ankh on the way to the Carrack "
               "Mountains.  It is a harder starting location than "
               "Ankh-Morpork but close enough that it is not that much of an "
               "issue.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/square");

   set_language("pumpkin");
   set_currency_area("Pumpkin");
   set_default_start_location("/d/am/buildings/drum/mendeddrum");
}
// --- END [/mnt/home2/grok/lib/std/nationality/pumpkin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/nationality/accents/regional/round.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/nationality/accents/regional/round.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629895   Available: 13577249
Inodes: Total: 5242880    Free: 4960136
844 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/nationality/accents/regional/round.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629895   Available: 13577249
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/nationality/accents/accent_base.c";

string query_accent_name() {
   return "Morporkian";
}


string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   
   return replace( mess, ({ "au", "$AU_PROTECT",
                               "oo", "$OO_PROTECT",
                               "ou", "$OU_PROTECT",
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                                "$OO_PROTECT", "oo",
                               "$OU_PROTECT", "ou",
                               "$AU_PROTECT", "au"
                               }) );
}

// --- END [/mnt/home2/grok/lib/std/nationality/accents/regional/round.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/nationality/accents/regional/square.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/nationality/accents/regional/square.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629894   Available: 13577248
Inodes: Total: 5242880    Free: 4960136
658 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/nationality/accents/regional/square.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629894   Available: 13577248
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/nationality/accents/accent_base.c";

string query_accent_name() {
   return "Pumpkian";
}


string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   
   return replace( mess, ({ "a", "aa",
                               "oo", "o",
                               "ou", "ooou"
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                               }) );
}

// --- END [/mnt/home2/grok/lib/std/nationality/accents/regional/square.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/nationality/accents/accent_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/nationality/accents/accent_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629894   Available: 13577248
Inodes: Total: 5242880    Free: 4960136
1146 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/nationality/accents/accent_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629894   Available: 13577248
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * An inherit for regional accents to call national
 * accents if needed.
 *
 * by goldenthread, started 2 August y2k2
 */

#define NATIONAL_ACCENT_PATH "/std/nationality/accents/national/"

mapping accent_lang_map = ([
   "Pumpkin" : "pumpkin",
   ]);

string query_nat_accent( string lang ) {
   return NATIONAL_ACCENT_PATH + lang;
}

string national_garble( string mess, object person, object sayer, int say_type,
                        string def_lang, string accent ) {
   string accent_lang = accent_lang_map[ accent ];
   string nat_accent = query_nat_accent( accent_lang );
   
   
   if( def_lang != accent_lang ) {
      if( nat_accent )
         mess = load_object( query_nat_accent( accent_lang ) )->garble_say( mess,
                                                                            person,
                                                                            sayer,
                                                                            say_type );
   } else {
      //tell_object( this_player(), "Something has gone wrong, "
                   //"please contact a creator.\n" );
   }

   return mess;
}

// --- END [/mnt/home2/grok/lib/std/nationality/accents/accent_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/nationality/accents/national/pumpkin.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/nationality/accents/national/pumpkin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629893   Available: 13577247
Inodes: Total: 5242880    Free: 4960136
333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/nationality/accents/national/pumpkin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629893   Available: 13577247
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
string garble_say( string mess, object person,
                   object sayer, int say_type ) {
   return replace( mess, ({ 
                            "eh", "a",
                            "ah", "eh",
                            "ou", "oo"
                         }) );
}

string query_accent_name() {
   return "Pumpkinian";
}
// --- END [/mnt/home2/grok/lib/std/nationality/accents/national/pumpkin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/nationality/basic.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/nationality/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629893   Available: 13577247
Inodes: Total: 5242880    Free: 4960136
6096 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/nationality/basic.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629893   Available: 13577247
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The basic nationality inherit.  The nationality keeps track of any
 * specific information about the nationality.
 * @author Pinkfish
 * @started Tue Jun  4 15:08:33 PDT 2002
 */

inherit "/std/basic/setup";

class region {
   string description;
   string start_location;
   string accent_ob;
}

private string _name;
private string _information;
private string _same_nat_description;
private string _different_nat_description;
private string _start_loc;
private string _language;
private string _accent;
private string _currency;

private mapping _regions;

void create() {
   _regions = ([ ]);
   // This is mostly just in case we need it in the future.
   do_setup();
}

/**
 * This method adds a region to the nationality.
 * @param name the name of the region
 * @param description the description of the region
 * @param start the start location of the region
 * @param accent the accent object for this region
 */
void add_region(string name, string description, string start, string accent) {
   class region bing;

   bing = new(class region,
              description : description,
              start_location : start,
              accent_ob : accent);
   _regions[name] = bing;
}

/**
 * This method sets the name of the nationality.
 * @param name the name of the nationality
 */
void set_name(string name) {
   _name = name;
}

/**
 * This method returns the name of the nationality.
 * @return the name of the nationality
 */
string query_name() {
   return _name;
}

/**
 * This method sets the description of the nationality when viewed
 * by someone who is also the same nationality.
 * @param description the description of the nationality
 */
void set_same_nationality_description(string description) {
   _same_nat_description = description;
}

/**
 * This method returns the description of the nationality when viewed
 * by someone who is also the same nationality.
 * @return the description of the nationality
 */
string query_same_nationality_description() {
   return _same_nat_description;

}
/**
 * This method sets the description of the nationality when viewed
 * by someone who is of a different nationality.
 * @param description the description of the nationality
 */
void set_different_nationality_description(string description) {
   _different_nat_description = description;
}

/**
 * This method returns the description of the nationality when viewed
 * by someone who is of a different nationality.
 * @return the description of the nationality
 */
string query_different_nationality_description() {
   return _different_nat_description;
}

/**
 * This method returns the description shown to the person looking
 * at the character.  This is currently disabled.
 * @param looker the person doing the looking
 * @param person the person being looked at
 * @return a nice description
 */
string query_look_description(object person, object looker) {
   return "";
   if (person->query_nationality() == looker->query_nationality()) {
      return capitalize(person->query_pronoun()) + " " +
             _same_nat_description;
   } else {
      return capitalize(person->query_pronoun()) + " " +
             _different_nat_description;
   }
}

/**
 * This method sets the start location of the nationality.
 * @param start_loc the start location of the nationality
 */
void set_default_start_location(string start_loc) {
   _start_loc = start_loc;
}

/**
 * This method returns the start location of the nationality.
 * @return the start location of the nationality
 */
string query_default_start_location() {
   return _start_loc;
}

/**
 * This method sets the language of the nationality.
 * @param language the language of the nationality
 */
void set_language(string language) {
   _language = language;
}

/**
 * This method returns the language of the nationality.
 * @return the language of the nationality
 */
string query_language() {
   return _language;
}

/**
 * This is the informaton the player will see in the start room.  Should
 * be full of happy stuff to make people want to be from the this place.
 * @param info the information to use
 */
void set_information(string info) {
   _information = info;
}

/**
 * This method returns the information the player will see in the start
 * room.
 * @return the information about the nationality
 */
string query_information() {
	if (!_information) {
      _information = "The $C$" + query_name() + " nationality is yet to "
                     "be described.\n";
   }
   return _information;
}

/**
 * This method returns the names of all the regions in nationality.
 * @return the names of the regions
 */
string* query_regions() {
   return keys(_regions);
}

/**
 * This method returns the description for the specific regions.
 * @param region the region
 * @return the description
 */
string query_region_description(string region) {
   return _regions[region]->description;
}

/**
 * This method returns the start location for the specific regions.
 * @param region the region
 * @return the start location
 */
string query_region_start_location(string region) {
   return _regions[region]->start_location;
}

/**
 * This method returns the start location, if the region does not have one
 * set it uses the default one.
 * @param region the region to look at first
 */
string query_start_location(string region) {
   if (_regions[region] && _regions[region]->start_location) {
      return _regions[region]->start_location;
   }
   return _start_loc;
}

/**
 * This method returns the accent object for the specific region.
 * @param region the region to find the accent for
 * @return the accent object
 */
string query_region_accent_ob(string region) {
   if (_regions[region]) {
      return _regions[region]->accent_ob;
   }
   return 0;
}

/**
 * This method sets the currency area to use for the nationality.
 * @param currency the currency to use
 */
void set_currency_area(string area) {
   _currency = area;
}

/**
 * This method returns the current area to use for the nationality.
 * @return the currency area
 */
string query_currency_area() {
   return _currency;
}
// --- END [/mnt/home2/grok/lib/std/nationality/basic.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/mineral.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/mineral.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629891   Available: 13577245
Inodes: Total: 5242880    Free: 4960136
6457 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/mineral.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629891   Available: 13577245
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <mineral.h>

#define HANDLER "/obj/handlers/cmr_handler"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
#define DEFAULT_MARKET "Ankh-Morpork"

inherit "/std/object";

int check_tool( object *tools );

nosave string mineral;

void create() {
   write( "If you've not just logged in and are waiting for your "
         "inventory to be regenerated, please bug report this location, "
         "as it's using the obsolete mineral object.\n" );
   ::create();
} /* create() */

void init() {
   this_player()->add_command( "chip", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "chip", this_object(), "<direct:object> 'using' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'using' <indirect:object>" );
} /* init() */

varargs void make_mineral( string word, int number, string *inputs ) {
   string adjective, material_adjective, colour_code, noun, *args;
   mineral = word;
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   colour_code = (string)HANDLER->query_material_ansi_colour( mineral );
   set_weight( number );
   switch( number ) {
      case 0..PEBBLE:
         adjective = "small";
         noun = "pebble";
         break;
      case PEBBLE+1..STONE:
         adjective = "medium sized";
         noun = "stone";
         break;
      case STONE+1..ROCK:
         adjective = "large";
         noun = "rock";
         break;
      default:
         adjective = "huge";
         noun = "boulder";
   }
   if ( !pointerp( inputs ) )
      args = allocate( 10 );
   else
      args = inputs + ({ 0, 0, 0, 0, 0 });
   if ( !args[0] ) {
      set_name( noun );
      add_plural( noun +"s" );
   } else {
      set_name( args[0] );
      if ( !args[3] )
         add_plural( args[0] +"s" );
      else
         add_plural( args[3] );
   }
   if ( !args[1] ) {
      set_short( colour_code + material_adjective +" "+ noun +"%^RESET%^" );
      set_main_plural( colour_code + material_adjective +" "+ noun +
            "s%^RESET%^" );
   } else {
      set_short( args[1] );
      if ( !args[4] )
         set_main_plural( args[1] +"s" );
      else
         set_main_plural( args[4] );
   }
   if ( !args[2] )
      set_long( "This is a "+ adjective +" lump of $mineral$.\n" );
   else
      set_long( args[2] );
   add_adjective( ({ adjective }) + explode( material_adjective, " " ) );
} /* make_mineral() */

string long( string str, int dark ) {
   string bit1, bit2, ret;
   sscanf( ::long( str, dark ), "%s$mineral$%s", bit1, bit2 );
   ret = bit1 + (string)HANDLER->identify_material( mineral, this_player(), 1 )
      + bit2;
   return ret;
} /* long() */

string *query_adjectives() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::query_adjectives() + ({ ret });
} /* query_adjectives() */

string *parse_command_adjectiv_id_list() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::parse_command_adjectiv_id_list() + ({ ret });
} /* parse_command_adjectiv_id_list() */

string query_mineral() { return mineral; }

string query_material() { return mineral; }

int query_value() {
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral,
            DEFAULT_MARKET ) );
} /* query_value() */

int query_value_in( string word ) {
  if ( ( !word || ( word == "" ) ) || ( word == "default" ) )
    word = DEFAULT_MARKET;
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral, word ) );
} /* query_value_in() */

int do_chip( object *tools ) {
   object chip;
   if ( !check_tool( tools ) )
      return 0;
   if ( query_weight() == 1 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
                this_player(), 0 ) +" is already a chip.\n" );
      return 0;
   }
   set_weight( query_weight() - 1 );
   chip = clone_object( MINERAL );
   chip->make_mineral( mineral, 1 );
   chip->move( environment() );
   this_player()->add_succeeded( tools[0] );
   return 1;
} /* do_chip() */

int do_smash( object *tools ) {
   int i, j, largest, number, size;
   object debris, remains;
   if ( !check_tool( tools ) )
      return 0;
   largest = this_player()->query_max_weight();
   if ( largest >= query_weight() )
      largest = query_weight();
   else {
      remains = clone_object( MINERAL );
      remains->make_mineral( mineral, query_weight() - largest );
      remains->move( environment() );
   }
   tools[ 0 ]->hit_weapon( largest, "blunt" );
   number = 2 + random( 4 );
   for ( i = 0; i < 8; i++ ) {
      largest /= number;
      for ( j = 1; j < number; j++ ) {
         size = ( 3 * largest + random( largest ) ) / 4;
         if ( size ) {
            debris = clone_object( MINERAL );
            debris->make_mineral( mineral, size );
            debris->move( environment() );
          }
       }
   }
   this_player()->add_succeeded( tools[0] );
   move( "/room/rubbish" );
   return 1;
} /* do_smash */

int check_tool( object *tools ) {
   string tool;
   object *held;
   if ( sizeof( tools ) > 1 ) {
      write( "You only need to use one tool at a time.\n" );
      return 0;
   }
   if ( !sizeof( tools ) ) {
      write( "You need to use a tool of some sort.\n" );
      return 0;
   }
   held = this_player()->query_holding();
   if ( member_array( tools[0], held ) == -1 ) {
      write( "You need to use a tool that you are holding.\n" );
      return 0;
   }
   tool = tools[0]->query_name();
   if ( member_array( tool, ({ "pickaxe", "pick" }) ) == -1 ) {
      write( "You need to use a tool appropriate to the job.\n" );
      return 0;
   }
   return 1;
} /* check_tool() */

mixed *stats() {
   return ::stats() + ({
      ({ "mineral", mineral, }),
   });
} /* stats() */

mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "mineral" : mineral,
   ]);
} /* int_query_static_auto_load() */

void init_static_arg( mapping map ) {
   if ( map["::"] )
      ::init_static_arg( map["::"] );
   if ( !undefinedp( map["mineral"] ) )
      mineral = map["mineral"];
} /* init_static_arg() */

mixed query_static_auto_load() {
   if ( file_name( this_object() )[ 0 .. 11 ] == "/std/mineral" )
      return int_query_static_auto_load();
   return ([ ]);
} /* query_static_auto_load() */
// --- END [/mnt/home2/grok/lib/std/mineral.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/ken_mangle.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/ken_mangle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629890   Available: 13577244
Inodes: Total: 5242880    Free: 4960136
6066 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/ken_mangle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629890   Available: 13577244
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ken_mangle.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: ken_mangle.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
string *replace_matrix;
mapping trans;

void create() {  
  replace_matrix = ({ 
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });

  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
} /* trans() */

string do_transmute(string str) {
  string tmp, *bits;
  mixed erp;
  int i;

  tmp = replace(" "+str+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
} /* do_transmute() */
// --- END [/mnt/home2/grok/lib/std/curses/ken_mangle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/newbie_eff_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/newbie_eff_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629888   Available: 13577242
Inodes: Total: 5242880    Free: 4960136
4901 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/newbie_eff_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629888   Available: 13577242
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_eff_shadow.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: newbie_eff_shadow.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
inherit "/std/effect_shadow";
#define MY_NAME "NEWBIE SIMULATOR"

/*
 * The Newbie Simulator. Completely shuts off your conversational abilities,
 * replacing about half of your comments with "amusing" alternative from the
 * list below. 
 * 
 * Veronica 1/94, modified from the Upper Case curse. (with the spelling 
 *                                 cleaned up, too... )
 * Modified 2/94 by Veronica to make it unreadable, and use stupid variables
 * in line with DW coding directives. It's also now an effect and thus three
 * times as big.
 */


object my_player;
string name, my_name;

void remove_effect_shadow(int i) {
   if (i == id) {
      destruct(this_object());
      return;
   }
      else player->remove_effect_shadow(i);
}


protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n", 
	"How can I level in this mud?\n",
	"How do I kill things?\n", 
	"This is nothing like my nintendo... where are the baddies?\n", 
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
} /* newbie() */

protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});

  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});

  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
} /* newbie() */

int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
} /* do_say() */

int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
} /* do_tell() */

int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
} /* do_loud_say() */

int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
} /* do_echo() */

int do_emote_all(string str) {
  return (int)my_player->do_emote_all(newbie_emote(str));
} /* do_emote_all() */

int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
} /* do_emote() */

int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
} /* do_whisper() */

int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
} /* do_echo_to() */

int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
} /* do_shout() */

int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
} /* do_talk() */
// --- END [/mnt/home2/grok/lib/std/curses/newbie_eff_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/ken_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/ken_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629886   Available: 13577240
Inodes: Total: 5242880    Free: 4960136
2215 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/ken_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629886   Available: 13577240
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: ken_curse.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: ken_curse.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
#include "path.h"
#define MY_NAME "ken curse"

/*
 * The shout curse.  Makes people unable to shout...
 */
object my_player;

int init_curse(object pl) {
  string str, i;

  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
/* A class, not a clone. */
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
} /* init_curse() */

/*
 * No special requirements for removeing this curse...
 */
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
} /* query_remove() */

/*
 * Called when the player logs on
 */
int player_start(object pl) {
  object ob;

  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"ken_curse");
  ob->init_curse(pl);
} /* player_start() */

/*
 * This gets called with the name of the curse we are getting rid of.
 */
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
} /* destruct_curse() */

int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"ken_mangle")->do_transmute(str));
} /* do_emote_all() */

int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"ken_mangle")->do_transmute(str));
} /* do_shout() */

int do_say(string str) {
  return (int)my_player->do_say((HERE+"ken_mangle")->do_transmute(str));
} /* do_say() */

int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"ken_mangle")->do_transmute(str));
} /* do_loud_say() */

int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"ken_mangle")->do_transmute(str));
} /* do_emote() */

int do_tell(string str) {
  string s1;

  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"ken_mangle")->do_transmute(str));
} /* do_tell() */
// --- END [/mnt/home2/grok/lib/std/curses/ken_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/shout_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/shout_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629886   Available: 13577240
Inodes: Total: 5242880    Free: 4960136
1570 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/shout_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629886   Available: 13577240
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: shout_curse.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: shout_curse.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
#include "path.h"
#define MY_NAME "Shout curse"

/*
 * The shout curse.  Makes people unable to shout...
 */
object my_player;

int init_curse(object pl) {
  string str, i;

  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
/* A class, not a clone. */
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  printf("%O, %O\n", pl, this_object());
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
} /* init_curse() */

/*
 * No special requirements for removeing this curse...
 */
int query_remove(string name) {
  return 1;
} /* query_remove() */

/*
 * Called when the player logs on
 */
int player_start(object pl) {
  object ob;

  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"shout_curse");
  ob->init_curse(pl);
} /* player_start() */

/*
 * This gets called with the name of the curse we are getting rid of.
 */
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
} /* destruct_curse() */

int do_emote_all(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
} /* do_emote_all() */

int do_shout(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
} /* do_shout() */
// --- END [/mnt/home2/grok/lib/std/curses/shout_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/newbie_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/newbie_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629884   Available: 13577238
Inodes: Total: 5242880    Free: 4960136
5491 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/newbie_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629884   Available: 13577238
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: newbie_curse.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: newbie_curse.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
#include "path.h"
#define MY_NAME "NEWBIE SIMULATOR"

/*
 * The Newbie Simulator. Completely shuts off your conversational abilities,
 * replacing about half of your comments with "amusing" alternative from the
 * list below. 
 * 
 * Veronica 1/94, modified from the Upper Case curse. (with the spelling 
 *                                 cleaned up, too... )
 */

object my_player;

int init_curse(object pl) {
  string str;
  int i;

  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
/* A class not a clone */
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
} /* init_curse() */

/*
 * No special requirements for removeing this curse...
 */
int query_remove() { return 1; }

/*
 * Called when the player logs on
 */
int player_start(object pl) {
  object ob;

  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
} /* player_start() */

/*
 * This gets called with the name of the curse we are getting rid of.
 */
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
} /* destruct_curse() */

protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n", 
	"How can I level in this mud?\n",
	"How do I kill things?\n", 
	"This is nothing like my nintendo... where are the baddies?\n", 
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
} /* newbie() */

protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});

  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});

  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
} /* newbie() */

int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
} /* do_say() */

int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
} /* do_tell() */

int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
} /* do_loud_say() */

int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
} /* do_echo() */

int do_emote_all(string str) {
  return (int)my_player->do_echo_all(newbie_emote(str));
} /* do_emote_all() */

int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
} /* do_emote() */

int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
} /* do_whisper() */

int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
} /* do_echo_to() */

int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
} /* do_shout() */

int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
} /* do_talk() */
// --- END [/mnt/home2/grok/lib/std/curses/newbie_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/chef_mangle.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/chef_mangle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629883   Available: 13577237
Inodes: Total: 5242880    Free: 4960136
1160 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/chef_mangle.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629883   Available: 13577237
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chef_mangle.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: chef_mangle.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
/* chef.x - convert English on stdin to Mock Swedish on stdout
 *
 * The WC definition matches any word character, and the NW definition matches
 * any non-word character.  Two start conditions are maintained: INW (in word)
 * and NIW (not in word).  The first rule passes TeX commands without change.
 *
 * HISTORY
 *
 * Apr 15, 1992; John Hagerman: Created.
 */
/*
 * Taken from the above and converted into lpc by Pinkfish.
 */

string *replace_matrix;

void create() {
  replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
} /* create() */

string do_transmute(string str) {
  return replace(" "+str, replace_matrix)[1..10000];
} /* do_transmute() */
// --- END [/mnt/home2/grok/lib/std/curses/chef_mangle.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/chef_curse.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/chef_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629882   Available: 13577236
Inodes: Total: 5242880    Free: 4960136
2225 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/chef_curse.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629882   Available: 13577236
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chef_curse.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: chef_curse.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
#include "path.h"
#define MY_NAME "chef curse"

/*
 * The shout curse.  Makes people unable to shout...
 */
object my_player;

int init_curse(object pl) {
  string str, i;

  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
/* A class, not a clone. */
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
} /* init_curse() */

/*
 * No special requirements for removeing this curse...
 */
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
} /* query_remove() */

/*
 * Called when the player logs on
 */
int player_start(object pl) {
  object ob;

  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"chef_curse");
  ob->init_curse(pl);
} /* player_start() */

/*
 * This gets called with the name of the curse we are getting rid of.
 */
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
} /* destruct_curse() */

int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"chef_mangle")->do_transmute(str));
} /* do_emote_all() */

int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"chef_mangle")->do_transmute(str));
} /* do_shout() */

int do_say(string str) {
  return (int)my_player->do_say((HERE+"chef_mangle")->do_transmute(str));
} /* do_say() */

int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"chef_mangle")->do_transmute(str));
} /* do_loud_say() */

int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"chef_mangle")->do_transmute(str));
} /* do_emote() */

int do_tell(string str) {
  string s1;

  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"chef_mangle")->do_transmute(str));
} /* do_tell() */
// --- END [/mnt/home2/grok/lib/std/curses/chef_curse.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/curses/upper_case.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/curses/upper_case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629881   Available: 13577235
Inodes: Total: 5242880    Free: 4960136
2393 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/curses/upper_case.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629881   Available: 13577235
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: upper_case.c,v 1.1 1998/01/06 04:02:57 ceres Exp $
 * $Log: upper_case.c,v $
 * Revision 1.1  1998/01/06 04:02:57  ceres
 * Initial revision
 * 
*/
#include "path.h"
#define MY_NAME "UPPER CASE"

/*
 * The upper case curse.  Means everything you say comes out in upper
 * case.
 */
object my_player;

int init_curse(object pl) {
  string str;
  int i;

  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
/* A class not a clone */
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
} /* init_curse() */

/*
 * No special requirements for removeing this curse...
 */
int query_remove() { return 1; }

/*
 * Called when the player logs on
 */
int player_start(object pl) {
  object ob;

  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
} /* player_start() */

/*
 * This gets called with the name of the curse we are getting rid of.
 */
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
} /* destruct_curse() */

protected string upper_case(string str) {
  string ret;
  int i;

  ret = "";
  for (i=0;i<strlen(str);i++)
    ret += capitalize(str[i..i]);
  return ret;
} /* upper_case() */

int do_say(string str) {
  return (int)my_player->do_say(upper_case(str));
} /* do_say() */

int do_tell(string str) {
  return (int)my_player->do_tell(upper_case(str));
} /* do_tell() */

int do_loud_say(string str) {
  return (int)my_player->do_loud_say(upper_case(str));
} /* do_loud_say() */

int do_echo(string str) {
  return (int)my_player->do_echo(upper_case(str));
} /* do_echo() */

int do_emote_all(string str) {
  return (int)my_player->do_echo_all(upper_case(str));
} /* do_emote_all() */

int do_emote(string str) {
  return (int)my_player->do_emote(upper_case(str));
} /* do_emote() */

int do_whisper(string str) {
  return (int)my_player->do_whisper(upper_case(str));
} /* do_whisper() */

int do_echo_to(string str) {
  return (int)my_player->do_echo_to(upper_case(str));
} /* do_echo_to() */

int do_shout(string str) {
  return (int)my_player->do_shout(upper_case(str));
} /* do_shout() */
// --- END [/mnt/home2/grok/lib/std/curses/upper_case.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/smart_log.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/smart_log.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629881   Available: 13577235
Inodes: Total: 5242880    Free: 4960136
3323 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/smart_log.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629881   Available: 13577235
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* $Id: smart_log.c,v 1.14 2003/04/23 19:39:57 pinkfish Exp pinkfish $ */

#include <log.h>
#include <db.h>
#include <config.h>
#include <playtesters.h>

/* Define this to use the old ERROR_REPORTS file system */
#undef OLD_SYSTEM

/* Define this to use the new SQL based errors system */
#define NEW_SYSTEM

//int db_fd;

void create() {
   //catch(db_fd = db_connect("localhost", "errors", CONFIG_DB_USER));
}

void smart_log(string full_type, string reporter, string text,
                      string trace, string file) {
   int i;
   string type, temp1, *j, *person, dir;
#ifdef OLD_SYSTEM
   string temp2, report;
#endif
#ifdef NEW_SYSTEM
   string query, name, category;
   int rtime;
#endif
    
   seteuid("Root");
   person = ({ });

   person = master()->query_assigned_to_directory(file);

   j = explode(file, "/") - ({ "" });
   dir = "/" + implode(j[0..<2], "/");
   // Normalise the file name.
   file = implode(j, "/");
   sscanf(full_type, "%s %s", category, full_type);
   if (!sscanf(full_type, "%s %s", type, name)) {
      type = full_type;
      name = "";
   }
   rtime = time();
   if (sizeof(person) > 0) {
      query = sprintf("INSERT INTO errors (EntryDate, DirEntryDate, "
                           "Directory, Filename, Category, Type, Name, Reporter, "
                           "Report, Runtime, AssignedTo) VALUES(%d, %d, '%s', '/%s', '%s', '%s', "
                           "'%s', '%s', '%s', '%s', '%s');", rtime, rtime, dir,
                           db_escape(file), category, type, db_escape(name), reporter,
                           db_escape(text), (trace ? db_escape(trace) : ""),
                           db_escape(person[0]));
   } else {
      query = sprintf("INSERT INTO errors (EntryDate, DirEntryDate, "
                           "Directory, Filename, Category, Type, Name, Reporter, "
                           "Report, Runtime) VALUES(%d, %d, '%s', '/%s', '%s', '%s', "
                           "'%s', '%s', '%s', '%s');", rtime, rtime, dir,
                           db_escape(file), category, type, db_escape(name), reporter,
                           db_escape(text), (trace ? db_escape(trace) : ""));
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "",
                                query, (: tell_creator("pinkfish", "%O %O\n", $1, $2) :));

   PLAYTESTER_HAND->report_made(reporter, type, file,
                               (sizeof(person) > 0 ?
                                 "Assigned to " + capitalize(person[0]) + "\n\n" : "Not assigned to anyone.\n\n" ) +
                               text + ( trace
                                       ? "\nError:\n" + trace : ""));
  
   //catch(db_exec(db_fd, query));

   j = explode( file, "/" );
   file = "/"+ implode( j[ 0 .. <2 ], "/" );
   for(i=0;i<sizeof(person);i++) {
      temp1 = read_file("/w/"+person[i]+"/"+PLAYER_ERROR_LOG);
      if (!temp1) {
         temp1 = "";
      }
      j = explode(temp1, "\n");
      if (!j) {
         j = ({ });
      }
      if (member_array(file, j) == -1) {
         j += ({ file });
      }
      temp1 = implode(j, "\n")+ "\n";
      master()->do_log(person[i], temp1);
   }
} /* smart_log()*/

void dest_me() {
   //catch(db_close(db_fd));
   destruct(this_object());
}

void clean_up() { dest_me(); }

void reset() { dest_me(); }
// --- END [/mnt/home2/grok/lib/std/smart_log.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/sign_writer.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/sign_writer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629880   Available: 13577234
Inodes: Total: 5242880    Free: 4960136
14501 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/sign_writer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629880   Available: 13577234
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/room/basic_room";
#include <money.h>
#include <move_failures.h>

#define SIGN_MAKING_PICK_UP_TIME (24 * 60 * 60)

class sign_type {
   string short;
   string long;
   int cost;
   int weight;
   int max_letters;
   int max_lines;
}

class sign_making {
   int type;
   string mess;
   string colour;
   int pick_up;
}

private nosave class sign_type* _signtypes;
private nosave mapping _paintcolours;
private nosave string _save_file;
private nosave string _language;
private nosave function _open_func;
private mapping _signs;

void do_load();

void create() {
   _signtypes = ({ });
   _paintcolours = ([ ]);
   _signs = ([ ]);
   ::create();
   do_load();
   add_help_file("sign_writer");
} /* create() */

/**
 * This method checks to see if the shop is open.
 * @return 1 if it is open, 0 if not
 */
int is_open() {
   if (_open_func) {
      return evaluate(_open_func);
   }
   return 1;
} /* is_open() */

/**
 * This method sets a function to call to test to see if the shop
 * is open.
 * @param open_func the function to call
 */
void set_open_func(function func) {
   _open_func = func;
} /* set_open_func() */

/**
 * This method returns the current function used to test to see
 * if the shop is open or not.
 */
function query_open_func() {
   return _open_func;
} /* query_open_func() */

/**
 * This method sets the language the shop works in.
 * @param language the language the shop uses
 */
void set_language(string lang) {
   _language = lang;
} /* set_language() */

/**
 * This method returns the language the shop works in.
 * @return the language the shop works in
 */
string query_language() {
   return _language;
} /* query_language() */

/**
 * This method sets the save file for the shop.
 * @param save_file the save file name
 */
void set_save_file_name(string save) {
   _save_file = save;
} /* set_save_file_name() */

/**
 * THis method returns the current save file name of the shop.
 * @return the save file name of the shop
 */
string query_save_file_name() {
   return _save_file;
} /* query_save_file_name() */

/**
 * This method saves us.
 * @ignore yes
 */
void do_save() {
   if (_save_file) {
      save_object(_save_file);
   }
} /* do_save() */

/**
 * This method saves us.
 * @ignore yes
 */
void do_load() {
   if (_save_file) {
      restore_object(_save_file);
   }
} /* do_load() */

/**
 * This method adds a paint colour to the shop and how much that 
 * colour costs to use.  The cost for the colour is the cost per
 * letter.
 * @param colour the colour of the paint
 * @param cost the cost of the paint
 */
void add_paint_colour(string colour, int cost) {
   _paintcolours[colour] = cost;
} /* add_paint() */

/**
 * This method adds the types of signs that are available.
 * @param short the short description of the sign
 * @param cost the base cost of the sign
 * @param weight how heavy the sign is
 * @param max_letters most letters
 * @param max_lines the most lines
 */
void add_sign_type(string short, string long, int cost,
                   int weight, int max_letters, int max_lines) {
   class sign_type bing;

   bing = new(class sign_type);
   bing->short = short;
   bing->long = long;
   bing->cost = cost;
   bing->weight = weight;
   bing->max_letters = max_letters;
   bing->max_lines = max_lines;
   _signtypes += ({ bing });
} /* add_sign_type() */

/**
 * This method adds a sign into the current list of signs to be
 * made.
 * @param owner the person who owns the sign
 * @param type the type of the sign
 * @param mess the message on the sign
 * @param colour the colour of the sign
 */
void add_sign_making(string owner, int type, string mess,
                     string colour, int pick_up) {
   class sign_making bing;

   bing = new(class sign_making);
   bing->type = type;
   bing->mess = mess;
   bing->colour = colour;
   bing->pick_up = pick_up;
   if (!_signs[owner]) {
      _signs[owner] = ({ });
   }
   _signs[owner] += ({ bing });
   do_save();
} /* add_sign_making() */

/**
 * This method is called when the player orders a sign.
 * @param type the type of sign to order
 * @return 1 on success 0 on failure
 */
int do_order(string type) {
   int pos;
   int cost;
   string place;

   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }

   if (strlen(type) == 1) {
      pos = lower_case(type)[0] - 'a';
      if (pos < 0 || pos > sizeof(_signtypes)) {
         add_failed_mess("The id must be between 'a' and '" +
               sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
         return 0;
      }
   } else {
      add_failed_mess("The id must be between 'a' and '" +
            sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   cost = _signtypes[pos]->cost;
   if (cost > this_player()->query_value_in(place)) {
      add_failed_mess("You do not have enough money to pay for this "
            "sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return 0;
   }
   //
   // Ok, we have our type...   Now lets get a message...
   //
   write("Using a sign of type " + _signtypes[pos]->short +
         ".  What message would "
         "you like on your sign?\n");
   this_player()->do_edit("", "finish_editing_message", this_object(),
                          0, pos);
   add_succeeded_mess(({ "",
                         "$N looks into getting a sign made up.\n" }));
   return 1;
} /* do_order() */


/** @ignore yes*/
void finish_editing_message(string mess, int type) {
   string colour;
   int cost;
   string place;
   class sign_type bing;

   if (!mess) {
      write("Aborting sign writing process.\n");
      return ;
   }

   bing = _signtypes[type];
   if (strlen(replace(mess, ({ "\n", "", }))) > bing->max_letters) {
      write("The message " + mess + " has too many letters for the "
            "sign " + bing->short + ", the most allowed is " +
            bing->max_letters + ", you have " +
            strlen(replace(mess, ({ "\n", "", }))) +
            ".\n");
      return ;
   }

   if (sizeof(explode(mess, "\n")) > bing->max_lines) {
      write("The message " + mess + " has too many lines for the "
            "sign " + bing->short + ", the most allowed is " +
            bing->max_lines + ", you have " +
            sizeof(explode(mess, "\n")) +
            ".\n");
      return ;
   }

   write("You have selected a sign of type " + bing->short + " and have "
         "decided to put the message:\n" + mess + "\nonto the sign.\n"
         "Paint colours are:\n");
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   foreach (colour, cost in _paintcolours) {
      write(sprintf("%-20s %s per letter\n", colour,
            MONEY_HAND->money_value_string(cost, place)));
   }

   write("What colour paint would you like? ");
   input_to("finish_sign", 0, type, mess);
} /* finish_editing_message() */

/** @ignore yes */
void finish_sign(string colour, int type, string mess) {
   int cost;
   string place;
   class sign_type bing;

   colour = lower_case(colour);
   bing = _signtypes[type];
   if (!strlen(colour)) {
      write("Aborting the sign process.\n");
      return ;
   }

   if (!_paintcolours[colour]) {
      write("I am sorry, we do not stock " + colour + ".\n");
      write("Try one of " +
            query_multiple_short(keys(_paintcolours)) + ".\n");
      write("What colour paint would you like? ");
      input_to("finish_sign", 0, type, mess);
      return ;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   cost = _paintcolours[colour] *
          strlen(replace(mess, ({ "\n", "", " ", "" })));
   cost += bing->cost;
   if (cost > this_player()->query_value_in(place)) {
      write("You do not have enough money to pay for this sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return ;
   }
   write("Making a sign of type " + bing->short + " with a message of:\n" +
         mess + "\nWill cost " + 
         MONEY_HAND->money_value_string(cost, place) +
         ".\nDo you wish to make this sign? ");
   input_to("validate_sign", 0, type, mess, colour, cost);
} /* finish_sign() */

/** @ignore yes */
void validate_sign(string choice, int type, string mess,
                   string colour, int cost) {
   int pick_up;
   string place;
   class sign_type bing;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (cost > this_player()->query_value_in(place)) {
      write("You do not have enough money to pay for this sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return ;
   }

   bing = _signtypes[type];
   choice = lower_case(choice);
   if (!strlen(choice) || (choice[0] != 'n' && choice[0] != 'y')) {

      write("You did not enter 'yes' or 'no'.  Please try again.\n");
      write("Making a sign of type " + bing->short + " with a message of:\n" +
            mess + "\nWill cost " + 
            MONEY_HAND->money_value_string(cost, place) +
            ".\nDo you wish to make this sign? ");
      input_to("validate_sign", 0, type, mess, colour);
      return 0;
   }

   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );

   pick_up = time() + SIGN_MAKING_PICK_UP_TIME;
   add_sign_making(this_player()->query_name(), type, mess, colour,
                   pick_up);
   write("Ok, we will start making your sign.  Please come "
         "back tomorrow (after " + ctime(pick_up) +
         ") to pick up your sign.\n");
} /* validate_sign() */

/**
 * This method is called when the player comes back to pick up a sign
 * (or signs) that are being made.
 */
int do_collect() {
   class sign_making sign;
   class sign_type type;
   object* ok;
   string* not_yet;
   string* bits;
   object ob;

   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }

   if (!_signs[this_player()->query_name()]) {
      add_failed_mess("You have no signs to pick up.\n");
      return 0;
   }

   ok = ({ });
   not_yet = ({ });
   foreach (sign in _signs[this_player()->query_name()]) {
      if (time() > sign->pick_up) {
         type = _signtypes[sign->type];
         //
         // Ok!
         //
         ob = clone_object("/std/room/furniture/basic");
         bits = explode(type->short, " ");
         ob->set_name(bits[<1]);
         ob->add_adjective(bits[0..<2]);
         ob->set_short(type->short);
         ob->set_long(type->long);
         ob->set_weight(type->weight);
         ob->add_read_mess(sign->mess, sign->colour + " paint",
                           query_language(), 1);
         ob->add_property("sign");
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         ok += ({ ob });
      } else {
         not_yet += ({ _signtypes[sign->type]->short + " with " +
                       sign->colour + " letters" });
      }
   }

   if (sizeof(ok)) {
      add_succeeded_mess("$N pick$s up $I.\n", ok);
      return 1;
   }
   if (sizeof(not_yet) == 1) {
      add_failed_mess("The sign " + query_multiple_short(not_yet) +
                      " is not ready to be picked up yet.\n");
   } else {
      add_failed_mess("The signs " + query_multiple_short(not_yet) +
                      " are not ready to be picked up yet.\n");
   }
   return 0;
} /* do_collect() */

/**
 * This method browses one of the sign types.  THis shows detailed
 * information about the sign type.
 * @param type the type to browse
 */
int do_browse(string type) {
   class sign_type bing;
   string place;
   int pos;

   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (strlen(type) == 1) {
      pos = lower_case(type)[0] - 'a';
      if (pos < 0 || pos > sizeof(_signtypes)) {
         add_failed_mess("The id must be between 'a' and '" +
               sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
         return 0;
      }
   } else {
      add_failed_mess("The id must be between 'a' and '" +
            sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
      return 0;
   }


   bing = _signtypes[pos];

   write("The sign of type " + type + " has a short description of '" +
         bing->short + "' and a long description:\n" + bing->long +
         "\nIt will cost " +
         MONEY_HAND->money_value_string(bing->cost, place) +
         " and will take a maximum of " + bing->max_letters +
         " letters and a maximum number of lines of " +
         bing->max_lines + ".\n");
   add_succeeded_mess(({ "", "$N browses a sign in " + the_short() +
                             ".\n" }));
   return 1;
} /* do_browse() */

/**
 * This method lists all the current sign types.
 */
int do_list() {
   class sign_type bing;
   int i;
   string ret;
   string place;
   string colour;
   int cost;

   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "Signs availabe:\n";
   for (i = 0; i < sizeof(_signtypes); i++) {
      bing = _signtypes[i];
      ret += "$I$7=   " + sprintf("%c", 'a' + i) +
             ") " + bing->short + " costs " +
         MONEY_HAND->money_value_string(bing->cost, place) +
         " with " + bing->max_letters + " characters and " +
         bing->max_lines + " lines.\n";
             
   }

   ret += "\n$I$0=Colours available:\n";
   foreach (colour, cost in _paintcolours) {
      ret += sprintf("$I$7=   %-20s %s per letter\n", colour,
            MONEY_HAND->money_value_string(cost, place));
   }

   write("$P$Sign browse$P$" + ret);
   add_succeeded_mess(({ "", "$N lists the signs in " +
                             the_short() + ".\n" }) );
   return 1;
} /* do_list() */

void init() {
   add_command("list", "", (: do_list() :));
   add_command("browse", "<string'sign'>", (: do_browse($4[0]) :));
   add_command("collect", "sign", (: do_collect() :));
   add_command("buy", "<string'sign'>", (: do_order($4[0]) :));
   add_command("order", "<string'sign'>", (: do_order($4[0]) :));
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/sign_writer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_craft_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629876   Available: 13577230
Inodes: Total: 5242880    Free: 4960136
2254 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629876   Available: 13577230
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is just like a normal craft shop, except it to be used by players.
 * It handles things like messing with the descriptions and so on, it is
 * mostly designed to be used in places like club rooms and things.
 * @author Pinkfish
 * @started Mon Sep 20 19:28:22 PDT 1999
 */
#include <config.h>

#ifdef __DISTRIBUTION_LIB__
inherit "/std/room";
#else
inherit "/std/room/player_housing";
#endif
inherit "/std/shops/inherit/player_craft_shop";


/** @ignore yes */
void create() {
#ifdef __DISTRIBUTION_LIB__
   room::create();
#else
   player_housing::create();
#endif
   player_craft_shop::create();
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   add_help_file("player_craft_shop");
} /* create() */

/** @ignore yes */
void init() {
#ifdef __DISTRIBUTION_LIB__
   room::init();
#else
   player_housing::init();
#endif
   player_craft_shop::init();
} /* init() */

/** @ignore yes */
void dest_me() {
#ifdef __DISTRIBUTION_LIB__
   room::dest_me();
#else
   player_craft_shop::dest_me();
#endif
   player_housing::dest_me();
} /* dest_me() */

/**
 * @ignore yes
 * Set this up to catch the directory set and setup both the save files...
 */
void set_save_dir(string dir) {
   set_save_file(dir + "_main");
#ifndef __DISTRIBUTION_LIB__
   ::set_save_dir(dir);
#endif
} /* set_save_dir() */

/**
 * This method tells us if the person is allowed to use this shop.
 * @param name the name of the person
 */
int is_allowed(string name) {
   if (name == "pinkfish") {
      return 1;
   }

   if (lower_case(name) == lower_case(query_owner())) {
      return 1;
   }

   if (member_array(lower_case(name), query_allowed()) != -1) {
      return 1;
   }
   return 0;
} /* is_allowed() */

/** @ignore yes */
void event_exit(object ob, string mess, object to) {
#ifdef __DISTRIBUTION_LIB__
   room::event_exit(ob, mess, to);
#else
   player_housing::event_exit(ob, mess, to);
#endif
   player_craft_shop::event_exit(ob, mess, to);
} /* event_exit() */

#ifndef __DISTRIBUTION_LIB__
/** @ignore yes */
int ownership_change(string old_owner, string new_owner) {
   player_craft_shop::ownership_change(old_owner, new_owner);
   return player_housing::ownership_change(old_owner, new_owner);
} /* ownership_change() */
#endif
// --- END [/mnt/home2/grok/lib/std/shops/player_craft_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/bank.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/bank.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629875   Available: 13577229
Inodes: Total: 5242880    Free: 4960136
14922 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/bank.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629875   Available: 13577229
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id: bank.c,v 1.6 2003/05/08 15:58:21 carmine Exp $
 */
/**
 * This is the bank inheritable.  It handles all the bank transactions
 * and other such exciting stuff.
 * @author Pinkfish
 */
#include <money.h>
#include <move_failures.h>

#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"

nosave inherit "/std/room/basic_room";

int total_account, total_made;
nosave int account_cost, percentage;
nosave string bank_name, place;

int do_withdraw(int num, string type);
int do_deposit(string str);

nosave string save_file;

void create() {
  account_cost = 0;
  percentage = 90;
  total_account = 0;
  total_made = 0;
  bank_name = "Bing's First";
  place = "default";
  add_help_file("bank");
  ::create();
} /* create() */

void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<number> <string>",
               (: do_withdraw($4[0], $4[1]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
  ::init();
} /* init() */

/**
 * This method returns the amount of money it costs to start an account
 * at this bank.
 * @return the account cost
 */
int query_account_cost() { return account_cost; }

/**
 * This method sets the amount of money that it costs to start an account
 * at this bank.
 * @param number the cost of starting an account
 */
void set_account_cost( int number ) { account_cost = number; }

/**
 * This method queries the percentage the bank charges on transactions.
 * @return the percentage the bank charges
 */
int query_percentage() { return percentage; }

/**
 * This method sets the percentage the bank charges on transactions.
 * @param number the percentage to charge
 */
void set_percentage( int number ) { percentage = number; }

/**
 * This method returns the total value of all the accounts.
 * @return the totaly value of all the accounts
 */
int query_total_account() { return total_account; }

/**
 * This method returns the amount of money the bank has made off the
 * players.
 * @param total_made the amount of money mae
 */
int query_total_made() { return total_made; }

string query_bank_name() { return bank_name; }

void set_bank_name( string word ) { bank_name = word; }

string query_place() { return place; }
string query_money_place() { return query_place(); }

void set_place( string word ) { place = word; }

string query_save_file() { return save_file; }

void set_save_file( string word ) {
  save_file = word;
  if ( file_size( save_file +".o" ) > 0 )
    unguarded((: restore_object, save_file :));
} /* set_save_file() */

void do_save() {
   if ( !save_file ) {
      return;
   }
   unguarded( (: save_object, save_file :) );
} /* do_save() */

int get_account() {
  int amount;

  if ( amount = (int)this_player()->query_property( "bank "+ OLD_BANK ) ) {
    HANDLER->adjust_account( NAME, bank_name, amount );
    this_player()->remove_property( "bank "+ OLD_BANK );
    total_account += amount;
    do_save();
  }
  return (int)HANDLER->query_account( NAME, bank_name );
} /* get_account() */

int set_account( int amount ) {
  HANDLER->set_account( NAME, bank_name, amount );
} /* set_account() */

int do_balance() {
  int amount;

  amount = get_account();
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     this_player()->add_succeeded_mess(this_object(),
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }), ({ }) );
    return 1;
  }
  this_player()->add_succeeded_mess(this_object(),
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount, place ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }), ({ }) );
  return 1;
} /* do_balance() */

int do_withdraw( int number, string type ) {
  int amount;
  int best;
  int total;
  object money;

  total = get_account();

  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }

  if ( number <= 0 ) {
    notify_fail( "You must withdraw something.\n" );
    return 0;
  }

  money = clone_object( MONEY_OBJECT );
  money->set_money_array( (mixed *)MONEY_HAND->query_values_in( place ) );
  if ( ( best = (int)money->find_best_fit( type ) ) == -1 ) {
    notify_fail( "That currency is not legal tender here.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  type = ( (mixed *)money->query_money_array() )[ best ];
  amount = number * ( (mixed *)money->query_money_array() )[ best + 1 ];
  if ( ( amount > total ) ||
       ( amount < 0 ) ) {
    notify_fail( "You don't have enough money in your account.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  money->set_money_array( ({ type, number }) );
  set_account( total - amount );
  total_account -= amount;
  do_save();
  this_player()->add_succeeded_mess(this_object(),
   ({ "You withdraw "+ (string)money->short() +".\n" + 
      "You have "+ (string)MONEY_HAND->money_value_string( get_account(), 
                                                           place ) +
        " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
       }), ({ }) );
  if ( (int)money->move( this_player() ) != MOVE_OK ) {
    write( "You are too heavily burdened to collect the money, so the teller "+
      "puts it on the counter for you.\n" );
    money->move( this_object() );
  }
  this_player()->save();
  return 1;
} /* do_withdraw() */

int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;

   total = get_account();
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }

   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only deposit money.\n" );
         default :
            return notify_fail( "You can only deposit legal tender.\n" );
      }
   }

   // Figure out the legal tender
   if (!place) {
      place = "default";
   }
   tender = MONEY_HAND->filter_legal_tender( money, place);
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
     amount = legal->query_value_in(place);
     if (place != "default") {
       amount += legal->query_value_in("default");
     }

     // Minimum amount added to prevent depositing 1c 1000 times to avoid
     // charges.
     if(amount < 200) {
       if( legal->move( this_player() ) != MOVE_OK ) {
          legal->move( environment( this_player() ) );
          tell_object( this_player(), "You lose hold of some coins and "
             "they tumble to the floor.\n" );
          tell_room( environment( this_player() ), this_player()->one_short() + 
             "accidentally drops some coins.\n", this_player() );
       }
       if(illegal)
         if( illegal->move( this_player() ) != MOVE_OK ) {
            illegal->move( environment( this_player() ) );
            tell_object( this_player(), "You lose hold of some coins and "
               "they tumble to the floor.\n" );
            tell_room( environment( this_player() ), this_player()->one_short() + 
             "accidentally drops some coins.\n", this_player() );
         }
       add_failed_mess("That is too small an amount to deposit.\n");
       return 0;
     }
     
     tmp = ( amount * ( 100 - percentage ) ) / 100;
     total_made += tmp;
     amount = amount - tmp;
     set_account( total + amount );
     total_account += amount;
     do_save();
   }

   // Give them back their illegal money and zap the other stuff.
   if (illegal) {
      if( illegal->move( this_player() ) != MOVE_OK ) {
         illegal->move( environment( this_player() ) );
         tell_object( this_player(), "You lose hold of some coins and "
            "they tumble to the floor.\n" );
         tell_room( environment( this_player() ), this_player()->one_short() + 
            "accidentally drops some coins.\n", this_player() );
       }
   }

   if (legal) {
      howmuch = legal->the_short();
      legal->move( "/room/rubbish" );
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }

   write( "You give the teller "+ howmuch +".\n" );
   write( "After expenses, this leaves "+ (string)MONEY_HAND->
          money_value_string( amount, place ) +".\n" );

   this_player()->add_succeeded_mess(this_object(),
       ({  "$N $V "+words+".\n"
           "This gives a total of " +
           MONEY_HAND->money_value_string(total + amount, place ) +
           " in your account.\n",
           "$N deposit$s some money into $p account.\n" }), ({ }) );

   return 1;
} /* do_deposit() */

int do_open() {
  int amount;
  object money;

  if ( get_account() >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( account_cost ) {
    if ( !( money = present( MONEY_ALIAS, this_player() ) ) ) {
      notify_fail( "You do not have any money.\n" );
      return 0;
    }
    amount = (int)money->query_value_in( place );
    if ( place != "default" )
      amount += (int)money->query_value_in( "default" );
    if ( amount < account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      account_cost, place ) +" to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  return 1;
} /* do_open() */

int check_open( string word ) {
  object money;

  word = lower_case( word );
  if (word [ 0 ] == /* "n" */ 110 ) {
    write( "Okay, not opening an account.\n" );
    return 1;
  }
  if ( word[ 0 ] != /* "y" */ 121 ) {
    write( "Do you want to open an account? Answer \"yes\" or \"no\".\n" );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  write( "You now have an account here.\n" );
  money = present( MONEY_ALIAS, this_player() );
  MONEY_HAND->pay_amount_from( account_cost, money, place );
  total_made += account_cost;
  do_save();
  this_player()->save();
  return 1;
} /* check_open() */

int do_close() {
  int total;
  object money;

  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }

  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, place ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
      total_made += total;
    }
    total_account -= total;
  } else
    write( "You close your account.\n" );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  set_account( -1 );
  do_save();
  this_player()->save();
  return 1;
} /* do_close() */

mixed *stats() {
  return ::stats() + ({
    ({ "account cost", account_cost }),
    ({ "percentage", percentage }),
    ({ "total accounts", total_account }),
    ({ "total made", total_made }),
    ({ "bank name", bank_name }),
    ({ "place", place }),
    ({ "save file", save_file }) });
} /* stats() */

int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = (int)HANDLER->query_account( player_name, bank_name ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      HANDLER->adjust_account( player_name, bank_name, -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  total_account -= total;
  amount = total / 3;
  total_made += 2 * amount;
  do_save();
  mon_array = (mixed *)MONEY_HAND->create_money_array( amount / number, place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
} /* make_bank_robbers() */
// --- END [/mnt/home2/grok/lib/std/shops/bank.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/commercial.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629871   Available: 13577225
Inodes: Total: 5242880    Free: 4960136
160 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629871   Available: 13577225
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The inheritable for commercial player housing.
 * @author Pinkfish
 * @started Sat Jun  2 19:29:07 PDT 2001
 */
inherit "/std/shops/inherit/commercial";
// --- END [/mnt/home2/grok/lib/std/shops/commercial.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/controllers/craft_shop_controller.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/controllers/craft_shop_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629871   Available: 13577225
Inodes: Total: 5242880    Free: 4960136
46435 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/controllers/craft_shop_controller.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629871   Available: 13577225
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is to handle a place where players can sell a number of neato
 * craft items they have made up.  It will be extended to deal with
 * books as well.
 * <p>
 * It keeps track of who sold each item and how much they will
 * receive when they pay for it.  Then tracks the royalties so
 * they can come back and collect them.
 * <p>
 * This will be run as a handler object so that npcs and rooms can
 * both run as this sort of shop.
 * <p>
 * NB: This object is not saved using save_object.  You need to set the
 * save and load functions for this system to work.
 * @author Pinkfish
 * @started Thu Feb  5 15:39:57 CST 1998
 */

#include <obj_parser.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <shops/craft_shop.h>

/**
 * This keeps track of the object information itself.
 * @element cost the cost of the object when it is sold
 * @element cap_owner the capitalised owner of the object
 * @element short the short describtions of the object
 * @element ob_num the number of the object
 */
class craft_object {
   int cost;
   string cap_owner;
   int ob_num;
   string category;
   string short;
}

/**
 * This class is the main sellable list.
 */
class craft_sellable {
   /**
    * The list of objects, it is indexed on the owners name.
    */
   mapping objects;
}

/**
 * This is the class with information about the category in it.
 */
class craft_category {
   int state;
   string description;
   string information;
   string* voted;
   int yes;
   int no;
   int abstain;
   int timeout;
}

#define SELL_OBJECT_NAME_PROP "sell name"
#define SELL_OBJECT_OWNER_PROP "sell owner"
#define SELL_OBJECT_CLASS_PROP "sell class"
#define SELL_OBJECT_ID_PROP "sell id"

/*
 * This will index on the name tag and will have an object, an array of owners
 * and
 * a number left count as the value in an array.  The object is
 * a dummy object to match on.  The real object will be created from
 * the save information.  
 */
private nosave mapping _sellables;
/*
 * This is the contained containingt the objects to sell.  We keep them in
 * a container so that we can do find_match matches.
 */
private nosave object _sell_list;
/* The royalties to be payed to each player. */
private nosave mapping _royalties;
/* The current id to use for the save files... */
private nosave int _current_save_num;
/* The categories we are using, the default is none. */
private nosave mapping _categories;
private nosave int _category_callout;
/* If not set then we add a name on by default if it doesn't exist. */
private nosave int _category_dont_use_name;


/* The functions to save and load the files... */
private nosave function _save_function;
private nosave function _load_function;
private nosave function _category_function;
private nosave int *_current_ids;
private nosave int _has_loaded;

void load_it();
void save_it();
private void update_sellable(string name);
class craft_object create_craft_object(object ob,
                                       string owner,
                                       int cost,
                                       string category);
void adjust_royalty(string player, int amt);
class craft_sellable create_craft_sellable();
void adjust_royalty(string player, int amt);
class craft_object query_class_of_shop_object(object ob);
object find_shop_object(class craft_object frog);
object *query_sell_list_obs();
string query_id_of_shop_object(object ob);
void remove_shop_id(string id);
private void setup_timeout_call();
object* query_items_with_shop_id(string id);

void create() {
   /* Create a nice container to put our sell list in. */
   _sell_list = clone_object("/std/container");
   _current_save_num = 1;
   _current_ids = ({ });
   _categories = ([ ]);
} /* create() */

/**
 * This method is called by the controled object onto here to control
 * if the owners name is added to shop objects.  If this is set to 1
 * then the owners name will  not be added by default.
 * @param flag the flag to set
 */
void set_dont_use_name(int flag) {
   _category_dont_use_name = flag;
} /* set_dont_use_name() */

/**
 * This method is used to determine the status of the flag which controls
 * adding the owners name to shop objects by default.
 * If this is set to 1
 * then the owners name will  not be added by default.
 * @return 1 if the object owners name is not used, 0 if it is
 */
int query_dont_use_name() {
   return _category_dont_use_name;
} /* query_dont_use_name() */

/**
 * This method creates a save file for the specified objects autoloading
 * capability.  If the number to write to is non-null then it will
 * write to that object.
 * @param ob the object to get an autoload number for
 * @param fixed_num the file number to write to
 * @return the auto load number
 * @see save_it()
 */
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   mixed tmp;

   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         // Make it error on the last one...
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = evaluate(_load_function,
                        CRAFT_SHOP_DATA_SAVE_FILE,
                        "" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   evaluate(_save_function,
            CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "" + fixed_num);
   return fixed_num;
} /* create_auto_load_file() */

/**
 * This method creates a real object from the save file number.
 * @param num the save file number
 * @return the nice shiny new object
 * @see create_auto_load_file()
 */
protected object create_real_auto_load_object(int num, object player) {
   mixed *auto_load;
   object *obs;

   auto_load = evaluate(_load_function,
                        CRAFT_SHOP_DATA_SAVE_FILE,
                        "" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0; // clone_object("/std/object");
} /* create_object_from_auto_load() */

/**
 * This method removes the auto load stuff after it is no longer needed.
 * @param num the file number to remove
 * @see create_object_from_auto_load()
 */
protected void remove_auto_load_file(int num) {
   evaluate(_save_function,
            CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
            0,
            "" + num);
} /* remove_auto_load_file() */

/**
 * This method adds a selable into the current sellable array.
 * @param name the name the object willb elisted under
 * @param owner the owner of the object being sold
 * @param ob the objects being sold
 * @see add_sell_list_object()
 * @see change_name_of_object()
 */
protected void add_to_sellables(string name,
                                string owner,
                                class craft_object *ob) {
   class craft_sellable craft_sell;

   if (_sellables[name]) {
      craft_sell = (class craft_sellable)_sellables[name];
   } else {
      craft_sell = create_craft_sellable();
      _sellables[name] = craft_sell;
   }

   /*
    * This seemingly weird way of handling the craft objects is so we have
    * an easily returnable handle to the class which we can pass to the
    * dummy shop objects.
    */
   if (!craft_sell->objects[owner]) {
      craft_sell->objects[owner] = ({ });
   }
   craft_sell->objects[owner] += ob;
   
   update_sellable(name);
} /* add_to_selllist() */

/**
 * This will allow us to add an object into the inventory of the
 * craft shop.  If the name already exists in the inventory we
 * just increment the number left by the number passed in here.
 * If the number left goes below 0 then the item is remove
 * from the inventory.
 * @param ob the object to add
 * @param name the tag to use for it
 * @param num the number to add
 * @param category the category to add the item to
 * @param dont_update_cost allows the same name to have multiple prices
 * @see remove_list_object()
 * @see add_sell_list_name()
 */
int add_list_object(object ob,
                    string name,
                    int cost,
                    string owner,
                    string category,
                    int dont_update_cost) {
   class craft_object craft_ob;
   string cap_owner;

   if (!objectp(ob) || !stringp(name) || !intp(cost)) {
      return 0;
   }

   cap_owner = owner;
   owner = lower_case(owner);
   add_to_sellables(name,
                    owner,
                    ({ create_craft_object(ob, cap_owner, cost, category) }));
   if (!dont_update_cost) {
      foreach (craft_ob in ((class craft_sellable)_sellables[name])->objects[owner]) {
         craft_ob->cost = cost;
         craft_ob->category = category;
      }
   }
   save_it();
   return 1;
} /* add_list_object() */

/**
 * This method removes a single object from the current object list.
 * @param name the name of object to remove
 * @param owner the owner of the object to remove
 * @param ob the craft object pointer itself we want removed
 * @see add_list_object()
 */
void remove_list_object(string name, string owner, class craft_object ob) {
   int i;
   object us;
   class craft_object *data;

   if (_sellables[name] &&
       ((class craft_sellable)_sellables[name])->objects[owner]) {
      data = ((class craft_sellable)_sellables[name])->objects[owner];
      for (i = 0; i < sizeof(data); i++) {
         if (data[i] == ob) {
            break;
         }
      }
      //i = member_array(ob, (class craft_object)_sellables[name]->objects[owner]);
      if (i < sizeof(data)) {
         ((class craft_sellable)_sellables[name])->objects[owner] -= ({ ob });
         if (!sizeof(((class craft_sellable)_sellables[name])->objects[owner])) {
            map_delete(((class craft_sellable)_sellables[name])->objects, owner);
            if (!sizeof(((class craft_sellable)_sellables[name])->objects)) {
               map_delete(_sellables, name);
               us = find_shop_object(ob);
               remove_shop_id(query_id_of_shop_object(us));
            }
         }
         save_it();
         remove_auto_load_file(ob->ob_num);
         us = find_shop_object(ob);
         us->dest_me();
      } else {
         printf("Unable to find the object to remove? %O, %O\n", name, owner);
      }
   }
} /* remove_list_object() */

/**
 * This method turns a craft_object class into an actual object.
 * @param craft the craft object to create
 * @return the newly formed craft object
 * @see create_all_real_objects()
 */
object create_real_object(object player, class craft_object craft) {
   return create_real_auto_load_object(craft->ob_num, player);
} /* create_real_object() */

/**
 * This method creates real objects for all the passed in dummy objects.
 * Remember to dest the objects after you are finished with them.
 * @param obs the dummy objects to find real ones of
 * @return the real object values
 * @see create_real_object()
 * @example
 * real_obs = create_real_objects(this_player(), obs);
 * foreach (ob in real_obs) {
 *    ret += ob->the_short + ":\n" + ob->long() + "\n";
 * }
 */
object *create_all_real_objects(object player, object *obs) {
   object *ret;
   object ob;
   class craft_object craft;
   object new_ob;

   ret = ({ });
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      new_ob = create_real_object(player, craft);
      if (!new_ob) {
         ret->move("/room/rubbish");
         return ({ });
      }
      ret += ({ new_ob });
   }
   return ret;
} /* create_all_real_objects() */

/**
 * This method creates a craft object from the input actual object.
 * @param ob the real input object
 * @param owner the owner of the object
 * @param cost the cost of the object
 * @param category the category of the object
 * @return a nice craft object
 */
class craft_object create_craft_object(object ob,
                                       string owner,
                                       int cost,
                                       string category) {
   class craft_object craft;
   int num;

   craft = new (class craft_object);
   num = create_auto_load_file(ob, 0);
   craft->ob_num = num;
   craft->cost = cost;
   craft->cap_owner = owner;
   craft->category = category;
   craft->short = ob->query_short();
   return craft;
} /* create_craft_object() */

/**
 * This method creates a sellable class.
 * @return a new sellable class
 */
class craft_sellable create_craft_sellable() {
   class craft_sellable craft;

   craft = new(class craft_sellable);
   craft->objects = ([ ]);
   return craft;
} /* create_craft_sellable() */

/**
 * This method returns the owner associated with the shop
 * object.
 * @param ob the shop object to query the owner of
 * @return the owner of the shop object
 */
string query_owner_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_OWNER_PROP);
} /* query_owner_of_shop_object() */

/**
 * This method returns the list name associated with the shop
 * object.
 * @param ob the shop object to query the list name of
 * @return the owner of the shop object
 */
string query_name_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_NAME_PROP);
} /* query_name_of_shop_object() */

/**
 * This method returns the id associated with the shop object.
 * This is the one letter id used for buying selling etc.
 * @param ob the shop object to query the id of
 * @return the id of the shop object
 */
string query_id_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_ID_PROP);
} /* query_id_of_shop_object() */

/**
 * This method sets the current id of the shop objects.
 * @param obs the objects to set the id for
 * @param id the new id for them all
 */
void set_id_of_shop_objects(object *obs, string id) {
   obs->add_property(SELL_OBJECT_ID_PROP, id);
   obs->add_alias(id);
} /* set_id_of_shop_objects() */

/**
 * This method returns the category of the speficied shop object.
 * @param ob the object to find the category of
 * @return the category of the object
 */
string query_category_of_shop_object(object ob) {
   class craft_object craft;

   craft = query_class_of_shop_object(ob);
   if (craft) {
      return craft->category;
   }
   return 0;
} /* query_category_of_shop_object() */

/**
 * This method returns the possible short descriptions of the shop objects.
 * @param ob the object to find the shorts of
 * @return the short descriptions
 */
string query_short_of_shop_object(object ob) {
   class craft_object craft;

   craft = query_class_of_shop_object(ob);
   if (craft) {
      if (sizeof(craft) == 5) {
         return craft->short;
      }
      return "womble";
   }
   return 0;
} /* query_shorts_of_shop_object() */

/**
 * This method updates the internal representation of the specified
 * craft object.  It replaces the saved auto load info with the new
 * stuff.
 * @param craft the craft object containing the info to replace
 * @param replacement_ob the new object
 */
void update_craft_object(object craft_ob, object replacement_ob) {
   class craft_object craft;

   craft = query_class_of_shop_object(craft_ob);
   if (craft) {
      create_auto_load_file(replacement_ob, craft->ob_num);
   }
} /* update_craft_object() */

/**
 * This method attempts to figure out what the next id would
 * be for the object.  It will allocate this id as well as returning.
 * @return the next id for the shop
 * @see remove_shop_id()
 * @see update_sellables()
 */
string query_next_shop_id() {
   int num;

   num = 0;
   while (member_array(num, _current_ids) != -1) {
      num++;
   }
   _current_ids += ({ num });
   return sprintf("%c%c", (num / 26) + 'a',
                          (num % 26) + 'a');
} /* query_next_shop_id() */

/**
 * This method removes an id when that book has been taken from the
 * shop.
 * @param id the id to remove
 * @see query_next_shop_id()
 */
void remove_shop_id(string id) {
   int real_id;

   real_id = (id[0] * 26) - 'a' + id[1] - 'a';
   _current_ids -= ({ real_id });
} /* remove_shop_id() */

/**
 * This method searches the current sell list to see if the object
 * passed corresponds to any of the existing things in our
 * sell list.
 * @param ob the object to check
 * @return the craft_object class pointed to by the object
 * @see add_object()
 * @see remove_object()
 * @see create_real_object()
 */
class craft_object query_class_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_CLASS_PROP);
} /* query_class_of_shop_object() */

/**
 * This method figured out what the real object is for the class.
 * @param frog the class to find the object for
 * @return the dummy object for the class
 */
object find_shop_object(class craft_object frog) {
   object ob;

   foreach (ob in query_sell_list_obs()) {
      if (query_class_of_shop_object(ob) == frog) {
         return ob;
      }
   }
   return 0;
} /* find_shop_object() */

/**
 * This method changes the value of the shop object.
 * @param ob the shop object
 * @param value the new value
 */
void change_value_of_shop_object(object ob, int value) {
   string owner;
   string name;
   class craft_object wombat;
   //object frog;
   //int old_cost;
   object* obs;

   obs = query_items_with_shop_id(query_id_of_shop_object(ob));

   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      wombat = query_class_of_shop_object(ob);
      wombat->cost = value;
      ob->set_value(value);
      //old_cost = wombat->cost;
      

/*
      foreach (wombat in ((class craft_sellable)_sellables[name])->objects[owner]) {
         if (wombat->cost == old_cost) {
            wombat->cost = value;
            frog = find_shop_object(wombat);
            frog->set_value(value);
         }
      }
 */
   }
   save_it();
} /* change_value_of_shop_object() */

/**
 * This method changes the name of the shop object.
 * @param ob the shop object to change
 * @param new_name the new name of the shop object
 * @param dont_update_cost allows the names to merge and not update costs
 * @return 1 on success, 0 on failure
 */
int change_name_of_shop_object(object ob, string new_name,
                               int dont_update_cost) {
   string owner;
   string name;
   object* obs;
   string* names;
   class craft_object wombat;
   int new_cost;
   class craft_object* fluff;
   int i;

   obs = query_items_with_shop_id(query_id_of_shop_object(ob));

   names = ({ });
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      wombat = query_class_of_shop_object(ob);

      if (!_sellables[name]) {
tell_creator("pinkfish", "The name %O does not exist.\n", name);
         return 0;
      }

      if (!wombat) {
tell_creator("pinkfish", "Unable to find the class.\n");
         return 0;
      }

      if (!dont_update_cost &&
          _sellables[new_name] &&
          (((class craft_sellable)_sellables[new_name])->objects[owner])) {
         new_cost = (((class craft_sellable)_sellables[new_name])->objects[owner])[0]->cost;
         wombat->cost = new_cost;
      }
      //
      // First, add this thingy to the new spot.
      //
      //add_to_sellables(new_name, owner, ({ ob }));
      if (!_sellables[new_name]) {
         _sellables[new_name] = create_craft_sellable();
      }
      if (!(((class craft_sellable)_sellables[new_name])->objects[owner])) {
         (((class craft_sellable)_sellables[new_name])->objects[owner]) = ({ });
      }
      (((class craft_sellable)_sellables[new_name])->objects[owner]) += ({ wombat });

      //
      // Next, remove it from where it came from.
      //
      fluff = ((class craft_sellable)_sellables[name])->objects[owner];
      for (i = 0; i < sizeof(fluff); i++) {
         if (fluff[i] == wombat) {
            fluff = fluff[0..i-1] + fluff[i+1..];
         }
      }
      if (sizeof(fluff)) {
         ((class craft_sellable)_sellables[name])->objects[owner] = fluff;
      } else {
         map_delete(((class craft_sellable)_sellables[name])->objects, owner);
      }
      if (!sizeof(((class craft_sellable)_sellables[name])->objects)) {
         map_delete(_sellables, name);
      }
      names |= ({ name });
   }

   if (sizeof(names)) {
      update_sellable(name);
      update_sellable(new_name);
      save_it();
      return 1;
   }
   return 0;
} /* change_name_of_shop_object() */

/**
 * This method changes the category of the shop object.
 * @param ob the shop object to change
 * @param new_category the new category of the shop object
 */
int change_category_of_shop_object(object ob, string new_category) {
   string owner;
   string name;
   class craft_object bing;
   object* obs;
   int do_save;

   obs = query_items_with_shop_id(query_id_of_shop_object(ob));
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      if (!_sellables[name] ||
          !((class craft_sellable)_sellables[name])->objects[owner]) {
         return 0;
      }
      foreach (bing in ((class craft_sellable)_sellables[name])->objects[owner]) {
         bing->category = new_category;
         do_save = 1;
      }
   }
   if (do_save) {
      save_it();
   }
   return 1;
} /* change_name_of_shop_object() */

/**
 * This method removes the real data behind the specified shop object.
 * The object passed in must be one of the dummy objects used for
 * listing the shops inventory.
 * @param ob the object to remove
 * @see sell_objects()
 * @see query_class_of_shop_object()
 */
void remove_shop_object(object ob) {
   string name;
   string owner;

   owner = query_owner_of_shop_object(ob);
   name = query_name_of_shop_object(ob);
   remove_list_object(name, owner, query_class_of_shop_object(ob));
} /* remove_shop_object() */

/**
 * This method finds the objects which matched the passed in pattern.
 * Note, this returns the dummy pointer objects not the actual
 * objects, they need to be changed into real objects before they
 * are really sold.
 * @param str the pattern to match the objects on
 * @return the matching objects
 * @see query_class_of_shop_object()
 * @see value_of_objects()
 * @see sell_objects()
 */
class obj_match find_matching_objects(string str) {
   class obj_match obs;

   obs = (class obj_match)match_objects_in_environments(str, ({ _sell_list }));
   return obs;
} /* find_matching_objects() */

/**
 * This method determines the price of all the shop objects in the
 * array.
 * @return the price of the shop objects
 * @param obs the objects to price
 * @see find_matching_objects()
 * @see query_class_of_shop_object()
 * @see sell_objects()
 */
int value_of_objects(object *obs) {
   object ob;
   class craft_object craft;
   int value;

   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      if (craft) {
         value += craft->cost;
      }
   }
   return value;
} /* value_of_shop_objects() */

/**
 * This method sells the specified shop objects to the player.  This
 * will make the payments to the player.  The objects will all attempt
 * to be moved into the player.  The cut must be between 0 and 100.
 * <p>
 * The royalties from selling the object will be placed into the
 * correct place by the function, so they can be picked up at a 
 * later date.  The 'cut' will be taken out of the sale.
 * @param obs the objects to sell
 * @param place the place to sell the objects in
 * @param player the player to sell the objects too
 * @param cut the cut the manager takes from the sale (percentage)
 * @return the array of sold objects
 * @see value_of_objects()
 * @see find_matching_objects()
 * @see adjust_royalty()
 */
object *sell_objects(object *obs, string place, object player, int cut) {
   object ob;
   object this_ob;
   object *sold;
   class craft_object craft;

   sold = ({ });
   if (cut < 0) {
      cut = 0;
   }
   if (cut > 100) {
      cut = 100;
   }
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      if (craft) {
         if (player->query_value_in(place) >= craft->cost) {
            // Create the object.
            this_ob = create_real_object(player, craft);
            if (this_ob && this_ob->move(player) == MOVE_OK) {
               sold += ({ this_ob });
               // Make the player pay for it.
               player->pay_money(
                       MONEY_HAND->create_money_array(craft->cost, place),
                       place);
               // Adjust the players current royalties.
               adjust_royalty(query_owner_of_shop_object(ob),
                              craft->cost - (craft->cost * cut) / 100);
               // Remove the object from our inventory.
               remove_shop_object(ob);
            }
         }
      }
   }
   return sold;
} /* sell_objects() */


/**
 * This method deletes the specified list entry.  The player
 * owner will not be payed.
 * @param id The list entry to delete
 */
void delete_objects( string id ) {
   object ob, *obs;

   obs = all_inventory( _sell_list );

   obs = filter( obs,
         (: $1->query_property( SELL_OBJECT_ID_PROP ) == $(id) :) );
   
   foreach( ob in obs ) {
      remove_shop_object( ob );
   }
   
} /* delete_objects() */

/**
 * This method will buy the specified objects and place them into our
 * current potential sell list.  This will destroy the objects after
 * it has been added into the sell list correctly.
 * @param obs the object to sell
 * @param name the name of the object to sell
 * @param cost the cost of the object being sold
 * @param owner the person to who the object belongs
 * @param category the category of the object
 * @param dont_update_costs allows the system to handle objects with the same
 * name and different costs
 * @see sell_objects()
 */
object *buy_objects(object *obs,
                    string name,
                    int cost,
                    string owner,
                    string category,
                    int dont_update_costs) {
   object ob;
   object *bought;

   bought = ({ });
   foreach (ob in obs) {
      if (add_list_object(ob, name, cost, owner, category, dont_update_costs)) {
         ob->move("/room/rubbish");
         bought += ({ ob });
      }
   }
   return bought;
} /* buy_objects() */

/**
 * This method creates a dummy object for use when selling items.  This
 * allows use to use alias names for the potions when buying/selling
 * and not the real name of the container.  When bought these names
 * will be added to the thingy as aliases.
 * @param owner the owner of the object
 * @param name the sell list name of the object
 * @return a dummy object to place into the sell list
 */
protected object create_dummy_object(string owner, string name, int cost,
                                     class craft_object craft) {
   object new_name;
   string *bits;

   new_name = clone_object("/std/object");
   new_name->reset_get();
   bits = explode(lower_case(name), " ");
   
   if (!sizeof (bits)) {
    new_name->set_name("error");
   }
   else {
    new_name->set_name(bits[<1]);
    new_name->add_adjective(bits[0..<2]);
   }
  
   if (member_array(lower_case(owner), bits) == -1) {
      new_name->add_adjective(owner);
   }
   if (!_category_dont_use_name &&
       member_array(lower_case(owner) + "'s", bits) == -1) {
      new_name->add_adjective(lower_case(owner) + "'s");
      new_name->set_short(craft->cap_owner + "'s " + name);
   } else {
      new_name->set_short(capitalize(name));
   }
   new_name->add_property(SELL_OBJECT_NAME_PROP, name);
   new_name->add_property(SELL_OBJECT_OWNER_PROP, owner);
   new_name->add_property(SELL_OBJECT_CLASS_PROP, craft);
   new_name->add_property("determinate", "");
   new_name->set_value(cost);
   return new_name;
} /* create_dummy_object() */

/**
 * This method adds an object into the current sell list.
 * @param ob the object to add
 */
private void add_sell_object(object ob) {
   if (ob->move(_sell_list) != MOVE_OK) {
      printf("Unable to move %O into the sell list (%O).\n", ob, _sell_list);
   }
} /* add_sell_object() */

/**
 * This method returns all the current objects in the sell list.
 * @return all the current objects in the sell list
 */
object *query_sell_list_obs() {
   return all_inventory(_sell_list);
} /* query_sell_list_obs() */

/**
 * This method returns the container associated with the sell list.
 * @return the container for the sell list
 */
object query_sell_list() {
   return _sell_list;
} /* query_sell_list() */

/**
 * This method returns all the objects which match the specified
 * id of the shop object.
 * @param id the shop id to match on
 * @return the objects which match it
 */
object* query_items_with_shop_id(string id) {
   return filter(query_sell_list_obs(), (: query_id_of_shop_object($1) == $2 :),
                 id);
} /* query_items_with_shop_id() */

/**
 * This method updates the specified named set of sellables.  This
 * removes and creates the nessessary dummy objects needed to
 * handle the selling code.  It will also set the ids for objects
 * which need them, creating a new id if nessessary.
 * @param name the name of the sellables list to update
 * @see query_sell_list_obs()
 */
private void update_sellable(string name) {
   string owner;
   class craft_sellable bing;
   mixed *data;
   class craft_object womble;
   class craft_object craft;
   object shop_ob;
   string id;
   mixed *need_ids;
   int cost;
   mapping costs;
   int pos;

   if (_sellables[name]) {
      bing = _sellables[name];
      costs = ([ ]);
      foreach (owner, data in bing->objects) {
         id = 0;
         data = filter(data, (: $1 :));
         bing->objects[owner] = data;
         pos = 0;
         foreach (womble in data) {
            if (sizeof(womble) == 4) {
               craft = new(class craft_object);
               craft->ob_num = womble->ob_num;
               craft->cost = womble->cost;
               craft->cap_owner = womble->cap_owner;
               craft->category = womble->category;
               craft->short = "womble";
               data[pos] = craft;
            }
            pos++;

            shop_ob = find_shop_object(womble);
            if (!shop_ob ||
                query_name_of_shop_object(shop_ob) != name) {
               if (shop_ob) {
                  shop_ob->move("/room/rubbish");
               }
               add_sell_object(create_dummy_object(owner, name,
                                                   womble->cost, womble));
            }
            shop_ob = find_shop_object(womble);
            if (!costs[womble->cost]) {
               costs[womble->cost] = ({ 0, ({ }) });
            }
            if (!costs[womble->cost][0]) {
               id = query_id_of_shop_object(shop_ob);
               if (id) {
                  costs[womble->cost][0] = id;
               }
            }
            if (!costs[womble->cost][0] ||
                query_id_of_shop_object(shop_ob) != costs[womble->cost][0]) {
               costs[womble->cost][1] += ({ shop_ob });
            }
         }
         if (!_category_dont_use_name) {
            foreach (cost, need_ids in costs) {
               if (!need_ids[0]) {
                  need_ids[0] = query_next_shop_id();
               }
               set_id_of_shop_objects(need_ids[1], need_ids[0]);
            }
         }
      }

      if (_category_dont_use_name) {
         foreach (cost, need_ids in costs) {
            if (!need_ids[0]) {
               need_ids[0] = query_next_shop_id();
            }
            set_id_of_shop_objects(need_ids[1], need_ids[0]);
         }
      }
   }
} /* update_sellables() */

/**
 * This method returns the list of sellables that the owner currently
 * has in the shop.  This will potentially return more than one of the
 * same name if the owner has more than one of the same sort of object
 * being sold.
 * @param owner the owner to check
 * @return the array of all the possible sellables
 * @see query_list_object_cost()
 */
string *query_owner_sellables(string owner) {
   class craft_sellable sell;
   mixed *womble;
   string *ret;
   string name;

   ret = ({ });
   foreach (name, sell in _sellables) {
      if (sell->objects[owner]) {
         womble = sell->objects[owner];
         ret += allocate(sizeof(womble), (: $(name) :) );
      }
   }
   return ret;
} /* query_owner_sellables() */

/**
 * This method returns the cost of the specified type of object.
 * @param name the name of the object
 * @param owner the owner of the object
 * @return the cost of the object, 0 if it is not known
 * @see query_owner_sellables()
 */
int query_list_object_cost(string name, string owner) {
   class craft_sellable sell;
   class craft_object wombat;

   owner = lower_case(owner);
   if (_sellables[name]) {
      sell = _sellables[name];
      if (sell->objects[owner]) {
         wombat = sell->objects[owner][0];
         return wombat->cost;
      }
   }
   return 0;
} /* query_list_object_cost() */

/**
 * This method sets the save function on the class.  The save function will
 * be called with two parameters, one is the file name to be saved and
 * the other is the text to be saved to it.
 * @param func the new save function
 */
void set_save_function(function func) {
   _save_function = func;
} /* set_save_function() */

/**
 * This method sets the load function on the class.  The restore function
 * will be called with one parameter and is expected to return a string.
 * The parameter is the file name to load.
 * @param func the new load function
 */
void set_load_function(function func) {
   _load_function = func;
} /* set_load_function() */

/**
 * This method is called when categories complete each of their phases to
 * see if the idea was passed by enough majority or whatever to go onto
 * the next one.
 * @param func the new category function
 */
void set_category_function(function func) {
   _category_function = func;
} /* set_category_function() */

/**
 * This method saves the current state of the system.
 * @see set_save_function()
 * @see load_it()
 */
void save_it() {
   if (_has_loaded) {
      evaluate(_save_function, CRAFT_SHOP_MAIN_SAVE_FILE,
            ({ _sellables, _royalties, _current_save_num, _categories }) );
   }
} /* save_it() */

/**
 * This method loads the current state of the system.
 * @see set_load_function()
 */
void load_it() {
   mixed *map;
   string name;

   _has_loaded = 1;
   map = evaluate(_load_function, CRAFT_SHOP_MAIN_SAVE_FILE);
   if (pointerp(map) && sizeof(map) == 3) {
      _sellables = map[0];
      _royalties = map[1];
      _current_save_num = map[2];
      foreach (name in keys(_sellables)) {
         reset_eval_cost();
         update_sellable(name);
      }
   } else if (pointerp(map) && sizeof(map) == 4) {
      _sellables = map[0];
      _royalties = map[1];
      _current_save_num = map[2];
      _categories = map[3];
      // This does need to be run even if there are no categories.  What has
      // no categories anyway?
      foreach (name in keys(_sellables)) {
         reset_eval_cost();
         update_sellable(name);
      }
   } else {
      _sellables = ([ ]);
      _royalties = ([ ]);
   }
   setup_timeout_call();
} /* load_it() */

/**
 * This method adjusts the current royalties for the player.
 * @param player the name of the player to pay the royalties to
 * @param amt the amount to adjust the value by
 * @see query_royalties()
 * @see pay_out_royalties()
 */
void adjust_royalty(string player, int amt) {
   _royalties[player] += amt;
   save_it();
} /* adjust_royalities() */

/**
 * This method returns the current royalties for the specified person.
 * @param player the player to get the royalties for
 * @return the current royalties
 * @see adjust_royalties()
 * @see pay_out_royalties()
 */
int query_royalty(string player) {
  return _royalties[player];
} /* query_royalties() */

/**
 * This method returns the royalty mapping on the object.  This is only
 * use for debug information.
 * @return the royalties mapping
 */
mapping query_all_royalties() {
   return copy(_royalties);
} /* query_all_royalties() */

/**
 * This method pays out the royalties owed to the specified player.
 * @param player the player to pay out
 * @param place the place in which the royalties are to occur
 * @param amount the amount to pay out, 0 for everything
 * @see query_royalties()
 * @see adjust_royalties()
 */
void pay_out_royalty(string player, string place, int amount) {
   object pl;
 
   pl = find_player(player);
   if (pl && _royalties[player]) {
      if (!amount) {
         amount = _royalties[player];
      }
      pl->adjust_money(MONEY_HAND->create_money_array(amount, place));
      _royalties[player] -= amount;
      if (!_royalties[player]) {
         map_delete(_royalties, player);
      }
      save_it();
   }
} /* pay_out_royalties() */

//
//  All the category handling code goes after this point.
//

/**
 * This method checks to make sure that the category is valid.  This
 * means a category that has been properly accepted.
 * @param category the category to check
 */
int is_valid_category(string category) {
   if (_categories[category] &&
       (_categories[category]->state == CRAFT_CATEGORY_STATE_ACCEPTED ||
        _categories[category]->state == CRAFT_CATEGORY_STATE_DELETEING)) {
      return 1;
   }
   return 0;
} /* is_valid_category() */

/**
 * Add a request for a new category.
 * @param name the name of the category
 * @param player the person who suggested it
 * @param timeout the initial timeout for the nomination period
 * @return 1 if successful added, 0 if not
 */
int add_category_request(string name,
                         object player,
                         int timeout) {
   if (!_categories[name]) {
      _categories[name] = new(class craft_category);
      _categories[name]->state = CRAFT_CATEGORY_STATE_NOMINATING;
      _categories[name]->voted = ({ player->query_name() });
      _categories[name]->description = 0;
      _categories[name]->yes = 0;
      _categories[name]->no = 0;
      _categories[name]->timeout = time() + timeout;
      save_it();
      return 1;
   }
   return 0;
} /* add_category_request() */

/**
 * This method removes a category immediately.
 * @param name the name of the category
 */
int remove_category_accepted(string category) {
   if (_categories[category]) {
      map_delete(_categories, category);
      save_it();
      return 1;
   }
   return 0;
} /* remove_category_accepted() */

/**
 * This method adds a category and sets it as already being accepted.
 * @param name the name of the category to add
 */
int add_category_accepted(string name) {
   if (!_categories[name]) {
      _categories[name] = new(class craft_category);
      _categories[name]->state = CRAFT_CATEGORY_STATE_ACCEPTED;
      _categories[name]->voted = ({ });
      _categories[name]->description = 0;
      _categories[name]->yes = 0;
      _categories[name]->no = 0;
      _categories[name]->timeout = 0;
      save_it();
      return 1;
   }
   return 0;
} /* add_category_accepted() */

/**
 * This method sets the description of the category.
 * @param cat the category to set the description of
 * @param desc the description of the category
 */
void set_category_description(string cat, string desc) {
   if (_categories[cat]) {
      _categories[cat]->description = desc;
      save_it();
   }
} /* set_category_description() */

/**
 * This method returns the category description.
 * @param cat the cateogryt to find the description for
 * @return 0 for no description, the main description otherwise
 */
string query_category_description(string cat) {
   if (_categories[cat]) {
      if (stringp(_categories[cat]->description)) {
         return _categories[cat]->description;
      }
   }
   return 0;
} /* query_category_description() */

/**
 * This method sets the information of the category.
 * @param cat the category to set the information of
 * @param info the information of the category
 */
void set_category_information(string cat, string info) {
   if (_categories[cat]) {
      _categories[cat]->information = info;
      save_it();
   }
} /* set_category_information() */

/**
 * This method returns the category information.
 * @param cat the cateogryt to find the information for
 * @return 0 for no information, the main information otherwise
 */
string query_category_information(string cat) {
   if (_categories[cat]) {
      if (stringp(_categories[cat]->information)) {
         return _categories[cat]->information;
      }
   }
} /* query_category_information() */

/**
 * This method returns the category associated with this name/category
 * set.
 */
string query_category_of(string name, string owner) {
   if (_sellables[name] &&
       sizeof( ((class craft_sellable)_sellables[name])->objects[owner])) {
      return ((class craft_sellable)_sellables[name])->objects[owner][0]->category;
   }
   return 0;
} /* query_category_of() */

/**
 * This method checks to see if the player has voted (or nominated) for a
 * specified category already.
 * @param name the name of the category
 * @param player the player being checked
 * @return 1 if they have voted/nominated 0 if they have not
 */
int has_voted_for_category(string name,
                           object player) {
   return _categories[name] &&
       member_array(player->query_name(), _categories[name]->voted) != -1;
} /* has_player_voted() */

/**
 * This method returns the time the current category has left before it
 * times out.
 * @param name the name of the cateogyr
 * @return the time it timesout
 */
int query_category_timeout(string name) {
   if (_categories[name]) {
      return _categories[name]->timeout;
   }
   return CRAFT_CATEGORY_ERROR;
} /* query_category_timeout() */

/**
 * This method allows the player to vote for the specified category.
 * @param name the name of the category
 * @param player the player voting
 * @param choice their choice
 * @return 1 if the vote was successful, 0 if not
 */
int vote_for_category(string name,
                      object player,
                      int choice) {
   if (_categories[name]) {
      if (!has_voted_for_category(name, player)) {
         if (choice == CRAFT_CATEGORY_CHOICE_YES ||
             choice == CRAFT_CATEGORY_CHOICE_NO ||
             choice == CRAFT_CATEGORY_CHOICE_ABSTAIN) {
            switch (choice) {
            case CRAFT_CATEGORY_CHOICE_YES :
               _categories[name]->yes++;
               break;
            case CRAFT_CATEGORY_CHOICE_NO :
               _categories[name]->no++;
               break;
            case CRAFT_CATEGORY_CHOICE_ABSTAIN :
               _categories[name]->abstain++;
               break;
            }
            _categories[name]->voted += ({ player->query_name() });
            save_it();
         }
      }
   }
   return 0;
} /* vote_for_category() */

/**
 * This method returns the list of categories for the current shop.
 * @return the list of categories
 */
string* query_categories() {
   return filter(keys(_categories), (: is_valid_category($1) :));
} /* query_categories() */

/**
 * This method is used to go through the categories and see which ones
 * need to timeout.
 */
private void do_timeout_categories() {
   string name;
   class craft_category cat;
   int timeout;

   foreach (name, cat in _categories) {
      if (cat->state != CRAFT_CATEGORY_STATE_ACCEPTED &&
          cat->timeout &&
          cat->timeout < time()) {
         //
         // Timed out!
         //
         timeout = evaluate(_category_function,
                            cat->state,
                            cat->voted,
                            cat->yes,
                            cat->no,
                            cat->abstain);
         if (timeout) {
            //
            // Ok, do something groovy based on the state.
            //
            cat->voted = ({ });
            cat->yes = 0;
            cat->no = 0;
            switch (cat->state) {
            case CRAFT_CATEGORY_STATE_NOMINATING :
               cat->state = CRAFT_CATEGORY_STATE_VOTING;
               cat->timeout = time() + timeout;
               break;
            case CRAFT_CATEGORY_STATE_VOTING :
               cat->state = CRAFT_CATEGORY_STATE_ACCEPTED;
               cat->timeout = 0;
               break;
            case CRAFT_CATEGORY_STATE_DELETEING :
               map_delete(_categories, name);
               break;
            }
         } else {
            switch (cat->state) {
            case CRAFT_CATEGORY_STATE_VOTING :
            case CRAFT_CATEGORY_STATE_NOMINATING :
               map_delete(_categories, name);
               break;
            case CRAFT_CATEGORY_STATE_DELETEING :
               cat->state = CRAFT_CATEGORY_STATE_ACCEPTED;
               cat->timeout = 0;
               cat->voted = ({ });
               cat->yes = 0;
               cat->no = 0;
               break;
            }
         }
      }
   }
   save_it();
   setup_timeout_call();
} /* do_timeout_categories() */

/**
 * This method sets up a timeout call based on the next thing to timeout.
 */
private void setup_timeout_call() {
   string name;
   class craft_category cat;
   int bing;

   foreach (name, cat in _categories) {
      if (cat->state != CRAFT_CATEGORY_STATE_ACCEPTED &&
          cat->timeout != 0 &&
          cat->timeout < bing) {
         bing = cat->timeout;
      }
   }
   if (_category_callout) {
      remove_call_out(_category_callout);
   }
   if (bing) {
      _category_callout = call_out((: do_timeout_categories() :), bing);
   }
} /* setup_timeout_call() */

/** @ignore yes */
void dest_me() {
  if(_sell_list) {
    all_inventory(_sell_list)->move("/room/rubbish");
    _sell_list->dest_me();
  }
  destruct(this_object());
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/controllers/craft_shop_controller.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/person_expressions.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/person_expressions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629859   Available: 13577213
Inodes: Total: 5242880    Free: 4960136
3111 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/person_expressions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629859   Available: 13577213
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a set of functions to be used for people controlling things
 * in rooms and shops.
 * @author Pinkfish
 * @started Fri Jun  1 21:29:18 PDT 2001
 */
#include <expressions.h>
#include <player_handler.h>
#include <clubs.h>
#include <nomic_system.h>

void add_allowed_function(string name, int type, int* args, function value);
void add_allowed_variable(string name, int type, function value);


private int variable_player_level(string seller) {
   return PLAYER_HANDLER->test_level(seller);
} /* variable_player_level() */

private string variable_player_guild(string seller) {
   string guild;

   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      return guild->query_name();
   }
   return "";
} /* variable_player_guild() */

private string variable_player_order(string seller) {
   string guild;

   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      guild = guild->query_wizard_order();
      if (guild) {
         return replace_string(lower_case(guild), "_", " ");
      }
   }
   return "";
} /* variable_player_order() */

private string variable_player_name(string seller) {
   return lower_case(seller);
} /* variable_player_order() */

private string variable_player_deity(string seller) {
   string deity;

   deity = PLAYER_HANDLER->test_deity(seller);
   if (deity) {
      return deity;
   }
   return "";
} /* variable_player_deity() */

private string variable_player_family(string seller) {
   string family;

   family = PLAYER_HANDLER->test_family(seller);
   if (family) {
      return family;
   }
   return "";
} /* variable_player_family() */

private int function_club_member(string club, string seller) {
   return CLUB_HANDLER->is_member_of(club, seller);
} /* function_club_member() */

private int function_citizen_of(string region, string seller) {
   return NOMIC_HANDLER->is_citizen_of(region, seller);
} /* function_citizen_of() */

/**
 * This method adds all the functions and variables.
 */
void create() {
   if (!function_exists("add_allowed_variable", this_object())) {
      return ;
   }
   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_player_level :) );
   add_allowed_variable("guild", EXPRESSION_TYPE_STRING,
                        (: variable_player_guild :) );
   add_allowed_variable("deity", EXPRESSION_TYPE_STRING,
                        (: variable_player_deity :) );
   add_allowed_variable("family", EXPRESSION_TYPE_STRING,
                        (: variable_player_family :) );
   add_allowed_variable("order", EXPRESSION_TYPE_STRING,
                        (: variable_player_order :) );
   add_allowed_variable("playername", EXPRESSION_TYPE_STRING,
                        (: variable_player_name :) );
   add_allowed_function("clubmember", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
   add_allowed_function("citizenof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
} /* create() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/person_expressions.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629859   Available: 13577213
Inodes: Total: 5242880    Free: 4960136
165425 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629859   Available: 13577213
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the file containing extra controls for the player run
 * craft shop.  We will assume that all player run craft shops will be
 * rooms and not npcs.
 * @author Pinkfish
 * @started Fri Apr 21 13:37:44 PDT 2000
 */
inherit "/std/basic/expressions";
inherit "/std/shops/inherit/craft_shop_category";
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <shops/craft_shop.h>
#include <player_handler.h>
#include <clubs.h>
#define EXPRESSION_NO_CLASSES
#include <expressions.h>
#include <mail.h>
#include <nroff.h>


//#define PRESTO_DEBUG

#define CHARGE_MULT 10 /* This is out of /obj/weapons/maces/cleric_rod.c */
#define PLAYER_CRAFT_SHOP_CHECK_PROP "player craft shop check"

#define PLAYER_CRAFT_SHOP_SELL      1
#define PLAYER_CRAFT_SHOP_SELL_AUTO 2
#define PLAYER_CRAFT_SHOP_BUY       3
#define PLAYER_CRAFT_SHOP_APPROVE   4

#define PLAYER_CRAFT_SHOP_EXPR_DENY   1
#define PLAYER_CRAFT_SHOP_EXPR_ACCEPT 2

class approval_item  {
   mixed value;
   string list_name;
   int markup;
   int final_cost;
}

class expression_type {
   int type;
   class parse_node* condition;
   class parse_node* value;
   string list_name;
}

class approval {
   mixed hairy;
   class expression_type* expressions;
   int low_cost;
   int high_cost;
   mapping items;
   int num_allowed;
   int high_cost_deny;
}

class approval_obs {
   string seller;
   string category;
   int value;
   string name;
   int* saved;
   int enter_time;
   int* checkout;
}

#if USE_TRANSACTIONS
class shop_transaction {
   int time;
   string person;
   string objects;
   string name_cat;
   int type;
   int amount;
   mixed extra;
}
#endif

class shop_stats {
   int num_sold;
   int value_sold;
}

class seller_information {
   int max_sellable;
   int value_limit;
   int deny_value_limit;
}

private class approval_obs* _waiting_for_approval;
private class approval_obs* _approved;
private class approval _automatic_approval;
// This is the list of allowable list names.
private string* _list_names;
private int _automatic_percentage;
private int _royalty_percentage;
private int _current_save_num;
private int _total_outgoing;
private int _total_ingoing;
private string _shop_name;
private class parse_node *_tax_expression;
#if USE_TRANSACTIONS
private class shop_transaction* _transactions;
#endif
private mapping _sell_stats;
private int _stats_start;
private mapping _sellers;
private string *_black_list;
private class parse_node* _buy_expression;
private class parse_node* _use_expression;
private string _auto_load_sign_str;
private int _broken_sign;
private mapping _num_checked_so_far;

private nosave string _parcel_post;
private nosave int _something_checkedout;
private nosave int _maximum_inventory;
private nosave object _sign_ob;
private nosave int _round_value;
private nosave int _max_list_names;
private nosave int _max_items_in_queue;
private nosave object _royalty_ob;

protected void confirm_approval(string answer, class approval_obs approve, int final_cost);
private mixed* parse_or(string str);
private int variable_player_level(string seller, int cost, object* ob);
private string variable_player_guild(string seller, int cost, object* ob);
private string variable_player_deity(string seller, int cost, object* ob);
private string variable_player_family(string seller, int cost, object* ob);
private string variable_player_order(string seller, int cost, object* ob);
private object* variable_objects(string seller, int cost, object* ob);
private string function_object_type(object*, string seller, int cost, object* ob);
private int function_object_value(object*, string seller, int cost, object* ob);
private int function_object_base_value(object*, string seller, int cost, object* ob);
private int function_object_condition(object*, string seller, int cost, object* ob);
private int function_object_enchant(object*, string seller, int cost, object* ob);
private object* function_object_stolen(object*, string seller, int cost, object* ob);
private object* function_object_warded(object*, string seller, int cost, object* ob);
private int function_object_charges(object*, string seller, int cost, object *ob);
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category);
private string variable_sale_name(string seller, int cost, object* ob, string name, string category);
private string variable_sale_category(string seller, int cost, object* ob, string name, string category);
private int function_club_member(string club, string seller, int cost, object* ob);
private object* function_object_contains_spell(object*, string spell, string seller, int cost, object* ob);
private object* function_object_contains_imbue(object*, string spell, string seller, int cost, object* ob);
private int function_object_percentage_liquid(object*, string liquid, string seller, int cost, object* ob);
private object* function_object_matching(object*, string match, string seller, int cost, object* ob);
private object* function_object_short(object* obs, string match, string seller, int cost, object* fluff);
private int function_inventory_number(string short, string seller, int cost, object* ob);
private object* function_contents(object ob, string seller, int cost, object* obs);


/*
 * This methods must be defined in an upper level class.
 */
string query_owner();
int is_allowed(string person);
void do_save();
void event_save(object thing);
string *query_allowed();
void set_short(string short);
void add_property(string name, mixed value);

void create() {
   class parse_node* expr;

   _round_value = 1;
   if (!_waiting_for_approval) {
      _waiting_for_approval = ({ });
   }
   if (!_approved) {
      _approved = ({ });
   }
   if (!_list_names) {
      _list_names = ({ });
   }
   if (!_automatic_approval) {
      _automatic_approval = new(class approval);
      //_automatic_approval->sellers = ({ });
      //_automatic_approval->categories = ([ ]);
      _automatic_approval->expressions = ({ });
      _automatic_approval->items = ([ ]);
   }
   if (!_automatic_percentage) {
      _automatic_percentage = 10;
   }
#if USE_TRANSACTIONS
   if (!_transactions) {
      _transactions = ({ });
   }
#endif
   if (!_sell_stats) {
      _sell_stats = ([ ]);
   }
   if (!_stats_start) {
      _stats_start = time();
   }
   if (!_sellers) {
      _sellers = ([ ]);
   }
   if (!_black_list) {
      _black_list = ({ });
   }
   if (!_num_checked_so_far) {
      _num_checked_so_far = ([ ]);
   }
   if (!_tax_expression)  {
      _tax_expression = ({ });
   }
   //
   // Set it up so that selling it the normal way gets no money.
   //
   set_cut(100);
   _max_items_in_queue = 100;
   craft_shop_category::create();
   expressions::create();
   if (_shop_name) {
      set_short(_shop_name);
      add_property("determinate", "");
   }
   set_always_ask_price(1);
   if (!_buy_expression) {
      expr = parse_boolean_string("false");
      _buy_expression = expr;
   }
   if (!_use_expression) {
      expr = parse_boolean_string("false");
      _use_expression = expr;
   }

   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_player_level :) );
   add_allowed_variable("guild", EXPRESSION_TYPE_STRING,
                        (: variable_player_guild :) );
   add_allowed_variable("deity", EXPRESSION_TYPE_STRING,
                        (: variable_player_deity :) );
   add_allowed_variable("family", EXPRESSION_TYPE_STRING,
                        (: variable_player_family :) );
   add_allowed_variable("order", EXPRESSION_TYPE_STRING,
                        (: variable_player_order :) );
   add_allowed_variable("objects", EXPRESSION_TYPE_OBJECT +
                                   EXPRESSION_TYPE_ARRAY_OFFSET,
                        (: variable_objects :) );
   add_allowed_function("objectenchant", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_enchant :) );
   add_allowed_function("objectvalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_value :) );
   add_allowed_function("objectbasevalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_base_value :) );
   add_allowed_function("objectcondition", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_condition :) );
   add_allowed_function("objecttype", EXPRESSION_TYPE_STRING,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_type :) );
   add_allowed_function("objectwarded", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_warded :) );
   add_allowed_function("objectstolen", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_stolen :) );
   add_allowed_variable("salecost", EXPRESSION_TYPE_MONEY,
                        (: variable_sale_cost :) );
   add_allowed_variable("salename", EXPRESSION_TYPE_STRING,
                        (: variable_sale_name :) );
   add_allowed_variable("salencategory", EXPRESSION_TYPE_STRING,
                        (: variable_sale_category :) );
   add_allowed_function("charges", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_charges :) );
   add_allowed_function("clubmember", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
   add_allowed_function("containsspell", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_spell :) );
   add_allowed_function("containsimbue", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_imbue :) );
   add_allowed_function("percentageliquid", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_percentage_liquid :) );
   add_allowed_function("objectmatch", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_matching :) );
   add_allowed_function("objectshort", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING,
                           EXPRESSION_TYPE_BOOLEAN }),
                        (: function_object_short :) );
   add_allowed_function("inventorynumber", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_STRING, }),
                        (: function_inventory_number :) );
   add_allowed_function("contents", EXPRESSION_TYPE_OBJECT +
                                    EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT }),
                        (: function_contents :) );
} /* create() */

/**
 * This method strips off enclosing quotation marks, if any
 */
private string strip_quotes(string str)  {
   if (str)  {
      if (str[0] == '\"')  str = str[1 .. ];
      if (str[<1] == '\"')  str = str[0 .. <2];
   }
   return str;
}


/**
 * This method sets the maximum inventory size for the shop.
 * @param size the maximum inventory size
 */
void set_maximum_waiting_queue_size(int size) {
   _max_items_in_queue = size;
} /* set_maximum_waiting_queue_size() */

/**
 * This method returns the maximum inventory size for the shop.
 * @return the maximum inventory size
 */
int query_maximum_waiting_queue_size() {
   return _max_items_in_queue;
} /* query_maximum_waiting_queue_size() */

/**
 * This method sets the maximum inventory size for the shop.
 * @param size the maximum inventory size
 */
void set_maximum_inventory_size(int size) {
   _maximum_inventory = size;
} /* set_maximum_inventory_size() */

/**
 * This method returns the maximum inventory size for the shop.
 * @return the maximum inventory size
 */
int query_maximum_inventory_size() {
   return _maximum_inventory;
} /* query_maximum_inventory_size() */

/**
 * This method sets the parcel post to use for rejecting items.
 * @param parcel the parcel post office
 */
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
} /* set_parcel_post() */

/**
 * This method tells us the current parcel post used for rejecting items.
 * @return the current parcel post
 */
string query_parcel_post() {
   return _parcel_post;
} /* query_parcel_post() */

/**
 * This method sets the name of the shop.
 * @param name the name of the shop
 */
void set_shop_name(string name) {
   _shop_name = name;
   add_property("determinate", "");
   set_short(_shop_name);
} /* set_shop_name() */

/**
 * This method returns the name of the shop.
 * @return the name of the shop
 */
string query_shop_name() {
   return _shop_name;
} /* query_shop_name() */

/**
 * THis method sets the amount to round all the sell values for.  THis is
 * deal with annoying currencies like AM money which does not have a
 * '1' item.
 * @param round the price to round at
 */
void set_round_price(int round) {
   _round_value = round;
} /* set_round_price() */

/**
 * This method returns the amount to round all sell values for.
 * @return the round price
 */
int query_round_prices() {
   return _round_value;
} /* query_round_prices() */

/**
 * This method returns the current approval list for the shop.
 */
class approval_obs* query_approval_list(int approved) {
   if (approved) {
      return _approved;
   } else {
      return _waiting_for_approval;
   }
} /* query_approval_list() */

/**
 * This method returns the number of items currently in the shop by
 * the specified person.  This includes items waiting for approval.
 */
int query_number_of_items_listed(string name) {
   int num;
   class approval_obs bing;

   name = lower_case(name);
   num = sizeof(query_controller()->query_owner_sellables(name));
   foreach (bing in _waiting_for_approval) {
      if (lower_case(bing->seller) == name) {
         num += sizeof(bing->saved);
      }
   }
   return num;
} /* query_number_of_items_listed() */

/**
 * This method returns the royalties for the specific person.
 * @param person the name of the person to get the royalties of
 * @return the the royalties
 */
int query_royalty(string name) {
   return query_controller()->query_royalty(name);
} /* query_royalty() */

/**
 * This method adjusts the royalty.
 * @param person the person to adjust
 * @param amt the amoutn to adjust by
 */
void adjust_royalty(string name, int amount) {
   query_controller()->adjust_royalty(name, amount);
} /* adjust_royalty() */

/**
 * This method checks to see if the specified item is approved.
 * @param seller the name of the seller
 * @param value the amount it is sold for
 * @param name the name of the item being solde
 * @param sellables the sold items
 * @param category the category of the sold item
 * @param final_cost the final cost of the item
 * @return 1 if is approved, 0 if not, -1 if denied, string if it is approved
 *         with a list name
 */
mixed is_item_approved(string seller, int value, string name, object* sellables,
                     string category, int ref final_cost) {
   string short;
   object ob;
   int item_approval;
   class expression_type bing;
   class parse_node frog;
   int cost;
   mixed item;

   final_cost = ((value * (100 + _automatic_percentage)) / 100);

   value = value - (cost % _round_value);

   if (is_allowed(seller)) {
      // Owners sell for the exact amount the specified.
      final_cost = value;
      return 1;
   }

   //
   // This is the value we don't automatically accept at.
   //
   seller = lower_case(seller);
   if (_sellers[seller] &&
       _sellers[seller]->deny_value_limit) {
      if (_sellers[seller]->deny_value_limit < value) {
         return -1;
      }
   } else if (_automatic_approval->high_cost_deny &&
              _automatic_approval->high_cost_deny <= value) {
      return -1;
   }

   //
   // Check through the automatic approval stuff to see if we should
   // approve it.
   //
   foreach (ob in sellables) {
      if (!ob) {
         // Always deny things with broken objects references.
         return -1;
      }
      short = ob->query_short();
      if (_automatic_approval->items[short]) {
         if (classp(_automatic_approval->items[short])) {
            item = ((class approval_item)_automatic_approval->items[short])->value;
         } else {
            item = _automatic_approval->items[short];
         }
         if (pointerp(item)) {
            frog = evaluate_expression(item,
                                     seller,
                                     value,
                                     ({ ob }),
                                     name,
                                     category);
            cost = frog->value - (frog->value % _round_value);
            if (cost < value) {
               item_approval = 0;
               break;
            }
            item_approval++;
         } else if (item < value) {
            item_approval = 0;
            break;
         } else {
            item_approval++;
         }
      }
   }

   if (item_approval) {
      if (classp(_automatic_approval->items[short]))  {
         class approval_item womble;

         womble = _automatic_approval->items[short];
         if (sizeof(womble) == 3) {
            _automatic_approval->items[short] = new(class approval_item,
                   markup : womble->markup,
                   value : womble->value,
                   list_name : womble->list_name,
                   final_cost : 0);
            womble = _automatic_approval->items[short];
         }
         if (womble->markup) {
            final_cost = ((value * (100 + womble->markup)) / 100);
         } else if (womble->final_cost) {
            final_cost = womble->final_cost;
         }
         if (womble->list_name) {
            return womble->list_name;
         } else {
            return 1;
         }
      } else {
         return 1;
      }
   }

   //
   // Then check any setup expressions.
   //
   if (!pointerp(_automatic_approval->expressions)) {
      _automatic_approval->expressions = ({ });
   }
   foreach (bing in _automatic_approval->expressions) {
      if (evaluate_expression(bing->condition,
                              seller,
                              value,
                              sellables,
                              name,
                              category)->value) {
         if (bing->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
            frog = evaluate_expression(bing->value,
                                 seller,
                                 value,
                                 sellables,
                                 name,
                                 category);
            cost = frog->value - (frog->value % _round_value);
            if (cost >= value) {
               if (bing->list_name) {
                  return bing->list_name;
               }
               else if (classp(_automatic_approval->items[short]))  {
                  return ((class approval_item)_automatic_approval->items[short])->list_name;
               }
               else return 1;
            }
         } else {
            return -1;
         }
      }
   }

   if (_sellers[seller] &&
       _sellers[seller]->value_limit) {
      if (_sellers[seller]->value_limit < value) {
         return 0;
      } else if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   } else if (_automatic_approval->high_cost &&
              _automatic_approval->high_cost < value) {
      return 0;
   }

   if (_automatic_approval->low_cost &&
       _automatic_approval->low_cost >= value) {
      if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   }

   return 0;
} /* is_item_approved() */

/**
 * This method checks to see if the shop is a closed shop and then checks
 * to see if the person is allowed.
 * @param person the person to check to see if they are allowed
 * @return 1 if they are allowed, 0 if not
 */
int is_allowed_to_use_shop(string person) {
   class parse_node frog;

   if (is_allowed(person) || !sizeof(_use_expression)) {
      return 1;
   }

   frog = evaluate_expression(_use_expression, person, 0, ({ }), 0, 0);
   return frog->value;
} /* is_allowed_to_use_shop() */

/**
 * @ignore yes
 */
int check_open(object player, string type) {
   if (!::check_open(player)) {
      return 0;
   }

   // Make sure that can only sell stuff if the waiting list is not full.
   if (type == "sell") {
      if (sizeof(query_approval_list(0)) + sizeof(query_approval_list(1)) >= _max_items_in_queue) {
         add_failed_mess("Unable to sell things, the shop is full.\n");
         return 0;
      }
   }

   if (member_array(player->query_name(), _black_list) != -1) {
      add_failed_mess("You are not allowed to use this shop.\n");
      return 0;
   }

   if (!is_allowed_to_use_shop(player->query_name())) {
      add_failed_mess("The shop is currently closed.\n");
      return 0;
   }

   return 1;
} /* check_open() */

/**
 * @ignore yes
 */
void set_controller(string name) {
   ::set_controller(name);
   query_controller()->set_dont_use_name(1);
} /* set_controller() */

/**
 * @ignore yes
 */
int is_allowed_to_sell(object *obs, string name, string *sellable_names) {
   int num;
   int max;

   if (_automatic_approval->num_allowed ||
       _sellers[name]) {
      num = query_number_of_items_listed(name) + sizeof(obs);
      if (_sellers[name] && _sellers[name]->max_sellable) {
         max = _sellers[name]->max_sellable;
      } else {
         max = _automatic_approval->num_allowed;
      }

      if (num > max) {
         add_failed_mess("You cannot have more than " + max + " items "
                         "listed at " + the_short() + ", with this sale you "
                         "would have " +
                         num + ".\n");
         return 0;
      }
   }

   if (member_array(lower_case(name), _black_list) != -1) {
      add_failed_mess("You are not allowed to sell things here.\n");
      return 0;
   }

   //
   // Otherwise see if we are over the shops total maximum size.
   //
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(obs) > query_maximum_inventory_size()) {
      add_failed_mess("The shop is full, it can only hold " +
                      query_maximum_inventory_size() + " and it currently "
                      "holds " + num + ".\n");
      return 0;
   }
   return 1;
} /* is_allowed_to_sell() */

/**
 * This method finds out the maximum value that this item is allowed
 * to be sold for based on the current settings of the shop.
 * @param person the person doing the selling
 * @param items the item being sold
 * @return ({ queue limit, deny limit })
 */
int* query_maximum_sale_value_both(string person, object item) {
   int max_deny;
   int max_accept;
   string short;
   class expression_type stuff;
   mixed app_item;

   if (_sellers[person]) {
      if (_sellers[person]->value_limit) {
         max_accept = _sellers[person]->value_limit;
      }
      if (_sellers[person]->deny_value_limit) {
         max_deny = _sellers[person]->deny_value_limit;
      }
   }
   if (!max_accept) {
      max_accept = _automatic_approval->high_cost;
   }
   if (!max_deny) {
      max_deny = _automatic_approval->high_cost_deny;
   }

   short = item->query_short();
   if (_automatic_approval->items[short]) {
      if (classp(_automatic_approval->items[short]))  {
         app_item = ((class approval_item)_automatic_approval->items[short])->value;
      } else {
         app_item= _automatic_approval->items[short];
      }
      if (pointerp(app_item)) {
         max_accept = evaluate_expression(app_item,
                                        person, 0, ({ item }), 0, 0)->value;
      } else if (app_item < max_deny) {
         max_accept = app_item;
      }
   }

   foreach (stuff in _automatic_approval->expressions) {
      if (evaluate_expression(stuff->condition, person, 0, ({ }), 0, 0)->value) {
         if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_DENY) {
            max_deny = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         } else {
            max_accept = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         }
      }
   }

   max_accept -= max_accept % _round_value;
   max_deny -= max_deny % _round_value;

   return ({ max_accept, max_deny });
} /* query_maximum_sale_value() */

/**
 * This method will return the maximum value at which the set of items
 * will be denied.
 * @param person the person selling the item
 * @param obs the set of objects
 * @return the deny value
 */
int query_maximum_sale_value(string person, object* obs) {
   int* stuff;
   object ob;
   int cur_deny;

   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(person, ob);
      if (!cur_deny && stuff[1]) {
         cur_deny = stuff[1];
      } else if (cur_deny && cur_deny > stuff[1]) {
         cur_deny = stuff[1];
      }
   }
   return cur_deny;
} /* query_maximum_sale_value() */

/** @ignore yes */
string query_extra_price_information(string seller, object *obs) {
   int* max;
   int* max_tmp;
   string ret;
   string place;
   object ob;

   max = ({ 0, 0 });
   foreach (ob in obs) {
      max_tmp = query_maximum_sale_value_both(seller, ob);
      if (max_tmp[0] && max[0] > max_tmp[0]) {
         max[0] = max_tmp[0];
      }
      if (max_tmp[1] && max[1] > max_tmp[1]) {
         max[1] = max_tmp[1];
      }
   }

   ret = "";
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (max[0]) {
      ret += "the maximum price you can sell this straight into the "
             "inventory for is " +
             MONEY_HAND->money_value_string(max[0], place);
   }
   if (max[1]) {
      if (max[0]) {
         ret += " and ";
      }
      ret += "the maximum price you can sell the item for at all is " +
             MONEY_HAND->money_value_string(max[1], place);
   }
   return capitalize(ret) + ".\n";
} /* query_extra_price_information() */


/**
 * This method creates a save file for the specified objects autoloading
 * capability.  If the number to write to is non-null then it will
 * write to that object.
 * @param ob the object to get an autoload number for
 * @param fixed_num the file number to write to
 * @return the auto load number
 * @see save_it()
 */
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   string tmp;

   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         // Make it error on the last one...
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   do_save_file(CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "app_" + fixed_num);
   return fixed_num;
} /* create_auto_load_file() */

/**
 * This method creates a real object from the save file number.
 * @param num the save file number
 * @return the nice shiny new object
 * @see create_auto_load_file()
 */
protected object create_real_auto_load_object(int num, object player) {
   string auto_load;
   object *obs;

   auto_load = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
} /* create_object_from_auto_load() */

/**
 * This method turns all the specified id into an item to be checked.
 * @param id the id of the object to create
 * @param player the player to use for autoloading
 */
object create_checkout_object(class approval_obs approve,
                            int id,
                            object player) {
   object ob;
   int i;

   ob = create_real_auto_load_object(id, player);
   if (ob) {
      ob->add_effect("/std/effects/object/no_save");
      ob->add_property(PLAYER_CRAFT_SHOP_CHECK_PROP, ({ approve, id }));
      i = member_array(id, approve->saved);
      approve->checkout[i] = 1;
      event_save(this_object());
      _something_checkedout++;
   }
   return ob;
} /* create_checkout_object() */

/**
 * This method updates the checked out item and changes to to be what
 * we now have...
 * @param ob the object to destroy
 */
int destroy_checkout_object(object ob) {
   int id;
   int *ids;
   int i;
   class approval_obs approve;

   if (!ob) {
      return 0;
   }

   if (ob->move("/room/rubbish") != MOVE_OK) {
      return 0;
   }
   //
   // Zap the effect too.
   //
   ids = ob->effects_matching("/std/effects/object/no_save"->query_classification());
   foreach (id in ids) {
      ob->delete_effect(id);
   }

   id = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[1];
   approve = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[0];
   i = member_array(id, approve->saved);
   approve->checkout[i] = 0;

   ob->remove_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
   create_auto_load_file(ob, id);
   event_save(this_object());
   _something_checkedout--;
   if (_something_checkedout < 0) {
       _something_checkedout = 0;
   }
   return 1;
} /* destroy_checkout_object() */

/**
 * This method checks to see if the specified item is a checked out
 * item.
 * @param ob the object to check
 * @return 1 if it is, 0 if not
 */
int is_checkout_object(object ob) {
   return ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
} /* is_checkout_object() */

/**
 * This method adds an item to the list of items that need to be approved.
 * @param seller name of the player
 * @param sellables the list of items to sell
 * @param value the cost of the item
 * @param name the name of the items
 * @param category the category of the item
 * @param approved a flag to say if this was approved or not
 * @return obs the objects we bought
 */
object* add_to_approval_list(string seller, object* sellables, int value,
                          string name, string category, int approved) {
   class approval_obs stuff;
   object ob;
   object* obs;

   obs = ({ });
   foreach (stuff in query_approval_list(approved)) {
      if (lower_case(stuff->name) == lower_case(name) &&
          stuff->seller == seller &&
          stuff->value == value) {
         stuff->category = category;
         foreach (ob in sellables) {
            if (ob->move("/room/rubbish") == MOVE_OK) {
               stuff->saved += ({ create_auto_load_file(ob, 0) });
               stuff->checkout += ({ 0 });
               obs += ({ ob });
            }
         }
         if (sizeof(obs)) {
            event_save(this_object());
         }
         return obs;
      }
   }


   stuff = new(class approval_obs);
   stuff->seller = seller;
   stuff->value = value;
   stuff->name = name;
   stuff->category = category;
   stuff->saved = ({ });
   stuff->enter_time = time();
   foreach (ob in sellables) {
      if (ob->move("/room/rubbish") == MOVE_OK) {
         stuff->saved += ({ create_auto_load_file(ob, 0) });
         obs += ({ ob });
      }
   }
   stuff->checkout = allocate(sizeof(stuff->saved));
   if (sizeof(obs)) {
      if (approved) {
         _approved += ({ stuff });
      } else {
         _waiting_for_approval += ({ stuff });
      }
      event_save(this_object());
   }
   return obs;
} /* add_to_approval_list() */

/**
 * This method removes the item from the approval list.
 * @param approve the item to remove
 */
void remove_from_approval_list(class approval_obs approve) {
   int i;
   int pos;

   for (i = 0; i < sizeof(_approved); i++) {
      if (_approved[i] == approve) {
         //
         // Zap the files...
         //
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _approved = _approved[0..i-1] + _approved[i+1..];

         event_save(this_object());
         return ;
      }
   }
   for (i = 0; i < sizeof(_waiting_for_approval); i++) {
      if (_waiting_for_approval[i] == approve) {
         //
         // Zap the files...
         //
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _waiting_for_approval = _waiting_for_approval[0..i-1] + _waiting_for_approval[i+1..];

         event_save(this_object());
         return ;
      }
   }
} /* remove_from_approval_list() */

/**
 * This method adds in transaction into the transaction list.
 * @param person the person doing the thing
 * @param objects the string name of the objects
 * @param type the type of the transaction
 * @param amount the cost of the transaction
 * @param name_cat the name/category of the item
 * @param extra anything extra about the transaction
 */
void add_transaction(string person, object* objects, int type, int amount,
                     string name_cat, mixed extra) {
#if USE_TRANSACTIONS
   class shop_transaction bing;
   string str;

   str = query_multiple_short(objects, 0, 1);

   bing = new(class shop_transaction);
   bing->time = time();
   bing->person = person;
   bing->objects = str;
   bing->type = type;
   bing->amount = amount;
   bing->name_cat = name_cat;
   bing->extra = extra;
   _transactions += ({ bing });
   event_save(this_object());
#endif
} /* add_transaction() */

#if USE_TRANSACTIONS
/**
 * This method truns a transaction into a string.
 * @param trans the transaction
 * @return the transaction as a string
 */
string query_transaction_string(class shop_transaction trans) {
   string ret;
   string amt;
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   amt = MONEY_HAND->money_value_string(trans->amount, place);
   ret = ctime(trans->time)[4..<9] + ": " + trans->person;
   switch (trans->type) {
   case PLAYER_CRAFT_SHOP_SELL :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_SELL_AUTO :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") [accepted] for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_APPROVE :
      ret += " approves " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_BUY :
      ret += " buys " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   }
   return ret;
} /* query_transaction_string() */
#endif

/**
 * This method is called to complete the sale completely.  It is split
 * up into a second function to allow the extra sell stuff
 * to work neatly.
 * @param value the value of the objects to sell
 * @param name the list name
 * @param sellable the list of objects to sell
 * @param category the category of the object, 0 if none
 * @ignore yes
 */
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   string place;
   object *bought;
   mixed approve;
   int final_cost;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   //
   // Make sure we mess with the price before we do any of the approval
   // things.
   //
   _num_checked_so_far = ([ ]);
   approve = is_item_approved(this_player()->query_name(),
                        value, name, sellable, category, ref final_cost);
   if (approve == -1) {
      write("This item is denied sale here, it is not something the "
            "owner wishes to buy.\n");
      say(this_player()->query_cap_name() + " finished attempting to sell " +
                query_multiple_short(sellable) + " to " + the_short() + ".\n");
      return ;
   }

   if (approve == 1 || stringp(approve)) {
      if (stringp(approve)) {
         name = approve;
      }
   }

   write("Waiting for approval from the shop owner for the items " +
         query_multiple_short(sellable) + " with the name '" +
         name + "' selling for " +
         MONEY_HAND->money_value_string(value, place) +
         " in category " + category + ".\nIf the item is accepted the "
         "money will be paid into your royalty pool.\n");

   bought = add_to_approval_list(this_player()->query_cap_name(), sellable,
                        value, name, category, approve != 0);
   if (sizeof(bought)) {
      add_transaction(this_player()->query_name(),
                   bought,
                   PLAYER_CRAFT_SHOP_SELL,
                   value * sizeof(sellable),
                   name + " in " + category,
                   0);
      if (sizeof(bought) != sizeof(sellable)) {
         write("Unable to sell " + query_multiple_short(sellable - bought) +
                  " to " + the_short() + ".\n");
      }
      say(this_player()->the_short() + " completes selling something "
       "to the shop.\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + " to " +
            the_short() + ".\n");
   }
} /* complete_sale() */

/**
 * This method returns the position as a two letter value.
 * @param pos the position to mangle
 * @return the letter value
 */
string query_letter_value(int pos) {
   return sprintf("%c%c", 'A' + (pos / 26), 'A' + (pos % 26));
} /* query_letter_value() */

/**
 * This method goes from a letter value to a number.
 * @param letter the letters
 * @return the number
 */
int query_number_value(string letter) {
   if (!strlen(letter)) {
      return -1;
   }

   letter = lower_case(letter);
   if (strlen(letter) < 2) {
      if (letter[0] >= 'a' && letter[0] <= 'z') {
         return letter[0] - 'a';
      }
   }
   if (strlen(letter) > 2) {
      return -1;
   }
   if (letter[0] >= 'a' && letter[0] <= 'z') {
      if (letter[1] >= 'a' && letter[1] <= 'z') {
         return (letter[0] - 'a') * 26 + (letter[1] - 'a');
      }
   }
   return -1;
} /* query_number_value() */

/**
 * This method returns the approval class from the string name.  THis is
 * assumed to be called from inside a command.
 * @param name the string name
 * @param approved from the approved or waiting list
 * @return the approval object
 */
class approval_obs query_approval_class(string name) {
   int pos;

   if (name[0] == '-') {
      pos = query_number_value(name[1..]);
   } else {
      pos = query_number_value(name);
   }
   if (pos == -1) {
      add_failed_mess(name + " is not a valid number.\n");
      return 0;
   }

   if (name[0] == '-') {
      if (!sizeof(query_approval_list(0))) {
         add_failed_mess("There is nothing in the approval list currently.\n");
         return 0;
      }
      if (pos >= sizeof(query_approval_list(0))) {
         add_failed_mess("The " + name + " is out of range, must be between AA-" +
                         query_letter_value(sizeof(query_approval_list(0)) - 1) +
                         ".\n");
      }

      return query_approval_list(0)[pos];
   }

   if (pos >= sizeof(query_approval_list(1))) {
      add_failed_mess("The " + name + " is out of range, must be between AA-" +
                      query_letter_value(sizeof(query_approval_list(1)) - 1) +
                      ".\n");
      return 0;
   }

   return query_approval_list(1)[pos];
} /* query_approval_class() */

/** @ignore yes */
int ownership_change(string old_owner, string new_owner) {
   class parse_node* expr;

   if (old_owner == new_owner) {
      return 0;
   }

   //
   // Setup all the defaults.
   //
   _automatic_approval = new(class approval);
   //_automatic_approval->sellers = ({ });
   //_automatic_approval->categories = ([ ]);
   _automatic_approval->items = ([ ]);
   _automatic_approval->expressions = ({ });
   _automatic_percentage = 10;
#if USE_TRANSACTIONS
   _transactions = ({ });
#endif
   _sell_stats = ([ ]);
   _stats_start = time();
   _sellers = ([ ]);
   _black_list = ({ });
   expr = parse_boolean_string("false");
   _buy_expression = expr;
   _use_expression = expr;
} /* ownership_change() */

/** @ignore yes */
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
   string name_cat;
   int i;
   class shop_stats stat;

   _total_ingoing += value;
   adjust_royalty(query_owner(), value);
   for (i = 0; i < sizeof(obs); i++) {
      name_cat = names[i] + " in " + cats[i];
      add_transaction(this_player()->query_name(),
                      obs[i..i],
                      PLAYER_CRAFT_SHOP_BUY,
                      values[i],
                      name_cat,
                      sellers[i]);
      stat = _sell_stats[sellers[i] + " - " + name_cat];
      if (!stat) {
         stat = new(class shop_stats);
      }
      stat->num_sold++;
      stat->value_sold += values[i];
      _sell_stats[sellers[i] + " - " + name_cat] = stat;
   }
} /* inform_of_buy() */

/** @ignore yes */
object* check_for_checkout(object ob) {
   object* obs = ({ });

   if (_something_checkedout) {
      //
      // Give them a look.
      //
      if (living(ob)) {
         obs = filter(deep_inventory(ob), (: is_checkout_object($1) :));
      } else {
         if (is_checkout_object(ob)) {
            obs = ({ ob });
         }
      }
      if (sizeof(obs)) {
         foreach (ob in obs) {
            if (!destroy_checkout_object(ob)) {
               obs -= ({ ob });
            }
         }
      }
      return obs;
   }
   return ({ });
} /* check_for_checkout() */

/** @ignore yes */
void event_exit(object ob, string message, object to) {
   object *obs;

   obs = check_for_checkout(ob);
   if (sizeof(obs)) {
      tell_object(ob, "You suddenly find the uncheckout items " +
                      query_multiple_short(obs) + " check themselves "
                      "back in.\n");
      obs->move("/room/rubbish");
   }
} /* event_exit() */

/** @ignore yes */
void event_dest_me(object ob) {
   check_for_checkout(ob);
   if (_sign_ob) {
      _sign_ob->dest_me();
   }
} /* event_dest_me() */

/**
 * This method returns all the checkedout objects to the shop.
 */
void return_all_checkedout_objects() {
   object ob;
   object* obs;

   if (_something_checkedout) {
      obs = filter(deep_inventory(this_object()), (: is_checkout_object($1) :));
      if (sizeof(obs)) {
         foreach (ob in obs) {
            destroy_checkout_object(ob);
         }
      }
      tell_room(this_object(), query_multiple_short(obs) +
                " mysteriously check themselves back in.\n");
   }
} /* return_all_checkedout_objects() */

/** @ignore yes */
void dest_me() {
   ::dest_me();
} /* dest_me() */

/**
 * @ignore yes
 * In a player run shop we change this so that only allowed people can change
 * an item once it is sold.
 */
int is_able_to_change(object ob) {
   return is_allowed(this_player()->query_name());
} /* is_able_change_ob() */

/**
 * This method returns the current level of the owners money.
 */
int query_owners_money() {
   return query_royalty(query_owner());
} /* query_owners_money() */

/**
 * This method changes the current level of the owners money.
 */
void adjust_owners_money(int amt) {
   adjust_royalty(query_owner(), amt);
} /* adjust_owners_money() */

/**
 * This method returns the current sign object for the shop.
 * @return the current sign object
 */
object query_sign_object() {
   object* obs;
   if (!_sign_ob && _auto_load_sign_str && !_broken_sign) {
      if (catch(obs = PLAYER_OB->load_auto_load_to_array(_auto_load_sign_str))) {
         _broken_sign = 1;
      } else {
         if (sizeof(obs)) {
            _sign_ob = obs[0];
            _sign_ob->reset_get();
         } else {
            _broken_sign = 1;
         }
      }
   }
   return _sign_ob;
} /* query_sign_object() */

/**
 * This method sets the current sign object.
 * @param sign the new sign object
 */
void set_sign_object(object ob) {
   if (ob) {
      _auto_load_sign_str = PLAYER_OB->create_auto_load(({ ob }));
      ob->reset_get();
   } else {
      _auto_load_sign_str = 0;
   }
   _sign_ob = ob;
   event_save(this_object());
} /* set_sign_object() */


/**
 * @ignore yes
 */
int do_buy(object *obs) {
   int status;
/*
   int markup;
   int i;
   int pos;
   int bing;
   mixed approve;
   object *sellables;
   object *bought;
   string name;
   class approval_obs app_obs;
 */

   if (!evaluate_expression(_buy_expression, this_player()->query_name(), 0, ({ }), 0, 0)->value &&
       !is_allowed_to_use_shop(this_player()->query_name())) {
      add_failed_mess("You cannot buy anything at this shop.\n");
      return 0;
   }
   status = ::do_buy(obs);
   if (!status)  return 0;

/*
   foreach(app_obs in query_approval_list(approved))  {
      sellables = ({ });
      for (i = 0; i < sizeof(app_obs->saved); i++) {
         pos = app_obs->saved[i];
         if (!app_obs->checkout[i]) {
            sellables += ({ create_real_auto_load_object(pos, this_player()) });
         }
         else {
            sellables->move("/room/rubbish");
            sellables = ({ });
         }
      }

      if (sizeof(sellables))  {
         _num_checked_so_far = ([ ]);
         approve = is_item_approved(lower_case(app_obs->seller), app_obs->value,
                                    app_obs->name, sellables, app_obs->category,
                                    ref markup);
      } else  {
         approve = 0;
      }

      if (approve == 1 || stringp(approve)) {
         if (stringp(approve)) {
            name = approve;
         } else  {
            name = app_obs->name;
         }

         if (markup) {
            bing = ((app_obs->value * (100 + markup)) / 100);
         } else {
            bing = ((app_obs->value * (100 + _automatic_percentage)) / 100);
         }
         bing -= bing % _round_value;

         bought = query_controller()->buy_objects(sellables, name, bing,
                                app_obs->seller, app_obs->category, 1);
         if (sizeof(bought)) {
            add_transaction(app_obs->seller, sellables,
                            PLAYER_CRAFT_SHOP_SELL_AUTO,
                            app_obs->value * sizeof(sellables),
                            name + " in " + app_obs->category, 0);
            remove_from_approval_list(app_obs);
            if (query_owner() != app_obs->seller)  {
               _total_outgoing += app_obs->value * sizeof(sellables);
               adjust_royalty(query_owner(),
                              -app_obs->value * sizeof(sellables));
               adjust_royalty(app_obs->seller,
                              app_obs->value * sizeof(sellables));
               event_save(this_object());
            }
         }
         break;
      }
   }
 */

   return 1;
} /* do_buy() */

/**
 * This method runs through the objects and checks to see what sort of levels
 * they are allowed to sell them for to this shop.
 * @return 1 on success, 0 on failure
 */
int do_check_sell(object *obs) {
   int *stuff;
   object ob;
   string ret;
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "";
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(this_player()->query_name(), ob);
      ret += "$I$5=$C$" + the_short() + ": ";
      if (stuff[0]) {
         ret += "will be queued for more than " +
                MONEY_HAND->money_value_string(stuff[0], place);
      }
      if (stuff[0] && stuff[1]) {
         ret += " and ";
      }
      if (stuff[1]) {
         ret += "will be denied for more than " +
                MONEY_HAND->money_value_string(stuff[1], place);
      }
      ret += ".\n";
   }
   write("$P$Check Sell$P$" + ret);
   add_succeeded_mess(({ "", "$N checks the sale of $I.\n" }), obs);
   return 1;
} /* do_check_sell() */

/**
 * List the items for approval.
 */
int do_list_approval(int approved) {
   class approval_obs approve;
   int pos;
   int shown;
   int allowed;
   int checkout;
   int i;
   int fluff;
   string place;
   string ret;
   object* obs;
   object *current;
   object* result;
   string *possible_names;
   string start;
   mapping result_type;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   allowed = is_allowed(this_player()->query_name());
   if (!allowed) {
      approved = 1;
   }
   if (!approved) {
      start = "-";
   } else {
      start = "";
   }

   result_type = ([ ]);
   ret = "";
   current = query_controller()->create_all_real_objects(this_player(),
                 query_controller()->query_sell_list_obs());
   while (allowed || approved) {
      if (approved == 2) {
         approved = 0;
         start = "-";
      }
      foreach (approve in query_approval_list(approved)) {
         if (lower_case(approve->seller) == this_player()->query_name() ||
             allowed) {
            checkout = sizeof(filter(approve->checkout, (: $1 :)));
   
            obs = ({ });
            for (i = 0; i < sizeof(approve->saved); i++) {
               fluff = approve->saved[i];
               obs += ({ create_real_auto_load_object(fluff, this_player()) });
            }
            obs -= ({ 0 });
            possible_names = obs->query_short();
            obs->move("/room/rubbish");
            if (!result_type[lower_case(approve->name)]) {
               result = filter(current,
                        (: member_array($1->query_short(),
                                        $(possible_names)) > -1 :)); 
               result_type[lower_case(approve->name)] = sizeof(result);
            }
            ret += start + query_letter_value(pos) + ") " +
                  approve->seller + "'s " + approve->name + " for " +
                  MONEY_HAND->money_value_string(approve->value, place) +
                  " in " + approve->category + ", " +
                  sizeof(approve->saved) + " objects (" +
                  query_multiple_short(obs) + ") " +
                  result_type[lower_case(approve->name)] + " in stock";
   
            if (checkout) {
               ret += " and " + checkout + " checked out.\n";
            } else {
               ret += ".\n";
            }
            shown++;
         }
         pos++;
      }
      if (!allowed && approved) {
         approved = 2;
         pos = 0;
      } else {
         break;
      }
   }
   if (sizeof(current)) {
      current->dest_me();
   }

   if (!shown) {
      add_failed_mess("No items to approve at the moment.\n");
      return 0;
   }

   write("$P$Approval list$P$The current approval items are:\n" + ret);
   return 1;
} /* do_list_approval() */

/**
 * This method returns the item to the person that started to sell it.
 * This only works before the item has been approved.
 * @param name the name of the item to return
 */
int do_return(string name) {
   object *obs;
   object *ok;
   object *here;
   object *fail;
   object *checkout;
   object money;
   class approval_obs approve;
   object ob;
   int pos;
   int i;
   int value;
   string place;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) != this_player()->query_name()) {
      add_failed_mess("You must be the one that sold the item to return "
                      "it.\n");
      return 0;
   }

   obs = ({ });
   checkout = ({ });
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      //
      // Try and return it.
      //
      return_all_checkedout_objects();
   }

   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }

   obs -= ({ 0 });
   checkout -= ({ 0 });

   if (sizeof(checkout)) {
      place = query_property("place");
      if (!place) {
         place = "default";
      }

      write("The items " + query_multiple_short(checkout) +
            " are currently checked out.  You are reimbused the amount "
            "they would have cost to sell.\n");
      value = approve->value * sizeof(checkout);
      money = MONEY_HAND->make_new_amount( value, place);
      money->move(this_player());
      _total_outgoing += approve->value * sizeof(checkout);
   }

   ok = ({ });
   here = ({ });
   fail = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) == MOVE_OK) {
         ok += ({ ob });
      } else if (ob->move(this_object())) {
         here += ({ ob });
      } else {
         fail += ({ ob });
      }
   }
   remove_from_approval_list(approve);

   if (sizeof(ok)) {
      add_succeeded_mess("$N $V $I.\n", map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(here)) {
      add_succeeded_mess("$N $V their $I and they get put on the floor.\n",
                         map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(fail)) {
      add_succeeded_mess( ({ "You find that $I do not want to be moved.\n",
                             "" }), fail);
   }
   return 1;
} /* do_return() */

/**
 * This method approves the specified item.
 */
int do_approve_item(string name, string money_str) {
   int cost;
   object *obs;
   class approval_obs approve;
   string place;
   int final_cost;
   int num;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(approve->saved) > query_maximum_inventory_size()) {
      add_failed_mess("You cannot approve anything, the shop is already "
                      "at the maximum number allowed.\n");
      return 0;
   }

   cost = approve->value * sizeof(obs);
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to put this into the shop.\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess("The amount " + money_str + " is not a valid "
                         "money cost.\n");
         return 0;
      }
   }

   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      //
      // Try and return it.
      //
      write("One of these objects is still checkedout, do you wish to "
            "continue this without these items? ");
      input_to("confirm_approval", 0, approve, final_cost);
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      return 1;
   }


   confirm_approval("y", approve, final_cost);
   return 1;
} /* do_approve_item() */

protected void confirm_approval(string answer,
                                class approval_obs approve,
                                int final_cost) {
   int pos;
   int i;
   int bing;
   int cost;
   object *obs;
   object *bought;
   object *checkout;
   string place;

   if (strlen(answer) < 1 || lower_case(answer)[0] != 'y') {
      write("Ok, canceled the approval of the item.\n");
      return ;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   //
   // Approval means we create all the objects, remove them, and then
   // send them off to the main engine...
   //
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }

   obs -= ({ 0 });
   checkout -= ({ 0 });

   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and therefore lost.\n");
   }

   if (!final_cost) {
      final_cost = ((approve->value * (100 + _automatic_percentage)) / 100);
   }
   final_cost -= final_cost % _round_value;
   bought = query_controller()->buy_objects(obs, approve->name,
                                   final_cost,
                                   approve->seller, approve->category, 1);
   if (sizeof(bought)) {
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      _total_outgoing += cost;
      remove_from_approval_list(approve);
      adjust_royalty(lower_case(approve->seller), cost);
      //
      // Try and remove from the cash float first.
      //
      if (query_owners_money() > 0) {
         if (query_owners_money() > cost) {
            adjust_owners_money(-cost);
            cost = 0;
         } else {
            cost -= query_owners_money();
            adjust_owners_money(-query_owners_money());
         }
      }
      if (cost > 0) {
         if (this_player()->query_value_in(place) > 0) {
            bing = this_player()->query_value_in(place);
            if (bing > cost) {
               bing = cost;
               cost = 0;
            } else {
               cost -= bing;
            }
            if (bing) {
               this_player()->pay_money(MONEY_HAND->create_money_array(bing, place), place);
            }
         }
         if (cost > 0) {
            adjust_owners_money(-cost);
         }
      }
      write("You approve " + query_multiple_short(obs) + " to be sold as " +
            approve->name + " in " + approve->category + " for " +
            MONEY_HAND->money_value_string(approve->value, place) + ".\n");
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      add_transaction(this_player()->query_name(),
                      obs,
                      PLAYER_CRAFT_SHOP_APPROVE,
                      approve->value * (sizeof(obs) + sizeof(checkout)),
                      approve->name + " in " + approve->category,
                      approve->seller);
   } else {
      write("Unable to move the items into the shops inventory.  "
            "Contact a creator or error report this please.\n");
   }
   return ;
} /* do_approve_item() */

/**
 * This method rejects the specified item.
 */
int do_approve_reject(string name, string mess, int reject_pos) {
   object *obs;
   object *ok;
   object *here;
   object *checkout;
   object ob;
   object play;
   class approval_obs approve;
   int pos;
   int i;
   int ret;
   string ob_mess;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) == this_player()->query_name()) {
      //
      // Return the stuff to them.
      //
      return do_return(name);
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You're not allowed to reject items.\n");
      return 0;
   }


   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      //
      // Try and return it.
      //
      return_all_checkedout_objects();
   }

   if (reject_pos != -1 &&
       (reject_pos <= 0 ||
       reject_pos > sizeof(approve->saved))) {
      add_failed_mess("You cannot reject the item of position " + reject_pos +
                      " since there are only " + sizeof(approve->saved) +
                      " items.\n");
      return 0;
   }

   if (reject_pos != -1) {
      reject_pos--;
   }

   //
   // Approval means we create all the objects, remove them, and then
   // send them off to the main engine...
   //
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      if (reject_pos == -1 ||
          reject_pos == i) {
         pos = approve->saved[i];
         if (!approve->checkout[i]) {
            obs += ({ create_real_auto_load_object(pos, this_player()) });
         } else {
            checkout += ({ create_real_auto_load_object(pos, this_player()) });
         }
      }
   }

   obs -= ({ 0 });
   checkout -= ({ 0 });

   if (member_array(0, obs) != -1) {
      add_failed_mess("There seems to be a problem with this rejection set, "
                      "one of the items is 0.\n");
      return 0;
   }

   if (reject_pos != -1 && sizeof(checkout)) {
      add_failed_mess("The item $I has been checked out, you cannot reject "
                      "it.\n", checkout);
      return 0;
   }

   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and lost.\n");
      adjust_royalty(lower_case(approve->seller),
                                approve->value * sizeof(checkout));
      AUTO_MAILER->auto_mail(lower_case(approve->seller),
                            this_player()->query_name(),
                            "Rejected items", "",
                            sprintf("%-=75s",
                                   this_player()->query_name() + " lost your " +
                                   query_multiple_short(checkout, "the", 1) +
                                   ",so you have been paid but the items "
                                   "were not returned.\n"));
   }

   if (!sizeof(obs)) {
      write("Nothing to give back or send off.\n");
   } else {
      //
      // They are here, so give it back.
      //
      play = find_player(lower_case(approve->seller));
      if (play  &&  environment(play) == this_object()) {
         ok = ({ });
         here = ({ });
         foreach (ob in obs) {
            if (ob) {
               if (ob->move(play) == MOVE_OK) {
                  ok += ({ ob });
               } else if (ob->move(this_object()) == MOVE_OK) {
                  here += ({ ob });
               }
            }
         }
         if (sizeof(ok)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed in your inventory.\n");
         }
         if (sizeof(here)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed on the floor here.\n");
         }
         write("You reject the item.\n");
      } else {
         if (!_parcel_post) {
            add_failed_mess("Eeek!  No parcel post defined on this room.\n");
            return 0;
         }

         ob_mess = "The shop " + this_player()->convert_message(the_short()) +
                   " rejected " + query_multiple_short(obs, "the", 1) +
                   " because:\n";
         ret = _parcel_post->deposit_parcel(obs, lower_case(approve->seller), 1);
         if (ret != 1) {
            if (ret == -5) {
               write("The player " + approve->seller + " has been denied use "
                     "of the parcel post system, tossing objects away.\n");
               obs->move("/room/rubbish");
               if (mess) {
                  write("Still sending the message to the person.\n");
                  mess += "\nYou were denied use of the parcel post system "
                          "so your objects were thrown away.\n";
               }
            } else if (ret == -4) {
               write("You have been denied use of the postal system, perhaps "
                     "you could try clearing this up with the creators?\n");
               obs->move("/room/rubbish");
               return 1;
            } else if (ret == -2) {
               write("The player " + approve->seller + " no longer exists, "
                     "tossing objects away.\n");
               obs->move("/room/rubbish");
            } else {
               add_failed_mess("Unable to send the parcel for some reason (" +
                            ret + ").\n");
                  obs->move("/room/rubbish");
               return 0;
            }
         }
         if (ret != -2) {
            if (mess) {
               AUTO_MAILER->auto_mail(approve->seller, this_player()->query_name(),
                               "Rejected items", "",
                               ob_mess + mess);
            } else {
               write("You reject the item and it is parcel posted back to the "
                  "person who "
                  "sent it.\nWould you like to send them a note about it as well? ");
               obs -= ({ 0 });
               input_to("check_reject_note", 0, ob_mess,
                        approve->seller);
            }
         }
      }
   }

   if (reject_pos != -1) {
      approve->saved = approve->saved[0..reject_pos-1] + approve->saved[reject_pos+1..];
      event_save(this_object());
      if (!sizeof(approve->saved)) {
         reject_pos = -1;
      }
   }

   if (reject_pos == -1) {
      remove_from_approval_list(approve);
   }
   add_succeeded_mess(({ "", "$N reject$s a sellable object.\n" }));
   return 1;
} /* do_approve_reject() */

/**
 * @ignore yes
 */
void check_reject_note(string str, string ob_str, string name) {
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' &&
        str[0] != 'n')) {
      write("Please answer yes or no.\nWould you like to send them "
            "a note about it as well?");
      input_to("check_reject_note", 0, ob_str, name);
      return ;
   }
   if (str[0] == 'n') {
      write("ok, bye then!\n");
      return ;
   }
   this_player()->do_edit("Your items " + ob_str + " were rejected "
                         "from " + the_short() + ".\n\n",
                         "send_reject_note", this_object(), 0, name);
} /* check_reject_note() */

/** @ignore yes */
void send_reject_note(string mess, string name) {
   if (!mess) {
      write("Aborted.\n");
      return ;
   }
   //write("Sending to " + name + ".\n");
   AUTO_MAILER->auto_mail(name, this_player()->query_name(),
                            "Rejected items", "", mess);
} /* send_reject_note() */

/**
 * This method browses the specified item.
 */
int do_approve_browse(string name) {
   object *obs;
   object ob;
   string read;
   string ret;
   class approval_obs approve;
   int pos;
   string place;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) == this_player()->query_name()) {
      //
      // Return the stuff to them.
      //
      return do_return(name);
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }


   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   //
   // Create the objects, browse them, kill them.
   //
   obs = ({ });
   foreach (pos in approve->saved) {
      obs += ({ create_real_auto_load_object(pos, this_player()) });
   }

   obs -= ({ 0 });

   ret = "";
   foreach (ob in obs) {
      ret += ob->the_short() + ": (Base cost " +
             MONEY_HAND->money_value_string(ob->query_base_value(), place) +
             "; scaled cost " +
             MONEY_HAND->money_value_string(ob->query_value(), place) +
             ")\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         ret += "You read " +
                 replace_string(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }

   obs->move("/room/rubbish");

   write("$P$Browse list$P$" + ret);

   add_succeeded_mess("$N browse$s an item waiting for approval.\n");
   return 1;
} /* do_approve_browse() */

/**
 * This method checks out the specified item.
 */
int do_approve_checkout(string name) {
   object *obs;
   object *bad;
   object *checkout;
   object ob;
   class approval_obs approve;
   int pos;
   int i;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) == this_player()->query_name()) {
      //
      // Return the stuff to them.
      //
      return do_return(name);
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }


   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   //
   // Create the objects, browse them, kill them.
   //
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         ob = create_checkout_object(approve, pos, this_player());
         if (!ob) {
            write("Unable to create " + pos + approve->name + ", weird...\n");
         } else {
            obs += ({ ob });
         }
      } else {
         checkout += ({ create_checkout_object(approve, pos, this_player()) });
      }
   }

   checkout->move("/room/rubbish");

   if (!sizeof(obs) &&
       sizeof(checkout)) {
      if (sizeof(checkout) > 0) {
         add_failed_mess("$I are already checked out.\n", checkout);
      } else {
         add_failed_mess("$I is already checked out.\n", checkout);
      }
      return 0;
   }

   bad = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) != MOVE_OK) {
         bad += ({ ob });
         destroy_checkout_object(ob);
      }
   }

   if (sizeof(bad)) {
      write("Unable to move " + query_multiple_short(bad) + " into your "
            "inventory for you to check.\n");
   }

   obs -= bad;
   if (sizeof(obs)) {
      write("Moved " + query_multiple_short(obs) + " into your inventory "
            "for you to check.\n");
      add_succeeded_mess("$N check$s out $I.\n", obs);
   }

   return 1;
} /* do_approve_checkout() */

/**
 * This method checks in a checked out object.
 */
int do_approve_checkin(object* obs) {
   object ob;
   object* ok;

   ok = ({ });
   foreach (ob in obs) {
      if (is_checkout_object(ob)) {
         destroy_checkout_object(ob);
         ok += ({ ob });
      }
   }

   if (!sizeof(ok)) {
      add_failed_mess("None of $I have been checked out.\n", obs);
      return 0;
   }

   add_succeeded_mess("$N check$s $I back in.\n", ok);
   return 1;
} /* do_approve_checkin() */

/**
 * This method changes the name of the item to be approved.
 * @param name the reference
 * @param new_name the new name for the item
 */
int do_approve_name_change(string name, string new_name) {
   class approval_obs approve;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   approve = query_approval_class(name);
   if (!approve)  return 0;
   write("You change the name of the item waiting to be approved from " +
         approve->name + " to " + new_name + ".\n");
   approve->name = new_name;
   add_succeeded_mess( ({ "", "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
} /* do_approve_name_change() */

/**
 * This method changes the category of the item waiting to be approved.
 * @param name the reference
 * @param new_category the new category for the item
 */
int do_approve_category_change(string name, string new_category) {
   class approval_obs approve;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }

   approve->category = new_category;
   add_succeeded_mess(({
      "You change the category of the approval item " + name + ".\n",
      "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
} /* do_approve_category_change() */

/**
 * This method sets the automatic low acception level.
 * @param cost the cost to use a low level
 */
int do_approve_auto_low(string cost) {
   string place;
   int value;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = value_from_string(cost, place);
   _automatic_approval->low_cost = value;
   event_save(this_object());
   if (!value) {
      add_succeeded_mess(({ "You disable the automatic acception of items of "
                            "low value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }

   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "costing less than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_low() */

/**
 * This method sets the automatic high cut off level.
 * @param cost the cost to use a high cut off level
 */
int do_approve_auto_high(string cost) {
   string place;
   int value;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost = value;
      add_succeeded_mess(({ "You disable the automatic placing items into the "
                            "approve list of items of high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }

   _automatic_approval->high_cost = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically put any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) +
                         " into the approve list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_high() */

/**
 * This method sets the automatic high cut off level for denying sales.
 * @param cost the cost to use a high cut off level
 */
int do_approve_auto_high_deny(string cost) {
   string place;
   int value;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost_deny = 0;
      add_succeeded_mess(({ "You disable the automatic denying of items of "
                            "high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }

   _automatic_approval->high_cost_deny = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_high() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add(string item, string money, string list_name,
                             int markup, string money_str) {
   int value;
   string place;
   int final_cost;
   mixed app_item;
   class approval_item new_app_item;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }

   if (markup < 0) {
      markup = 0;
   }

   item = strip_quotes(item);
   list_name = strip_quotes(list_name);

   if (classp(_automatic_approval->items[item])) {
      app_item = ((class approval_item)_automatic_approval->items[item])->value;
   } else {
      app_item = _automatic_approval->items[item];
   }
   if (app_item == value) {
      add_failed_mess("The item " + item + " already has a cut off "
                      "value of " +
                      MONEY_HAND->money_value_string(value, place) + ".\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;

   place = query_property("place");

   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_add() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add_object(object *obs, string money,
                                    string list_name, int markup,
                                    string money_str) {
   int value;
   string place;
   object ob;
   string name;
   object *ok;
   object *bad;
   mixed item;
   class approval_item new_item;
   int final_cost;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   if (markup < 0) {
      markup = 0;
   }
   bad = ({ });
   ok = ({ });

   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      if (classp(_automatic_approval->items[name])) {
         item = ((class approval_item)_automatic_approval->items[name])->value;
      } else {
         item = _automatic_approval->items[name];
      }
      if (item == value) {
         bad += ({ name });
      } else {
         new_item = new(class approval_item);
         new_item->value = value;
         new_item->list_name = list_name;
         new_item->markup = markup;
         new_item->final_cost = final_cost;
         _automatic_approval->items[name] = new_item;
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You set the shop to automatically accept any of "
                         "$I up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   } else {
      add_failed_mess("You cannot set $I to a value limit of " +
                      MONEY_HAND->money_value_string(value, place) +
                      " since it already has this limit.\n");
      return 0;
   }
} /* do_approve_auto_item_add_object() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add_expr(string item, string expr,
                                  string list_name, int markup,
                                  string money_str) {
   class approval_item new_app_item;
   class parse_node* value;
   string place;
   int final_cost;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   if (markup < 0) {
      markup = 0;
   }

   item = strip_quotes(item);
   list_name = strip_quotes(list_name);

   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;

   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " with an expression "
                         "of " + query_expression_string(value, 1) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_add_expr() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add_object_expr(object *obs, string expr,
                          string list_name, int markup, string money_str) {
   class parse_node* value;
   object ob;
   string name;
   class approval_item new_item;
   int final_cost;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }

   if (money_str) {
      place = query_property("place");
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   if (markup < 0) {
      markup = 0;
   }
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      new_item = new(class approval_item);
      new_item->value = value;
      new_item->list_name = list_name;
      new_item->markup = markup;
      new_item->final_cost = final_cost;
      _automatic_approval->items[name] = new_item;
   }
   event_save(this_object());

   add_succeeded_mess(({ "You set the shop to automatically accept any of "
                      "$I with an expression "
                      "of " + query_expression_string(value, 1) +
                      (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                       "$N fiddle$s with something in the shop.\n" }), obs );
   return 1;
} /* do_approve_auto_item_add_object_expr */

/**
 * This method checks to see if the specified object can really be sold or
 * not automatically.
 * @param obs the objects to test
 */
int do_approve_auto_item_test(object* obs) {
   object ob;
   string place;
   mixed cost;
   int found;
   int allowed;
   class expression_type stuff;
   class parse_node frog;

   allowed = is_allowed(this_player()->query_name());

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   foreach (ob in obs) {
      found = 0;
      cost = _automatic_approval->items[ob->query_short()];
      if (classp(cost)) {
         cost = ((class approval_item)cost)->value;
      }
      if (cost) {
         if (pointerp(cost)) {
            frog = evaluate_expression(cost, this_player()->query_name(),
                                        0, ({ ob }), 0, 0);
            if (allowed) {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  query_expression_string(cost, 1) +
                  ";\n" + ob->query_short() + " - " +
                  MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            } else {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  " " + MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            }
         } else {
            write("$I$5=The item " + ob->the_short() + " can be sold if it "
              "costs less than " +
               MONEY_HAND->money_value_string(cost, place) +
               " (" + ob->query_short() + ").\n");
         }
         found |= 1;
      }

      foreach (stuff in _automatic_approval->expressions) {
         frog = evaluate_expression(stuff->condition,
                                    this_player()->query_name(),
                                    0, ({ ob }), 0, 0);
         if (frog->value) {
            if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
               frog = evaluate_expression(stuff->value,
                                      this_player()->query_name(),
                                      0, ({ ob }), 0, 0);
               if (allowed) {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        query_expression_string(stuff->value, 1) +
                        ";\n" + ob->query_short() + " - " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               } else {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               }
               found |= 2;
            }
            else found |= 4;
         }
      }
      if (found & 4)  {
         write("$I$5=The item " + ob->the_short() + " will be denied sale.\n");
      }
      else if (!found) {
         write("$I$5=The item " + ob->the_short() + " will not be "
               "automatically accepted.\n");
      }
   }
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_test() */

/**
 * This method sets the automatic items to allow.
 * @param item the item to accept
 */
int do_approve_auto_item_remove(string item) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   item = strip_quotes(item);
   if (!_automatic_approval->items[item]) {
      add_failed_mess("The item " + item + " is not in the list.\n");
      return 0;
   }

   map_delete(_automatic_approval->items, item);
   event_save(this_object());
   add_succeeded_mess(({ "You remove the item " + item +
                         " from the list of automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_remove() */

/**
 * This method sets the automatic items to allow.
 * @param item the item to accept
 */
int do_approve_auto_item_remove_object(object *obs) {
   object ob;
   object *bad;
   object *ok;
   string name;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   ok = ({ });
   bad = ({ });
   foreach (ob in obs) {
      name = ob->query_short();
      if (!_automatic_approval->items[name]) {
         bad += ({ ob });
      } else {
         ok += ({ ob });
         map_delete(_automatic_approval->items, name);
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You remove $I from the list of "
                            "automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   }
   add_failed_mess("None of $I are in the shops allow item list for you "
                   "to remove.\n", bad);
   return 0;
} /* do_approve_auto_item_remove() */

/**
 * This method sets the automatic expressions to allow.
 * @param expression the expressions short to allow
 */
int do_approve_auto_expression_add(string expression, string value_str,
                                   int type, string list_name) {
   class parse_node* expr;
   class parse_node* value;
   class expression_type bing;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }

   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      value = parse_money_string(value_str);
      if (!sizeof(value)) {
         add_failed_mess(query_last_expression_error() + ".\n");
         return 0;
      }
   }

   list_name = strip_quotes(list_name);
   bing = new(class expression_type);
   bing->type = type;
   bing->condition = expr;
   bing->value = value;
   bing->list_name = list_name;
   _automatic_approval->expressions += ({ bing });

   event_save(this_object());
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + " with a cost "
                         "of " + query_expression_string(value, 0) +
                         " as '" + list_name + "'.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
} /* do_approve_auto_expression_add() */

/**
 * This method removes an allowed expression
 * @param id the expression id to remove
 */
int do_approve_auto_expression_remove(string idstr) {
   class expression_type expr;
   int id;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   id = query_number_value(idstr);
   if (id == -1 || id >= sizeof(_automatic_approval->expressions)) {
      add_failed_mess("The id " + idstr + " is invalid.\n");
      return 0;
   }

   expr = _automatic_approval->expressions[id];
   _automatic_approval->expressions = _automatic_approval->expressions[0..id - 1] +
                                      _automatic_approval->expressions[id + 1..];

   event_save(this_object());
   add_succeeded_mess(({ "You remove the expression " +
                         query_expression_string(expr->condition, 1) +
                         " cost: " +
                         query_expression_string(expr->value, 1) +
                         " from the list of allowed expressions.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_remove() */

/**
 * This method sets the percentage to add to the sell price.
 * @param num the number to set the percentage to
 */
int do_approve_percentage(mixed num) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   if (num <= 0) {
      add_failed_mess("The percentage to add must be greator than 0.\n");
      return 0;
   }

   _automatic_percentage = num;
   add_succeeded_mess(({ "You set the percentage to add to the sale price "
                         "to " + _automatic_percentage + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_percentage() */

/**
 * This method sets the limit on number of items sellable by all the players.
 * @param limit the default limit
 */
int do_approve_limit(string limit) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   if (limit == "disable")  {
      _automatic_approval->num_allowed = 0;
      add_succeeded_mess(({ "You disable the default number of sold items "
                         "per person.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   else if (to_int(limit) > 0)  {
      _automatic_approval->num_allowed = to_int(limit);
      add_succeeded_mess(({ "You set the default number of sold items per "
                            "person to " + _automatic_approval->num_allowed + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   return 0;
} /* do_approve_limit() */

/**
 * This method sets the limit per person to be a specified value.
 * @param person the person to set a limit on
 * @param value the limit to set
 */
int do_approve_limit_person_items(string name, string value) {
   int amt;
   class seller_information info;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return 0;
   }

   amt = to_int(value);
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->max_sellable = amt;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }

   if (amt)
      add_succeeded_mess(({ "You set the maximum number of items sellable by " +
                            name + " to " + info->max_sellable + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
   else
      add_succeeded_mess(({ "You remove the limit for the maximum number of "
         "items sellable by " + name + ".\n",
         "$N fiddle$s with something in the shop.\n" }));
   return 1;
} /* do_approve_limit_person_items() */

/**
 * This method sets the limit at which a person can automatically sell
 * to the shop.
 * @param person the person to set a limit on
 * @param money the limit to set it to
 */
int do_approve_limit_person_value(string name, string money) {
   class seller_information info;
   int value;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }

   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }

      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }

   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->value_limit = value;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }

   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items automatically "
                            "approved by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items "
                         "automatically approved by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
} /* do_approve_limit_person_value() */

/**
 * This method sets the limit at which a person can automatically sell
 * to the shop (deny limit).
 * @param person the person to set a limit on
 * @param money the limit to set it to
 */
int do_approve_limit_person_value_deny(string name, string money) {
   class seller_information info;
   int value;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }

   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }

      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }

   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->deny_value_limit = value;
   if (info->deny_value_limit || info->max_sellable || info->value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }

   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items accepted by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->deny_value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items to be sold by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
} /* do_approve_limit_person_value() */

/**
 * This method removes any limits set on the player.
 * @param person the person to remove the limit on
 */
int do_approve_limit_person_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove limits "
                      "off someone.\n");
      return 0;
   }

   name = lower_case(name);

   if (!_sellers[name]) {
      add_failed_mess("The person " + name + " does not have any limits placed "
                      "on them.\n");
      return 0;
   }
   map_delete(_sellers, name);
   event_save(this_object());
   add_succeeded_mess(({ "You remove any limits set on " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_limit_person_remove() */

/**
 * This method adds the person to the black list.
 * @param person the person to add to the black list
 */
int do_approve_black_list_add(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("Sorry, " + name + " does not play here.\n");
      return 0;
   }

   if (is_allowed(name)) {
      add_failed_mess("This person is in the list of people allowed to use "
                      "the shop.  They cannot be put on a black list.\n");
      return 0;
   }

   if (member_array(name, _black_list) != -1) {
      add_failed_mess("The person " + name + " is already in the "
                      "black list.\n");
      return 0;
   }
   _black_list += ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You add " + name + " to the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_black_list_add() */

/**
 * This method adds their ignore list to the black list
 */
int do_approve_black_list_add_ignore() {
   string *people;
   string *bad;
   string *ok;
   string name;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }

   people = this_player()->query_property("ignoring");
   if (!people) {
      add_failed_mess("You are not ignoring anyone.\n");
      return 0;
   }

   bad = ({ });
   ok = ({ });
   foreach (name in people) {
      name = lower_case(name);

      if (!PLAYER_HANDLER->test_user(name)) {
         bad += ({ name });
      } else if (member_array(name, _black_list) != -1) {
         bad += ({ name });
      } else {
         _black_list += ({ name });
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (!sizeof(ok)) {
      add_failed_mess("Your ignore list is already added to the black list.\n");
      return 0;
   }

   add_succeeded_mess(({ "You add " + query_multiple_short(ok) + " to the "
                         "black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_black_list_add() */

/**
 * This method removes the person from the black list.
 * @param person the person to remove from the black list
 */
int do_approve_black_list_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove people from "
                      "the black list.\n");
      return 0;
   }

   name = lower_case(name);

   if (member_array(name, _black_list) == -1) {
      add_failed_mess("The person " + name + " is not in the black list.\n");
      return 0;
   }
   _black_list -= ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You remove " + name + " from the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_black_list_remove() */

/**
 * This method allows a function to be added to the base set of user 
 * functions.
 * @param def the name and arguements
 * @param expr the expression itself
 * @return 1 on success, 0  on failure
 */
int do_user_function_add(string def, string expr) {
   string name;

if (this_player()->query_name() != "presto")
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add functions to this store.\n");
      return 0;
   }

   //
   // Ok, try and parse the arguments and function name first.
   //
   name = parse_user_expression(def, expr);
   if (name) {
      if (strlen(query_last_expression_warning())) {
         write("WARNING!!! Any changes of types could cause expressions "
               "currently using the functions to fail.\n" +
               query_last_expression_warning());
      }
      write("You successfully add:\n" + query_user_function_string(name));
      add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
      event_save(this_object());
      return 1;
   }

   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
} /* do_user_function_add() */

/**
 * This method allows a function to be added to the base set of user 
 * functions.
 * @param def the name and arguements
 * @param expr the expression itself
 * @return 1 on success, 0  on failure
 */
int do_user_function_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove functions from this store.\n");
      return 0;
   }

   //
   // Ok, try and parse the arguments and function name first.
   //
   if (query_user_function_return_type(name) != EXPRESSION_TYPE_ERROR) {
      if (remove_user_expression(name)) {
         add_succeeded_mess(({ "You remove the function " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
         return 1;
      }
   }

   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
} /* do_user_function_remove() */

/**
 * This method shows the status of all the user defined functions.
 * These can be used in other exciting functions.
 */
int do_approve_status_internal_functions() {
   string* names;
   string name;
   string ret;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   names = query_function_names();
   ret = "Functions:\n";
   foreach (name in names) {
      ret += query_type_name(query_function_type(name)) + " " + name +
             "(" + implode(map(query_function_args_types(name),
                               (: query_type_name($1) :)), ", ") +
             ")\n";
   }

   ret += "\nVariables:\n";
   names = query_variable_names();
   foreach (name in names) {
      ret += query_type_name(query_variable_type(name)) + " " + name +
             "\n";
   }
   write("$P$Internal functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_status_functions() */

/**
 * Get help on a specific function.
 * @param name the name of the function to get help on
 */
int do_function_help(string name) {
   string nroff_fn;
   string str;
   string fname;

   fname = CRAFT_SHOP_EXPRESSION_HELP_DIR + name;
   if (file_size(fname) <= 0) {
      add_failed_mess("There is no help for the function '" + name + "'.\n");
      return 0;
   }

   nroff_fn = NROFF_DIR + replace(fname, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(fname, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }

   write("$P$function: " + name + "$P$" + str);
   return 1;
} /* do_function_help() */

/**
 * Get help on a specific function.
 * @param name the name of the function to get help on
 */
int do_function_help_list() {
   string *names;

   names = get_dir(CRAFT_SHOP_EXPRESSION_HELP_DIR);
   if (!sizeof(names)) {
      add_failed_mess("There is no help on any functions.\n");
      return 0;
   }

   names -= ({ ".", "..", "RCS" });

   write(sprintf("%-#*s\n", this_player()->query_cols(), implode(names, "\n")));
   return 1;
} /* do_function_help_list() */

/**
 * This method shows the status of all the user defined functions.
 * These can be used in other exciting functions.
 */
int do_approve_status_functions(int hints) {
   string* names;
   string name;
   string ret;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   names = query_user_function_names();
   if (!sizeof(names)) {
      add_failed_mess("Could not find any user defined expressions.\n");
      return 0;
   }
   ret = "";
   foreach (name in names) {
      ret += query_user_function_string(name) + "\n";
   }
   if (hints) {
      ret += "$I$0=       Hint: add function <function> as <expression>";
      ret += "$I$0=       Hint: remove function <function>";
   }
   write("$P$User functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_status_functions() */

/**
 * This method shows the current status of the shop.
 */
int do_approve_status(int status) {
   string ret;
   string place;
   mixed expr;
   string str;
   string name;
   class seller_information stuff;
   string *bits;
   int pos;
   int hint;
   int show_expr;
   class expression_type bing;
   class expression_type binger;
   class approval_item approval;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   hint = status & 1;
   show_expr = status & 2;

   ret = "";
   if (!show_expr) {
      ret += "$I$5=The owner of the shop is " + query_owner() + ".\n";
      ret += "$I$5=The name of the shop is " + _shop_name + ".\n";
      if (hint) {
         ret += "$I$0=       Hint: name shop <name>\n";
      }
      if (query_sign_object()) {
         ret += "$I$5=The shop currently has a sign set.\n";
      } else {
         ret += "$I$5=The shop does not currently have a sign set.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set sign <object>\n";
         ret += "$I$0=       Hint: remove sign\n";
      }
      if (sizeof(query_allowed())) {
         ret += "$I$5=People allowed to change the shop are " +
                query_multiple_short(sort_array(query_allowed(), 0)) + ".\n";
      } else if (hint) {
         ret += "$I$5=Only the owner can change the shop.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: allow <person>\n";
         ret += "$I$0=       Hint: deny <person>\n";
         ret += "$I$0=       Hint: allow list\n";
      }
      if (sizeof(_black_list)) {
         ret += "$I$5=People denied access to the shop are ";
         ret += query_multiple_short(sort_array(_black_list, 0)) + "\n";
      } else {
         ret += "$I$0=Noone is denied access to the shop.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: add <person> to blacklist\n";
         ret += "$I$0=       Hint: remove <person> from blacklist\n";
         ret += "$I$0=       Hint: add ignore to blacklist\n";
      }
      ret += "$I$0=\n";

      ret += "The current percentage to automatically add to the buy price is: " +
             _automatic_percentage + "%\n";
      if (hint) {
         ret += "$I$0=       Hint: markup <percent>\n";
      }
      ret += "Limits on what can be sold.\n";
      ret += "Maximum number of items allowed in the shop : ";
      if (query_maximum_inventory_size()) {
         ret += query_maximum_inventory_size() + " currently " +
                sizeof(query_controller()->query_sell_list_obs()) + " (fixed).\n";
      } else {
         ret += "disabled (fixed).\n";
      }
      ret += "Maximum number of items allowed per player  : ";
      if (_automatic_approval->num_allowed) {
         ret += _automatic_approval->num_allowed + ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set max number <number|disable>\n";
      }
      ret += "Automatically queue sales more than         : ";
      if (_automatic_approval->high_cost) {
         ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost, place) +
                ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set high queue cost <cost|disable>\n";
      }
      ret += "Automatically deny sales more than          : ";
      if (_automatic_approval->high_cost_deny) {
         ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost_deny, place) +
                ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set high deny cost <cost|disable>\n";
      }
      if (sizeof(_sellers)) {
         ret += "Limits set per player.\n";
         ret += sprintf("   %-15s %-15s %-20s %s\n", "Name", "Max Sellable",
                        "Approve Limit", "Deny limit (per item)");
         bits = sort_array(keys(_sellers), 0);
         foreach (name in bits) {
            stuff = _sellers[name];
            ret += sprintf("   %-15s %-15s %-20s %s\n", name,
                       (stuff->max_sellable?stuff->max_sellable+"":"disabled"),
                       (stuff->value_limit?MONEY_HAND->money_value_string(stuff->value_limit, place):"disabled"),
                       (stuff->deny_value_limit?MONEY_HAND->money_value_string(stuff->deny_value_limit, place):"disabled"));
         }
      } else {
         ret += "No limits set per player.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set max number <max sellable|disable> for <player>\n";
         ret += "$I$0=       Hint: set high queue cost <cost|disable> for <player>\n";
         ret += "$I$0=       Hint: set high deny cost <cost|disable> for <player> to <cost|disable>\n";
         //ret += "$I$0=       Hint: approve limit remove <player>\n";
      }

      ret += "\nAutomatically approve sales less than       : ";
      if (_automatic_approval->low_cost) {
         ret += MONEY_HAND->money_value_string(_automatic_approval->low_cost, place) +
                ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set low approve cost <cost|disable>\n";
      }
   }

   if (show_expr) {
      if (sizeof(_automatic_approval->items)) {
         ret += "$I$0=%^BOLD%^Automatically accept sales of items%^RESET%^\n";
         foreach (str, expr in _automatic_approval->items) {
            if (classp(expr)) {
               approval = (class approval_item)expr;
               expr = ((class approval_item)expr)->value;
            } else {
               approval = new(class approval_item);
            }
            if (pointerp(expr) && intp(expr[0])) {
               map_delete(_automatic_approval->items, str);
            } else {
               ret += sprintf("$I$10=   %-20s", "* " + str);
               if (sizeof(approval) == 3) {
                  approval = new(class approval_item,
                         markup : approval->markup,
                         value : approval->value,
                         list_name : approval->list_name,
                         final_cost : 0);
               }
               if (approval->list_name) {
                  ret += " listed as '" + approval->list_name + "'";
               }
               if (approval->markup) {
                  ret += " markup of " + approval->markup;
               }
               if (approval->final_cost) {
                  ret += " final cost of " +
                  MONEY_HAND->money_value_string(approval->final_cost, place);
               }
               ret += " max value:";
               if (pointerp(expr)) {
//printf("%O\n", str);
                  str = query_expression_string(expr, 0);
                  if (strsrch(str, "\n") != -1) {
                     ret += "\n" + str;
                  } else {
                     ret += str;
                  }
               } else {
                  ret += MONEY_HAND->money_value_string(expr, place);
               }
               ret += "\n";
            }
         }
      } else {
         ret += "Automatically accept sales of               : (none setup)\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: auto add name <name> up to <value>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> and markup <percentage>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> and value <final cost>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with value <final cost>\n";
         ret += "$I$0=       Hint: auto remove name <name>\n";
         ret += "$I$0=       Hint: auto remove object <object>\n";
      }
      ret += "\n$I$0=%^BOLD%^Automatic approval expressions.%^RESET%^\n";
      if (sizeof(_automatic_approval->expressions)) {
         //ret += "$I$0=Automatic approval expressions (if any of these evaluate as "
                //"true the item is accepted):\n";
         pos = 0;
         foreach (bing in _automatic_approval->expressions) {
            if (sizeof(bing) == 3) {
               binger = new(class expression_type);
               binger->type = bing->type;
               binger->condition = bing->condition;
               binger->value = bing->value;
               bing = binger;
               event_save(this_object());
            }

            if (bing->type != PLAYER_CRAFT_SHOP_EXPR_DENY) {
               str = query_expression_string(bing->value, 0);
               if (strsrch(str, "\n") != -1) {
                  str = "\n" + str;
               }
               str = " accept value: " + str;
               if (bing->list_name) {
                  str += " as " + bing->list_name;
               }
            } else {
               str = " -- deny item";
            }
            ret += "$I$5=" + query_letter_value(pos) + ") " +
                   query_expression_string(bing->condition, 0) + str + ".\n";
            pos++;
         }

      } else {
         ret += "$I$0=No automatic approval expressions setup.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: auto add approve expression <condition> cost <value> as <list name>\n";
         ret += "$I$0=       Hint: auto deny expression <expression>\n";
         ret += "$I$0=       Hint: auto remove expression <id>\n";
      }
   }

   ret += "\n$I$0=";
   if (sizeof(_buy_expression)) {
      ret += "Buy condition: " + query_expression_string(_buy_expression, 0) +
             ".\n";
   } else {
      ret += "Anyone can buy from the shop.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: buy expression <expression|disable>\n";
   }

   if (sizeof(_use_expression)) {
      ret += "Use condition: " + query_expression_string(_use_expression, 0) +
             ".\n";
   } else {
      ret += "Anyone can use the shop.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: use expression <expression|disable>\n";
   }

   if (!show_expr) {
      ret += "$I$0=Use 'expressions' to see the expressions.\n";
   }
   ret += "$I$0=Use 'functions' to see the user defined "
          "functions.\n";

   write("$P$Status$P$" + ret);

   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_status() */

/**
 * This method pays off the cash deficit (if one exists).
 */
int do_approve_pay_deficit() {
   int cost;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to pay off the deficit for " +
                      the_short() + ".\n");
      return 0;
   }

   if (query_owners_money() >= 0) {
      add_failed_mess("There is no deficit here to pay off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   cost = -query_owners_money();
   if (this_player()->query_value_in(place) >= cost) {
      adjust_royalty(query_owner(), cost);

      this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
      add_succeeded_mess("$N pay$s off the deficit in " + the_short() + ".\n");
      return 1;

   }
   add_failed_mess("You do not have enough money to pay off the deficit "
                   "of " + MONEY_HAND->money_value_string(cost, place) +
                   ".\n");
   return 0;
} /* do_approve_pay_deficit() */

/**
 * This method sets up the expression to use when calculating the
 * ability to buy from the shop.
 */
int do_approve_buy_expression(string str) {
   class parse_node* expr;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the shop.\n");
      return 0;
   }

   if (str == "disable")  {
      _buy_expression = ({ });
      add_succeeded_mess(({"You disable checking to see if someone "
         "can buy from the shop.\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n"}));
      return 1;
   }
   expr = parse_boolean_string(str);

   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _buy_expression = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can buy from the shop to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
} /* do_approve_buy_expression() */

/**
 * This method sets up the expression to use when calculating the
 * ability to use the shop.
 */
int do_approve_use_expression(string str) {
   class parse_node* expr;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the shop.\n");
      return 0;
   }

   if (str == "disable")  {
      _use_expression = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the shop.\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);

   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_expression = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the shop to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
} /* do_approve_use_expression() */

/**
 * This method allows the player to add a new category to the list.
 * @param category the new category name
 */
int do_add_new_category(string category) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }

   if (query_controller()->is_valid_category(category)) {
      add_failed_mess("The category already exists.\n");
      return 0;
   }

   add_shop_category(category);
   add_succeeded_mess("$N add$s a new category.\n");
   return 1;
} /* do_add_new_category() */

/**
 * This method allows the player to remove a category from the list.
 * @param category the category to remove
 */
int do_remove_category(string category) {
   object* obs;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove categories.\n");
      return 0;
   }

   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }

   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }


   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );

   if (sizeof(obs)) {
      add_failed_mess("The category '" + category + "' is not empty "
                     "and cannot be removed.\n");
      return 0;
   }

   write("Do you wish to remove the category " + category + " from " +
         the_short() + " (y/n)?");
   input_to("check_remove_category", 0, category);
   add_succeeded_mess(({ "", "$N removes a category from the shop.\n" }));
   return 1;
} /* do_remove_category() */

/**
 * This method allows the player to remove a category from the list.
 * @param category the category to rename
 * @param new_category the new name of a category
 */
int do_rename_category(string category, string new_category) {
   object* obs;
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to rename categories.\n");
      return 0;
   }

   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }

   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }

   add_shop_category(new_category);
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );

   if (sizeof(obs)) {
      foreach (ob in obs) {
         query_controller()->change_category_of_shop_object(ob, new_category);
      }
   }
   remove_shop_category(category);

   add_succeeded_mess("$N rename$s category " + category + " to " +
                      new_category + ".\n");
   return 1;
} /* do_rename_category() */

/**
 * This method is called into to check to see if we can remove the category.
 * @param answer their answer
 * @param category the category to remove
 */
protected void check_remove_category(string answer, string category) {
   class approval_obs approve;

   if (!strlen(answer) ||
       lower_case(answer)[0] != 'y') {
      write("Aborting deleting the category " + category + ".\n");
      return ;
   }

   remove_shop_category(category);
   write("Removed the shop category " + category + ".\n");
   foreach (approve in query_approval_list(0)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   foreach (approve in query_approval_list(1)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   event_save(this_object());
   return ;
} /* check_remove_category() */

/**
 * This method sets the default category for the place.
 * @param default_cat the default category
 */
int do_set_default_category(string default_cat) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set the default category.\n");
      return 0;
   }

   default_cat = query_real_category_name(default_cat);
   if (!default_cat ||
       !query_controller()->is_valid_category(default_cat)) {
      add_failed_mess("The category " + default_cat + " does not exist.\n");
      return 0;
   }

   set_default_category(default_cat);
   add_succeeded_mess("$N set$s the default category for " + the_short() +
                      ".\n");
   event_save(this_object());
   return 1;
} /* do_set_default_category() */

/**
 * This method lists the current categories and shows us which one is
 * currently the default.
 */
int do_list_categories() {
   string cat;
   string ret;

   ret = "";
   foreach (cat in query_controller()->query_categories()) {
      if (cat == query_default_category()) {
         ret += cat + " (default)\n";
      } else {
         ret += cat + "\n";
      }
   }

   write("$P$Category list$P$The current categories are:\n" + ret);
   add_succeeded_mess(({ "", "$N browses the categories.\n" }));
   return 1;
} /* do_list_categories() */

/**
 * This method gives the shop a name.
 */
int do_name_shop(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the name of " + the_short() + ".\n");
      return 0;
   }

   set_shop_name(name);
   add_succeeded_mess("$N set$s the shop name to '" + name + "'.\n");
   return 1;
} /* do_name_shop() */

/**
 * This method shows the stats on all the sold items, the number and value
 * of each one sold.
 * @param type the type of sorting to do
 */
int do_stats_items(int type) {
   class shop_stats stat;
   string ret;
   string *bits;
   string place;
   string name;


   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }

   if (!sizeof(_sell_stats)) {
      add_failed_mess("Nothing has been sold in this transaction section "
                      "yet.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   switch (type) {
   case 1:
      bits = sort_array(keys(_sell_stats), (: _sell_stats[$1]->num_sold - _sell_stats[$2]->num_sold :));
      break;
   case 2:
      bits = sort_array(keys(_sell_stats), (: _sell_stats[$1]->value_sold - _sell_stats[$2]->value_sold :));
      break;
   default :
      bits = sort_array(keys(_sell_stats), 0);
      break;
   }

   ret = "Statistics for items sold since " + ctime(_stats_start) + ".\n";
   foreach (name in bits) {
      stat = _sell_stats[name];
      ret += name + ": " + stat->num_sold + " for " +
             MONEY_HAND->money_value_string(stat->value_sold, place) + ".\n";
   }

   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
} /* do_stats_items() */

#if USE_TRANSACTIONS
/**
 * This method shows a list of all the transactions that have occured in the
 * shop.
 */
int do_stats_transactions() {
   class shop_transaction bing;
   string ret;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }

   ret = "Statistics for transactions since " + ctime(_stats_start) + ".\n";
   foreach (bing in _transactions) {
      ret += "$I$5=" + query_transaction_string(bing) + "\n";
   }

   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
} /* do_stats_transactions() */
#endif

/**
 * This method shows stats about money and stuff in the shop.
 */
int do_stats_money() {
   string ret;
   int stock_value;
   string place;
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "";
   ret += "\nCurrent money spent " +
          MONEY_HAND->money_value_string(_total_outgoing, place) +
          " and money made " +
          MONEY_HAND->money_value_string(_total_ingoing, place) + ".\n";

   foreach (ob in query_controller()->query_sell_list_obs()) {
      stock_value += ob->query_value();
   }

   ret += "The current stock value is " +
             MONEY_HAND->money_value_string(stock_value, place) +
          ".\n";

   ret += "\n";
   if (query_owners_money() > 0) {
      ret += "The owner current has a cash float (royalties) of " +
             MONEY_HAND->money_value_string(query_owners_money(), place) +
             ".\n";
   } else if (query_owners_money() < 0) {
      ret += "The owner current has a cash deficit of " +
             MONEY_HAND->money_value_string(-query_owners_money(), place) +
             ".\n";
   }

   write(ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
} /* do_stats_money() */

/**
 * This method sets the sign you wish to use for your shop.
 * The sign will be displayed outside the shop for passer bys.
 * @param obs the sign
 */
int do_set_sign(object* obs) {
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the shop.\n");
      return 0;
   }

   if (sizeof(obs) > 1) {
      add_failed_mess("You must only specifiy one sign.\n");
      return 0;
   }

   if (living(obs[0])) {
      add_failed_mess("You have to wait till " + obs[0]->the_short() +
                      " dies first.\n");
      return 0;
   }

   if (obs[0]->get()) {
      add_failed_mess("Cannot set something as a sign that you cannot get.\n");
      return 0;
   }

   ob = query_sign_object();
   if (obs[0]->move("/room/rubbish") == MOVE_OK) {
      set_sign_object(obs[0]);
   } else {
      add_failed_mess("Unable to move $I off you.\n", obs[0..0]);
      return 0;
   }
   if (query_sign_object() != ob) {
      if (ob) {
         ob->set_get();
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         add_succeeded_mess(({ "You remove the sign " +ob->the_short() +
                               " and set " + obs[0]->the_short() +
                               " as your shop sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      } else {
         add_succeeded_mess(({ "You set " + obs[0]->the_short() +
                               " as your shop sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      }
      return 1;
   } else {
      obs[0]->move(this_player());
      add_failed_mess("You cannot set the sign for some reason.\n");
      return 0;
   }
} /* do_set_sign() */

/**
 * This method removes the sign from the shop.
 */
int do_remove_sign() {
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the shop.\n");
      return 0;
   }

   if (!query_sign_object()) {
      add_failed_mess("You cannot remove the sign since there is no sign.\n");
      return 0;
   }

   ob = query_sign_object();
   ob->set_get();
   if (ob->move(this_player()) == MOVE_OK) {
      add_succeeded_mess("$N $V $I from " + the_short() +
                         ".\n", ({ ob }));
      set_sign_object(0);
      return 1;
   } else {
      ob->reset_get();
      add_failed_mess("You cannot remove the sign, unable to hold it?\n");
      return 0;
   }
} /* do_remove_sign() */

/**
 * This method collects royalities up to a certain amount.  This is
 * only usable by the owner of the shop.
 * @param amount the amount to collect
 * @return 1 on success, 0 on failure
 */
int do_collect_partial_royalties(string amount) {
   int amt;
   string place;

   if (query_owner() != this_player()->query_name()) {
      add_failed_mess("Only the owner can do this.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }

   if (amt > query_owners_money()) {
      add_failed_mess("You cannot collect more money than you have.\n");
      return 0;
   }

   query_controller()->pay_out_royalty(this_player()->query_name(), place, amt);
   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
} /* do_collect_partial_royalites() */

private int variable_player_level(string seller, int cost, object* ob) {
   return PLAYER_HANDLER->test_level(seller);
} /* variable_player_level() */

private string variable_player_guild(string seller, int cost, object* ob) {
   string guild;

   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      return guild->query_name();
   }
   return "";
} /* variable_player_guild() */

private string variable_player_order(string seller, int cost, object* ob) {
   string guild;

   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      guild = guild->query_wizard_order();
      if (guild) {
         return replace_string(lower_case(guild), "_", " ");
      }
   }
   return "";
} /* variable_player_order() */

private string variable_player_deity(string seller, int cost, object* ob) {
   string deity;

   deity = PLAYER_HANDLER->test_deity(seller);
   if (deity) {
      return deity;
   }
   return "";
} /* variable_player_deity() */

private string variable_player_family(string seller, int cost, object* ob) {
   string family;

   family = PLAYER_HANDLER->test_family(seller);
   if (family) {
      return family;
   }
   return "";
} /* variable_player_family() */

private int function_object_base_value(object* obs, string seller, int cost, object* fluff) {
   int value;
   object ob;
   int tmp;

   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_base_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
} /* function_object_base_value() */

private int function_object_value(object* obs, string seller, int cost, object* fluff) {
   int value;
   object ob;
   int tmp;

   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
} /* function_object_value() */

private int function_object_condition(object* obs, string seller, int cost, object* fluff) {
   int cond;
   object ob;
   int tmp;
   int max;

   cond = 100;
   foreach (ob in obs) {
      tmp = ob->query_cond();
      max = ob->query_max_cond();
      if (max) {
         tmp = tmp * 100 / max;
         if (tmp < cond) {
            cond = tmp;
         }
      }
   }
   return cond;
} /* function_object_condition() */

private int function_object_enchant(object*obs, string seller, int cost, object* fluff) {
   int enchant;
   object ob;
   int tmp;
   int max;
   string bing;

   if (!sizeof(obs)) {
      return 0;
   }

   //
   // First check to see if any of the owners can actually detect this.
   //
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_octarine()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_octarine()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }

   enchant = 100;
   foreach (ob in obs) {
      tmp = ob->query_enchant();
      max = ob->query_max_enchant();
      tmp = tmp * 100 / max;
      if (tmp < enchant) {
         enchant = tmp;
      }
   }
   return enchant;
} /* function_object_enchant() */

private object* variable_objects(string seller, int cost, object* obs) {
   return obs;
} /* function_object_type() */

private string function_object_type(object* obs, string seller, int cost, object* fluff) {
   string type;
   string old_type;
   object ob;

   if (!sizeof(obs)) {
      return 0;
   }

   //
   // First check to see if any of the owners can actually detect this.
   //
   foreach (ob in obs) {
      if (ob->query_weapon()) {
         type = "weapon";
      } else if (ob->query_armour()) {
         type = "armour";
      } else if (ob->query_clothing()) {
         type = "clothing";
      } else {
         type = "misc";
      }
      if (old_type && old_type != type) {
         type = "mixed";
      }
      old_type = type;
   }

   return type;
} /* function_object_type() */

private object* function_object_stolen(object* obs, string seller, int cost, object* fluff) {
   obs = filter(obs, (: $1->query_property("stolen") :));
   return obs;
} /* function_object_stolen() */

private object* function_object_warded(object* obs, string seller, int cost, object* fluff) {
   string classification;

   classification = "/std/effects/object/ward"->query_classification();
   obs = filter(obs, (: sizeof($1->effects_matching($2)) :), classification);
   return obs;
} /* function_object_warded() */

private string variable_sale_name(string seller, int cost, object* ob, string name, string category) {
   if (name) {
      return lower_case(name);
   }
   return "";
} /* variable_sale_name() */

private string variable_sale_category(string seller, int cost, object* ob, string name, string category) {
   if (category) {
      return lower_case(category);
   }
   return "";
} /* variable_sale_category() */

private int variable_sale_cost(string seller, int cost, object* ob, string name, string category) {
   return cost;
} /* variable_sale_category() */

private object* function_object_contains_spell(object* obs, string spell_name,
                          string seller, int cost, object* fluff) {
   string bing;
   int tmp;

   if (!sizeof(obs)) {
      return 0;
   }

   //
   // First check to see if any of the owners can actually detect this.
   //
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_spells()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_spells()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }

   obs = filter(obs, (: $1->query_magic_scroll() &&
           ($2 == "any" || lower_case($1->query_spell_name()) == lower_case($2)) :), spell_name);
   return obs;
} /* function_object_contains_spell() */

private object* function_object_contains_imbue(object* obs, string ritual_name,
                          string seller, int cost, object* fluff) {
   if (!sizeof(obs)) {
      return ({ });
   }


   obs = filter(obs, (: $1->query_faith_imbue() &&
      ($2 == "any" ||
       lower_case($1->query_ritual_name()) == lower_case($2)) :), ritual_name );
   return obs;
} /* function_object_contains_ritual() */

private int function_object_percentage_liquid(object* obs, string liquid_name,
                          string seller, int cost, object* fluff) {
   object ob;
   object* liquids;
   object liq;
   int volume;
   int found;
   int tmp;

   if (!sizeof(obs)) {
      return 0;
   }

   volume = 100;
   foreach (ob in obs) {
      //
      // See what liquids are in the object
      //
      liquids = filter(all_inventory(ob), (: $1->query_liquid() :));
      if (sizeof(liquids))  {
         foreach (liq in liquids) {
            if (liq->query_short() &&
                lower_case(liq->query_short()) == lower_case(liquid_name)) {
               tmp = liq->query_weight() * 100 / ob->query_max_weight();
               if (tmp < volume) {
                  volume = tmp;
                  found = 1;
               }
            }
         }
      }
      // Problem: some things (like healing vials) don't actually have
      // anything in them.  So we have to do something different.
      else if (ob->query_liquid_short() &&
               lower_case(ob->query_liquid_short()) ==
               lower_case(liquid_name))
      {
         tmp = ob->query_water_volume() * 100 / ob->query_max_volume();
         if (tmp < volume)  {
            volume = tmp;
            found = 1;
         }
      }
   }
   if (found) {
      return volume;
   }
   return 0;
} /* function_object_percentage_liquid() */

private int function_object_charges(object* obs, string seller, int cost, object *fluff)  {
   int total = 0;
   int possible = 0;
   int charges;
   mixed info;
   object ob;

   foreach (ob in obs)  {
      charges = ob->query_charges();
      if (charges)  {
         info = ob->query_static_auto_load();
         if (pointerp(info)  &&  sizeof(info) == 2  &&  info[0] == charges)  {
            possible += info[1] * CHARGE_MULT;
            total += charges;
         }
      }
   }
   if (possible)
      return 100 * total / possible;
   else
      return 0;
} /* function_object_charges() */

private object* function_object_matching(object* obs, string match,
                          string seller, int cost, object* fluff) {
   object ob;
   string *bits;
   string bit;
   object* ret;

   bits = explode(match, ",");
   ret = ({ });
   foreach (ob in obs)  {
      foreach(bit in bits)   {
         if (ob && ob->full_id(bit)) {
            ret += ({ ob });
         }
      }
   }
   return ret;
} /* function_object_matching() */

private object* function_object_short(object* obs, string match,
                          string seller, int cost, object* fluff) {
   string* bits;
   object* result;

   bits = explode(match, ",");
   result = filter(obs, (: member_array($1->query_short(), $2) != -1 :),
                   bits);
   return result;
} /* function_object_short() */

private int function_inventory_number(string inventory_type,
                          string seller, int cost, object* fluff) {
   object* result;
   int quantity;
   string lc_type;

/*
   lc_type = lower_case(inventory_type);
   if (undefinedp(_num_checked_so_far[lc_type])) {
      _num_checked_so_far[lc_type] = 1;
   }
 */

   result = filter(query_controller()->query_sell_list_obs(),
     (: lower_case(query_controller()->query_name_of_shop_object($1)) == $2 :),
                   lc_type);
   quantity = sizeof(result); //  + _num_checked_so_far[lc_type];

   //++_num_checked_so_far[lc_type];
   return quantity;
} /* function_inventory_number() */

private int function_club_member(string club, string seller, int cost, object* ob) {
   return CLUB_HANDLER->is_member_of(club, seller);
} /* function_club_member() */

private object* function_contents(object ob, string seller, int cost, object* obs) {
   if (!ob) {
      return ({ });
   }
   return all_inventory(ob);
} /* function_contents() */

/**
 * Tells the playe they have some royalties to pick up.
 * @param player the player to tell about the royalties
 */
void inform_of_royalties(object player) {
   if (player && environment(player) == this_object()) {
      tell_object(player, "You have some royalties to pick up.\n");
   }
} /* inform_of_royalties() */

void init() {
   if (query_controller()->query_royalty(this_player()->query_name())) {
      call_out("inform_of_royalties", 5);
   }
   add_command("waiting", "", (: do_list_approval(1) :));
   add_command("waiting", "unapproved", (: do_list_approval(0) :));
   add_command("reject", "<string'id'>",
               (: do_approve_reject($4[0], 0, -1) :));
   add_command("retrieve", "<string'id'>", (: do_return($4[0]) :) );
   add_command("return", "<string'id'>", (: do_return($4[0]) :) );
   add_command("value", "<indirect:object>",
               (: do_approve_auto_item_test($1) :));
   if (!is_allowed(this_player()->query_name())) {
      ::init();
      return ;
   }

   add_command("approve", "<string'id'>", (: do_approve_item($4[0], 0) :));
   add_command("approve", "<string'id'> for <string'value'>",
               (: do_approve_item($4[0], $4[1]) :));
   add_command("reject", "<string'id'> position <number>",
               (: do_approve_reject($4[0], 0, $4[1]) :));
   add_command("reject", "<string'id'> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[1], -1) :));
   add_command("reject", "<string'id'> position <number> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[2], $4[1]) :));
/*
   add_command("approve", "reject <string'id'> <number'position'>",
               (: do_approve_reject_num($4[0], $4[1]) :));
 */
   add_command("set", "low approve cost <string'cost|disable'>",
               (: do_approve_auto_low($4[0]) :));
   add_command("auto", "add approve expression <string'condition'> cost <string'value'> as <string'list name'>",
               (: do_approve_auto_expression_add($4[0], $4[1],
                            PLAYER_CRAFT_SHOP_EXPR_ACCEPT, $4[2]) :));
   add_command("auto", "add deny expression <string'condition'>",
               (: do_approve_auto_expression_add($4[0], 0,
                            PLAYER_CRAFT_SHOP_EXPR_DENY, 0) :));
   add_command("auto", "remove expression <string'id'>",
               (: do_approve_auto_expression_remove($4[0]) :));
   add_command("markup", "<number'percentage'>",
               (: do_approve_percentage($4[0]) :));
   add_command("auto", "add name <string'name'> up to <string'value'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "remove name <string'name'>",
               (: do_approve_auto_item_remove($4[0]) :));
   add_command("auto", "remove object <indirect:object>",
               (: do_approve_auto_item_remove_object($1) :));
   add_command("set", "high queue cost <string'cost|disable'>",
               (: do_approve_auto_high($4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'>",
               (: do_approve_auto_high_deny($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'>",
               (: do_approve_limit($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'> for <string'player'>",
               (: do_approve_limit_person_items($4[1], $4[0]) :));
   add_command("set", "high queue cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value($4[1], $4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value_deny($4[1], $4[0]) :));
   add_command("approve", "limit remove <string'player'>",
               (: do_approve_limit_person_remove($4[0]) :));
   add_command("add", "<string'player'> to blacklist",
               (: do_approve_black_list_add($4[0]) :));
   add_command("add", "ignore to blacklist",
               (: do_approve_black_list_add_ignore() :));
   add_command("remove", "<string'player'> from blacklist",
               (: do_approve_black_list_remove($4[0]) :));
   add_command("add",
               "function <string'function'> as <string'expression'>",
               (: do_user_function_add($4[0], $4[1]) :));
   add_command("remove",
               "function <string'function'>",
               (: do_user_function_remove($4[0]) :));
   add_command("status", "",
               (: do_approve_status(0) :));
   add_command("expressions", "",
               (: do_approve_status(2) :));
   add_command("functions", "internal",
               (: do_approve_status_internal_functions() :));
   add_command("functions", "",
               (: do_approve_status_functions(0) :));
   add_command("functions", "help list",
               (: do_function_help_list() :));
   add_command("functions", "help <string'function name'>",
               (: do_function_help($4[0]) :));
   add_command("functions", "hints",
               (: do_approve_status_functions(1) :));
   add_command("expressions", "hints",
               (: do_approve_status(3) :));
   add_command("status", "hints",
               (: do_approve_status(1) :));
   add_command("browse", "waiting <string'id'>",
               (: do_approve_browse($4[0]) :));
   add_command("checkout", "<string'id'>",
               (: do_approve_checkout($4[0]) :));
   add_command("checkin", "<indirect:object>",
               (: do_approve_checkin($1) :));
   add_command("pay", "deficit",
               (: do_approve_pay_deficit() :));
   add_command("buy", "expression <string'expression|disable'>",
               (: do_approve_buy_expression($4[0]) :));
   add_command("use", "expression <string'expression|disable'>",
               (: do_approve_use_expression($4[0]) :));

   add_command("name", "shop <string'shop name'>",
               (: do_name_shop($4[0]) :));

   add_command("set", "sign <indirect:object'sign'>",
               (: do_set_sign($1) :) );
   add_command("remove", "sign",
               (: do_remove_sign() :) );

   add_command("stats", "items by name", (: do_stats_items(0) :));
   add_command("stats", "items by number", (: do_stats_items(1) :));
   add_command("stats", "items by value", (: do_stats_items(2) :));
#if USE_TRANSACTIONS
   add_command("stats", "transactions", (: do_stats_transactions() :));
#endif
   add_command("stats", "money", (: do_stats_money() :));

   add_command("check", "sell <indirect:object>",
                (: do_check_sell($1) :));

   add_command("category", "list", (: do_list_categories() :));
   add_command("category", "default <string'category'>",
               (: do_set_default_category($4[0]) :));
   add_command("category", "add <string'category'>",
               (: do_add_new_category($4[0]) :));
   add_command("category", "remove <string'category'>",
               (: do_remove_category($4[0]) :));
   add_command("category", "rename <string'category'> to <string'category'>",
               (: do_rename_category($4[0], $4[1]) :));

   add_command("collect", "royalties of <string'amount'>",
               (: do_collect_partial_royalties($4[0]) :));

   ::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category_modify.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category_modify.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629818   Available: 13577172
Inodes: Total: 5242880    Free: 4960136
4739 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category_modify.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629818   Available: 13577172
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room will handle craft shop like things, where you sell stuff to
 * the store and it will sell it onto other players after taking
 * a margin.  This can be used for potions, pottery, swords, anything!
 * @author Pinkfish
 * @started Thu Feb  5 15:39:57 CST 1998
 */
#include <money.h>
#include <shops/craft_shop.h>

inherit "/std/shops/inherit/craft_shop_category";

private nosave int _minimum_age_to_vote;
private nosave int _minimum_age_to_nominate;
private nosave int _minimum_number_nominated;
private nosave int _minimum_number_voted;
private nosave int _percentage_needed_creation;
private nosave int _percentage_needed_deletion;
private nosave int _nomination_time;
private nosave int _election_time;
private nosave int _deletion_time;

#define DAY (24 * 60 * 60)

//
// Predefinitions.
//
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables);
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories);

void create() {
   if (!_minimum_age_to_vote) {
      _minimum_age_to_vote = 2 * DAY;
   }
   if (!_minimum_age_to_nominate) {
      _minimum_age_to_nominate = 10 * DAY;
   }
   if (!_minimum_number_nominated) {
      _minimum_number_nominated = 4;
   }
   if (!_nomination_time) {
      _nomination_time = 7 * DAY;
   }
   if (!_election_time) {
      _election_time = 7 * DAY;
   }
   if (!_deletion_time) {
      _deletion_time = 7 * DAY;
   }
   if (!_minimum_number_voted) {
      _minimum_number_voted = 20;
   }
   if (!_percentage_needed_creation) {
      _percentage_needed_creation = 75;
   }
   if (!_percentage_needed_deletion) {
      _percentage_needed_deletion = 75;
   }
   ::create();
} /* create() */

/**
 * This is the function used as a call back from the controller to deal with
 * category based stuff.
 * @param name the name of the category being processed
 * @param state the state the category is currently in
 * @param voted the number of people who voted
 * @param yes the number who voted yes
 * @param no the number who voted no
 * @param abstain the number who abstained
 * @return 0 on error, timeout of the next stage
 */
protected int category_function(string name,
                      int state,
                      string* voted,
                      int yes,
                      int no,
                      int abstain) {
   switch (state) {
   case CRAFT_CATEGORY_STATE_NOMINATING :
      if (sizeof(voted) > _minimum_number_nominated) {
         return _election_time;
      }
      break;
   case CRAFT_CATEGORY_STATE_VOTING :
      if (sizeof(voted) > _minimum_number_voted) {
         if (yes * 100 / (no + yes) >= _percentage_needed_creation) {
            return 1;
         }
      }
      break;
   case CRAFT_CATEGORY_STATE_DELETEING :
      if (sizeof(voted) > _minimum_number_voted) {
         if (yes * 100 / (no + yes) >= _percentage_needed_deletion) {
            return 1;
         }
      }
   }
   return 0;
} /* category_function() */

/**
 * This method sets the minimum age you need to be to vote in category
 * elections.
 * @param age the minimum age to vote
 */
void set_minimum_age_to_vote(int age) {
   _minimum_age_to_vote = age;
} /* set_minimum_age_to_vote() */

/**
 * This method sets the minimum age you need to be to nominate a new
 * category.
 * @param age the minimum age to nominate
 */
void set_minimum_age_to_nominate(int age) {
   _minimum_age_to_nominate = age;
} /* set_minimum_age_to_nominate() */

/*
 * This method sets the minimum number of people you need before a
 * nomination is successful.
 * @param num the minimum number of people to nominate
 */
void set_minimum_nomination_number(int num) {
   _minimum_number_nominated = num;
} /* set_minimum_nomination_number() */

/**
 * This method sets the amount of time it takes for a category nomination
 * to go through the process.
 * @param time the nomination time
 */
void set_nomination_time(int tim) {
   _nomination_time = tim;
} /* set_nomination_time() */

/**
 * This method sets the amount of time it takes for a category election
 * to go through the process.
 * @param time the election time
 */
void set_election_time(int tim) {
   _election_time = tim;
} /* set_election_time() */

/**
 * This method sets the amount of time it takes for a category deletion
 * to go through the process.
 * @param time the deletion time
 */
void set_deletion_time(int tim) {
   _deletion_time = tim;
} /* set_deletion_time() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category_modify.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/commercial.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629817   Available: 13577171
Inodes: Total: 5242880    Free: 4960136
44167 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/commercial.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629817   Available: 13577171
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the file that is the basic inheritable for commercial
 * properties.  The only different between commercial properties and
 * player housing properties is that commerical ones can deal with
 * signs and commercial furniture.
 * @author Pinkfish
 * @started Fri Apr 21 13:37:44 PDT 2000
 */
#include <player.h>
#include <move_failures.h>
#include <expressions.h>
#include <money.h>
#include <player_handler.h>
#include <mail.h>
inherit "/std/room/player_housing";
inherit "/std/shops/inherit/expression_util";
inherit "/std/shops/inherit/person_expressions";

#define COMMERCIAL_WEEKLY_STATS_TIME (7 * 24 * 60 * 60)
#define COMMERCIAL_ROYALTY_TIMEOUT_PERIOD (7 * 24 * 60 * 60)

class float_withdrawls {
   string person;
   int amount;
   int withdrawl_time;
}

class weekly_status {
   int total_incoming;
   int total_outgoing;
   class float_withdrawls* withdrawls;
}

class royalty_data {
   int value;
   int last_withdrawl;
}

private string* _auto_load_sign_str;
private int _broken_sign;
private string _property_name;
private mapping _royalties;
private class parse_node* _use_expression;
private class parse_node* _entry_cost;
private int _entry_time_limit;
private mapping _use_type_expressions;
private string* _black_list;
private int _last_stats;
private class weekly_status _weekly_status;
private int _commercial_id;

private nosave object _sign_ob;
private nosave string _parcel_post;
private nosave object* _commercial_things;
private nosave string _use_type;
private nosave string _commercial_type;
private nosave string _save_dir;
private nosave int _property_size;
private nosave string _language;

#define COMMERCIAL_SALESPERSON "/obj/monster/commercial"

private string variable_use_type(string seller);

void create() {

    _commercial_things = ({ });
    _royalties = ([ ]);
    _use_type_expressions = ([ ]);
    _property_size = 25;
    _black_list = ({ });
    _last_stats = time();
    _weekly_status = new(class weekly_status);
    _weekly_status->withdrawls = ({ });
    _language = "common";
    expression_util::create();
    player_housing::create();
    
    // This is pointless, since setup hasn't been called yet, so it won't
    // have loaded the data yet and will never have a property name for us
    // to use.
    //
    // Instead, we handle it by masking short() (the other solutions were
    // fairly vile).  Leaving it here in case other code in this method
    // needs similar treatment, and a generally more satisfactory solution
    // is found for this problem too.
    //
    // if (_property_name) {
    //     set_short(_property_name);
    //     add_property("determinate", "");
    // }

    person_expressions::create();

    add_allowed_variable("type", EXPRESSION_TYPE_STRING,
                        (: variable_use_type :));
    set_expression_type("room");
    add_help_file("commercial");

    if (!_use_expression) {
        _use_expression = parse_boolean_string("false");
    }

    if (!_black_list) {
        _black_list = ({ });
    }

    if (!_last_stats) {
        _last_stats = time();
    }

    if (_last_stats + COMMERCIAL_WEEKLY_STATS_TIME - time() < 0) {
        call_out("mail_weekly_status", 0);
    }
    else {
        call_out("mail_weekly_status", _last_stats + 
            COMMERCIAL_WEEKLY_STATS_TIME - time());
    }

} /* create() */


/**
 * This gets round the problems with setting the property name before
 * we have a save file.
 */
string short() {

    if (_property_name) {
        set_short(_property_name);
        add_property("determinate", "");
    }
    return ::short();
    
} /* short() */


/**
 * This gets round the problems with setting the property name before
 * we have a save file.
 */
string long(string word, int dark) {

    if (_property_name) {
        set_short(_property_name);
        add_property("determinate", "");
    }
    return ::long(word, dark);
    
} /* long() */


/**
 * This method is called to try and see if the property is open for
 * the specific type of thingy attempted.
 * @param type the type of thing
 */
int is_open_for(string type, string person) {
   class parse_node ret;

   if (is_allowed(person)) {
      return 1;
   }

   // People black listed cannot use the property.
   if (member_array(person, _black_list) != -1) {
      return 0;
   }

   // Check and see what the use expressions are setup as.
   _use_type = type;
   ret = evaluate_expression(_use_expression, this_player()->query_name());
   if (ret->value) {
      if (_use_type_expressions[type]) {
         ret = evaluate_expression(_use_type_expressions[type],
                                   this_player()->query_name());
      }
   }
   return ret->value;
} /* is_open_for() */

/**
 * This method checks returns the main room.  THis is used when the
 * property can have multiple sub-rooms.
 * @return the main room
 */
object query_main_room() {
   return this_object();
} /* query_main_room() */

/**
 * This method adds a commercial thing into the list of current
 * commercial things.
 * @param thing the thing to add
 */
void add_commercial_thing(object ob) {
   _commercial_things += ({ ob });
   // Make them load themselves after they are in the room.
   ob->load_me();
} /* add_commercial_thing() */

/**
 * This method removes a commercil thing from the list of current
 * commercial things.
 * @param thing the thing to remove
 */
void remove_commercial_thing(object thing) {
   // Finish saving any extra needed data after they are removed.
   thing->save_me();
   _commercial_things -= ({ thing });
} /* remove_commercial_thing() */

/**
 * This method returns the current list of commercial things in
 * the room.
 * @return the list of commercial things
 */
object* query_commercial_things() {
   return _commercial_things;
} /* query_commercial_things() */

/**
 * This method figures out how much float the owner has in the current
 * property.
 * @return the current float
 */
int query_owners_money() {
   if (classp(_royalties[query_owner()])) {
      return ((class royalty_data)_royalties[query_owner()])->value;
   }
   return 0;
} /* query_owners_money() */

/**
 * This method adds money into the specified person's royalty
 * float.
 * @param person the person to add the royalty to
 * @param amount the amount to add
 */
void adjust_royalty(string person, int amount) {
   if (is_allowed(person)) {
      if (!_weekly_status) {
         _weekly_status = new(class weekly_status);
         _weekly_status->withdrawls = ({ });
      }
      if (amount > 0) {
         _weekly_status->total_incoming += amount;
      } else {
         _weekly_status->total_outgoing += -amount;
      }
      if (!classp(_royalties[query_owner()])) {
         _royalties[query_owner()] = new(class royalty_data, 
                      value : amount + _royalties[query_owner()],
                      last_withdrawl : time());
      } else {
         if (((class royalty_data)_royalties[query_owner()])->value == 0) {
            ((class royalty_data)_royalties[query_owner()])->last_withdrawl = time();
         }
         ((class royalty_data)_royalties[query_owner()])->value += amount;
      }
   } else {
      if (!classp(_royalties[person])) {
         _royalties[person] = new(class royalty_data, 
                      value : amount + _royalties[person],
                      last_withdrawl : time());
      } else {
         if (((class royalty_data)_royalties[person])->value == 0) {
            ((class royalty_data)_royalties[person])->last_withdrawl = time();
         }
         ((class royalty_data)_royalties[person])->value += amount;
      }
   }
   event_save(this_object());
} /* adjust_royalty() */

/**
 * This method returns the amount of money in the specified person's
 * royalty float.
 */
int query_royalty(string person) {
   if (classp(_royalties[person])) {
      return ((class royalty_data)_royalties[person])->value;
   }
   return 0;
} /* query_royalty() */

/**
 * This method returns the float of the property.  The float is the
 * owner's current royalty balance.
 * @return the float of the property
 */
int query_float() {
   return query_owners_money();
} /* query_float() */

/**
 * This method returns true for any commercial property.
 * @return 1 for commercial property
 */
int query_commercial_property() {
   return 1;
} /* query_commercial_property() */

/**
 * This method sets the parcel post to use for rejecting items.
 * @param parcel the parcel post office
 */
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
} /* set_parcel_post() */

/**
 * This method tells us the current parcel post used for rejecting items.
 * @return the current parcel post
 */
string query_parcel_post() {
   return _parcel_post;
} /* query_parcel_post() */

/**
 * This sets the language items in the shop should be displayed in,
 * if a language is required.
 * @param language the language to use
 */
void set_language(string language) {
   _language = language;
}

/**
 * This method returns the language items in the shop should use if they
 * need to use a language.
 */
string query_language() {
   return _language;
}

/**
 * This method sets the commercial type of the property.
 * @param name the commecial type
 */
void set_commercial_type(string name) {
   _commercial_type = name;
} /* set_commercial_type() */

/**
 * This method returns the commercial type of the property.
 * @return the commercial type of the property
 */
string query_commercial_type() {
   return _commercial_type;
} /* query_commercial_type() */

/**
 * This method sets the name of the property.
 * @param name the name of the property
 */
void set_property_name(string name) {
  if(strsrch(name, "%^") != -1)
    return 0;
  
   _property_name = name;
   add_property("determinate", "");
   set_short(_property_name);
} /* set_property_name() */

/**
 * This method returns the name of the property.
 * @return the name of the property
 */
string query_property_name() {
   return _property_name;
} /* query_property_name() */

/** @ignore yes */
void event_dest_me(object ob) {
   if (_sign_ob) {
      _sign_ob->dest_me();
   }
} /* event_dest_me() */

/**
 * This method returns the current sign object for the property.
 * @return the current sign object
 */
object query_sign_object() {
   object* obs;
   if (!_sign_ob && _auto_load_sign_str && !_broken_sign) {
      if (catch(obs = (PLAYER_OB)->load_auto_load_to_array(_auto_load_sign_str))) {
         _broken_sign = 1;
      } else {
         if (sizeof(obs)) {
            _sign_ob = obs[0];
            _sign_ob->reset_get();
         } else {
            _broken_sign = 1;
         }
      }
   }
   return _sign_ob;
} /* query_sign_object() */

/**
 * This method sets the current sign object.
 * @param sign the new sign object
 */
void set_sign_object(object ob) {
   if (ob) {
      _auto_load_sign_str = (PLAYER_OB)->create_auto_load(({ ob }));
      ob->reset_get();
   } else {
      _auto_load_sign_str = 0;
   }
   _sign_ob = ob;
   event_save(this_object());
} /* set_sign_object() */

/** @ignore yes */
void set_save_file(string str) {
   printf("ERROR!  Do not use set_save_file.\n");
} /* set_save_file() */

/**
 * This method sets the save directory for the the room.
 * @param dir the directory to save stuff in
 */
void set_save_dir(string dir) {
   if (dir[<1] != '/') {
      dir += "/";
   }
   _save_dir = dir;
   ::set_save_file(dir + "_main");
} /* set_save_dir() */

/**
 * This method returns the save directory for the room.  This should be
 * used as a reference point for other save stuff.
 * @return the save directory
 */
string query_save_dir() {
   return _save_dir;
} /* query_save_dir() */

/**
 * This method finds a unique commercial id in the room to use as new
 * save file.
 * @return a unique commercial id for the room
 */
int find_next_commercial_id() {
   object *obs;

   obs = all_inventory();
   while (file_size(query_save_dir() + _commercial_id) >= 0 ||
          file_size(query_save_dir() + _commercial_id + ".o") >= 0 ||
          file_size(query_save_dir() + _commercial_id + ".o.gz") >= 0 ||
          sizeof(filter(obs,
                        (: $1->query_commercial_id() == _commercial_id :)))) {
      _commercial_id++;
   }
   event_save(this_object());
   return _commercial_id;
} /* find_next_commercial_id() */

/**
 * This method sets the size of the property.  The property size ranges
 * from 0 (no size) to 100 (big shop).
 * @param size the new size of the property
 */
void set_property_size(int size) {
   _property_size = size;
} /* set_property_size() */

/**
 * This method returns the size of the property.  The property size ranges
 * from 0 (no size) to 100 (big shop).
 * @return the property size
 */
int query_property_size() {
   return _property_size;
} /* query_property_size() */

/**
 * This method resets the weekly status when the stats are mailed out.
 * It will also reset all the commercial objects.
 */
void reset_weekly_status() {
   object ob;

   _weekly_status = new(class weekly_status);
   _weekly_status->withdrawls = ({ });
   foreach (ob in _commercial_things) {
      if (ob) {
         ob->reset_weekly_status();
      }
   }
} /* reset_weekly_status() */

/**
 * This method returns the string that will be sent to the owners at the
 * end of the week.
 * @return the weekly status
 */
string query_weekly_status_string() {
   string place;
   string ret;
   string str;
   object ob;
   class float_withdrawls withdrawl;

   place = query_property("place");

   if (!_weekly_status) {
      _weekly_status = new(class weekly_status);
      _weekly_status->withdrawls = ({ });
   }

   ret = "";
   ret += "\n$I$0=---=== " + the_short() + " ===---\n";
   ret += "Total outgoing   : " +
          MONEY_HAND->money_value_string(_weekly_status->total_outgoing, place) + "\n";
   ret += "Total incoming   : " +
          MONEY_HAND->money_value_string(_weekly_status->total_incoming, place) + "\n";
   if (sizeof(_weekly_status->withdrawls)) {
      ret += "Float withdrawls:\n";
      foreach (withdrawl in _weekly_status->withdrawls) {
         ret += "$I$6=   " + ctime(withdrawl->withdrawl_time)[0..11] + " " +
                withdrawl->person + " for " +
                MONEY_HAND->money_value_string(withdrawl->amount, place) + "\n";
      }
   } else {
      ret += "No withdrawls from the float.\n";
   }

   foreach (ob in _commercial_things) {
      if (ob) {
         str = ob->query_weekly_status_string();
         if (str) {
            ret += "\n$I$0=---=== " + ob->the_short() + " ===---\n";
            ret += str;
         }
      }
   }

   return ret;
} /* query_weekly_status_string() */


/**
 * This method will mail out the weekly status for the shop.
 */
protected void mail_weekly_status() {
   string str;
   string ret;
   class royalty_data data;
   string person;

   if(!query_owner()) {
      return;
   }

   foreach (person, data in _royalties) {
      if (classp(data)) {
         if (person != query_owner() &&
             data->value > 0 &&
             data->last_withdrawl +
                  COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
            AUTO_MAILER->auto_mail(person,
                                   the_short(),
                                   "Lost royalties.",
                                   0,
                                   "You took too long to collect your "
                                   "royalties and they vanished.\n\n"
                                   "Good luck!\n"
                                   "Administrator.");
            map_delete(_royalties, person);
         }
      }
   }

   ret = catch(str = query_weekly_status_string());
   if (ret) {
      AUTO_MAILER->auto_mail(query_owner(),
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        implode(query_allowed(), ","),
                        "The weekly stats generated an error: " + ret + "\n");
      AUTO_MAILER->auto_mail("pinkfish",
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        0,
                        "The weekly stats generated an error: " + 
                        ret + "\nin room: " + file_name(this_object()) + "\n");
   } else {
      str = PLAYER_OB->convert_message(str);
      AUTO_MAILER->auto_mail(query_owner(),
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        implode(query_allowed(), ","),
                        str);
   }
   _last_stats = time();

   // Now, update the costs.
   foreach (object ob in _commercial_things) {
      adjust_royalty(query_owner(), -ob->query_weekly_upkeep_cost());
   }

   event_save(this_object());
   reset_weekly_status();
   event_save(this_object());
} /* mail_weekly_status() */

/**
 * This function will try and track down a specific type of commercial
 * object in the current location.  It will look into 'partitioned'
 * rooms for the item as well.
 * @param type the type to look for
 * @return the object found
 */
object* find_commercial_items(string type) {
   object* obs;

   obs = filter(all_inventory(this_object()),
                (: $1->query_commercial_name() == $2 :), type);
   return obs;
} /* query_object_found() */

/**
 * This registers a set of use types so they can be seen and controlled.
 * @param types the list of types to register
 */
void register_use_types(string* types) {
   string bing;

   if (!_use_type_expressions) {
      _use_type_expressions = ([ ]);
   }
   foreach (bing in types) {
      if (!_use_type_expressions[bing]) {
         _use_type_expressions[bing] = parse_boolean_string("true");
      }
   }
} /* register_use_types() */

/**
 * This method gives the property a name.
 */
int do_name_property(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the name of " + the_short() + ".\n");
      return 0;
   }

   set_property_name(name);
   add_succeeded_mess("$N set$s the property name to '" + name + "'.\n");
   return 1;
} /* do_name_property() */

/**
 * This method sets the sign you wish to use for your property.
 * The sign will be displayed outside the property for passer bys.
 * @param obs the sign
 */
int do_set_sign(object* obs) {
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the property.\n");
      return 0;
   }

   if (sizeof(obs) > 1) {
      add_failed_mess("You must only specifiy one sign.\n");
      return 0;
   }

   if (living(obs[0])) {
      add_failed_mess("You have to wait till " + obs[0]->the_short() +
                      " dies first.\n");
      return 0;
   }

   if (obs[0]->get()) {
      add_failed_mess("Cannot set something as a sign that you cannot get.\n");
      return 0;
   }

   ob = query_sign_object();
   if (obs[0]->move("/room/rubbish") == MOVE_OK) {
      set_sign_object(obs[0]);
   } else {
      add_failed_mess("Unable to move $I off you.\n", obs[0..0]);
      return 0;
   }
   if (query_sign_object() != ob) {
      if (ob) {
         ob->set_get();
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         add_succeeded_mess(({ "You remove the sign " +ob->the_short() +
                               " and set " + obs[0]->the_short() +
                               " as your property sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      } else {
         add_succeeded_mess(({ "You set " + obs[0]->the_short() +
                               " as your property sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      }
      return 1;
   } else {
      obs[0]->move(this_player());
      add_failed_mess("You cannot set the sign for some reason.\n");
      return 0;
   }
} /* do_set_sign() */

/**
 * This method removes the sign from the property.
 */
int do_remove_sign() {
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the property.\n");
      return 0;
   }

   if (!query_sign_object()) {
      add_failed_mess("You cannot remove the sign since there is no sign.\n");
      return 0;
   }

   ob = query_sign_object();
   ob->set_get();
   if (ob->move(this_player()) == MOVE_OK) {
      add_succeeded_mess("$N $V $I from " + the_short() +
                         ".\n", ({ ob }));
      set_sign_object(0);
      return 1;
   } else {
      ob->reset_get();
      add_failed_mess("You cannot remove the sign, unable to hold it?\n");
      return 0;
   }
} /* do_remove_sign() */

/** @ignore yes */
int do_status(int hint) {
   string ret;
   object ob;
   string str;
   string place;
   string fluff;
   class parse_node* expr;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   place = query_property("place");

   ret = "";
   ret += "$I$5=The owner of the property is " + query_owner() + ".\n";
   ret += "$I$5=The name of the property is " + _property_name + ".\n";
   if (hint) {
      ret += "$I$0=       Hint: name property <name>\n";
   }
   if (sizeof(_black_list)) {
      ret += "$I$5=The black list is " +
             query_multiple_short(_black_list) + ".\n";
   } else {
      ret += "$I$5=The black list is empty.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: blacklist add <name>\n";
      ret += "$I$0=       Hint: blacklist add ignore\n";
      ret += "$I$0=       Hint: blacklist remove <name>\n";
   }
   if (query_sign_object()) {
      ret += "$I$5=The property currently has a sign set.\n";
   } else {
      ret += "$I$5=The property does not currently have a sign set.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set sign <object>\n";
      ret += "$I$0=       Hint: remove sign\n";
   }
   if (sizeof(query_allowed())) {
      ret += "$I$5=People allowed to change the property are " +
             query_multiple_short(sort_array(query_allowed(), 0)) + ".\n";
   } else if (hint) {
      ret += "$I$5=Only the owner can change the property.\n";
   }

   ret += "$I$5=Current float is " +
          MONEY_HAND->money_value_string(query_float(), place) + ".\n";

   if (sizeof(_use_expression)) {
      ret += "$I$5=Use condition: " + query_expression_string(_use_expression, 0) +
             ".\n";
   } else {
      ret += "$I$5=Anyone can use the shop.\n";
   }
   foreach (fluff, expr in _use_type_expressions) {
      ret += "$I$5=  Use " + fluff + " condition: " +
             query_expression_string(expr, 0) + ".\n";
   }

   ret += "$I$0=\n";

   foreach (ob in _commercial_things) {
      if (ob) {
         str = ob->query_main_status(hint);
         if (str) {
            ret += str;
         }
      }
   }

   write("$P$Status$P$" + ret);
   return 1;
} /* do_status() */

/** @ignore yes */
int do_weekly_status() {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   write("$P$Weekly Status$P$" + query_weekly_status_string());
   return 1;
} /* do_weekly_status() */

/**
 * This method sets up the expression to use when calculating the
 * ability to use the shop.
 */
int do_use_expression(string str) {
   class parse_node* expr;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the property.\n");
      return 0;
   }

   if (str == "disable")  {
      _use_expression = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the property.\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);

   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_expression = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the property to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
} /* do_use_expression() */

/**
 * This method sets up the expression to use when calculating the
 * ability to use the shop.
 */
int do_use_expression_type(string type, string str) {
   class parse_node* expr;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the property.\n");
      return 0;
   }

   if (!_use_type_expressions[type]) {
      add_failed_mess("The type '" + type + "' is invalid, must be one "
                      "of " +
                      query_multiple_short(keys(_use_type_expressions)) +
                      ".\n");
      return 0;
   }

   if (str == "disable")  {
      _use_type_expressions[type] = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the property for " + type + ".\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);

   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_type_expressions[type] = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the property for " +
                            type + " to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
} /* do_use_expression_type() */

/**
 * This method shows any royalties that you might be able to collect.
 * @return 1 on succes, 0 on failure
 */
int do_royalties() {
   string place;
   class royalty_data data;

   // Check to make sure the shop is open.
   if (!is_open_for("royalty", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }

   if (!classp(_royalties[this_player()->query_name()]) &&
       _royalties[this_player()->query_name()] != 0) {
      data = new(class royalty_data,
                 value : _royalties[this_player()->query_name()],
                 last_withdrawl : time());
     _royalties[this_player()->query_name()] = data;
   }

   data = _royalties[this_player()->query_name()];
   if (!data) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }

   if (this_player()->query_name() != query_owner() && data->value > 0) {
      if (data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
         write("Your royalties timed out before you could claim them.\n");
         map_delete(_royalties, this_player()->query_name());
      }
   }

   if (data->value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }

   if (data->value == 0) {
      map_delete(_royalties, this_player()->query_name());
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   add_succeeded_mess(({ "You have " +
                      MONEY_HAND->money_value_string(data->value, place) +
                      " in royalties currently which will timeout in " +
                      query_time_string(data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time(), 2) + ".\n",
                      "$N checks $p royalties.\n" }));
   return 1;
} /* do_royalites() */

/**
 * This method shows any royalties that you might be able to collect.
 * @return 1 on succes, 0 on failure
 */
int do_royalty_list() {
   string place;
   mixed value;
   class royalty_data data;
   string person;
   string ret;

   // Check to make sure the shop is open.
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Only the property owners can do this.\n");
      return 0;
   }

   if (!sizeof(_royalties)) {
      add_failed_mess("No one has royalties here currently.\n");
      return 0;
   }

   place = query_property("place");
   ret = "";
   foreach (person in sort_array(keys(_royalties), 0)) {
      value = _royalties[person];
      if (!classp(value)) {
         data = new(class royalty_data, value : value, last_withdrawl : time());
      } else {
         data = value;
      }
      if (PLAYER_HANDLER->test_user(person)) {
         ret += capitalize(person) + " " +
                MONEY_HAND->money_value_string(data->value, place);
         if (person != query_owner()) {
            ret += " (Timeout: " + query_time_string(data->last_withdrawl +
                     COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time(), 2) + ")\n";
         } else {
            ret += "\n";
         }
      } else {
         map_delete(_royalties, person);
      }
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   write("$P$Royalties$P$" + ret);
   return 1;
} /* do_royalites() */

/**
 * This method shows the current royalties you can pick up.
 */
int do_collect() {
   string place;
   string name;
   class royalty_data data;

   if (!is_open_for("royalty", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   name = this_player()->query_name();
   if (!classp(_royalties[this_player()->query_name()]) &&
       _royalties[this_player()->query_name()] != 0) {
      data = new(class royalty_data,
                 value : _royalties[this_player()->query_name()],
                 last_withdrawl : time());
     _royalties[this_player()->query_name()] = data;
   }

   data = _royalties[name];

   if (!data) {
      add_failed_mess("You have no royalties to collect.\n");
      return 0;
   }

   if (name != query_owner() && data->value > 0) {
      if (data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
         write("Your royalties timed out before you could claim them.\n");
         map_delete(_royalties, name);
         return 1;
      }
   }

   if (data->value == 0) {
      map_delete(_royalties, this_player()->query_name());
   }

   if (this_player()->query_refresh_time() &&
       this_player()->query_refresh_time() > data->last_withdrawl) {
      add_failed_mess("You have refreshed since your last collection.\n");
      map_delete(_royalties, name);
      return 0;
   }

   if ((!data || !data->value) && is_allowed(this_player()->query_name())) {
      name = query_owner();
      data = _royalties[name];
   }

   if (data->value > 0) {
      this_player()->adjust_money(MONEY_HAND->create_money_array(data->value, place));
      if (name == query_owner()) {
         _weekly_status->withdrawls += ({ new(class float_withdrawls, amount : data->value,
                               person : name,
                               withdrawl_time : time() ) });
      }
      event_save(this_object());
      add_succeeded_mess(({ "You collect " +
                            MONEY_HAND->money_value_string(data->value, place) +
                            " in royalties.\n",
                            "$N collects some royalties.\n" }));
      data->value = 0;
      if (!data->value && name != query_owner()) {
         map_delete(_royalties, name);
      }
      return 1;
   } else if (!data->value) {
      add_failed_mess("You have no royalties to collect.\n");
   } else {
      if (this_player()->query_value_in(place) < -data->value) {
         add_failed_mess("You do not have enough money to pay off "
                         "your debts.\n");
         return 0;
      }
      this_player()->pay_money(MONEY_HAND->create_money_array(-data->value, place),
                               place);
      add_succeeded_mess(({ "You pay off " +
                            MONEY_HAND->money_value_string(data->value, place) +
                            " in debt.\n",
                            "$N pays off some debt.\n" }));
      if (name != query_owner()) {
         map_delete(_royalties, name);
      } else {
         data->value = 0;
      }
      return 1;
   }
} /* do_collect() */

/**
 * This method collects royalities up to a certain amount.  This is
 * only usable by the owner of the shop.
 * @param amount the amount to collect
 * @return 1 on success, 0 on failure
 */
int do_collect_partial_royalties(string amount) {
   int amt;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Only the owners can do this.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }

   if (amt > query_owners_money()) {
      add_failed_mess("You cannot collect more money than you have.\n");
      return 0;
   }

   this_player()->adjust_money(MONEY_HAND->create_money_array(amt, place));
   ((class royalty_data)_royalties[query_owner()])->value -= amt;
   if (!((class royalty_data)_royalties[query_owner()])->value) {
      map_delete(_royalties, query_owner());
   }
   if (!_weekly_status) {
      _weekly_status = new(class weekly_status);
      _weekly_status->withdrawls = ({ });
   }
   _weekly_status->withdrawls += ({ new(class float_withdrawls, amount : amt,
                                        person : this_player()->query_name(),
                                        withdrawl_time : time() ) });
   event_save(this_object());

   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
} /* do_collect_partial_royalites() */

/**
 * This method lets the person pay for entry into the premesis.
 */
int do_pay_entry() {
   string place;
   class parse_node ret;

   if (!_entry_cost) {
      add_failed_mess("Entry into " + the_short() + " is free.\n");
      return 0;
   }

   if (!is_open_for("entry", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }

   ret = evaluate_expression(_entry_cost, this_player()->query_name());
   if (this_player()->query_value_in(place) < ret->value) {
      add_failed_mess("You do not have the " +
                      MONEY_HAND->money_value_string(ret->value, place) +
                      " needed to enter.\n");
      return 0;
   }

   this_player()->pay_money(MONEY_HAND->create_money_array(ret->value, place),
                            place);
   // Time limit is in hours.
   this_player()->add_property(file_name(this_object()),
                               _entry_time_limit * 60 * 60);
   add_succeeded_mess("$N pay$s " +
                      MONEY_HAND->money_value_string(ret->value, place) +
                      " for entry into " + the_short() + ".\n");
   return 1;
} /* do_pay_entry() */

/**
 * Adds money into the float for the shop.
 * @param amount the amount to add to the float
 */
int do_add_royalties(string amount) {
   int amt;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot add to the float.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }

   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to add to the float.\n");
      return 0;
   }

   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                            place);
   if (!classp(_royalties[query_owner()])) {
       int value;

       value = _royalties[query_owner()];
       _royalties[query_owner()] = new(class royalty_data,
            value : value,
            last_withdrawl : time());
   }
   ((class royalty_data)_royalties[query_owner()])->value += amt;
   add_succeeded_mess(({ "You add " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to " + poss_short() + " float.\n",
                      "$N fiddles about in " + the_short() + ".\n" }));
   return 1;
} /* do_add_royalties() */

/**
 * This methof calls ups the estate person to purchase stuff off.
 */
int do_purchase() {
   object ob;

   ob = clone_object(COMMERCIAL_SALESPERSON);
   ob->move(this_object(), "$N arrives in a flash.\n");
   ob->set_commercial_type(query_commercial_type());
   ob->do_start_speil(this_player());
   return 1;
} /* do_purchase() */

/**
 * This method deposits money into the float
 * @param obs the objects which could be money
 */
int do_deposit(object* obs) {
   object* monies;
   object money;
   string place;

   monies = filter(obs, (: $1->id(MONEY_ALIAS) :));
   if (!sizeof(monies)) {
      add_failed_mess("YOu cannot deposit any of $I.\n", obs);
      return 0;
   }

   money = monies[0];
   place = query_property("place");
   monies = MONEY_HAND->filter_legal_tender(money, place);
   if (monies[1]) {
      monies[1]->move(this_player());
//write(monies[0]->the_short());
   }
   if (!monies[0]) {
      add_failed_mess("You must use legal tender.\n");
      return 0;
   }

   adjust_royalty(query_owner(), monies[0]->query_value_in(place));
   monies[0]->move("/room/rubbish");
   add_succeeded_mess(({ "$N $V $I into " + the_short() + ".\n",
                         "$N $V some money into " + the_short() + ".\n" }),
                      monies[0..0]);
   event_save(this_object());
   return 1;
} /* do_deposit() */

/**
 * This method adds the person to the black list.
 * @param person the person to add to the black list
 */
int do_black_list_add(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("Sorry, " + name + " does not play here.\n");
      return 0;
   }

   if (is_allowed(name)) {
      add_failed_mess("This person is in the list of people allowed to use "
                      "the shop.  They cannot be put on a black list.\n");
      return 0;
   }

   if (member_array(name, _black_list) != -1) {
      add_failed_mess("The person " + name + " is already in the "
                      "black list.\n");
      return 0;
   }
   _black_list += ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You add " + name + " to the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_black_list_add() */

/**
 * This method adds their ignore list to the black list
 */
int do_black_list_add_ignore() {
   string *people;
   string *bad;
   string *ok;
   string name;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }

   people = this_player()->query_property("ignoring");
   if (!people) {
      add_failed_mess("You are not ignoring anyone.\n");
      return 0;
   }

   bad = ({ });
   ok = ({ });
   foreach (name in people) {
      name = lower_case(name);

      if (!PLAYER_HANDLER->test_user(name)) {
         bad += ({ name });
      } else if (member_array(name, _black_list) != -1) {
         bad += ({ name });
      } else {
         _black_list += ({ name });
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (!sizeof(ok)) {
      add_failed_mess("Your ignore list is already added to the black list.\n");
      return 0;
   }

   add_succeeded_mess(({ "You add " + query_multiple_short(ok) + " to the "
                         "black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_black_list_add() */

/**
 * This method removes the person from the black list.
 * @param person the person to remove from the black list
 */
int do_black_list_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove people from "
                      "the black list.\n");
      return 0;
   }

   name = lower_case(name);

   if (member_array(name, _black_list) == -1) {
      add_failed_mess("The person " + name + " is not in the black list.\n");
      return 0;
   }
   _black_list -= ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You remove " + name + " from the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_black_list_remove() */

private string variable_use_type(string seller) {
   return _use_type;
} /* variable_player_guild() */

int do_measure() {

    this_player()->add_succeeded_mess( this_object(), 
        ({
            "$N $V up the size of the property and calculate that it is "
            "about " + query_num(query_property_size()) + " square yards.\n",
            "$N $V up the size of the property.\n"
        }), ({ }) );
    return 1;
    
} /* do_measure() */


void init() {
   if (!_royalties) {
      _royalties = ([ ]);
   }
   player_housing::init();
   expression_util::init();
   add_command("collect", "royalties", (: do_collect() :));
   add_command("royalties", "", (: do_royalties() :));
   add_command("royalty", "", (: do_royalties() :));
   add_command("measure", "property", (: do_measure() :) );

   // The following commands are owner-only
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }

   add_command("royalty", "list", (: do_royalty_list() :));
   add_command("royalties", "list", (: do_royalty_list() :));
   add_command("collect", "royalties of <string'amount'>",
               (: do_collect_partial_royalties($4[0]) :));
   add_command("royalty", "add <string'amount'> to float",
               (: do_add_royalties($4[0]) :));
   add_command("deposit", "[to] float <indirect:object>",
               (: do_deposit :));

   add_command("status", "room",
               (: do_status(0) :));
   add_command("status", "room {hint|hints}",
               (: do_status(1) :));
   add_command("status", "room weekly",
               (: do_weekly_status() :));

   add_command("name", "property <string'property name'>",
               (: do_name_property($4[0]) :));

   add_command("set", "use expression <string'expression'>",
               (: do_use_expression($4[0]) :));
   add_command("set",
               "use expression for <string'type'> as <string'expression'>",
               (: do_use_expression_type($4[0], $4[1]) :));
   add_command("set", "sign <indirect:object'sign'>",
               (: do_set_sign($1) :) );
   add_command("remove", "sign",
               (: do_remove_sign() :) );

   add_command("blacklist", "add <string'person'>",
               (: do_black_list_add($4[0]) :));
   add_command("blacklist", "add ignore",
               (: do_black_list_add_ignore() :));
   add_command("blacklist", "remove <string'person'>",
               (: do_black_list_remove($4[0]) :));

   add_command("purchase", "stuff", (: do_purchase() :));
      
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/commercial.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/vault_entry.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/vault_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629806   Available: 13577160
Inodes: Total: 5242880    Free: 4960136
10453 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/vault_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629806   Available: 13577160
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: vault_entry.c,v 1.2 2002/11/07 16:19:42 carmine Exp $
 */
/**
 * Standard vault inheritable object. There are two inheritables (this one and
 * /std/vault.c) which are provided to make it easy to setup your own
 * vaults.
 * This object should be inherited by your vault entrance area. It is used to
 * define most of the customisation for your vault.
 *
 * You must use set_vault_name and set_vault_entrance. You must also define
 * a vault proprietor NPC and use set_proprietor() to let the system know
 * which NPC it is. You should also check for this proprietors location and
 * existance every reset. You may also want to provide some protection to
 * prevent the NPC being killed too frequently.
 *
 * @author Ceres
 * @see /std/vault_entrance.c
 */
#include <money.h>
#include <vault.h>

#define PTS proprietor->the_short()
#define TIME_LIMIT 500

#define SPAM_GUARD (60 * 3)


void add_exit(string name, string dest, string type);
void modify_exit(string name, mixed* stuff);
mixed query_property(string name);
void add_property(string name, mixed value);
void remove_property(string name);

string location, vault_name, vault_room;
int visit_cost, open_cost;
object proprietor;

/* Setup functions which should be called by the child of this object to
   set the properties of a specific vault */

/**
 * This function is used to set the location used for calculation of which
 * currency the vault proprietor will accept.
 * @param location The name of the location.
 */
void set_location(string str) { location = str; }

/**
 * This is used to set the cost to open an account (in monetary units)
 * @param cost The cost of a new account
 */
void set_open_cost(int i) { open_cost = i; }

/**
 * This is used to set the cost of a visit to the vault (in monetary units)
 * @param cost The cost of a vist
 */
void set_visit_cost(int i) { visit_cost = i; }

/**
 * This is the object that is the proprietor of the vault. This should be an
 * NPC.
 * @param proprietor The proprietor NPC object.
 */
void set_proprietor(object ob) { proprietor = ob; }

/**
 * Used to set the name of the vault, as used for the save file. This should
 * be a unique name for this vault.
 * @param name The name of the vault.
 */
void set_vault_name(string str) { vault_name = str; }

/**
 * Used to set the exit from this vault entrance room into the vault itself.
 * The parameters are just like those of add_exit.
 * @param direction The direction of the exit.
 * @param dest The destination object. Usually the filename of the destination.
 * @param type An exit type as in add_exit.
 * @return void
 * @see add_exit
 */
void set_vault_exit(string direc, mixed dest, string type) {
  vault_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}

/**
 * @ignore yes
 *
 * Internal function used to setup a new account.
 */
int apply_for_account() {
  string owner;
  object container;

  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  
  /* We don't want one... */
  this_player()->add_succeeded_mess( this_object(), "", ({ }) );

  write("You ask for an account.\n");
  say((string)this_player()->one_short() +" asks for an account.\n");

  owner = (string)this_player()->query_name();

  // I have no idea why this spam guard stuff is in here, but I've left it
  // just in case :)
  if ( master()->file_exists( VAULT_SAVE +vault_name+ "/"+ owner +".o" ) ||
       query_property( owner ) ) 
  {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you already have an "
         "account." );
      return notify_fail("");
    }
   
    proprietor->do_command( "say You already have an account!" );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }

  if ( this_player()->query_value_in( location) < open_cost ) {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you don't have enough money!" );
      return notify_fail("");
    }
   
    proprietor->do_command("say You do not have the "+
                           (string)MONEY_HAND->money_value_string(open_cost,
                                                                  location) +
                           " that it costs to open an account." );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }

  proprietor->do_command("say Very well, that'll be "+
                         (string)MONEY_HAND->money_value_string( open_cost,
                                                                 location) +
                         ", please." );
  this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( open_cost,
                                                                     location),
                            location);
  write( "You pay "+PTS+".\n" );
  say( (string)this_player()->the_short() +" pays "+proprietor->the_short()+
       ".\n" );

  proprietor->do_command("say As a new account holder, "
                         "your first use of the facility will be free.  "
                         "Thereafter, it will cost "+
                         (string)MONEY_HAND->money_value_string( visit_cost,
                                                                 location) +
                         " each time.");
  add_property( owner, 1 );

  // Force it to make a save file
  container = vault_room->init_container(this_player());
  container->dest_me();
  
  return 1;
} /* apply_for_account() */

/**
 * @ignore yes
 */
void init() {
  add_command( "apply", "for [an] account", (: apply_for_account :) );
} /* init() */

/**
 * @ignore yes
 *
 * Internal function to check if this player is a customer
 */
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  
  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  
  // Added by Oaf, 15 Oct 2000, to stop NPCs wandering into vaults.
  if( !interactive(thing) )
    return 0;

  owner = (string)thing->query_name();
  
  if ( !master()->file_exists( VAULT_SAVE +vault_name+ "/" + owner +".o" ) &&
       !query_property( owner ) ) 
  {
    tell_object( thing, PTS+
                 " intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+
               (string)thing->the_short() +".\n",
               thing );

    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have an account "
         "so I won't let you in!" );
      return notify_fail("");
    }

    proprietor->do_command("say You do not have an account!");
    if( interactive(thing) )
      proprietor->do_command("say For "+
                             (string)MONEY_HAND->money_value_string(open_cost,
                                                                    location)+
                             ", you could apply for an account.\n" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  
  if ( !( vroom = find_object( vault_room ) ) ) {
    vault_room->load_me();
    vroom = find_object( vault_room );
  }

  if( sizeof( filter_array( all_inventory( vroom ), (: userp( $1 ) :) ) ) ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short() 
       +".\n", thing );

    if( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just told you, someone is using the "
         "facility at the moment!" );
      return notify_fail("");
    }

    proprietor->do_command("say Someone is using the facility at the moment!");
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
    
  if( query_property( owner ) ) {
    remove_property(owner);
    tell_object(thing, PTS+" waves you through.\n" );
    tell_room( this_object(), PTS+" waves "+(string)thing->the_short() +
      " through.\n", thing );
    call_out( "check_idler", TIME_LIMIT, thing );
    return 1;
  }
  
  if ( (int)thing->query_value_in( location ) < visit_cost ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short() 
      +".\n", thing );
    
    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have enough "
         "money to use the facility!" );
      return notify_fail("");
    }
   
    proprietor->do_command("say It costs "+
                           (string)MONEY_HAND->money_value_string( visit_cost,
                                                                   location ) +
                           " to use the facility!" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay "+PTS+" who waves you through.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays "+PTS+" who waves "+ (string)thing->query_objective() +
             " through.\n", thing );

  remove_call_out("check_idler");
  call_out("check_idler", TIME_LIMIT, thing);
  return 1;
} /* check_customer() */


void check_idler(object who) {
  if(who && base_name(environment(who)) == vault_room) { 
    tell_object(who, "You've been in here too long so " + PTS + " comes and "
              "drags you out.\n");
    who->move_with_look(this_object(),
                      "$N is dragged out of the vault by the hair.",
                      "$N is dragged out of the vault by the hair.");
  }
}

/**
 * @ignore yes
 */
void player_quitting(object who, object env) {
}
// --- END [/mnt/home2/grok/lib/std/shops/inherit/vault_entry.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/auction_house.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/auction_house.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629803   Available: 13577157
Inodes: Total: 5242880    Free: 4960136
32449 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/auction_house.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629803   Available: 13577157
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This inherit handles auctioning stuff.
 * @author Pinkfish
 * @started Mon Apr 30 22:47:38 PDT 2001
 */
#include <room/auction.h>
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <mail.h>
#include <player_handler.h>
#include <am_time.h>

inherit "/std/shops/inherit/shop_event";
inherit "/std/shops/inherit/open_shop";

// 15 minutes.
#define DEFAULT_QUICK_AUCTION_LENGTH (15 * 60)
// 1 hour
#define DEFAULT_SHORT_AUCTION_LENGTH (60 * 60)
// 1 day
#define DEFAULT_MEDIUM_AUCTION_LENGTH (AM_SECONDS_PER_DAY)
// 3 days.
#define DEFAULT_LONG_AUCTION_LENGTH (AM_SECONDS_PER_DAY * 3)
// 14 days.
#define DEFAULT_VERY_LONG_AUCTION_LENGTH (AM_SECONDS_PER_DAY * 14)
#define DEFAULT_RETRIEVAL_TIME (AM_SECONDS_PER_DAY * 7)
#define DEFAULT_EXTENSION_TIME (20 * 60)

class auction {
   mixed save_stuff;
   int time_started;
   int auction_length;
   string name;
   string seller;
   string current_bidder;
   int bid;
   int reserve;
   int retries;
   string end_function;
   mixed extra;
}

private nosave mixed* _auction_obs;
private nosave int _callout_id;
private nosave string _save_file;
private nosave int _max_auctions;
private nosave mapping _auction_times;
private nosave int _retrieval_time;
private nosave int _max_retries;
private nosave int _cut;
private nosave int _minimum_bid_increase; // percentage
private nosave function _can_bid;
private nosave int _allow_add;
private nosave string _bid_type_names;
private class auction* _auctions;
private class auction* _finished_auctions;
private mapping _royalties;

void next_auction_finish();
mixed query_property(string name);
class auction query_auction_item(string id);
void retry_auction(class auction auction);

void create() {
   _auctions = ({ });
   _finished_auctions = ({ });
   _cut = 10;
   _max_auctions = 20;
   _auction_obs = ({ });
   _royalties = ([ ]);
   _auction_times = ([
                      "quick" : DEFAULT_QUICK_AUCTION_LENGTH,
                      "short" : DEFAULT_SHORT_AUCTION_LENGTH,
                      "medium" : DEFAULT_MEDIUM_AUCTION_LENGTH,
                      "long" : DEFAULT_LONG_AUCTION_LENGTH,
                      "very long" : DEFAULT_VERY_LONG_AUCTION_LENGTH
                    ]);
   _retrieval_time = DEFAULT_RETRIEVAL_TIME;
   _max_retries = 5;
   _minimum_bid_increase = 10; // percentage
   _allow_add = 1;
   shop_event::create();
} /* create() */

/**
 * This method returns the current list of available auctions.
 * @return the current auctions
 */
class auction *query_auctions() { return copy(_auctions); }

/**
 * This method returns the current list of finished auctions.
 * @return the current auctions
 */
class auction *query_finished_auctions() { return copy(_finished_auctions); }

/**
 * This method loads the auction house up.
 */
void load_me() {
   unguarded( (: restore_object(_save_file, 1) :));
   _auction_obs = allocate(sizeof(_auctions));
   if (!_royalties) {
      _royalties = ([ ]);
   }
   next_auction_finish();
} /* load_me() */

/**
 * This method saves the auction house.
 */
void save_me() {
   unguarded( (: save_object(_save_file) :));
} /* save_me() */

/**
 * This method sets the save file name.
 * @param fname the save file name
 */
void set_save_file(string fname) {
   _save_file = fname;
   load_me();
} /* set_save_file() */

/**
 * This method queries the save file name.
 */
string query_save_file() {
   return _save_file;
} /* query_save_file() */

/**
 * This method sets a function to be called to check if someone can
 * bid or not.
 * @param func the function to call
 */
void set_check_can_bid(function f) {
   _can_bid = f;
} /* set_check_can_bid() */

/**
 * This method sets the allowed add flag.  If theis flag is set to 0
 * then it is not possible for players to add items for
 * auctions.
 * @param flag the allowed add flag
 */
void set_allowed_add(int flag) {
   _allow_add = flag;
} /* set_allowed_add() */

/**
 * This method sets the maximum number of simultaneous auctions.
 * @param i the number of items.
 */
void set_max_auctions(int i) { _max_auctions = i; }

/**
 * This method sets the length of auctions in seconds.
 * @param index the name of the auction type to change
 * @param i the length of auctions.
 */
void set_auction_time(string index, int i) {
   if (!i) {
      map_delete(_auction_times, index);
   } else {
      if (!_auction_times[index]) {
         _bid_type_names = 0;
      }
      _auction_times[index] = i;
   }
}

/**
 * This method returns the length of auctions in seconds.
 * @return the length of auctions.
 */
mapping query_auction_times() { return _auction_times; }

/**
 * This method sets the length of the retrieval time.
 *
 * @param i the number of seconds the item will wait for someone to claim it.
 */
void set_retrieval_time(int i) { _retrieval_time = i; }

/**
 * This method sets the number of times an item will be retried before
 * the auction is failed.
 *
 * @param i the number of seconds the item will wait for someone to claim it.
 */
void set_max_retries(int i) { _max_retries = i; }

/**
 * This method sets the minimum bid increase (as a percentage of the
 * current bid).
 *
 * @param i percentage
 */
void set_min_bid_increase(int i) { _minimum_bid_increase = i; }

/**
 * This method puts an item up for auction.
 * @param obs the objects to sell
 * @param name the name of the item
 * @param reserve the reserve price of the item
 * @param seller the seller of the item
 * @param length the length of the auction
 * @param end_function the function to call when the item is sold
 * @return 1 on success, 0 on failure
 */
int add_item_to_auction(object* obs, string name, int reserve,
                        string seller, int length,
                         string end_function, mixed extra) {
   class auction new_auct;

   if (sizeof(_auctions) + sizeof(_finished_auctions) >= _max_auctions) {
      return 0;
   }

   if (!reserve) {
      reserve = 40;
   }

   new_auct = new(class auction);
   new_auct->save_stuff = AUTO_LOAD_OB->create_auto_load(obs);
   new_auct->name = name;
   new_auct->reserve = reserve;
   new_auct->end_function = end_function;
   new_auct->time_started = time();
   if (!length) {
      new_auct->auction_length = _auction_times["very long"];
   } else {
      new_auct->auction_length = length;
   }
   new_auct->seller = seller;
   new_auct->extra = extra;
   _auctions += ({ new_auct });
   _auction_obs += ({ obs });
   save_me();
   next_auction_finish();
   // To stop it hanging onto object references that might cease to exist
   _auction_obs -= ({ obs });
   _auction_obs += ({ 0 });
   return 1;
} /* add_item_to_auction() */

/**
 * This method finds the objects associated with the auction item.
 * @param auction the auction item
 * @return the objects associated with it
 */
object* query_auction_objects(class auction auct) {
   int i;


   for (i = 0; i < sizeof(_auctions); i++) {
      if (_auctions[i] == auct) {
         if (!_auction_obs[i]) {
            _auction_obs[i] = AUTO_LOAD_OB->load_auto_load_to_array(auct->save_stuff);
         }
         return _auction_obs[i];
      }
   }
   return ({ });
} /* query_auction_objects() */

/**
 * This method makes a bid on an item.
 * @param item the item to bid on
 * @param bid the amount to bid
 * @param person the person making the bid
 */
void bid_on_item(class auction auct,
                 int bid, string person) {
                 
    if (bid > auct->bid && bid >= auct->reserve) {
        auct->bid = bid;
        auct->current_bidder = person;
        if (auct->auction_length + auct->time_started - time() < 
            DEFAULT_EXTENSION_TIME) {
         
            auct->auction_length = time() - auct->time_started + 
                DEFAULT_EXTENSION_TIME;
        }
    }
    
} /* bid_on_item() */

/** @ignore yes
 * This can be used to alter the bid info if necessary.
 */
int reset_bid(string id, int bid, string person) {
  class auction auct;
  
  if(!(this_player()->query_lord()))
    return 0;
  auct = query_auction_item(id);
  if(!auct)
    return 0;

  auct->bid = bid;
  auct->current_bidder = person;
  return 1;
}

/**
 * This method removes the specified auction from the list.
 * @param auction the auction item that is being removed
 */
void remove_finished_auction_item(class auction auction) {
   int i;

   for (i = 0; i < sizeof(_finished_auctions); i++) {
      if (_finished_auctions[i] == auction) {
         _finished_auctions = _finished_auctions[0..i-1] + _finished_auctions[i+1..];
      }
   }
} /* remove_auction_item() */

/**
 * This method removes the specified auction from the list.
 * @param auction the auction item that is being removed
 */
void remove_auction_item(class auction auction) {
   int i;

   for (i = 0; i < sizeof(_auctions); i++) {
      if (_auctions[i] == auction) {
         if (i < sizeof(_auction_obs) && _auction_obs[i]) {
            ((_auction_obs[i]) - ({ 0 }))->move("/room/rubbish");
         }
         _auctions = _auctions[0..i-1] + _auctions[i+1..];
         _auction_obs = _auction_obs[0..i-1] + _auction_obs[i+1..];
      }
   }
} /* remove_auction_item() */

/**
 * This method finishes the aution on the specified item.
 * @param auction the auction item that is being finished
 */
void finish_auction(class auction auction) {
   string place;

   if (auction->end_function) {
      call_other(this_object(), auction->end_function, 
                 AUCTION_FINISH_PHASE, auction, auction->extra,
                 auction->current_bidder, auction->bid);
   }

   place = query_property("place");
   remove_auction_item(auction);
   // make them pay to get the item back
   if (!auction->current_bidder) {
      auction->current_bidder = auction->seller;
      auction->bid = 4000;
   }
   _finished_auctions += ({ auction });
   save_me();
   if (auction->current_bidder &&
       PLAYER_HANDLER->test_user(lower_case(auction->current_bidder))) {
      AUTO_MAILER->auto_mail(lower_case(auction->current_bidder),
                              this_object()->query_short(),
                              "Results of auction for " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed.\nPlease pay the " +
                              MONEY_HAND->money_value_string(auction->bid, place) +
                              " as soon as you can.\n", 0, auction->current_bidder);
   } else {
      // Retry it.
      retry_auction(auction);
   }
   return ;
} /* finish_auction() */

/**
 * This method forcibly finishes the auction on the specified item.
 * This is only to be used for debugging purposes.
 * @param auction the auction item that is being finished
 */
void force_finish_auction(string id) {
   string place;
   class auction auction;

   auction = query_auction_item(id);

   if (auction->end_function) {
      call_other(this_object(), auction->end_function, 
                 AUCTION_FINISH_PHASE, auction, auction->extra,
                 auction->current_bidder, auction->bid);
   }

   place = query_property("place");
   remove_auction_item(auction);
   // make them pay to get the item back
   if (!auction->current_bidder) {
      auction->current_bidder = auction->seller;
      auction->bid = 4000;
   }
   _finished_auctions += ({ auction });
   save_me();
   if (auction->current_bidder &&
       PLAYER_HANDLER->test_user(lower_case(auction->current_bidder))) {
      AUTO_MAILER->auto_mail(lower_case(auction->current_bidder),
                              this_object()->query_short(),
                              "Results of auction for " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed.\nPlease pay the " +
                              MONEY_HAND->money_value_string(auction->bid, place) +
                              " as soon as you can.\n");
   }
   return ;
} /* finish_auction() */

/**
 * This method retries the aution on the specified item.
 * @param auction the auction item that is being finished
 */
void retry_auction(class auction auction) {
   string place;

   if (auction->end_function) {
      call_other(this_object(), auction->end_function, 
                 AUCTION_RETRY_PHASE, auction, auction->extra);
   }

   place = query_property("place");
   remove_finished_auction_item(auction);
   // make them pay to get the item back
   auction->bid = 0;
   auction->current_bidder = 0;
   auction->retries++;
   auction->time_started = time();
   if (auction->retries > _max_retries) {
      // Toss it completely.
   } else {
      _auctions += ({ auction });
      _auction_obs += ({ 0 });
   }
   save_me();
   if (auction->seller &&
       PLAYER_HANDLER->test_user(lower_case(auction->seller))) {
      AUTO_MAILER->auto_mail(lower_case(auction->seller),
                              this_object()->query_short(),
                              "Default on auction of " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed and the payee defaulted.\n"
                              "The item has been put up for reauctioning.\n");
   }
   return ;
} /* finish_auction() */

/**
 * This method finds the item based on some useful string.
 * @param id the id to lookup
 * @return the auction item, 0 in the case of error
 */
class auction query_auction_item(string id) {
   id = lower_case(id);
   if (strlen(id) == 1 &&
       id[0] >= 'a' && id[0] < 'a' + sizeof(_auctions)) {
      return _auctions[id[0] - 'a'];
   }
   return 0;
} /* query_auction_item() */

/**
 * This method prints a nice string showing how long it is till then
 * end of the thing.
 * @param left the time to get the difference for
 * @return time end string
 */
string query_time_end_string(int left) {
   string str;
   string extra;

   if (left >= AM_SECONDS_PER_DAY) {
      str = (left / AM_SECONDS_PER_DAY) + " day";
      if ((left / AM_SECONDS_PER_DAY) > 1) {
         str += "s";
      }
      left = left % (AM_SECONDS_PER_DAY);
      if (left >= (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) {
         if ((left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) > 1) {
             extra = "s";
          } else {
             extra = "";
         }
         return str + " and " +
           (left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) + " hour" +
           extra;
      }
      return str;
   } else if (left >= AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR) {
      if ((left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) > 1) {
          extra = "s";
       } else {
          extra = "";
      }
      str = (left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) + " hour" +
            extra;
      left %= AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR;
      if ((left / (AM_SECONDS_PER_MINUTE)) > 1) {
          extra = "s";
       } else {
          extra = "";
      }
      if (left > AM_SECONDS_PER_MINUTE) {
         return str + " and " + (left / AM_SECONDS_PER_MINUTE) + " minute" +
                extra;
      }
      return str;
   } else if (left <= 0) {
      return "already finished";
   }

    if( !(left/60) ) {
        return "less than a minute";
    }
    else {
        str = "";
        str += ( left / 60) + " minute";
        if (left / 60 > 1) {
            str += "s";
        }
        return str;
    }
   
} /* query_auction_end_string() */

/**
 * This method printsd a nice string showing how long till the auction
 * ends.
 * @param auction the auction to get an end string for
 * @return auction end string
 */
string query_auction_end_string(class auction auction) {
   return query_time_end_string(auction->time_started +
                                auction->auction_length - time());
} /* query_auction_end_string() */

/**
 * This method figures out when the last auction will finish.
 * @return when the last auction finished
 */
int query_last_auction_finish_time() {
   int tim;
   class auction auction;

   foreach (auction in _auctions) {
      if (tim < auction->time_started + auction->auction_length) {
         tim = auction->time_started + auction->auction_length;
      }
   }
   return tim;
} /* query_last_auction_finish_time() */

/**
 * This method figures out when the next auction finishes and sets up
 * a timeout.
 */
void next_auction_finish() {
   class auction auct;
   int next;
   int tmp;

   next = 0;
   foreach (auct in _auctions) {
      tmp = auct->time_started + auct->auction_length - time();
      if (tmp <= 0) {
         finish_auction(auct);
      } else if (tmp < next || !next) {
         next = tmp;
      }
   }

   //
   // Check for auctions that have timedout out their stay in the
   // claim list.
   //
   foreach (auct in _finished_auctions) {
      tmp = auct->time_started + auct->auction_length + _retrieval_time -
        time();
      if (tmp <= 0) {
         retry_auction(auct);
         tmp = auct->time_started + auct->auction_length - time();
         if (tmp < next || !next) {
            next = tmp;
         }
      } else if (tmp < next || !next) {
         next = tmp;
      }
   }

   if (_callout_id) {
      remove_call_out(_callout_id);
      _callout_id = 0;
   }
   if (next) {
      _callout_id = call_out("next_auction_finish", next);
   }
} /* next_auction_finish() */

/**
 * This method lists all the current auctions.
 */
int do_list() {
   string str;
   class auction bing;
   int pos;
   string place;

   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }

   if (!sizeof(_auctions)) {
      add_failed_mess("Nothing currently on auction.\n");
      return 0;
   }

   place = query_property("place");
   str = "Items currently up for auction:\n";
   foreach (bing in _auctions) {
      str += sprintf("%c) %s", pos + 'A', bing->name);
      if (bing->current_bidder) {
         str += "; " + 
                MONEY_HAND->money_value_string(bing->bid, place) +
                " by " + bing->current_bidder + "; finishes in " +
                query_auction_end_string(bing) + ".\n";
      } else {
         str += "; no current bid; finishes in " +
                query_auction_end_string(bing) + ".\n";
      }
      pos++;
   }

   if (!broadcast_shop_event(AUCTION_EVENT_LIST,
                             this_player(), str)) {
      write("$P$Auctions$P$" + str);
   }
   return 1;
} /* do_list() */

/**
 * This method allows you to browse the item.
 * @param id the id of the auction thing to browse
 */
int do_browse(string id) {
   class auction bing;
   string place;
   string str;
   object* obs;
   object ob;

   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }

   bing = query_auction_item(id);
   if (!bing) {
      add_failed_mess("There is no auction item " + id + ".\n");
      return 0;
   }

   place = query_property("place");
   str = "Auction called " + bing->name + " started at " +
        amtime(bing->time_started) + " finishes at " +
        amtime(bing->time_started + bing->auction_length) + " (in " +
        query_auction_end_string(bing) + ".\n";
   str += "Reserve price " +
          MONEY_HAND->money_value_string(bing->reserve, place);
   if (bing->bid) {
      str += "; current bid " +
             MONEY_HAND->money_value_string(bing->bid, place) +
             " by " + bing->current_bidder + ".\n";
   } else {
      str += "; no current bid.\n";
   }
   obs = query_auction_objects(bing);
   foreach (ob in obs) {
      str += "\n$I$0=$C$" + ob->the_short() + ":\n$I$3=   " +
             ob->long();
      if (ob->query_readable_message(this_player())) {
         str += "$I$0=Read message:\n$I$3=   " + ob->query_readable_message(this_player()) + "\n";
      }
   }
 
   if (!broadcast_shop_event(AUCTION_EVENT_BROWSE,
                             this_player(), bing, obs, str)) {
      write("$P$Browse Auction$P$" + str);
   }
   return 1;
} /* do_browse() */

/**
 * This method makes a bid on the specified item.
 * @param id the item to bid on
 * @param bid the amount to bid
 * @return 1 on success, 0 on failure
 */
int do_bid(string id, string bid) {
   class auction auct;
   string place;
   int value;
   int inc;

   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   
   auct = query_auction_item(id);
   if (!auct) {
      if (!broadcast_shop_event(AUCTION_EVENT_BAD_ITEM,
                                 this_player(), id)) {
         add_failed_mess("There is no auction item " + id + ".\n");
      }
      return 0;
   }

   place = query_property("place");
   value = MONEY_HAND->value_from_string(bid, place);

   if (_can_bid) {
      if (!evaluate(_can_bid, this_player(), auct, value)) {
         return 0;
      }
   }

   inc = auct->bid + ((auct->bid * _minimum_bid_increase) / 100);
   if (value < inc) {
      if (!broadcast_shop_event(AUCTION_EVENT_BID_TOO_SMALL,
                                 this_player(), auct, value, inc)) {
         add_failed_mess("You must bid " + _minimum_bid_increase + "% more than "
                         "the current bid, current bid is " +
                         MONEY_HAND->money_value_string(auct->bid, place) +
                         " so " + _minimum_bid_increase + "% more is " +
                         MONEY_HAND->money_value_string(inc, place) +
                         ".\n");
      }
      return 0;
   }
   
   if (value < auct->reserve) {
      if (!broadcast_shop_event(AUCTION_EVENT_BID_BELOW_RESERVE,
                                 this_player(), auct, value, auct->reserve)) {
         add_failed_mess("You must bid more than the reserve bid, it is " +
                      MONEY_HAND->money_value_string(auct->reserve, place) + ".\n");
      }
      return 0;
   }

   bid_on_item(auct, value, this_player()->query_cap_name());
   save_me();
   if (!broadcast_shop_event(AUCTION_EVENT_BID,
                             this_player(), auct, value)) {
      add_succeeded_mess("$N $V " +
                         MONEY_HAND->money_value_string(value, place) +
                         " on " + auct->name + ".\n");
   }
   return 1;
} /* do_bid() */

/**
 * This method withdraws the item from bidding.  You pay a penalty when you
 * do this, 10% of the current item cost.
 * @param id the id to withdraw
 */
int do_withdraw(string id) {
   class auction auct;
   string place;
   int value;
   object* obs;
   object ob;

   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   
   auct = query_auction_item(id);
   if (!auct) {
      if (!broadcast_shop_event(AUCTION_EVENT_BAD_ITEM,
                                 this_player(), id)) {
         add_failed_mess("There is no auction item " + id + ".\n");
      }
      return 0;
   }

   place = query_property("place");
   if (lower_case(auct->seller) == this_player()->query_name() ||
       this_player()->query_creator()) {
      // Make sure they have the money.
      if (auct->reserve > auct->bid) {
         value = auct->reserve;
      } else {
         value = auct->bid;
      }
      if (this_player()->query_value_in(place) < value) {
         if (!broadcast_shop_event(AUCTION_EVENT_TOO_POOR,
                              this_player(), auct, 
                              this_player()->query_value_in(place),
                              auct->bid)) {
            add_failed_mess("You need at least " +
                            MONEY_HAND->money_value_string(value, place) +
                            " to withdraw this item from auction.\n");
         }
         return 0;
      }
      obs = query_auction_objects(auct);
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place),
        place);
      remove_auction_item(auct);
      save_me();
      if (auct->end_function) {
         call_other(this_object(), auct->end_function, 
                    AUCTION_WITHDRAW_PHASE, auct, auct->extra);
      }
      foreach (ob in obs) {
         if (ob->move(this_player()) != MOVE_OK) {
             ob->move(this_object());
             write("Unable to move " + ob->the_short() +
                   " into your inventory, put on the floor.\n");
         }
      }
      if (!broadcast_shop_event(AUCTION_EVENT_WITHDRAW,
                                 this_player(), auct)) {
         add_succeeded_mess("$N remove$s " + auct->name + " from auction.\n");
      }
      return 1;
   }
   if (!broadcast_shop_event(AUCTION_EVENT_CANNOT_WITHDRAW,
                              this_player(), auct)) {
      add_failed_mess("You cannot withdraw that item from auction.\n");
   }
   return 0;
} /* do_withdraw() */

/**
 * This method claims anything that you can bought and is waiting for
 * pickup.
 */
int do_claim() {
   class auction auction;
   int num;
   string place;
   object* obs;
   object ob;
   int i;
   int value;

   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   
   place = query_property("place");
   value = this_player()->query_value_in(place);
   foreach (auction in _finished_auctions) {
      if (!auction->current_bidder) {
         remove_finished_auction_item(auction);
      } else if (lower_case(auction->current_bidder) == this_player()->query_name()) {
         if (value < auction->bid) {
            if (!broadcast_shop_event(AUCTION_EVENT_TOO_POOR,
                              this_player(), auction, value, auction->bid)) {
               write("You do not have enough money to pay for " +
                     MONEY_HAND->money_value_string(auction->bid, place) +
                     ".\n");
            }
         } else {
            
            this_player()->pay_money( 
                MONEY_HAND->create_money_array(auction->bid, place), place);
            value -= auction->bid;
            // Add the bid to the royalties.
            _royalties[lower_case(auction->seller)] += auction->bid -
                                           auction->bid * _cut / 100;
            obs = AUTO_LOAD_OB->load_auto_load_to_array(auction->save_stuff);
            foreach (ob in obs) {
               if (ob->move(this_player()) != MOVE_OK) {
                  ob->move(this_object());
                  write("Unable to move " + ob->the_short() +
                        " into your inventory, put on the floor.\n");
               }
            }
            if (!broadcast_shop_event(AUCTION_EVENT_CLAIM,
                              this_player(), auction, auction->bid, obs)) {
               write("You paid " +
                     MONEY_HAND->money_value_string(auction->bid, place) +
                     " for " +
                     query_multiple_short(obs) + ".\n");
            }
            remove_finished_auction_item(auction);
            save_me();
            if (auction->end_function) {
               call_other(this_object(), auction->end_function, 
                          AUCTION_CLAIM_PHASE, auction, auction->extra,
                          auction->current_bidder, auction->bid, obs);
            }
         }
         num++;
      }
      i++;
   }
   if (!num) {
      if (!broadcast_shop_event(AUCTION_EVENT_NOTHING_TO_CLAIM,
                              this_player())) {
         add_failed_mess("You cannot find anything to claim.\n");
      }
   }
   return num;
} /* do_claim() */

/**
 * This method adds an item for bidding.
 * @param name the name to put them up for bidding as
 * @param obs the objects to auction
 * @param res_str the reserve price
 * @param length the length of the auction
 * @return 1 on success, 0 on failed
 */
int do_add(string name, object* obs, string res_str, string length) {
   int reserve;
   string ret;
   string place;
   int len;

   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   
   place = query_property("place");

   len = _auction_times[length];

   if (sizeof(_auctions) >= _max_auctions) {
      if (!broadcast_shop_event(AUCTION_EVENT_FULL,
                             this_player(), name, obs, reserve, len)) {
         add_failed_mess("The auction house is full.\n");
      }
      return 0;
   }

   if (res_str) {
      reserve = MONEY_HAND->value_from_string(res_str, place);
      if (!reserve) {
         if (!broadcast_shop_event(AUCTION_EVENT_BAD_MONEY,
                             this_player(), name, obs, reserve, len)) {
            add_failed_mess("Unable to figure out how much " + res_str +
                            " is.\n");
         }
         return 0;
      }
   }


   ret = "You are putting " + query_multiple_short(obs) + " up for "
         "auction as " + name + " for " +
          query_time_end_string(len);
   if (reserve) {
     ret += " with a reserve price of " +
            MONEY_HAND->money_value_string(reserve, place);
   }
   if (!broadcast_shop_event(AUCTION_EVENT_ADD_AUCTION,
                             this_player(), name, obs, reserve, len, ret + ".")) {
      write(ret + ".\n");
      write("Are you sure you wish to do this? ");
   }
   input_to("confirm_auction", 0, name, obs, reserve, len);
   add_succeeded_mess(({ "", "$N put$s $I up for auction.\n" }), obs);
   return 1;
} /* do_add() */

/** Confirm the addition */
void confirm_auction(string check, string name, object* obs, int reserve, int len) {
   string place;
   string ret;

   place = query_property("place");
   check = lower_case(check);
   if (!strlen(check) || check[0] != 'y') {
      if (!broadcast_shop_event(AUCTION_EVENT_ADD_ABORT,
                             this_player(), name, obs, reserve, len)) {
         write("Ok, Aborting.\n");
      }
      return ;
   }
   
   add_item_to_auction(obs, name, reserve,
                       this_player()->query_cap_name(), len, 0, 0);
   ret = "You put " + query_multiple_short(obs) + " up for "
         "auction as " + name + " for " + 
          query_time_end_string(len);
   if (reserve) {
     ret += " with a reserve price of " +
            MONEY_HAND->money_value_string(reserve, place) + "";
   }
   if (!broadcast_shop_event(AUCTION_EVENT_CONFIRM_AUCTION,
                             this_player(), name, obs, reserve, len, ret + ".")) {
      write(ret + ".\n");
   }
   
   // Finally, get rid of the items which now exist in the auction house
   obs->move("/room/rubbish");
   
} /* confirm_auction() */

/**
 * This method shoes information about the auction house, like the
 * amount of time for each type of auction.
 * @return 1 on success
 */
int do_info() {
   string ret;
   string name;
   int len;

   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }

   ret = "$I$3=The times for the auction are:\n";
   foreach (name, len in _auction_times) {
      ret += name + ": " + query_time_end_string(len) + "\n";
   }
   if (!broadcast_shop_event(AUCTION_EVENT_INFO, this_player(), ret)) {
      write("$P$Auction lengths$P$" + ret);
   }
   return 1;
} /* do_info() */

void init() {
   add_command("list", "", (: do_list() :));
   add_command("browse", "<string'auction id'>", (: do_browse($4[0]) :));
   add_command("bid", "<string'auction id'> for <string'money'>",
               (: do_bid($4[0], $4[1]) :));
   add_command("bid", "<string'money'> on <string'auction id'>",
               (: do_bid($4[1], $4[0]) :));
   add_command("claim", "", (: do_claim() :));
   add_command("withdraw", "<string'auction id'> [from auction]",
                (: do_withdraw($4[0]) :));
   if (_allow_add) {
      if (!_bid_type_names) {
         _bid_type_names = implode(keys(_auction_times), "|");
      }
      add_command("info", "", (: do_info() :));
      add_command("add", "{" + _bid_type_names +
                   "} auction of <indirect:object:me> as <string'name'>",
                  (: do_add($4[2], $1, 0, $4[0]) :));
      add_command("add", "{" + _bid_type_names +
                  "}  auction of <indirect:object:me> as <string'name'> reserve <string'price'>",
                  (: do_add($4[2], $1, $4[3], $4[0]) :));
   }
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/auction_house.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/newspaper_archive.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/newspaper_archive.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629795   Available: 13577149
Inodes: Total: 5242880    Free: 4960136
6192 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/newspaper_archive.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629795   Available: 13577149
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the newspaper archive inherit.  Allows you to buy back issues of the
 * paper.
 * @author Pinkfish
 * @started Wed May 23 15:56:13 PDT 2001
 */
inherit "/std/shops/inherit/shop_event";
#include <room/newspaper.h>
#include <shops/newspaper_archive.h>
#include <money.h>
#include <move_failures.h>

private nosave string _area;
private nosave string _paper;

mixed query_property(string name);

void create() {
   shop_event::create();
} /* create() */

/**
 * This sets the paper area to use for getting information from the archive.
 * @param area the area to set
 */
void set_paper_area(string area) {
   _area = area;
} /* set_paper_area() */

/**
 * This method returns the paper area for use in getting information form
 * the archive.
 * @return the paper area
 */
string query_paper_area() {
   return _area;
} /* query_paper_area() */

/**
 * This sets the paper to use for getting information from the archive.
 * @param area the area to set
 */
void set_paper(string paper) {
   _paper = paper;
} /* set_paper() */

/**
 * This method returns the paper for use in getting information form
 * the archive.
 * @return the paper area
 */
string query_paper() {
   return _paper;
} /* query_paper() */

/**
 * This method shows which papers are currently available for buying back
 * issues of.
 */
int do_list_papers() {
   string paper;
   string* papers;
   string str;
   int cost;
   string place;

   place = query_property("place");

   if (_paper) {
      papers = ({ _paper });
   } else {
      papers = NEWSPAPER_HANDLER->query_papers_in_area(_area);
   }
   if (!sizeof(papers)) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_NO_PAPERS, this_player())) {
         add_failed_mess("There do appear to be any newspapers to get "
                         "back issues of.\n");
      }
      return 0;
   }

   str = "Back issues of the following papers:\n";
   foreach (paper in papers) {
      cost = NEWSPAPER_HANDLER->query_paper_cost(paper) * 10;
      if (NEWSPAPER_HANDLER->query_last_edition_num(paper)) {
         if (NEWSPAPER_HANDLER->query_last_edition_num(paper) > 1) {
            str += "$I$5=" + paper + " issues, 1 to " + 
                   NEWSPAPER_HANDLER->query_last_edition_num(paper);
         } else {
            str += "$I$5=" + paper + " issue, 1";
         }
         str += " for " + MONEY_HAND->money_value_string(cost, place);
      } else {
         str += "$I$5=" + paper + " has no back issues.\n";
      }
      str += ".\n";
   }

   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_LIST, this_player(),
                             str, papers)) {
      write("$P$Archives$P$" + str);
   }
   return 1;
} /* do_list_papers() */

/**
 * This method buys a back issue of the paper.
 * @param paper the paper to buy a back issue of
 * @param issue the issue number to buy
 */
int do_buy(string paper, int edition) {
   string found_paper;
   int pos;
   object ob;
   string place;
   string* papers;
   int cost;
   int* editions;

   place = query_property("place");

   if (_paper) {
      papers = ({ _paper });
   } else {
      papers = NEWSPAPER_HANDLER->query_papers_in_area(_area);
   }
   if (strlen(paper) == 1) {
      pos = lower_case(paper)[0] - 'a';
      if (pos < 0 || pos >= sizeof(papers)) {
         found_paper = papers[pos];
      }
   } else {
      for (pos = 0; pos < sizeof(papers); pos++) {
         if (lower_case(paper) == lower_case(papers[pos])) {
            found_paper = papers[pos];
         }
      }
   }

   if (!found_paper) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_INVALID_PAPER,
                                this_player(), paper)) {
         add_failed_mess("There is no paper called " + paper + ".\n");
      }
      return 0;
   }

   if (edition < 0 ||
       edition > NEWSPAPER_HANDLER->query_last_edition_num(found_paper)) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_INVALID_EDITION,
                                this_player(), paper, edition)) {
         add_failed_mess("There is no edition " + edition + " of the "
                         "paper " + found_paper + ".\n");
      }
      return 0;
   }

   // Check their money.
   cost = NEWSPAPER_HANDLER->query_paper_cost(found_paper) * 10;
   if (this_player()->query_value_in(place) < cost) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_TOO_POOR,
                                this_player(), paper, edition, cost)) {
         add_failed_mess("You need " +
                         MONEY_HAND->money_value_string(cost, place) +
                         " to buy a back issue of " + found_paper + ".\n");
      }
      return 0;
   }

   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(found_paper);
   ob->set_edition(edition);
   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_MOVE_PAPER,
                             this_player(), paper, edition, cost, ob)) {
      if (ob->move(this_player()) != MOVE_OK) {
         ob->move(this_object());
         write("Unable to move the paper into your inventory, putting it "
               "on the floor.\n");
      }
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);

   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_BOUGHT,
                             this_player(), paper, edition, cost, ob)) {
      add_succeeded_mess("$N buy$s edition " + edition + " of " +
                         found_paper + " for " +
                         MONEY_HAND->money_value_string(cost, place) + ".\n");
   }

   // Put that they bought this into their bought array.
   editions = this_player()->query_property("Paper " + found_paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + found_paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        cost);
   }
   return 1;
} /* do_buy() */

void init() {
   add_command("list", "[papers]", (: do_list_papers() :));
   add_command("buy", "<number'edition number'> of <string'paper name'>",
                (: do_buy($4[1], $4[0]) :));
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/newspaper_archive.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/item_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/item_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629793   Available: 13577147
Inodes: Total: 5242880    Free: 4960136
21058 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/item_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629793   Available: 13577147
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Original /std/shops/inherit/item_shop
/**
 * Item shop inherit. 
 * @author Pinkfish
 * @change /17/03/00 Aquilo Separated the storing and duplicating of
 * items which was moved to /std/shops/inherit/clone_on_demand
 * @see /std/shops/inherit/clone_on_demand
 */

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shops/item_shop.h>

#define INFINITE_LEFT 10000
#define TYPE "item shop type"
#define DISPLAY "display in shop"

#define SHOP_INHERIT "/std/shops/inherit/"

inherit SHOP_INHERIT + "clone_on_demand";
inherit SHOP_INHERIT + "open_shop";
inherit SHOP_INHERIT + "shop_event";

private nosave int _no_steal;
private nosave int _steal_difficulty;
private nosave string _shoplift_handler;
private nosave function _list_func;
private nosave function _browse_func;
private nosave function _buy_func;
private nosave function _sort_func;

void setup_safe();
void do_banking();
int do_word_buy(string str);
int do_word_browse(string str);
int do_buy( object *things );
int do_browse( object *things );
void remove_property(string name);
mixed query_property(string name);
void set_max_float( int );
int query_max_float();

private nosave object _safe;
private nosave int _hidden_safe;
private nosave int _max_float;

void create() {
  shop_event::create();
  clone_on_demand::create();  
  this_object()->add_help_file("item_shop");
  // Create default safe.  The safe can be customised from the shop.
  setup_safe();
  // Set default float.  This can be customised from the shop.
  set_max_float( 20000 + random( 50000 ) );
} /* create() */

/**
 * query_safe - This method returns the object currently being used
 * as a safe in the shop. 
**/
object query_safe() {
  return _safe;
}

/**
 * This method creates the safe in the room.  The safe is then used for
 * various thief related activities.
 */
void setup_safe() {
  if( !_safe ) {
    _safe = clone_object( ITEM_SHOP_ITEMS + "item_shop_safe" );
    _safe->set_difficulty( 2 + random( 7 ) );
    _safe->set_ownership( "shop" );

    if ( this_object()->query_hidden_safe( _safe ) ) { 
        this_object()->add_hidden_object( _safe );
    } else {
        _safe->move( this_object() );
    }
  } 
}

/** 
 * This allows the creators to set their own safe. 
 */ 
void set_safe(object safe) {
    _safe = safe;

    if ( _safe ) { 
        _safe->set_ownership( "shop" );

        if ( this_object()->query_hidden_safe( _safe ) ) { 
            this_object()->add_hidden_object( _safe );
        } else {
            _safe->move( this_object() );
        }
    }
} /* set_safe() */ 

/** @ignore yes */
void reset() {
  ::reset();
  if(!random(3)) {
    remove_property("inventory_loss"); // This is incremented by shoplifting
  }
  // Float gets used to buy stock.
  do_banking();
}

mixed *switch_extra_properties(){
  return ({ TYPE, DISPLAY });
}

/**
 * This method tells us if the shop is really a shop or not.
 * @return 1 always
 */
int query_shop() {
   return 1;
} /* query_shop() */

/**
 * This method returns the items which can potentially be shop lifted
 * with the passed in string.
 * @param str the name for the object to attempt to shop lift
 * @return the array of matching objects
 * @see query_steal_difficulty()
 * @see query_shoplift_response_handler()
 */
object *query_shop_lift_items(string str, object player) {
   return filter(match_objects_for_existence(str, ({ query_cont() })),
     (: query_num_items_left($1) > 0 :));
} /* query_shop_lift_items() */

/**
 * This method turns the objects into real objects (if that is
 * nessessary, it is not with a normal shop).
 * @param ob the object to turn into a normal object
 */
object shoplift_success(object ob) {
   object real_ob;

   real_ob = create_real_object(ob);
   return real_ob;
} /* shoplift_success() */

string query_shoplift_response_handler() { return _shoplift_handler; }
void set_shoplift_response_handler( string word ) { _shoplift_handler = word; }

/**
 * This method sets the function to evaluate to detmine if the shop 
 * is open or not.
 * @param func the function to evaluate for openness
 * @see query_open_func()
 * @see set_open_condition()
 */
void set_open_func(function func) {
   ::set_open_function(func);
} /* set_open_func() */

/**
 * This method makes it compatible with the way that the open stuff works in
 * the normal shops.
 * @param func the function to evaluate for openness
 * @see set_open_func()
 * @see query_open_func()
 */
void set_open_condition(function func) {
   ::set_open_function(func);
} /* set_open_condition() */

/**
 * This method sets the function to use when buying something from
 * the shop.  The function will be called with two arguements, the
 * first is the player, the second is the array of objects being
 * bought.
 * @param func the function to set
 * @see set_list_function()
 * @see set_buy_function()
 * @see set_browse_function()
 * @see query_buy_function()
 */
void set_buy_function(function func) {
  _buy_func = func;
} /* set_buy_function() */

/**
 * This method returns the functionto be used when buying something.
 * @return the function to be used when buying something
 * @see query_list_function()
 * @see query_browse_function()
 * @see set_buy_function()
 */
function query_buy_function() {
   return _buy_func;
} /* query_buy_function() */

/**
 * This method sets the function to use when browseing something from
 * the shop.  The function will be called with two arguements, the
 * first is the player, the second is the array of objects being
 * browsed.
 * @param func the function to set
 * @see set_list_function()
 * @see set_buy_function()
 * @see set_browse_function()
 * @see query_browse_function()
 */
void set_browse_function(function func) {
  _browse_func = func;
} /* set_browse_function() */

/**
 * This method returns the functionto be used when browseing something.
 * @return the function to be used when browseing something
 * @see query_list_function()
 * @see query_browse_function()
 * @see set_buy_function()
 */
function query_browse_function() {
   return _browse_func;
} /* query_browse_function() */

/**
 * This method sets the function to use when listing something from
 * the shop.  The function will be called with two arguements, the
 * first is the player, the second is the array of objects being
 * bought.
 * @param func the function to set
 * @see set_list_function()
 * @see set_buy_function()
 * @see set_browse_function()
 * @see query_list_function()
 */
void set_list_function(function func) {
  _list_func = func;
} /* set_list_function() */

/**
 * This method returns the functionto be used when listing something.
 * @return the function to be used when listing something
 * @see query_buy_function()
 * @see query_browse_function()
 * @see set_list_function()
 */
function query_list_function() {
   return _list_func;
} /* query_list_function() */

/**
 * This method sets a function to be used to sort the inventory when it
 * is printed out.
 * @param func the function to use to sort the inventory
 * @see query_sort_function()
 */
void set_sort_function(function func) {
   _sort_func = func;
} /* set_sort_function() */

/**
 * This method returns the function used to sort the inventory of the 
 * shop when it is printed out.
 * @return the function to use to sort the inventory
 * @see set_sort_function()
 */
function query_sort_function() {
   return _sort_func;
} /* query_sort_function() */

/**
 * Sets this room as being unstealable.
 * @param i 1 if the room is unable to be stolen from
 * @see query_no_steal()
 */
void set_no_steal(int i) { _no_steal = i; }
/**
 * Queries to see if the room is unstealable.
 * @return 1 for making the room unstealable
 * @see set_no_steal()
 */
int query_no_steal() { return _no_steal; }
/**
 * Sets the steal difficulty of the room.
 * @param i the steal difficulty of the room
 */
void set_steal_difficulty(int i) { _steal_difficulty = i; }
/**
 * This method returns the steal difficulty of the room.
 * @return the steal difficulty of the room
 */
int query_steal_difficulty(int i) { return _steal_difficulty; }     

/** @ignore yes */
void init() {
   if (query_cont()) {
      add_command( "list", "[all]" );
      add_command( "browse", "<indirect:object:"+file_name(query_cont())+">" );
      add_command( "browse", "<word>", (: do_word_browse($4[0]) :) );
      add_command( "buy", "<indirect:object:"+file_name(query_cont())+">" );
      add_command( "buy", "<word>", (: do_word_buy($4[0]) :) );
   }
} /* init() */

private object find_object_from_number(int number) {
   object *things;

   things = all_inventory( query_cont() );
   if ( number >= sizeof( things ) ) {
      add_failed_mess( "There is no item with that label.\n" );
      return 0;
   }
   if (_sort_func) {
      things = sort_array(things, _sort_func);
   }
   return things[number];
} /* find_object_from_number() */

private string letter_name(int letter,
                           object* things) {
   string bing;

   if (sizeof(things) > 26) {
      bing = "AA";
      bing[0] = 'A' + (letter / 26);
      bing[1] = 'A' + (letter % 26);
      return bing;
   }
   bing = "A";
   bing[0] = 'A' + letter;
   return bing;
} /* letter_name() */

private string start_letter() {
   object *things;

   things = all_inventory( query_cont() );
   return letter_name(0, things);
} /* start_letter() */

private string end_letter() {
   object *things;

   things = all_inventory( query_cont() );
   return letter_name(sizeof(things) - 1, things);
} /* end_letter() */

private int query_number_from_string(string name) {
   object *things;
   int pos;

   things = all_inventory( query_cont() );
   if (sizeof(things) > 26) {
      if (strlen(name) != 2) {
         return -1;
      }
      name = lower_case(name);
      if (name[0] < 'a' || name[0] > 'z') {
         return -1;
      }
      if (name[1] < 'a' || name[1] > 'z') {
         return -1;
      }
      pos = (name[0] - 'a') * 26 + name[1] - 'a';
      if (pos >= sizeof(things)) {
         return -1;
      }
      return pos;
   }

   if (strlen(name) != 1) {
      return -1;
   }
   name = lower_case(name);
   if (name[0] < 'a' || name[0] > 'z') {
      return -1;
   }
   pos = name[0] - 'a';
   if (pos >= sizeof(things)) {
      return -1;
   }
   return pos;
} /* query_number_from_string() */

/**
 * This method returns the cost of the item shop object being talked about.
 * @param thing the thing to get the cost of
 * @return the cost of the thing
 */
int query_cost( object thing ) {
   int cost;
   string place;

   if (!thing) {
      return 0;
   }

   if ( environment( thing ) == query_cont() ) {
      cost = (int)thing->query_property( "cost here" );
      if ( cost ) {
         return cost;
      }
   }
   cost = (int)thing->query_value_at( this_object() );
   place = query_property( "place" );
   if ( !place ) {
      return cost;
   }
   /* This avoids problems with rounding errors. */
   cost = (int)MONEY_HAND->query_total_value(
         (mixed *)MONEY_HAND->create_money_array( cost, place ), place );
   if ( environment( thing ) == query_cont() ) {
      thing->add_property( "cost here", cost );
   }
   return cost;
} /* query_cost() */

/** @ignore yes */
int do_list( string str ) {
   int i;
   int left;
   string list;
   string place;
   string display;
   object thing;
   object *listed;
   object *things;

   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }

   listed = ({ });
   list = "";
   place = query_property( "place" );
   if ( !place || ( place == "" ) )  {
      place = "default";
   }
   if ( !query_cont() ) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_NOTHING, this_player())) {
         add_failed_mess( "There is nothing to buy here.\n" );
      }
      return 0;
   }

   things = all_inventory( query_cont() );
   if (_sort_func) {
      things = sort_array(things, _sort_func);
   }

   foreach ( thing in things ) {
      left = query_num_items_left(thing);
      if (!left) {
         i++;
         continue;
      }
      display = (string)thing->query_property( DISPLAY );
      if ( !stringp( display )  && thing->short()) {
         display = (string)thing->a_short();
      }
      if (display) {
         list += "$I$6=   "+ letter_name(i, things) +": "+ display +" for "+
               (string)MONEY_HAND->money_value_string(
               (int)this_object()->query_cost( thing ), place );
         if ( left == INFINITE_LEFT ) {
            list += " (plenty left).$I$0=\n";
         } else {
            list += " (" + query_num( left, 0 ) +" left).\n";
         }
         listed += ({ thing });
      }
      i++;
   }
   if ( list == "" ) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_NOTHING, this_player())) {
         add_failed_mess( "There is nothing to buy here.\n" );
      }
      return 0;
   }
   if (!broadcast_shop_event(ITEM_SHOP_EVENT_LIST, this_player(), list)) {
      list = "/global/events"->convert_message(list);
      write("$P$item list$P$" +
         "The following items are for sale:\n" + list);
      add_succeeded_mess(({ "", "$N list$s the inventory.\n" }), ({ }));
   }
   if (_list_func) {
      evaluate(_list_func, this_player(), listed);
   }
   return 1;
} /* do_list() */

/** @ignore yes */
int do_word_buy(string str) {
   object thing;
   int i;

   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }

   if ( strlen( str ) <= 2 ) {
      i = query_number_from_string( str );
      if ( i == -1) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BAD_LABEL, this_player(), str)) {
            add_failed_mess( "The item label must be from " +
                             start_letter() + " to " + end_letter() + ".\n" );
         }
         return 0;
      }
      thing = find_object_from_number(i);
      if ( !thing) {
         return 0;
      }
      return do_buy( ({ thing }) );
   }
   return 0;
} /* do_word_buy() */

/** @ignore yes */
int do_buy( object *things ) {
   int i, cost, value, ret, money_in_safe;
   string place;
   object thing, money, *sold, ob, *obs;
   mixed *money_arr, temp;

   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }

   sold = ({ });
   for (i = 0; i < sizeof(things); i++) {
      if (query_num_items_left(things[i]) <= 0) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_SOLD_OUT, this_player(), things[i..i])) {
            add_failed_mess( "The shop is sold out of "+
                  (string)things[ i ]->query_plural() +".\n" );
         }
         return 0;
      }
      place = query_property( "place" );
      if ( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)this_player()->query_value_in( place );
/*
      if ( place != "default" ) {
         value += (int)this_player()->query_value_in( "default" );
      }
 */
      cost = (int)this_object()->query_cost( things[i] );
      if ( cost > value ) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_TOO_EXPENSIVE, this_player(), things[i], cost, value)) {
            add_failed_mess("You cannot afford to buy $I.\n", ({ things[i] }));
         }
      } else {
        thing = create_real_object(things[i]);
        if (!thing){
          add_failed_mess( "Something is hosed.  Please file a bug "
                           "report.  Thank you.\n" );
          return 0;
        }

         ret = 1;
         this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
         
         // Put the money in the safe and lock it again.
         if( _safe ) {
           money_arr = MONEY_HAND->create_money_array( cost, place );
           money = clone_object( "/obj/money" );
           money->set_money_array( money_arr );
           money->move( _safe );
           _safe->set_closed();
           _safe->set_locked();

           // Check if banking should be done.
           obs = all_inventory( _safe );
           money_in_safe = 0;
           foreach( ob in obs ) {
             if( ob->query_property( "money" ) ) {
               temp = ob->query_money_array();
               money_in_safe += MONEY_HAND->query_total_value( temp, place );
             }
           }
           if( money_in_safe >= query_max_float() )
            do_banking();
         }

         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BUY_THING, this_player(), thing)) {
            add_succeeded_mess("$N $V $I.\n", ({ thing }) );
         }
         this_object()->something_bought( thing, this_player(), cost );
         if ( query_property( "package items" ) ) {
            thing = (object)this_object()->package_item( thing );
         }
         if ( (int)thing->move( this_player() ) != MOVE_OK ) {
            thing->move( this_object() );
            write( "You cannot pick "+ (string)thing->a_short() +
                  " up.  It's left on the floor for you.\n" );
         }
         sold += ({ thing });
      }
   }
   if (_buy_func) {
      evaluate(_buy_func, this_player(), sold);
   }
   return ret;
} /* do_buy() */

/** @ignore yes */
int do_word_browse( string words ) {
   int i;
   object thing;

   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }

   if ( strlen( words ) <= 2 ) {
      i = query_number_from_string( words );
      if ( i == -1) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BAD_LABEL, this_player(), words)) {
            add_failed_mess( "The item label must be from " +
                          start_letter() + " to " + end_letter() + ".\n" );
         }
         return 0;
      }
      thing = find_object_from_number(i);
      if ( !thing) {
         return 0;
      }
      return do_browse( ({ thing }) );
   }
   return 0;
} /* do_browse_word() */

/** @ignore yes */
int do_browse( object *things ) {
   int i;
   int num;
   string place;
   string mess;

   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }

   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   mess = "";
   for (i = 0; i < sizeof(things); i++) {
      if (query_num_items_left(things[i])) {
         mess += things[i]->the_short() + 
                 " is priced at " + MONEY_HAND->money_value_string(
                 this_object()->query_cost( things[ i ] ), place ) +
                 " and looks like:\n" + things[ i ]->long();
         num++;
      }
   }
   if (!num) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_SOLD_OUT, this_player(), things)) {
         add_failed_mess("The shop is sold out of $I.\n", things);
      }
      return 0;
   }
   if (!broadcast_shop_event(ITEM_SHOP_EVENT_BROWSE, this_player(), things, mess)) {
      write("$P$Browse things$P$" + mess);
      add_succeeded_mess(({ "", "$N $V $I.\n", }), things);
   }
   if (_browse_func) {
      evaluate(_browse_func, this_player(), things);
   }
   return 1;
} /* do_browse() */

/** @ignore yes */
void dest_me() {
  ::dest_me();  
} /* dest_me() */

/** @ignore yes */
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
  int stolen_from, difficulty;
  
  if( _safe ) {
    if( victim == _safe ) {
      // Record how many times the safe has been stolen from.
      stolen_from = _safe->query_property( "stolen from" );
      if( !stolen_from )
        _safe->add_property( "stolen from", 1 );
      else
        _safe->add_property( "stolen from", stolen_from + 1 );

      // Up the difficulty but only up to 10 (crack uses a the relative
      // difficulty scheme).
      difficulty = _safe->query_difficulty();
      if( difficulty + 1 <= 10 )
        _safe->set_difficulty( difficulty + 2 );
      else
        if( difficulty <= 10 )
          _safe->set_difficulty( difficulty + 1 );
      
    }
  }
}

/** @ignore yes */
void event_shoplift(object command_ob, object thief, object victim) {
   if (stringp(_shoplift_handler)) {
     if(_shoplift_handler != "none" ) {
       _shoplift_handler->handle_shoplift(thief, victim);
     }
   } else {
     "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
   }
} /* event_shoplift() */

void do_banking() {
  object ob, *obs;
  
  debug_printf( "Doing banking.\n" );
  if( _safe ) {
    obs = all_inventory( _safe );
     foreach( ob in obs ) {
       if( ob->query_property( "money" ) ) {
         ob->move( "/room/rubbish" );
       }
     }
   }
}

void set_max_float( int f ) {
  _max_float = f;
}

int query_max_float() {
  return _max_float;
}
// --- END [/mnt/home2/grok/lib/std/shops/inherit/item_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/clone_on_demand.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/clone_on_demand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629788   Available: 13577142
Inodes: Total: 5242880    Free: 4960136
9222 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/clone_on_demand.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629788   Available: 13577142
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a inheritable that provides an efficient way of storing
 * lots of items. Only one copy of the item is effectively in storage
 * and everytime one is removed, an exact copy is duplicated and
 * put back in the store. Objects are added to the store via
 * add_object(). The actual storage container object
 * can be returned by query_cont() and this container should be
 * searched when you want to find what objects the store contains.
 * <p>
 * Any object can inherit this, and methods
 * should be put in place in the inheriting file that end up calling
 * create_real_object() which will sort out duplicating the item
 * and returning an object pointer to the one you can deal with.
 * @example
 * inherit "clone_on_demand";
 * int do_buy( objects *obs );
 *
 * void setup(){
 *   set_name("shop");
 *   set_short("widget shop");
 *   add_object( "sprocket" );
 * }
 *
 * object create_object( string arg ){
 *   if( arg == "sprocket" )
 *     return clone_object( "/path/of/sprocket" );
 * }
 *
 * void init(){
 *   add_command("buy", "<indirect:object:" +
 *                      base_name( query_cont() ) + ">");
 * }
 *
 * int do_buy( object *obs ){
 *   object ob;
 *   foreach(ob in obs){
 *     widget = create_real_object(ob);
 *     widget->move( this_player() );
 *   }
 *   add_succeeded_mess( "$N buy$s $I.\n", obs );
 *   return 1;
 * }
 *
 * @author Pinkfish Aquilo
 * @see add_object
 */

#include <armoury.h>

#define INFINITE_LEFT 10000
#define MAX_PROP "max per reset"
#define NUM_REMOVED "number removed this reset"
#define REFERENCE "name we are reference by"
#define DISPLAY "display in shop"

nosave object _cont;
nosave string _domain;

void create(){
}

/**
 * This method returns the container which is used to keep one copy of
 * each items in storage.
 * @return the object container
 */
object query_cont(){  return _cont;  }

/** @ignore yes */
void check_cont() {
  if (!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
}

/** @ignore yes */
void reset() {
  object ob;
  check_cont();
  foreach( ob in all_inventory(_cont) ){
    ob->remove_property(NUM_REMOVED);
  }
}

/**
 * This method sets the domain the objects will be created from.
 * The default objects will always be matched as well.  So setting
 * this will allow objects from the default of the specified armoury
 * domain.
 * @param domain the domain to try and create from
 * @example
 * set_object_domain("cwc");
 */
void set_object_domain(string domain) {
   _domain = domain;
} /* set_object_domain() */

/**
 * This method returns the domain the objects will be created from.
 * @return the domain the objects are created from
 */
string query_object_domain() {
   return _domain;
} /* query_object_domain() */

/**
 * This method is used to add an item to the storage.
 * When this method is called, create_object() is called
 * (with the object name as an arg) in the inheriting file.
 * If no object is returned by that function,
 * the name is cloned with clone_object(), and failing that
 * request_item() is called in the armoury against the name.
 *
 * This method makes add_weapon() and add_armour() obsolete.
 *
 * @example
 * add_object( "frog", 1 + random( 3 ) );
 * // This will try and create an object called frog, in the order mentioned
 * // above
 * @example
 * add_object( "/obj/food/apple.food", 0 );
 * // Add unlimited numbers of apples.
 * @param name the name of the object to add.
 * @param max_per_reset the maximum number of items to be available at any one time
 * @param display_as the name that this item is displayed as in shops
 * @return 1 if the item was added successfully to the store, 0 if it was not.
 */
varargs int add_object( string name, int max_per_reset, string display_as ) {
  object ob;

  if(!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
  if (!(ob = this_object()->create_object(name))) {
    if(!ob = clone_object(name)) {
      ob = ARMOURY->request_item(name, 100, _domain);
    }
  }

  if(ob) {
    if (ob->query_decays()) {
      ob->set_decay_speed(0); // Stop decaying objects decaying in inventories.
    }
    ob->move(_cont);

    if (display_as) {
         ob->add_property( DISPLAY, display_as);
    }

    ob->add_property( REFERENCE, name);
    ob->add_property( MAX_PROP, max_per_reset );
    return 1;
  }
  return 0;
}

/**
 * Returns how more times object ob can be duplicated
 * @param ob the object to test
 * @return how many more times
 */
int query_num_items_left(object ob) {
   int max;
   int num;

   max = ob->query_property( MAX_PROP );
   num = ob->query_property( NUM_REMOVED );
   if( max ){
     return max - num;
   }
   return INFINITE_LEFT;
}

/**
 * This function returns the quantity of particular object available
 * to be cloned on demand. In matching which object is the one in
 * question it uses the short name of the object, which is passed as
 * an argument to the function.
 * @param name is the short name of the object you wish to query.
 * @return the number left, returns INFINITE_LEFT if the shop has an infinite
 * number, returns -1 if the item isn't stocked.
 */
int query_number_left(string name) {
   object * things;

   things = filter( all_inventory(_cont),
     (: $1->query_short() == $(name) :) );

   if( !sizeof(things) ) {
      return -1; // we don't have that item.
   }
   return query_num_items_left( things[0] );
} /* query_number_left() */

/**
 * This function can be used to check the quantity left of an array
 * of items.  It returns a parallel array of integers.  In other words
 * the array it returns contains the numbers of stock in array positions
 * corresponding to the array positions of the objects it was passed.
 * @example
 * query_items_left( ({ "banana" , "melon" }) )
 * would return ({ 12 , 6 }) if there were 12 bananas and 6 melons left.
 * @param names an array of the short names of the items you wish to query
 * @return an array of integers, each one returning like query_number_left
 * would for the object in that position of the object array.
 * @see query_number_left
 */
int * query_items_left( string *names ) {
   if( !names )
      return ({ });
   return map( names, (: query_number_left($1) :) );
}

/**
 * This function transfers certain tracking properties from the
 * original item to the new item which replaces it in storage. To
 * transfer any additional properties, have switch_extra_properties()
 * defined in your inheriting object and return an array of extra
 * properties to transfer
 */
private void switch_properties(object newone, object original) {
  mixed *extra, *props, prop;

  props = ({ MAX_PROP, NUM_REMOVED, REFERENCE });

  extra = this_object()->switch_extra_properties();
  if( sizeof(extra) )
    props += extra;

  foreach( prop in props ){
    newone->add_property( prop, original->query_property( prop ) );
    original->remove_property( prop );
  }

  if (newone->query_decay_speed()) {
     original->set_decay_speed( newone->query_decay_speed() );
     newone->set_decay_speed(0); // Stop decaying objects decaying in inventories.
  }
}

/**
 * The main point of entry. 'thing' should be an object already placed
 * in the clone_on_demand store container via 'add_object'. This
 * method then duplicates that object, replaces the original copy in
 * the container with this new one, and returns the original which can
 * be delt with as normal.
 * @param thing an object in the store
 * @return the original object
 * @see add_object
 */
protected object create_real_object(object thing) {
   string name;
   object new_thing, *continv, temp_cont;
   int j, max, num;

   name = thing->query_property( REFERENCE );
   if(!name)
     return 0;
   
   new_thing = this_object()->create_object( name );
   if ( !new_thing )  {
      new_thing = clone_object(name);
   }
   if ( !new_thing )  {
      new_thing = ARMOURY->request_item( name, 80 + random( 20 ), _domain );
   }

  if( new_thing ){
    switch_properties( new_thing, thing );

    /* Restore contents order */
    continv = all_inventory(_cont);
    j = member_array( thing, continv );
//    new_thing->move("/room/void");
    temp_cont = clone_object("/std/container");
    thing->move("/room/void");
    continv[j] = new_thing;
    new_thing->move(_cont);

      for (j=sizeof(continv)-1;j>=0;j--) {
      continv[j]->move(temp_cont);
      continv[j]->move(_cont);
    }
    temp_cont->dest_me();

    /* Decrement store if applicable */
    max = new_thing->query_property( MAX_PROP );
    num = new_thing->query_property( NUM_REMOVED );
    if ( max ) {
      new_thing->add_property( NUM_REMOVED, num + 1 );
    }
  }
  return thing;
}

/** @ignore yes */
void dest_me(){
  if( _cont )
    _cont->dest_me();
}

/* Old functions, use add_object instead */

/* ps 0, means infinite */
/** @ignore yes */
varargs int add_armour( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
} /* add_armour() */

/** @ignore yes */
varargs int add_weapon( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
} /* add_weapon() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/clone_on_demand.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/expression_util.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/expression_util.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629785   Available: 13577139
Inodes: Total: 5242880    Free: 4960136
6946 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/expression_util.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629785   Available: 13577139
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/basic/expressions";
#include <expressions.h>
#include <shops/craft_shop.h>
#include <nroff.h>

int is_allowed(string person);
void event_save(object ob);

private nosave string _type;

/**
 * This sets the thingy type.  It is what is put in front of the
 * control functions so many objects can set up exciting and confusing
 * controls of expressions.
 */
void set_expression_type(string type) {
   _type = type;
} /* set_expression_type() */

/**
 * This returns the expression type.
 * It is what is put in front of the
 * control functions so many objects can set up exciting and confusing
 * controls of expressions.
 * @return the expression type
 */
string query_expression_type() {
   return _type;
} /* qyery_expression_type() */

/**
 * This method allows a function to be added to the base set of user 
 * functions.
 * @param def the name and arguements
 * @param expr the expression itself
 * @return 1 on success, 0  on failure
 */
int do_user_function_add(string def, string expr) {
   string name;

if (this_player()->query_name() != "presto")
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add functions to this store.\n");
      return 0;
   }

   //
   // Ok, try and parse the arguments and function name first.
   //
   name = parse_user_expression(def, expr);
   if (name) {
      if (strlen(query_last_expression_warning())) {
         write("WARNING!!! Any changes of types could cause expressions "
               "currently using the functions to fail.\n" +
               query_last_expression_warning());
      }
      write("You successfully add:\n" + query_user_function_string(name));
      add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
      event_save(this_object());
      return 1;
   }

   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
} /* do_user_function_add() */

/**
 * This method allows a function to be added to the base set of user 
 * functions.
 * @param def the name and arguements
 * @param expr the expression itself
 * @return 1 on success, 0  on failure
 */
int do_user_function_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove functions from this store.\n");
      return 0;
   }

   //
   // Ok, try and parse the arguments and function name first.
   //
   if (query_user_function_return_type(name) != EXPRESSION_TYPE_ERROR) {
      if (remove_user_expression(name)) {
         add_succeeded_mess(({ "You remove the function " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
         return 1;
      }
   }

   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
} /* do_user_function_remove() */

/**
 * This method shows the status of all the user defined functions.
 * These can be used in other exciting functions.
 */
int do_approve_status_internal_functions() {
   string* names;
   string name;
   string ret;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   names = query_function_names();
   ret = "Functions:\n";
   foreach (name in names) {
      ret += query_type_name(query_function_type(name)) + " " + name +
             "(" + implode(map(query_function_args_types(name),
                               (: query_type_name($1) :)), ", ") +
             ")\n";
   }

   ret += "\nVariables:\n";
   names = query_variable_names();
   foreach (name in names) {
      ret += query_type_name(query_variable_type(name)) + " " + name +
             "\n";
   }
   write("$P$Internal functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_status_functions() */

/**
 * Get help on a specific function.
 * @param name the name of the function to get help on
 */
int do_function_help(string name) {
   string nroff_fn;
   string str;
   string fname;

   fname = CRAFT_SHOP_EXPRESSION_HELP_DIR + name;
   if (file_size(fname) <= 0) {
      add_failed_mess("There is no help for the function '" + name + "'.\n");
      return 0;
   }

   nroff_fn = NROFF_DIR + replace(fname, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(fname, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }

   write("$P$function: " + name + "$P$" + str);
   return 1;
} /* do_function_help() */

/**
 * Get help on a specific function.
 * @param name the name of the function to get help on
 */
int do_function_help_list() {
   string *names;

   names = get_dir(CRAFT_SHOP_EXPRESSION_HELP_DIR);
   if (!sizeof(names)) {
      add_failed_mess("There is no help on any functions.\n");
      return 0;
   }

   names -= ({ ".", "..", "RCS" });

   write(sprintf("%-#*s\n", this_player()->query_cols(), implode(names, "\n")));
   return 1;
} /* do_function_help_list() */

/**
 * This method shows the status of all the user defined functions.
 * These can be used in other exciting functions.
 */
int do_approve_status_functions(int hints) {
   string* names;
   string name;
   string ret;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   names = query_user_function_names();
   if (!sizeof(names)) {
      add_failed_mess("Could not find any user defined expressions.\n");
      return 0;
   }
   ret = "";
   foreach (name in names) {
      ret += query_user_function_string(name) + "\n";
   }
   if (hints) {
      ret += "$I$0=       Hint: add function <function> as <expression>";
      ret += "$I$0=       Hint: remove function <function>";
   }
   write("$P$User functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_status_functions() */

void init() {
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }

   add_command("add",
               _type + " function <string'function'> as <string'expression'>",
               (: do_user_function_add($4[0], $4[1]) :));
   add_command("remove",
               _type + " function <string'function'>",
               (: do_user_function_remove($4[0]) :));
   add_command("functions", _type + " internal",
               (: do_approve_status_internal_functions() :));
   add_command("functions", _type,
               (: do_approve_status_functions(0) :));
   add_command("functions", _type +" help list",
               (: do_function_help_list() :));
   add_command("functions", _type + " help <string'function name'>",
               (: do_function_help($4[0]) :));
   add_command("functions", _type + " hints",
               (: do_approve_status_functions(1) :));
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/expression_util.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/pawn_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/pawn_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629783   Available: 13577137
Inodes: Total: 5242880    Free: 4960136
9971 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/pawn_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629783   Available: 13577137
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/**
 * This inherit is under development.  Use at your own risk.
 * All bug reports to me, please.
 *
 * This is an inherit for pawn shops, which buy your items from you, but also
 * keep them for a short period of time for you to buy them back, before they
 * go into the shop's general inventory.
 *
 * It is built around the general store inherit /std/shop.
 *
 * @creator Vashti
 * @started 21st September 2002
 */

#include <money.h>
#include <move_failures.h>

#define RECEIPT "/obj/misc/pawn_receipt"
#define TO this_object()
#define TP this_player()

inherit "/std/shop" ;

private int    _pawn_ttl ;
private mixed  _pawn_mess ;
private int    _pawn_markup ;
private string _shop_language;


/**
 * This sets the language that the shop will use for receipts.
 * @param lang The language to write receipts in.
 */
void set_language( string lang ) {
    _shop_language = lang;
} /* set_language */


/**
 * This returns the language that the shop is using for receipts.
 * @return [string] The language receipts are written in.
 */
string query_language() {
    return _shop_language;
} /* query_language */


/**
 * This sets the percentage that the shop will mark reclaim prices up by.
 * The default is 20%.
 * @param percent The percentage to add to reclaim prices.
 */
void set_pawn_markup( int percent ) {
    _pawn_markup = percent ;
} /* set_pawn_markup */


/**
 * This returns the percentage that the shop will mark reclaim prices up by.
 * @return [int] The percentage to add to reclaim prices.
 */
int query_pawn_markup() {
    return _pawn_markup ;
} /* query_pawn_markup */



/**
 * This sets the time to live of pawned items, in seconds.  That is, the
 * length of time between an item being pawned and the shop selling that
 * item to recoup its costs.  The default is one week realtime.
 * @param ttl The time in seconds before the shop will sell a pawned item.
 */
void set_pawn_ttl( int ttl ) {
    _pawn_ttl = ttl ;
} /* set_pawn_ttl */


/**
 * This returns the time to live of pawned items, in seconds.  That is, the
 * length of time between an item's being pawned and the shop selling that
 * item to recoup its costs.
 * @return [int] The time in seconds before the shop will sell a pawned item.
 */
int query_pawn_ttl() {
    return _pawn_ttl ;
} /* query_pawn_ttl */


/**
 * This sets the message given out when somebody pawns something.
 * @param mess The message given when something is successfully pawned.
 */
void set_pawn_mess( mixed mess ) {
    _pawn_mess = mess ;
} /* set_pawn_mess */


/**
 * This returns the message given out when somebody pawns something.
 * @return [string] The message given when something is successfully pawned.
 */
string query_pawn_mess() {
    return _pawn_mess ;
} /* query_pawn_mess */


/** @ignore yes */
void create() {
    do_setup++ ;
    ::create() ;
    do_setup-- ;
    
    add_help_file( "pawn_shop" ) ;
    remove_help_file( "shop" );
  
    _pawn_mess = ({
        "You pawn $ob$ for $money$.\n",
        "$client$ pawns $ob$.\n"
    }) ;

    _pawn_markup = 20 ;             /* 20% */
    _pawn_ttl = 7 * 24 * 60 * 60 ;  /* 1 Roundworld week */
    _shop_language = "morporkian" ;
    set_min_amount( 400 ) ;         /* A$1 ; 4 silver coins */
    add_property( "no steal", 1 ) ; /* You can't just steal your item back */
    
    if ( ! do_setup ) {
        TO->setup() ;
        TO->reset() ;
    }
} /* create */


/** @ignore yes */
void init() {
    ::init() ;
    add_command( "pawn", "<indirect:object:me'items'>" ) ;
} /* init */


/**
 * This handles pawning items to the shop.
 */
int do_pawn( object *in_obs ) {
    int value, total ;
    mixed *m_array ;
    object ob, money, receipt ;
    object *cheap, *cre, *expensive, *kept, *nobuy, *stolen, *worn ;
    string place, fn ;
    string *text = ({ }) ;
    
    /* Make sure the shop is open for business */
    if ( ! is_open( TP, 0 ) ) {
        return 0 ;
    }
    
    in_obs = uniq_array( in_obs ) ;

    /* Check for cre-only items */
    cre = filter( in_obs, (: creator_object($1) :) ) ;
    if ( sizeof(cre) ) {
        if ( ! TP->query_creator() ) {
            tell_object( TP,
                "Oh dear, you shouldn't have " + query_multiple_short( cre ) +
                "!  "
                + ( sizeof(cre) > 1 ? "They disappear" : "It disappears" ) +
                " with a flash of octarine light.\n" ) ;
            cre->move( "/room/rubbish" ) ;
        } else {
            tell_object( TP,
                "You decide not to pawn " + query_multiple_short( cre ) +
                ", as " + ( sizeof(cre) > 1 ? "they are creator-only items"
                : "it is a creator-only item" ) + ".\n" ) ;
        }

        foreach( ob in cre ) {
            if ( fn = ob->query_property( "virtual name" ) ) {
                fn = ob->query_property( "virtual name" ) ;
            } else {
                fn = base_name( ob ) ;
            }
            text += ({ fn }) ;
        }
        
        log_file( "ILLEGAL_OBJECT", "%s: %s tried to pawn %s at %s.\n\n",
            ctime(time()), TP->query_name(), query_multiple_short( text ),
            file_name( TO ) ) ;
        
        in_obs -= cre ;
    }
    
    /* Check for kept items */
    kept = filter_array( in_obs, (: $1->query_keep() :) ) ;
    if ( sizeof(kept) ) {
        tell_object( TP,
            "You decide not to pawn " + query_multiple_short( kept ) +
            ", as you are keeping " + ( sizeof(kept) > 1 ? "them" : "it" )
            + ".\n" ) ;
        in_obs -= kept ;
    }

    /* Check for held or worn items */
    worn = filter( in_obs, (: $1->query_holder() || $1->query_worn_by() :) ) ;
    if ( sizeof(worn) ) {
        tell_object( TP, "You decide not to pawn "
            + query_multiple_short( worn ) + ", because you are wearing or "
            "holding " + ( sizeof(worn) > 1 ? "them" : "it" ) + ".\n" ) ;
        in_obs -= worn ;
    }

    /* Reject stolen items. */
    stolen = filter( in_obs, (: $1->query_property( "stolen" ) :) ) ;
    if ( sizeof(stolen) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( stolen ) +
            " because " + ( sizeof(stolen) > 1 ? "they're" : "it's" ) +
            " stolen!\n" ) ;
        in_obs -= stolen ;
    }

    /* Check for items that can't be sold, or that we don't buy */
    nobuy = filter( in_obs, (: $1->do_not_sell() || TO->do_not_buy($1) :) ) ;
    if ( sizeof( nobuy ) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( nobuy ) + ".\n" ) ;
        in_obs -= nobuy ;
    }
    
    /* Check for items that are too cheap */
    cheap = filter( in_obs, (: $1->query_value() < TO->query_min_amount() :) ) ;
    if ( sizeof(cheap) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( cheap ) +
            " as " + ( sizeof(cheap) > 1 ? "they are" : "it is" ) +
            " not expensive enough.\n" ) ;
        in_obs -= cheap ;
    }
    
    /* Check for items that are too expensive */
    expensive = filter( in_obs,
        (: $1->query_value() > TO->query_max_amount() :) ) ;
    if ( sizeof(expensive) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( expensive ) +
            " as " + ( sizeof(expensive) > 1 ? "they are" : "it is" ) +
            " too expensive.\n" ) ;
        in_obs -= expensive ;
    }
    
    /* Make sure we have something left to pawn after all that */
    if ( ! sizeof( in_obs ) ) {
        add_failed_mess( "You have nothing to pawn.\n" ) ;
        return 0 ;
    }

    /* Okay, we've passed all the checks.
     * Let's do some pawning.
     */

    /* Prepare for the sale - tally up how much money we have to give them,
     * give them the receipt(s), then zap the originals.
     */
    foreach( ob in in_obs ) {
        /* To get the value of the item, we use the same procedure as general
         * stores do for items that they don't specialise in.  This is so that
         * it doesn't become more worthwhile to pawn an object than to take it
         * to a general store.
         */
        value = scaled_value( ob->query_value() ) ;
        value = ( value * 90 ) / 100;
        total += value ;
        
        receipt = clone_object( RECEIPT ) ;
        if ( ! receipt ) {
            add_failed_mess(
                "Oh dear, something went very wrong (can't clone receipt object).  "
                "Please bugrep this room.\n" ) ;
            return 0 ;
        }
        receipt->setup_receipt( ob ) ;
        receipt->set_shop_path( TO ) ;
        receipt->set_item_value( value ) ;
        receipt->set_expiry_time( time() + query_pawn_ttl() ) ;
        receipt->setup_read_mess( _shop_language );
        receipt->move( TP ) ;
        ob->move( "/room/rubbish" ) ;
    }
    
    /* Get the currency in use */
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }

    /* Transfer some money to the mark^Wpawner */
    m_array = MONEY_HAND->create_money_array(total, place);
    money = clone_object(MONEY_OBJECT);
    if ( ! money ) {
        add_failed_mess(
            "Oh dear, something went very wrong (can't clone money object).  "
            "Please bugrep this room.\n" ) ;
        return 0 ;
    }
    money->set_money_array(m_array);

    if ( money->move( TP ) != MOVE_OK ) {
        tell_object( TP,
            "You're too heavily burdened to accept all that money, so the "
            "shopkeeper puts it on the floor.\n" ) ;
        money->move( TO ) ;
    }
    
    do_parse( _pawn_mess, in_obs, TP,
        MONEY_HAND->money_string( m_array ), "" ) ;
    
    return 1 ;
} /* do_pawn */


/** @ignore yes
 * Pawn shops don't just buy things.
 */
int do_sell( object *in_obs ) {
    add_failed_mess(
        "If you just want to sell items, you'll need to find a general "
        "store.  Pawn shops are for pawning in.\n" ) ;
    return 0 ;
} /* do_buy */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/pawn_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/bank_franchise.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/bank_franchise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629781   Available: 13577135
Inodes: Total: 5242880    Free: 4960136
5928 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/bank_franchise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629781   Available: 13577135
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The inherit to use for franchises for the bank.
 * @author Pinkfish
 * @started Fri Jun 15 18:52:48 PDT 2001
 */
inherit "/std/shops/inherit/bank_base";
#include <money.h>
#include <shops/bank.h>

class credit_note {
   int num;
   int amt;
   int made;
   string maker;
}

private int _credit_num;
private class credit_note* _notes;

void create() {
   _notes = ({ });
   ::create();
} /* create() */

/** @ignore yes */
int is_allowed(string name) {
   return 0;
}

/**
 * Are they allowed for credit transactions, listing outstanding credit,
 * making credit notes, etc.  This should allow the standard owner and the
 * owner of the main branch.
 * @param name the player name
 */
int is_allowed_credit(string name) {
   return is_allowed(name) ||
          name == query_main_branch_owner();
} /* is_allowed_credit() */

/**
 * This allows the current credit number for credit notes to be set.
 * @param num the new credit number
 */
protected void set_credit_num(int num) {
   _credit_num = num;
} /* set_credit_num() */

/**
 * This method returns the current credit number.
 * @return the current credit number
 */
int query_credit_num() {
   return _credit_num;
} /* query_credit_num() */

/**
 * This allowed the set of outstanding credit notes to be set.
 * @prarm notes the set of outstanding notes
 */
protected void set_credit_notes(class credit_note* notes) {
   _notes = notes;
} /* set_credit_notes() */

/**
 * This method returns the array of outstanding credit notes.
 * @return the array of outstanding credit notes
 */
class credit_note* query_credit_notes() {
   return copy(_notes);
} /* query_credit_notes() */

/**
 * This method returns the amount of money currently in outstanding credit
 * notes.
 * @return the amount in outstanding credit notes
 */
int query_outstanding_credit_value() {
   int diff;
   class credit_note note;

   foreach (note in _notes) {
      diff += note->amt;
   }
   return diff;
} /* query_outstanding_credit_value() */

/**
 * This method creates a credit note for the store based on wild and
 * exciting stuff.
 * @return 1 on success, 0 on failure
 */
int do_create() {
   object ob;
   int diff;

   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for creating credit notes.\n");
      return 0;
   }

   diff = query_total_difference() - query_outstanding_credit_value();

   if (diff == 0) {
      add_failed_mess("The bank is currently at a zero balance with the "
                      "outstanding credit notes.\n");
      return 0;
   }

   ob = clone_object(BANK_CREDIT_NOTE);
   ob->set_credit_num(++_credit_num);
   ob->set_franchise(query_franchise());
   ob->set_bank_name(query_bank_name());
   ob->set_amount(query_total_difference());
   ob->add_property("place", query_money_place());
   ob->setup_read_messages();
   ob->move(this_player());
   if (!_notes) {
      _notes = ({ });
   }
   _notes += ({ new(class credit_note, num : ob->query_credit_num(),
                                   amt : ob->query_amount(),
                                   maker : this_player()->query_cap_name(),
                                   made : time()) });
   event_save(this_object());
   //adjust_total_difference(-query_total_difference());
   add_succeeded_mess("$N $V " + ob->a_short() + ".\n");
   return 1;
} /* do_create() */

/** @ignore yes */
int do_list() {
   class credit_note note;
   string ret;
   string place;

   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for listing credit notes.\n");
      return 0;
   }

   place = query_money_place();

   if (!sizeof(_notes)) {
      add_failed_mess("No credit notes to list.\n");
      return 0;
   }

   ret = "Credit notes\n\n";
   foreach (note in _notes) {
      ret += "$I$6=" + sprintf("%3d) ", note->num) +
             ctime(note->made) + ": by " +
             note->maker + " for " +
             MONEY_HAND->money_value_string(note->amt, place) + "\n";
   }

   write("$P$Credit Notes$P$" + ret);
   return 1;
} /* do_list() */

/** @ignore yes */
int do_recind(int id) {
   class credit_note note;
   int i;
   string place;

   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for listing credit notes.\n");
      return 0;
   }

   for (i = 0; i < sizeof(_notes); i++) {
      note = _notes[i];
      if (note->num == id) {
          place = query_money_place();
          _notes = _notes[0..i-1] + _notes[i+1..];
          add_succeeded_mess(({ 
             "You recind #" + note->num + " made at " +
             ctime(note->made) + " by " +
             note->maker + " for " +
             MONEY_HAND->money_value_string(note->amt, place) + "\n", "" }));
          return 1;
      }
   }

   add_failed_mess("Unable to find credit note #" + id + ".\n");
   return 0;
} /* do_recind() */

/**
 * This method checks to find if the note is valid or not.
 * @param id the not to check
 * @return 1 on success, 0 on failure
 */
int is_valid_note(int id) {
   int i;

   for (i = 0; i < sizeof(_notes); i++) {
      if (_notes[i]->num == id) {
         return 1;
      }
   }
   return 0;
} /* is_valid_note() */

/**
 * THis is called when a specific credit note is processed
 * @param id the id of the note to process
 * @return 1 on a sucessful processing
 */
int process_note(int id) {
   int i;

   if (!is_valid_note(id)) {
      return 0;
   }
   for (i = 0; i < sizeof(_notes); i++) {
      if (_notes[i]->num == id) {
         adjust_total_difference(-_notes[i]->amt);
         _notes = _notes[0..i-1] + _notes[i+1..];
         i--;
      }
   }
   event_save(this_object());
   return 1;
} /* process_note() */


void init() {
   ::init();
   add_command("create", "credit note");
   add_command("list", "credit notes");
   add_command("recind", "credit note <number'id'>", (: do_recind($4[0]) :));
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/bank_franchise.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/object_expressions.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/object_expressions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629779   Available: 13577133
Inodes: Total: 5242880    Free: 4960136
11103 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/object_expressions.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629779   Available: 13577133
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the file with all the functions that get information
 * about objects.  All of these methods assume they are called
 * with the following data:  seller, objects
 * @author Pinkfish
 * @started Fri Jun  1 21:37:14 PDT 2001
 */
#include <expressions.h>
#include <player_handler.h>

#define CHARGE_MULT 10 /* This is out of /obj/weapons/maces/cleric_rod.c */

string query_owner();
string* query_allowed();

void add_allowed_function(string name, int type, int* args, function value);
void add_allowed_variable(string name, int type, function value);

private int function_object_base_value(object* obs) {
   int value;
   object ob;
   int tmp;

   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_base_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
} /* function_object_base_value() */

private int function_object_value(object* obs) {
   int value;
   object ob;
   int tmp;

   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
} /* function_object_value() */

private int function_object_condition(object* obs) {
   int cond;
   object ob;
   int tmp;
   int max;

   cond = 100;
   foreach (ob in obs) {
      tmp = ob->query_cond();
      max = ob->query_max_cond();
      if (max) {
         tmp = tmp * 100 / max;
         if (tmp < cond) {
            cond = tmp;
         }
      }
   }
   return cond;
} /* function_object_condition() */

private int function_object_enchant(object*obs) {
   int enchant;
   object ob;
   int tmp;
   int max;
   string bing;

   if (!sizeof(obs)) {
      return 0;
   }

   //
   // First check to see if any of the owners can actually detect this.
   //
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_octarine()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_octarine()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }

   enchant = 100;
   foreach (ob in obs) {
      tmp = ob->query_enchant();
      max = ob->query_max_enchant();
      tmp = tmp * 100 / max;
      if (tmp < enchant) {
         enchant = tmp;
      }
   }
   return enchant;
} /* function_object_enchant() */

private string function_object_type(object* obs) {
   string type;
   string old_type;
   object ob;

   if (!sizeof(obs)) {
      return 0;
   }

   //
   // First check to see if any of the owners can actually detect this.
   //
   foreach (ob in obs) {
      if (ob->query_weapon()) {
         type = "weapon";
      } else if (ob->query_armour()) {
         type = "armour";
      } else if (ob->query_clothing()) {
         type = "clothing";
      } else {
         type = "misc";
      }
      if (old_type && old_type != type) {
         type = "mixed";
      }
      old_type = type;
   }

   return type;
} /* function_object_type() */

private object* function_object_stolen(object* obs) {
   obs = filter(obs, (: $1->query_property("stolen") :));
   return obs;
} /* function_object_stolen() */

private object* function_object_warded(object* obs) {
   string classification;

   classification = "/std/effects/object/ward"->query_classification();
   obs = filter(obs, (: sizeof($1->effects_matching($2)) :), classification);
   return obs;
} /* function_object_warded() */

private object* function_object_contains_spell(object* obs, string spell_name) {
   string bing;
   int tmp;

   if (!sizeof(obs)) {
      return 0;
   }

   //
   // First check to see if any of the owners can actually detect this.
   //
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_spells()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_spells()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }

   obs = filter(obs, (: $1->query_magic_scroll() &&
           ($2 == "any" || lower_case($1->query_spell_name()) == lower_case($2)) :), spell_name);
   return obs;
} /* function_object_contains_spell() */

private object* function_object_contains_imbue(object* obs, string ritual_name) {
   if (!sizeof(obs)) {
      return ({ });
   }


   obs = filter(obs, (: $1->query_faith_imbue() &&
      ($2 == "any" ||
       lower_case($1->query_ritual_name()) == lower_case($2)) :), ritual_name );
   return obs;
} /* function_object_contains_ritual() */

private int function_object_percentage_liquid(object* obs, string liquid_name) {
   object ob;
   object* liquids;
   object liq;
   int volume;
   int found;
   int tmp;

   if (!sizeof(obs)) {
      return 0;
   }

   volume = 100;
   foreach (ob in obs) {
      //
      // See what liquids are in the object
      //
      liquids = filter(all_inventory(ob), (: $1->query_liquid() :));
      if (sizeof(liquids))  {
         foreach (liq in liquids) {
            if (liq->query_short() &&
                lower_case(liq->query_short()) == lower_case(liquid_name)) {
               tmp = liq->query_weight() * 100 / ob->query_max_weight();
               if (tmp < volume) {
                  volume = tmp;
                  found = 1;
               }
            }
         }
      }
      // Problem: some things (like healing vials) don't actually have
      // anything in them.  So we have to do something different.
      else if (ob->query_liquid_short() &&
               lower_case(ob->query_liquid_short()) ==
               lower_case(liquid_name))
      {
         tmp = ob->query_water_volume() * 100 / ob->query_max_volume();
         if (tmp < volume)  {
            volume = tmp;
            found = 1;
         }
      }
   }
   if (found) {
      return volume;
   }
   return 0;
} /* function_object_percentage_liquid() */

private int function_object_charges(object* obs) {
   int total = 0;
   int possible = 0;
   int charges;
   mixed info;
   object ob;

   foreach (ob in obs)  {
      charges = ob->query_charges();
      if (charges)  {
         info = ob->query_static_auto_load();
         if (pointerp(info)  &&  sizeof(info) == 2  &&  info[0] == charges)  {
            possible += info[1] * CHARGE_MULT;
            total += charges;
         }
      }
   }
   if (possible)
      return 100 * total / possible;
   else
      return 0;
} /* function_object_charges() */

private object* function_object_matching(object* obs, string match) {
   object ob;
   string *bits;
   string bit;
   object* ret;

   bits = explode(match, ",");
   ret = ({ });
   foreach (ob in obs)  {
      foreach(bit in bits)   {
         if (ob && ob->full_id(bit)) {
            ret += ({ ob });
         }
      }
   }
   return ret;
} /* function_object_matching() */

private object* function_object_short(object* obs, string match) {
   string* bits;
   object* result;

   bits = explode(match, ",");
   result = filter(obs, (: member_array(strip_colours($1->query_short()), $2) != -1 :),
                   bits);
   return result;
} /* function_object_short() */

private object* function_contents(object ob) {
   if (!ob) {
      return ({ });
   }
   return all_inventory(ob);
} /* function_contents() */

/**
 * This method adds all the object base functions.
 */
void create() {
   if (!function_exists("add_allowed_function", this_object())) {
      return ;
   }
   add_allowed_function("objectenchant", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_enchant :) );
   add_allowed_function("objectvalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_value :) );
   add_allowed_function("objectbasevalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_base_value :) );
   add_allowed_function("objectcondition", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_condition :) );
   add_allowed_function("objecttype", EXPRESSION_TYPE_STRING,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_type :) );
   add_allowed_function("objectwarded", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_warded :) );
   add_allowed_function("objectstolen", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_stolen :) );
   add_allowed_function("charges", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_charges :) );
   add_allowed_function("containsspell", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_spell :) );
   add_allowed_function("containsimbue", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_imbue :) );
   add_allowed_function("percentageliquid", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_percentage_liquid :) );
   add_allowed_function("objectmatch", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_matching :) );
   add_allowed_function("objectshort", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_short :) );
   add_allowed_function("contents", EXPRESSION_TYPE_OBJECT +
                                    EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT }),
                        (: function_contents :) );
} /* create() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/object_expressions.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629776   Available: 13577130
Inodes: Total: 5242880    Free: 4960136
14745 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629776   Available: 13577130
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room will handle craft shop like things, where you sell stuff to
 * the store and it will sell it onto other players after taking
 * a margin.  This can be used for potions, pottery, swords, anything!
 * @author Pinkfish
 * @started Thu Feb  5 15:39:57 CST 1998
 */
#include <money.h>
#include <shops/craft_shop.h>

inherit "/std/shops/inherit/craft_shop";

private nosave function _cat_extra_sell_check;
private string _default_category;

#define DAY (24 * 60 * 60)

//
// Predefinitions.
//
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables);
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories);
int do_list_category(string category);
int do_change_category(object* obs, string category);

void create() {
   ::set_extra_sell_check( (: setup_category :) );
   if (!_default_category) {
      _default_category = "General";
   }
   ::create();
} /* create() */

void init() {
   string storeroom;

   ::init();

   if (query_controller()) {
      storeroom = file_name(query_controller()->query_sell_list());
      add_command("change", "category of <indirect:object:" + storeroom +
                            "> to <string'category'>",
                  (: do_change_category($1, $4[1]) :));
   }
   add_command("list", "<string'category'>", (: do_list_category($4[0]) :));
} /* init() */

/**
 * This method adds a category into the accept list immediately.  This should
 * really only be used for initialy setting up the shop.
 * @param category the name of the category
 */
void add_shop_category(string category) {
   query_controller()->add_category_accepted(category);
} /* add_shop_category() */

/**
 * This method sets the description of the category.
 * @param category the name of the category
 * @param description the new description
 */
void set_category_description(string category, string description) {
   query_controller()->set_category_description(category, description);
} /* set_category_description() */

/**
 * This method sets the description of the category.
 * @param category the name of the category
 * @param info the new information
 */
void set_category_information(string category, string information) {
   query_controller()->set_category_information(category, information);
} /* set_category_information() */

/**
 * This method forcibly removes a category from the accepted list.
 * @param category the category to remove
 */
void remove_shop_category(string category) {
   query_controller()->remove_category_accepted(category);
} /* remove_shop_category() */

private void setup_default_category() {
   if (!query_controller()->is_valid_category(_default_category) &&
       _default_category) {
      add_shop_category(_default_category);
   }
} /* setup_default_category() */

/**
 * This method returns the current default category for the shop.
 * @return the default category
 */
string query_default_category() {
   return _default_category;
} /* query_default_category() */

/** @ignore yes */
void set_controller(string name) {
   ::set_controller(name);
   setup_default_category();
} /* set_controller() */

/**
 * You should run this when you change the system to the category
 * based system.  It will go through and set anything without
 * a category to have a category.
 */
void update_categories() {
   object *obs;
   object ob;

   //
   // Zip through an update all of the existing things to be in the
   // default category.
   //
   obs = query_controller()->query_sell_list_obs();
   foreach (ob in obs) {
      if (!query_controller()->query_category_of_shop_object(ob)) {
         query_controller()->change_category_of_shop_object(ob, _default_category);
      }
   }
} /* set_controller() */

/**
 * This correctly cases the name.
 * @return the correctly cases name, or 0 for failure
 */
string query_real_category_name(string in_cat) {
   string* categories;
   string cat;

   categories = query_controller()->query_categories();
   foreach (cat in categories) {
      if (lower_case(cat)[0..strlen(in_cat)-1] == lower_case(in_cat)) {
          return cat;
      }
   }
   return 0;
} /* query_real_category_name() */

/**
 * This method sets a category on the sellables.  It is called from
 * within the craft shop code itself.
 * @param func the function to call on exit
 * @param value the current value of the item
 * @param name the name of object
 * @param sellables the items for sale
 */
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables) {
   string* categories;
   string cat;
   int i;

   //
   // Check to see if this name/owner choice has a category already.
   //
   cat = query_controller()->query_category_of(name,
                                               this_player()->query_name());
   if (cat) {
      evaluate(func, value, name, sellables, cat);
   } else {
      categories = query_controller()->query_categories();
      if (sizeof(categories) == 1) {
         write("There is only category, putting it into the default " +
               categories[0] + ".\n");
         evaluate(func, value, name, sellables, categories[0]);
      } else {
         write("Categories:\n");
         for (i = 0; i < sizeof(categories); i++) {
            write(sprintf("%c) %s\n", i + 'A', categories[i]));
         }
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
      }
   }
} /* setup_category() */

private void complete_cat_sale(int value,
                               string name,
                               object* sellables,
                               string category,
                               function func) {
   evaluate(func, value, name, sellables, category);
} /* complete_cat_sale() */

/**
 * This method chooses which category to set the item in.
 * @param category the category to choose
 * @param func the function to call on exit
 * @param value the current value of the item
 * @param name the name of object
 * @param sellables the items for sale
 */
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories) {
   string real_category;

   if (!strlen(category)) {
      write("Ok, stopping the sell.\n");
      return ;
   }

   if (strlen(category) == 1) {
      category = lower_case(category);
      if (category[0] < 'a' ||
          category[0] >= 'a' + sizeof(categories)) {
         write("Sorry, " + category + " is out of range.  Try again.\n");
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories); 
         return ;
      } else {
         real_category = categories[category[0] - 'a'];
      }
   } else {
      real_category = query_real_category_name(category);
      if (!real_category) {
         write("Sorry, " + category + " is not a category.\n");
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
         return ;
      }
   }
   if (!real_category) {
      setup_category(func, value, name, sellables);
   } else {
      if (_cat_extra_sell_check) {
         evaluate(_cat_extra_sell_check,
                  (: complete_cat_sale :),
                  value, name, sellables, real_category, func);
      } else {
         complete_cat_sale(value, name, sellables, real_category, func);
      }
   }
} /* choose_category() */

/**
 * This method lists a specific category of items.
 * @param category the category to list
 */
int do_list_category(string category) {
   string place;
   string info;
   object *obs;
   object ob;
   mixed *morestuff;
   string ret;
   string list;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "list")) {
      return 0;
   }

   list = query_real_category_name(category);

   if (!list ||
       !query_controller()->is_valid_category(list)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }

   info = query_controller()->query_category_information(list);
   /* Do a list of the wombles... */
   obs = query_controller()->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), list );
   ret = "";
   ret += list + ":\n";
   if (info) {
      ret += "$I$3=" + info + "\n";
   }
   morestuff = unique_array(obs, (: query_controller()->query_id_of_shop_object($1) :));
   morestuff = sort_array(morestuff, (:
                strcmp(query_controller()->query_id_of_shop_object($1[0]),
                       query_controller()->query_id_of_shop_object($2[0])) :) );
   foreach (obs in morestuff) {
      ob = obs[0];
      ret += "$I$9=$C$   " + query_controller()->query_id_of_shop_object(ob) +
            ") $C$" + ob->short() + " for " +
            MONEY_HAND->money_value_string(ob->query_value(), place) + "; " +
            query_num(sizeof(obs)) + " left.\n";
   }
   write("$P$Shop list" + list + "$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
} /* do_list_category() */

/**
 * @ignore yes
 */
int do_list() {
   string place;
   object *obs;
   mixed *stuff;
   mixed *morestuff;
   string ret;
   string* categories;
   string cat;
   string desc;
   object ob;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "list")) {
      return 0;
   }

   /* Do a list of the wombles... */
   obs = query_controller()->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   categories = query_controller()->query_categories();
   stuff = unique_array(obs, (: query_controller()->query_category_of_shop_object($1) :), 12 );
   ret = "";
   foreach (obs in stuff) {
      if (!query_controller()->query_category_of_shop_object(obs[0])) {
         cat = "No category";
         foreach (ob in obs) {
            query_controller()->change_category_of_shop_object(ob, 
                              query_default_category());
         }
         cat = query_default_category();
      } else {
         cat = query_controller()->query_category_of_shop_object(obs[0]);
         categories -= ({ query_controller()->query_category_of_shop_object(obs[0]) });
         desc = query_controller()->query_category_description(cat);
      }
      morestuff = unique_array(obs, (: query_controller()->query_id_of_shop_object($1) :));
      //morestuff = unique_array(obs, (: $1->query_short() :));
      ret += "$I$3=" + cat + ": " + sizeof(morestuff) + 
             " different item" + (sizeof(morestuff)>1?"s":"") + " for sale.\n";
      if (desc) {
         ret += "$I$6=   " + desc + "\n";
      }
   }

   if (sizeof(categories) > 1) {
      ret += "$I$0=The categories " + query_multiple_short(categories) +
             " do not have anything for sale.\n";
   } else if (sizeof(categories)) {
      ret += "$I$0=The category " + query_multiple_short(categories) +
             " does not have anything for sale.\n";
   }

   ret += "\n$I$0=Please list each category for the items in the category.\n";
   write("$P$Shop list$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
} /* do_list() */

int do_change_category(object *obs, string new_category) {
   object *frog;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "change")) {
      return 0;
   }

   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the category of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }

   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }

   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }

   if (query_controller()->change_category_of_shop_object(obs[0], new_category)) {
      add_succeeded_mess(({ "You change the category of $I to " +
                               new_category + ".\n",
                               "$N changes the category of $I.\n" }),
                         ({ obs[0] }) );
   } else {
      add_failed_mess("Unable to change to category " + new_category + ".\n", obs);
   }

   return 1;
} /* do_change_category() */

/**
 * This method sets the extra sell function for the shop.  The extra sell
 * function is called after the sell process is almost finished.  It can
 * check for extra things needed in the sell process, like which page of
 * the book to browse.
 * @param func the extra sell function
 * @see query_extra_sell_check()
 * @see complete_sell()
 */
void set_extra_sell_check(function func) {
   _cat_extra_sell_check = func;
} /* set_extra_sell_check() */

/**
 * This method returns the extra sell check function.
 * @return the extra sell check function
 * @see set_extra_sell_check()
 */
function query_extra_sell_check() {
   return _cat_extra_sell_check;
} /* query_extra_sell_check() */

/**
 * This method sets the default category for the item.  This must be setup
 * for something useful to happen.
 * @param category the default category
 */
void set_default_category(string category) {
  _default_category = category;
} /* set_default_category() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/craft_shop_category.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/pub.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/pub.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629772   Available: 13577126
Inodes: Total: 5242880    Free: 4960136
26705 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/pub.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629772   Available: 13577126
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the inheritable bit of the pub.  The actual file you should
 * inherit is /std/shops/pub_shop.c
 * <p>
 * Based on the original "pub.c" code, this version allows you to buy an
 * actual drink (inna glass) instead of just forcefeeding you with whatever
 * you purchase.  You can also create food and serve it on plates, in boxes,
 * or whatever.
 * <p>
 * The items on sale are either cloned from the armoury, cloned from a file
 * or cloned in the "create_item()" code in the pub code itself.  Containers
 * for these items are done in the same way, using the "create_container()"
 * function.  This is the same as the "create_object()" system in
 * "item_shop.c".  You can also buy items for other people (or groups of
 * other people) in the pub.
 * <p>
 * There are several standard glasses and plates available for drinks and
 * food in the "pub_shop.h" header file, if you don't want to create the
 * glasses and plates yourself.  These plates use the "/obj/misc/plate.c"
 * inheritable file.
 * <p>
 * A "counter" will automatically be placed in the pub.  If any item cannot
 * be moved into the person who ordered it (i.e they are carrying too much )
 * it will be placed on the counter.  Empty glasses and so on will be
 * cleared from the counter after 3 seconds.  To ensure that this happens,
 * make sure that the container object you use has the property "pub item"
 * added to it.  Items will only be cleared if they are empty.
 * @author Lemming
 * @started 23/10/1999
 * @see /std/shops/pub_shop.c
 * @see /include/shops/pub_shop.h
 * @see /include/volumes.h
 */

#include <shops/pub_shop.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <map.h>

inherit "/std/shops/inherit/open_shop";
inherit "/std/shops/inherit/shop_event";

//
// Predefinitions needed from room.c
//
void add_hidden_object(object ob);

private mapping _menu_items;
private mapping _menu_aliases;
private string _menu_header;
private string _language;
private int _display_header;
private string *_menu_subheadings;
private int _display_subheadings;
private int no_standard_alias;
private object _menu_object;
private object _counter;

void add_menu_alias( mixed alias, string actual );
string *calc_standard_aliases( string *aliases );
int do_buy( object *obs, string dir, string indir, mixed *args );
float query_discount( object ob );
object make_counter();

/** @ignore */
void create() {
   shop_event::create();
   _menu_items = ([ ]);
   _menu_aliases = ([ ]);

   _menu_header = "The menu reads:";
   _display_header = 1;

   _menu_subheadings = ({ "Appetisers", "Main Courses", "Desserts",
                         "Alcoholic Beverages", "Soft Drinks",
                         "Hot Drinks" });
   _display_subheadings = 1;

   if( base_name( this_object() ) + ".c" != __FILE__ ) {
      _menu_object = clone_object( PUB_MENU_FILE );
      _menu_object->set_pub( this_object() );
      add_hidden_object( _menu_object );

      _counter = make_counter();
   }
} /* create() */

/** @ignore */
void init() {
   this_player()->add_command( "buy", this_object(), "<string>" );
   this_player()->add_command( "buy", this_object(),
                     "<string> for <indirect:living:here>" );
   this_player()->add_command( "order", this_object(), "<string>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
   this_player()->add_command( "order", this_object(),
                     "<string> for <indirect:living:here>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
} /* init() */

/**
 * This is the method used to add items to the menu.  Only the first four
 * parameters are required, the rest are optional.
 * <p>
 * The "type" parameter is used to determine which section of the menu the
 * item should reside in, and should be selected from those in the
 * "pub_shop.h" header file.
 * <p>
 * The "item" parameter is used to generate the actual product on sale.  This
 * value can be:
 * <ul>
 * <li> a name, which is passed to the "create_item()" function in the room code
 * <li> a filename, which is cloned, or
 * <li> an armoury identifier, which is passed to the armoury handler.
 * </ul>
 * <p>
 * The "container" parameter is the same as the "item" parameter, except that
 * it refers to the container the item comes in and is passed to
 * "create_container()" instead of "create_item()".  You can also use the
 * standard containers listed in the "pub_shop.h" header file.  It is
 * optional, and setting it to 0 will cause it to be ignored.
 * <p>
 * The "volume" parameter is optional and is passed directly to
 * "set_amount()" on the object cloned from "item".  It can be used to alter
 * the volume of a liquid cloned from a file, so the file itself does not
 * have to be changed.  It is optional, and setting it to 0 will cause it to
 * be ignored.  If this is set to 0 then the item will fill up the
 * container.  Standard volume definitions can be found in the "volumes.h"
 * header file.
 * <p>
 * The last parameter, "intox", is optional and is used only by NPCs to
 * determine how alcoholic an item is.  This should be between 0 and 10,
 * with 0 being non-alcoholic and 10 being something like Suicider.  It 
 * defaults to 0.  Note:  This has no effect on the actual alcohol content
 * of the item.
 * <p>
 * The different volumes of standard containers can be taken from
 * /include/volumes.h which has defines for all the standard volumes.
 * @param name the description to be displayed on the menu
 * @param type the type of item
 * @param cost the cost of the item
 * @param item the name, filename or armoury identifier for the item itself
 * @param container the name, filename or armoury identifier for the
 * container (optional)
 * @param volume the volume that the item should be set to (optional)
 * @param intox the intoxification value, on a scale of 0 to 10 (optional)
 * @example
 * // Add a main course called "Big meat pie", cloned from the file
 * // "/obj/food/meatpie.food"
 * add_menu_item( "Big meat pie", PUB_MAINCOURSE, 1000,
 *    "/obj/food/meatpie.food" );
 * @example
 * // Same as above, but let's put the pie on a plate
 * add_menu_item( "Big meat pie", PUB_MAINCOURSE, 1000,
 *    "/obj/food/meatpie.food", PUB_STD_PLATE );
 * @example
 * // Add a glass of ale, with the ale cloned from a file and the glass
 * // cloned in the "create_container()" function in the room code
 * add_menu_item( "Pint of ale", PUB_ALCOHOL, 500, "/obj/food/ale.food",
 *    "new_pint_glass" );
 * @example
 * // The same as above, but we only want half a pint of ale in the glass, we
 * // want to use the standard glasses in the header file and we want to set
 * // the intoxification value of the ale to 5
 * add_menu_item( "Half-pint of ale in a pint glass", PUB_ALCOHOL, 300,
 *    "/obj/food/ale.food", PUB_STD_PINT, VOLUME_HALFPINT, 5 );
 * @example
 * // Create a beefburger with added vodka in the "create_item()" function in
 * // the room code and put it in a small satchel from the armoury
 * add_menu_item( "Beefburger with special sauce", PUB_MAINCOURSE, 800,
 *    "vodka_burger", "small satchel", 0, 7 );
 * @see query_menu_items()
 * @see remove_menu_item()
 * @see /include/volumes.h
 */
varargs void add_menu_item(
   string name,
   int type,
   int cost,
   string item,
   string container,
   int volume,
   int intox
) {
   class menu_item new_item;
   string noun, alias;
   string *adjectives, *aliases;

   if( intox < 0 )
      intox = 0;
   if( intox > 10 )
      intox = 10;

   new_item = new( class menu_item );
   new_item->type = type;
   new_item->cost = cost;
   new_item->item = item;
   new_item->container = container;
   new_item->volume = volume;
   new_item->intox = intox;
   _menu_items[name] = new_item;

   if( no_standard_alias ) {
      if( lower_case( name ) != name )
         add_menu_alias( lower_case( name ), name );
      return;
   }

   adjectives = explode( lower_case( name ), " " );
   noun = adjectives[sizeof(adjectives) - 1];
   adjectives = adjectives[0..sizeof(adjectives) - 2];

   aliases = calc_standard_aliases( adjectives );

   foreach( alias in aliases ) {
      add_menu_alias( implode( ({ alias, noun }), " " ), name );
   }
} /* add_menu_item() */

/** @ignore */
string *calc_standard_aliases( string *array ) {
   int i, num_aliases;
   string *new_alias, *aliases;

   if( !sizeof( array ) )
      return ({ 0 });

   if( sizeof( array ) == 1 )
      return ({ array[0], 0 });

   aliases = calc_standard_aliases( array[0..sizeof( array ) - 2] );

   num_aliases = sizeof( aliases );

   for( i = 0; i < num_aliases; i++ ) {
      new_alias = ({ aliases[i], array[ sizeof( array ) - 1] });
      aliases += ({ implode( new_alias, " " ) });
   }

   return aliases;
} /* calc_standard_aliases() */

/**
 * This method returns a list of all the items currently available in
 * the pub.
 * @return items available, listing type, price and intoxification value
 * @see add_menu_item()
 * @see remove_menu_item()
 */
mapping query_menu_items() {
   return _menu_items;
} /* query_menu_items() */

/**
 * This method checks to see if this is a pub.
 * @return always return 1
 */
int query_pub() {
   return 1;
} /* query_pub() */

/**
 * This method sets the language to use in the shop.
 * @param language the language to use
 */
void set_language(string language) {
   _language = language;
} /* set_language() */

/**
 * This method returns the language used in the shop.
 * @return the language used in the shop
 */
string query_language() {
   return _language;
} /* query_language() */

/**
 * This method allows you to remove an item from those currently available
 * in the pub.
 * @param name the name of the item to remove
 * @return 1 if successful, 0 if unsuccessful
 * @see add_menu_item()
 * @see query_menu_items()
 */
int remove_menu_item( string name ) {
   if( !_menu_items[name] ) {
      return 0;
   }

   map_delete( _menu_items, name );
   return 1;
} /* remove_menu_item() */

/** @ignore */
string string_menu( string *items ) {
   int loop;
   string str, place;

   str = ""; 
   place = this_object()->query_property( "place" );
   if( !place || ( place == "" ) ) {
      place = "default";
   }

   for( loop = 0; loop < sizeof(items); loop++ ) {
      str += sprintf( "    %-30s %s\n", items[loop],
             MONEY_HAND->money_value_string(
             _menu_items[items[loop]]->cost, place ) );
   }

   return str;
} /* string_menu() */

/** @ignore */
string *query_items_of_type( int type ) {
   int i;
   string *selected;
   string *items;

   selected = ({ });
   items = keys( _menu_items );

   for( i = 0; i < sizeof(items); i++ ) {
      if( _menu_items[items[i]]->type == type ) {
         selected += ({ items[i] });
      }
   }

   selected = sort_array( selected, (: _menu_items[$1]->cost -
                                       _menu_items[$2]->cost :) );

   return selected;
} /* query_items_of_type() */

/** @ignore */
string string_menu_of_type( int type ) {
   string str;
   string *items;

   items = query_items_of_type( type );
   if( !sizeof(items) ) {
      return "";
   }

   if( _display_subheadings ) {
      str = _menu_subheadings[ type ] + "\n";
   }

   str += string_menu( items );
   return sprintf( "%-=*s\n", (int)this_player()->query_cols(), str );
} /* string_menu_of_type() */

/**
 * This method produces the menu from the item information, with the menu
 * header at the top, all items available grouped by type and sorted by
 * cost.  If you don't want the menu printed this way then mask this
 * function and return your own.
 * @return the menu text
 * @see add_menu_item()
 * @see set_display_header()
 * @see set_menu_header()
 * @see set_display_subheadings()
 * @see set_menu_subheadings()
 */
string read() {
   string ret;

   ret = "\n";

   if( _display_header ) {
      ret += _menu_header + "\n";
   }

   ret += string_menu_of_type( PUB_APPETISER );
   ret += string_menu_of_type( PUB_MAINCOURSE );
   ret += string_menu_of_type( PUB_DESSERT );
   ret += string_menu_of_type( PUB_ALCOHOL );
   ret += string_menu_of_type( PUB_SOFTDRINK );
   ret += string_menu_of_type( PUB_HOTDRINK );

   return ret;
} /* read() */

/**
 * This method allows you to switch the menu header (defaults to "The menu
 * reads:") that appears at the top of the menu on and off.
 * @param value set to 1 to display header or 0 to remove them
 * @see query_display_header()
 * @see set_menu_header()
 * @see query_menu_header()
 */
void set_display_header( int value ) {
   _display_header = value;
} /* set_display_header() */

/**
 * This method returns a flag stating whether display of the menu header
 * is on or off.
 * @return 1 for header, 0 for no header
 * @see set_display_header()
 * @see set_menu_header()
 * @see query_menu_header()
 */
int query_display_header() {
   return _display_header;
} /* query_display_header() */

/**
 * This method sets the header that appears at the top of the menu.  By
 * default this is "The menu reads:".
 * @param header the new menu header
 * @see query_menu_header()
 * @see set_display_header()
 * @see query_display_header()
 */
void set_menu_header( string header ) {
   _menu_header = header;
} /* set_menu_header() */
 
/**
 * This method returns the current menu header text.
 * @return the menu header text
 * @see set_menu_header()
 * @see set_display_header()
 * @see query_display_header()
 */
string query_menu_header() {
   return _menu_header;
} /* query_menu_header() */

/**
 * This method allows you to switch the subheadings ("Alcoholic Beverages",
 * "Meals", etc) that appear above different types of items on and off.
 * @param value set to 1 to display subheadings or 0 to remove them
 * @see query_display_subheadings()
 * @see set_menu_subheadings()
 * @see query_menu_subheadings()
 */
void set_display_subheadings( int value ) {
   _display_subheadings = value;
} /* set_display_subheadings() */

/**
 * This method returns a flag stating whether display of the menu subheadings
 * is on or off.
 * @return 1 for headings, 0 for no headings
 * @see set_display_subheadings()
 * @see set_menu_subheadings()
 * @see query_menu_subheadings()
 */
int query_display_subheadings() {
   return _display_subheadings;
} /* query_display_subheadings() */

/**
 * This method sets the subheadings that appear at the top of the menu.
 * @param subheading the subheading to change (use the #defines listed in
 * "pub_shop.h")
 * @param text the new menu subheading text
 * @see query_menu_subheadings()
 * @see set_display_subheadings()
 * @see query_display_subheadings()
 */
void set_menu_subheadings( int subheading, string text ) {
   _menu_subheadings[ subheading ] = text;
} /* set_menu_subheadings() */
 
/**
 * This method returns the current menu subheading text.
 * @return the menu subheadings
 * @see set_menu_subheadings()
 * @see set_display_subheadings()
 * @see query_display_subheadings()
 */
string *query_menu_subheadings() {
   return _menu_subheadings;
} /* query_menu_subheadings() */
 
/**
 * This method allows you to add an alias to an item sold in the pub.  Many
 * aliases are added by default so you shouldn't have to use this too
 * often.  See the help on "set_no_standard_alias()" to see what aliases are
 * added automatically.
 * @param alias the alias to add
 * @param alias the real item that the alias refers to
 * @example
 * // Allow "buy lancre ale" instead of "buy Ale from Lancre"
 * add_menu_alias( "lancre ale", "Ale from Lancre" );
 * @see add_menu_aliases()
 * @see query_menu_aliases()
 * @see remove_menu_alias()
 * @see set_no_standard_alias()
 */
void add_menu_alias( mixed alias, string actual ) {
   string bing;

   if (arrayp(alias)) {
      foreach (bing in alias) {
         add_menu_alias(bing, actual);
      }
   }
   _menu_aliases[alias] = actual;
} /* add_menu_alias() */

/**
 * This method allows you to add multiple aliases at once.  Many aliases are
 * added by default so you shouldn't have to use this too often.  See the 
 * help on "set_no_standard_alias()" to see what aliases are added 
 * automatically.
 * @param aliases an array of aliases to add
 * @param alias the real item that the aliases refer to
 * @example
 * // Add friendly aliases to "Beef burger and chips"
 * add_menu_aliases( ({ "beef burger",
 *                      "beefburger",
                        "burger" }), "Beef burger and chips" );
 * @see add_menu_alias()
 * @see query_menu_aliases()
 * @see remove_menu_alias()
 * @see set_no_standard_alias()
 */
void add_menu_aliases( string *aliases, string actual ) {
   string alias;

   foreach( alias in aliases ) {
      add_menu_alias( alias, actual );
   }
} /* add_menu_aliases() */

/**
 * This method returns a list of all the aliases currently available in
 * the pub.
 * @return alias : real name
 * @see add_menu_alias()
 * @see add_menu_aliases()
 * @see remove_menu_alias()
 * @see set_no_standard_alias()
 */
mapping query_menu_aliases() {
   return _menu_aliases;
} /* query_menu_aliases() */

/**
 * This method allows you to remove an alias from those currently available
 * in the pub.
 * @param alias the alias to remove from the list
 * @return 1 if successful, 0 if unsuccessful
 * @see add_menu_alias()
 * @see add_menu_aliases()
 * @see query_menu_aliases()
 * @see set_no_standard_alias()
 */
int remove_menu_alias( string alias ) {
   if( !_menu_aliases[alias] ) {
      return 0;
   }

   map_delete( _menu_aliases, alias );
   return 1;
} /* remove_menu_alias() */

/**
 * This method allows you to turn on or off the addition of standard aliases
 * when new menu items are added.  By default it is turned on.  Standard
 * aliases are added as follows:
 * If you added an item called "Lancre vintage wine" the aliases added would
 * be:
 * <ul>
 * <li> vintage wine
 * <li> lancre wine
 * <li> wine
 * </ul>
 * An alias of the name in lowercase is always added regardless of whether
 * or not this flag is turned on or off.  You may wish to turn this off if
 * you are adding several items which could be mistaken for each other, for
 * instance "Lancre beer" and "Morporkian beer".
 * @param flag 0 if standard aliases should be added, 1 if not
 * @see add_menu_alias()
 * @see query_menu_aliases()
 * @see remove_alias()
 * @see query_no_standard_alias()
 */
void set_no_standard_alias( int flag ) {
   no_standard_alias = flag;
} /* set_no_standard_alias() */

/**
 * This method returns a flag stating whether standard aliases will be added
 * or not.
 * @return 0 if standard aliases will be added, 1 if not
 * @see set_no_standard_alias()
 */
int query_no_standard_alias() {
   return no_standard_alias;
} /* set_no_standard_alias() */

/** @ignore */
object create_real_object( string name ) {
   object item, container;

   if( _menu_items[name]->container ) {
      container = this_object()->create_container(
                                    _menu_items[name]->container );
      if( !container ) {
         container = clone_object( _menu_items[name]->container );
      }
      if( !container ) {
         container = ARMOURY->request_item(
                                 _menu_items[name]->container, 100 );
      }
   }

   if( _menu_items[name]->item ) {
      item = this_object()->create_item( _menu_items[name]->item );
      if( !item ) {
         item = clone_object( _menu_items[name]->item );
      }
      if( !item ) {
         item = ARMOURY->request_item( _menu_items[name]->item, 100 );
      }
   }

   if( item && _menu_items[name]->volume ) {
      item->set_amount( _menu_items[name]->volume );
   } else if ( item && !_menu_items[name]->volume &&
              ( _menu_items[name]->type == PUB_ALCOHOL ||
                _menu_items[name]->type == PUB_HOTDRINK ||
                _menu_items[name]->type == PUB_SOFTDRINK ) ) {
      item->set_amount( container->query_max_volume() -
                        container->query_volume() );
   }

   if( item && container ) {
      if( (int)item->move( container ) != MOVE_OK ) {
         write( "The " + container->short() + " is too small to hold " +
            item->the_short() + ".  Please file a bug report.\n" );
         item->move( "/room/rubbish" );
      }
   }

   if( container ) {
      return container;
   }

   if( item ) {
      return item;
   }

   return 0;
} /* create_real_object() */

/** @ignore */
int do_buy( object *obs, string dir, string indir, mixed *args ) {
   int value, cost;
   string str, place;
   object person, thing;
   object *succeededpeople, *deadpeople, *failedpeople, *poorpeople;

   succeededpeople = ({ });
   deadpeople = ({ });
   failedpeople = ({ });
   poorpeople = ({ });

   str = args[0];

   if( this_player()->query_property( "dead" ) ) {
      add_failed_mess( "How can you expect to buy " + str + " when you're "
         "dead?\n" );
      return 0;
   }

   if( _menu_aliases[str] ) {
      str = _menu_aliases[str];
   }

   if( !_menu_items[str] ) {
      if (!broadcast_shop_event(PUB_EVENT_NOT_AVAILABLE, this_player(), str)) {
         add_failed_mess( "Sorry, " + str + " is not on the menu.\n" );
      }
      return 0;
   }

   // Check to make sure the pub is open.
   if ( !is_open( this_player(), _menu_items[str]->type ) ) {
      broadcast_shop_event(PUB_EVENT_NOT_OPEN, this_player());
      return 0;
   }

   if( !sizeof( obs ) ) {
      obs = ({ this_player() });
   }

   foreach( person in obs ) {
      if( person->query_property( "dead" ) ) {
         deadpeople += ({ person });
         continue;
      }

      if( !living( person ) ||
          !interactive( person ) && !person->query_property( "npc" ) ) {
         failedpeople += ({ person });
         continue;
      }

      cost = ( _menu_items[str]->cost ) * query_discount( this_player() );
      place = this_object()->query_property( "place" );
      if( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)this_player()->query_value_in( place );
      if( place != "default" ) {
         value += (int)this_player()->query_value_in( "default" );
      }

      if( cost > value ) {
         poorpeople += ({ person });
         continue;
      }

      thing = create_real_object( str );
      if( !thing ) {
         add_failed_mess( "Something is buggered.  Please file a bug report.  "
            "Thank you.\n" );
         return 0;
      }

      this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
                        cost, place ), place );

      succeededpeople += ({ person });

      if( (int)thing->move( person ) != MOVE_OK ) {
         if( (int)thing->move( _counter ) != MOVE_OK ) {
            thing->move( this_object() );
            write("You cannot pick " + thing->a_short() +
               " up.  It's left on the floor for you.\n" );
         } else {
           write("You cannot pick " + thing->a_short() +
              " up.  It's left on the counter for you.\n" );
         }
      }
   }

   /* This will be overidden if necessary */
   //add_succeeded_mess( this_object(), "", ({ }) );

   if( sizeof( succeededpeople ) ) {
      // Quite why compare_arrays() isn't an efun is beyond me...
      if (!broadcast_shop_event(PUB_EVENT_BOUGHT_STUFF, this_player(),
                           succeededpeople, str)) {
         if( !MAP_HANDLER->compare_arrays( succeededpeople,
                                           ({ this_player() }) ) ) {
            this_player()->add_succeeded_mess( this_object(),
               "$N $V $I.\n", ({ add_a(str) }) );
         } else {
            add_succeeded_mess("$N $V "
               + query_multiple_short( ({ thing }), "a" ) + " for $I.\n",
               succeededpeople);
         }
      }
   } else {
      if( sizeof( deadpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_DEAD_PEOPLE, this_player(),
                              deadpeople, str)) {
            add_failed_mess("What use " +
               ( sizeof( deadpeople ) > 1?"have ":"has " ) +
               query_multiple_short( deadpeople, "one" ) + " got for " + str +
               "?\n" );
         }
      }
   
      if( sizeof( failedpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_FAILED_PEOPLE, this_player(),
                              failedpeople, str)) {
            add_failed_mess("You can't buy anything for " +
               query_multiple_short( failedpeople, "one" ) + ".\n" );
         }
      }
   
      if( sizeof( poorpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_POOR_PERSON, this_player(),
                              poorpeople, str)) {
            add_failed_mess("You cannot afford to order " + str +
               " for " + query_multiple_short( poorpeople, "one" ) + ".\n" );
         }
      }
      return 0;
   }
   
   return 1;
} /* do_buy() */

/** @ignore */
void dest_me() {
   if( _menu_object ) {
      _menu_object->dest_me();
   }
} /* dest_me() */

/** 
 * This function can be masked and used to determine a discount that is
 * applied to all items sold, so for instance you could check the guild of
 * 'ob' and give a discount to Witches, or something.  By default the
 * discount is zero, so query_discount returns 1.0
 * @param ob the object doing the buying
 * @return a float to multiply the price by
 * @example
 * // Give Priests a 10% discount
 * float query_discount( object ob ) {
 *    if( ob->query_guild_ob() == "/std/guilds/priest.c" )
 *       return 0.9;
 *    else
 *       return 1.0;
 * }
 */
float query_discount( object ob ) {
   return 1.0;
} /* query_discount() */

/**
 * This function creates the counter for the pub.  It defaults to cloning
 * PUB_COUNTER_FILE and making it a hidden object.
 * If you are creating your own counter object then making it hidden is a
 * good idea.  If it's not hidden, make sure it at least cannot be moved or
 * buried.
 * The counter should clear empty objects with the "pub item" property if
 * they are placed on it.  Making it clear non-empty objects is a bad idea,
 * since items will be placed here if the purchaser is unable to carry
 * them.
 * @return the new counter object
 * @see query_counter()
 * @see /include/shops/pub_shop.h
 */
object make_counter() {
   object ob;

   ob = clone_object( PUB_COUNTER_FILE );
   add_hidden_object( ob );

   return ob;
} /* make_counter() */

/**
 * This method returns the object currently being used as a counter in the
 * pub.
 * @return the file name of the counter
 * @see make_counter()
 */
object query_counter() {
   return _counter;
} /* query_counter() */


/**
 * This method returns the object currently being used as a menu in the
 * pub.
 * @return the file name of the menu
 */
object query_menu() {
   return _menu_object;
} /* query_menu() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/pub.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629766   Available: 13577120
Inodes: Total: 5242880    Free: 4960136
139979 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629766   Available: 13577120
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the file containing extra controls for the player run
 * craft shop.  We will assume that all player run craft shops will be
 * rooms and not npcs.
 * @author Pinkfish
 * @started Fri Apr 21 13:37:44 PDT 2000
 */
inherit "/std/shops/inherit/craft_shop_category";
inherit "/std/shops/inherit/expression_util";
inherit "/std/shops/inherit/person_expressions";
inherit "/std/shops/inherit/object_expressions";
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <shops/craft_shop.h>
#include <player_handler.h>
#include <clubs.h>
#define EXPRESSION_NO_CLASSES
#include <expressions.h>
#include <mail.h>
#include <nroff.h>
#include <player_handler.h>

//#define PRESTO_DEBUG

#define PLAYER_CRAFT_SHOP_CHECK_PROP "player craft shop check"

#define PLAYER_CRAFT_SHOP_SELL      1
#define PLAYER_CRAFT_SHOP_SELL_AUTO 2
#define PLAYER_CRAFT_SHOP_BUY       3
#define PLAYER_CRAFT_SHOP_APPROVE   4

#define PLAYER_CRAFT_SHOP_EXPR_DENY   1
#define PLAYER_CRAFT_SHOP_EXPR_ACCEPT 2

class approval_item  {
   mixed value;
   string list_name;
   int markup;
   int final_cost;
}

class expression_type {
   int type;
   class parse_node* condition;
   class parse_node* value;
   string list_name;
}

class approval {
   mixed hairy;
   class expression_type* expressions;
   int low_cost;
   int high_cost;
   mapping items;
   int num_allowed;
   int high_cost_deny;
}

class approval_obs {
   string seller;
   string category;
   int value;
   string name;
   int* saved;
   int enter_time;
   int* checkout;
   string* shorts;
}

#if USE_TRANSACTIONS
class shop_transaction {
   int time;
   string person;
   string objects;
   string name_cat;
   int type;
   int amount;
   mixed extra;
}
#endif

class shop_stats {
   int num_sold;
   int value_sold;
   string seller;
   string name;
}

class helper_stats {
   int num_approved;
   int total_cost;
   int num_rejected;
   mapping items_approved;
}

class item_stats {
   int num_sold;
   int total_cost;
   int total_made;
   int num_bought;
}

class weekly_stats {
   int num_sold;
   int total_cost;
   int total_made;
   int num_bought;

   mapping items;
   mapping helper;
}

class seller_information {
   int max_sellable;
   int value_limit;
   int deny_value_limit;
}

private class approval_obs* _waiting_for_approval;
private class approval_obs* _approved;
private class approval _automatic_approval;
// This is the list of allowable list names.
private string* _list_names;
private int _automatic_percentage;
private int _current_save_num;
private int _total_outgoing;
private int _total_ingoing;
private int _time_of_mail;
private class parse_node *_tax_expression;
#if USE_TRANSACTIONS
private class shop_transaction* _transactions;
#endif
private mapping _sold_stats;
private int _stats_start;
private mapping _sellers;
private mapping _num_checked_so_far;
private string* _helpers;
private class weekly_stats _weekly_stats;

private nosave string _parcel_post;
private nosave int _something_checkedout;
private nosave int _maximum_inventory;
private nosave int _round_value;
private nosave int _max_list_names;
private nosave int _max_items_in_queue;

protected void confirm_approval(string answer, class approval_obs approve, int final_cost);
private object* variable_objects(string seller, int cost, object* ob);
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category);
private string variable_sale_name(string seller, int cost, object* ob, string name, string category);
private string variable_sale_category(string seller, int cost, object* ob, string name, string category);
private int function_inventory_number(string short, string seller, int cost, object* ob);


/*
 * This methods must be defined in an upper level class.
 */
string query_owner();
int is_allowed(string person);
void event_save(object thing);
int is_open_for(string type, string name);

void create() {
   _round_value = 1;
   if (!_waiting_for_approval) {
      _waiting_for_approval = ({ });
   }
   if (!_approved) {
      _approved = ({ });
   }
   if (!_list_names) {
      _list_names = ({ });
   }
   if (!_automatic_approval) {
      _automatic_approval = new(class approval);
      //_automatic_approval->sellers = ({ });
      //_automatic_approval->categories = ([ ]);
      _automatic_approval->expressions = ({ });
      _automatic_approval->items = ([ ]);
   }
   if (!_automatic_percentage) {
      _automatic_percentage = 10;
   }
#if USE_TRANSACTIONS
   if (!_transactions) {
      _transactions = ({ });
   }
#endif
   if (!_sold_stats) {
      _sold_stats = ([ ]);
   }
   if (!_helpers) {
      _helpers = ({ });
   }
   if (!_stats_start) {
      _stats_start = time();
   }
   if (!_sellers) {
      _sellers = ([ ]);
   }
   if (!_num_checked_so_far) {
      _num_checked_so_far = ([ ]);
   }
   if (!_tax_expression)  {
      _tax_expression = ({ });
   }
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }
   //
   // Set it up so that selling it the normal way gets no money.
   //
   set_cut(100);
   _max_items_in_queue = 100;
   craft_shop_category::create();
   expression_util::create();
   set_always_ask_price(1);

   add_allowed_variable("objects", EXPRESSION_TYPE_OBJECT +
                                   EXPRESSION_TYPE_ARRAY_OFFSET,
                        (: variable_objects :) );
   add_allowed_variable("salecost", EXPRESSION_TYPE_MONEY,
                        (: variable_sale_cost :) );
   add_allowed_variable("salename", EXPRESSION_TYPE_STRING,
                        (: variable_sale_name :) );
   add_allowed_variable("salencategory", EXPRESSION_TYPE_STRING,
                        (: variable_sale_category :) );
   set_expression_type("shop");
   object_expressions::create();
   person_expressions::create();
   set_no_royalty_commands(1);
} /* create() */

/**
 * This method checks to see if the specifgied person is a helper in the
 * shop or not.
 * @param person the person to check if they are a helper
 * @return 1 if they are a helper, 0 if not
 */
int is_helper(string person) {
   if (!_helpers) {
      _helpers = ({ });
   }
   return member_array(person, _helpers) != -1 ||
          is_allowed(person);
} /* is_helper() */

/**
 * This method strips off enclosing quotation marks, if any
 * @param str the srtring to strip of quotes
 * @return the string stripped of quotes
 */
private string strip_quotes(string str)  {
   if (str)  {
      if (str[0] == '\"')  str = str[1 .. ];
      if (str[<1] == '\"')  str = str[0 .. <2];
   }
   return str;
}


/**
 * This method sets the maximum inventory size for the shop.
 * @param size the maximum inventory size
 */
void set_maximum_waiting_queue_size(int size) {
   _max_items_in_queue = size;
} /* set_maximum_waiting_queue_size() */

/**
 * This method returns the maximum inventory size for the shop.
 * @return the maximum inventory size
 */
int query_maximum_waiting_queue_size() {
   return _max_items_in_queue;
} /* query_maximum_waiting_queue_size() */

/**
 * This method sets the maximum inventory size for the shop.
 * @param size the maximum inventory size
 */
void set_maximum_inventory_size(int size) {
   _maximum_inventory = size;
} /* set_maximum_inventory_size() */

/**
 * This method returns the maximum inventory size for the shop.
 * @return the maximum inventory size
 */
int query_maximum_inventory_size() {
   return _maximum_inventory;
} /* query_maximum_inventory_size() */

/**
 * This method sets the parcel post to use for rejecting items.
 * @param parcel the parcel post office
 */
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
} /* set_parcel_post() */

/**
 * This method tells us the current parcel post used for rejecting items.
 * @return the current parcel post
 */
string query_parcel_post() {
   return _parcel_post;
} /* query_parcel_post() */

/**
 * This method figures out the royalty.
 * @return the royalty
 */
int query_royalty(string person) {
   return query_controller()->query_royalty(person);
} /* query_royalty() */

/**
 * This method figures out the owner's money.
 * @return the owners money
 */
int query_owners_money() {
   return query_royalty(query_owner());
} /* query_owners_money() */

/**
 * This method changes the royalty.
 * @param person the person to change
 * @param amount the amount to change by
 */
void adjust_royalty(string person, int amount) {
   query_controller()->adjust_royalty(person, amount);
} /* query_royalty() */

/**
 * This method adjusts out the owner's money.
 * @param amount the amount to adjust it by
 */
int adjust_owners_money(int amount) {
   return adjust_royalty(query_owner(), amount);
} /* adjust_owners_money() */

/**
 * THis method sets the amount to round all the sell values for.  THis is
 * deal with annoying currencies like AM money which does not have a
 * '1' item.
 * @param round the price to round at
 */
void set_round_price(int round) {
   _round_value = round;
} /* set_round_price() */

/**
 * This method returns the amount to round all sell values for.
 * @return the round price
 */
int query_round_prices() {
   return _round_value;
} /* query_round_prices() */

/**
 * This method returns the current approval list for the shop.
 */
class approval_obs* query_approval_list(int approved) {
   if (approved) {
      return _approved;
   } else {
      return _waiting_for_approval;
   }
} /* query_approval_list() */

/**
 * This method returns the number of items currently in the shop by
 * the specified person.  This includes items waiting for approval.
 */
int query_number_of_items_listed(string name) {
   int num;
   class approval_obs bing;

   name = lower_case(name);
   num = sizeof(query_controller()->query_owner_sellables(name));
   foreach (bing in _waiting_for_approval) {
      if (lower_case(bing->seller) == name) {
         num += sizeof(bing->saved);
      }
   }
   return num;
} /* query_number_of_items_listed() */

/**
 * This method checks to see if the specified item is approved.
 * @param seller the name of the seller
 * @param value the amount it is sold for
 * @param name the name of the item being solde
 * @param sellables the sold items
 * @param category the category of the sold item
 * @param final_cost the final cost of the item
 * @return 1 if is approved, 0 if not, -1 if denied, string if it is approved
 *         with a list name
 */
mixed is_item_approved(string seller, int value, string name, object* sellables,
                     string category, int ref final_cost) {
   string short;
   object ob;
   int item_approval;
   class expression_type bing;
   class parse_node frog;
   int cost;
   mixed item;

   final_cost = ((value * (100 + _automatic_percentage)) / 100);

   value = value - (cost % _round_value);

   if (is_allowed(seller) ||
       is_helper(seller)) {
      // Owners sell for the exact amount the specified.
      final_cost = value;
      return 1;
   }

   //
   // This is the value we don't automatically accept at.
   //
   seller = lower_case(seller);
   if (_sellers[seller] &&
       _sellers[seller]->deny_value_limit) {
      if (_sellers[seller]->deny_value_limit < value) {
         return -1;
      }
   } else if (_automatic_approval->high_cost_deny &&
              _automatic_approval->high_cost_deny <= value) {
      return -1;
   }

   //
   // Check through the automatic approval stuff to see if we should
   // approve it.
   //
   foreach (ob in sellables) {
      if (!ob) {
         // Always deny things with broken objects references.
         return -1;
      }
      short = ob->query_short();
      if (_automatic_approval->items[short]) {
         if (classp(_automatic_approval->items[short])) {
            item = ((class approval_item)_automatic_approval->items[short])->value;
         } else {
            item = _automatic_approval->items[short];
         }
         if (pointerp(item)) {
            frog = evaluate_expression(item,
                                     seller,
                                     value,
                                     ({ ob }),
                                     name,
                                     category);
            cost = frog->value - (frog->value % _round_value);
            if (cost < value) {
               item_approval = 0;
               break;
            }
            item_approval++;
         } else if (item < value) {
            item_approval = 0;
            break;
         } else {
            item_approval++;
         }
      }
   }

   if (item_approval) {
      if (classp(_automatic_approval->items[short]))  {
         class approval_item womble;

         womble = _automatic_approval->items[short];
         if (sizeof(womble) == 3) {
            _automatic_approval->items[short] = new(class approval_item,
                   markup : womble->markup,
                   value : womble->value,
                   list_name : womble->list_name,
                   final_cost : 0);
            womble = _automatic_approval->items[short];
         }
         if (womble->markup) {
            final_cost = ((value * (100 + womble->markup)) / 100);
         } else if (womble->final_cost) {
            final_cost = womble->final_cost;
         }
         if (womble->list_name) {
            return womble->list_name;
         } else {
            return 1;
         }
      } else {
         return 1;
      }
   }

   //
   // Then check any setup expressions.
   //
   if (!pointerp(_automatic_approval->expressions)) {
      _automatic_approval->expressions = ({ });
   }
   foreach (bing in _automatic_approval->expressions) {
      if (evaluate_expression(bing->condition,
                              seller,
                              value,
                              sellables,
                              name,
                              category)->value) {
         if (bing->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
            frog = evaluate_expression(bing->value,
                                 seller,
                                 value,
                                 sellables,
                                 name,
                                 category);
            cost = frog->value - (frog->value % _round_value);
            if (cost >= value) {
               if (bing->list_name) {
                  return bing->list_name;
               } else if (classp(_automatic_approval->items[short]))  {
                  return ((class approval_item)_automatic_approval->items[short])->list_name;
               } else {
                  return 1;
               }
            }
         } else {
            return -1;
         }
      }
   }

   if (_sellers[seller] &&
       _sellers[seller]->value_limit) {
      if (_sellers[seller]->value_limit < value) {
         return 0;
      } else if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   } else if (_automatic_approval->high_cost &&
              _automatic_approval->high_cost < value) {
      return 0;
   }

   if (_automatic_approval->low_cost &&
       _automatic_approval->low_cost >= value) {
      if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   }

   return 0;
} /* is_item_approved() */

/**
 * This method checks to see if the shop is a closed shop and then checks
 * to see if the person is allowed.
 * @param person the person to check to see if they are allowed
 * @return 1 if they are allowed, 0 if not
 */
int is_allowed_to_use_shop(string person) {
   return (is_allowed(person) || is_helper(person) ||
           is_open_for("use", person));
} /* is_allowed_to_use_shop() */

/**
 * @ignore yes
 */
int check_open(object player, string type) {
   if (!::check_open(player)) {
      return 0;
   }

   // Make sure that can only sell stuff if the waiting list is not full.
   if (type == "sell") {
      if (sizeof(query_approval_list(0)) + sizeof(query_approval_list(1)) >= _max_items_in_queue) {
         add_failed_mess("Unable to sell things, the shop is full.\n");
         return 0;
      }
   }

   if (!is_allowed_to_use_shop(player->query_name())) {
      add_failed_mess("The shop is currently closed.\n");
      return 0;
   }

   return 1;
} /* check_open() */

/**
 * @ignore yes
 */
void set_controller(string name) {
   ::set_controller(name);
   query_controller()->set_dont_use_name(1);
} /* set_controller() */

/**
 * @ignore yes
 */
int is_allowed_to_sell(object *obs, string name, string *sellable_names) {
   int num;
   int max;

   if (_automatic_approval->num_allowed ||
       _sellers[name]) {
      num = query_number_of_items_listed(name) + sizeof(obs);
      if (_sellers[name] && _sellers[name]->max_sellable) {
         max = _sellers[name]->max_sellable;
      } else {
         max = _automatic_approval->num_allowed;
      }

      if (num > max) {
         add_failed_mess("You cannot have more than " + max + " items "
                         "listed at " + the_short() + ", with this sale you "
                         "would have " +
                         num + ".\n");
         return 0;
      }
   }

   if (sizeof(filter(obs, (: $1->query_property("money") :))) > 0) {
      add_failed_mess("You cannot sell money.\n");
      return 0;
   }

   //
   // Otherwise see if we are over the shops total maximum size.
   //
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(obs) > query_maximum_inventory_size()) {
      add_failed_mess("The shop is full, it can only hold " +
                      query_maximum_inventory_size() + " items and it currently "
                      "holds " + num + " items.\n");
      return 0;
   }
   return 1;
} /* is_allowed_to_sell() */

/**
 * This method finds out the maximum value that this item is allowed
 * to be sold for based on the current settings of the shop.
 * @param person the person doing the selling
 * @param items the item being sold
 * @return ({ queue limit, deny limit })
 */
int* query_maximum_sale_value_both(string person, object item) {
   int max_deny;
   int max_accept;
   string short;
   class expression_type stuff;
   mixed app_item;

   if (_sellers[person]) {
      if (_sellers[person]->value_limit) {
         max_accept = _sellers[person]->value_limit;
      }
      if (_sellers[person]->deny_value_limit) {
         max_deny = _sellers[person]->deny_value_limit;
      }
   }
   if (!max_accept) {
      max_accept = _automatic_approval->high_cost;
   }
   if (!max_deny) {
      max_deny = _automatic_approval->high_cost_deny;
   }

   if (!item) {
      return ({ 0, 0 });
   }

   short = item->query_short();
   if (_automatic_approval->items[short]) {
      if (classp(_automatic_approval->items[short]))  {
         app_item = ((class approval_item)_automatic_approval->items[short])->value;
      } else {
         app_item= _automatic_approval->items[short];
      }
      if (pointerp(app_item)) {
         max_accept = evaluate_expression(app_item,
                                        person, 0, ({ item }), 0, 0)->value;
      } else if (app_item < max_deny) {
         max_accept = app_item;
      }
   }

   foreach (stuff in _automatic_approval->expressions) {
      if (evaluate_expression(stuff->condition, person, 0, ({ }), 0, 0)->value) {
         if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_DENY) {
            max_deny = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         } else {
            max_accept = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         }
      }
   }

   max_accept -= max_accept % _round_value;
   max_deny -= max_deny % _round_value;

   return ({ max_accept, max_deny });
} /* query_maximum_sale_value() */

/**
 * This method will return the maximum value at which the set of items
 * will be denied.
 * @param person the person selling the item
 * @param obs the set of objects
 * @return the deny value
 */
int query_maximum_sale_value(string person, object* obs) {
   int* stuff;
   object ob;
   int cur_deny;

   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(person, ob);
      if (!cur_deny && stuff[1]) {
         cur_deny = stuff[1];
      } else if (cur_deny && cur_deny > stuff[1]) {
         cur_deny = stuff[1];
      }
   }
   return cur_deny;
} /* query_maximum_sale_value() */

/** @ignore yes */
string query_extra_price_information(string seller, object *obs) {
   int* max;
   int* max_tmp;
   string ret;
   string place;
   object ob;

   max = ({ 0, 0 });
   foreach (ob in obs) {
      max_tmp = query_maximum_sale_value_both(seller, ob);
      if (max_tmp[0] && max[0] > max_tmp[0]) {
         max[0] = max_tmp[0];
      }
      if (max_tmp[1] && max[1] > max_tmp[1]) {
         max[1] = max_tmp[1];
      }
   }

   ret = "";
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (max[0]) {
      ret += "the maximum price you can sell this straight into the "
             "inventory for is " +
             MONEY_HAND->money_value_string(max[0], place);
   }
   if (max[1]) {
      if (max[0]) {
         ret += " and ";
      }
      ret += "the maximum price you can sell the item for at all is " +
             MONEY_HAND->money_value_string(max[1], place);
   }
   return capitalize(ret) + ".\n";
} /* query_extra_price_information() */

/**
 * This method creates a save file for the specified objects autoloading
 * capability.  If the number to write to is non-null then it will
 * write to that object.
 * @param ob the object to get an autoload number for
 * @param fixed_num the file number to write to
 * @return the auto load number
 * @see save_it()
 */
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   string tmp;

   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         // Make it error on the last one...
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   do_save_file(CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "app_" + fixed_num);
   return fixed_num;
} /* create_auto_load_file() */

/**
 * This method creates a real object from the save file number.
 * @param num the save file number
 * @return the nice shiny new object
 * @see create_auto_load_file()
 */
protected object create_real_auto_load_object(int num, object player) {
   string auto_load;
   object *obs;

   auto_load = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
} /* create_object_from_auto_load() */

/**
 * This method turns all the specified id into an item to be checked.
 * @param id the id of the object to create
 * @param player the player to use for autoloading
 */
object create_checkout_object(class approval_obs approve,
                            int id,
                            object player) {
   object ob;
   int i;

   ob = create_real_auto_load_object(id, player);
   if (ob) {
      ob->add_effect("/std/effects/object/no_save");
      ob->add_property(PLAYER_CRAFT_SHOP_CHECK_PROP, ({ approve, id }));
      i = member_array(id, approve->saved);
      approve->checkout[i] = 1;
      event_save(this_object());
      _something_checkedout++;
   }
   return ob;
} /* create_checkout_object() */

/**
 * This method updates the checked out item and changes to to be what
 * we now have...
 * @param ob the object to destroy
 */
int destroy_checkout_object(object ob) {
   int id;
   int *ids;
   int i;
   class approval_obs approve;

   if (!ob) {
      return 0;
   }


   // Make sure we don't end up recursively messing with the same object.
   ob->add_property("destroy checkout object", 1, 2);
   if (ob->move("/room/rubbish") != MOVE_OK) {
      return 0;
   }
   debug_printf("Destroying the checkout object %O\n", ob);
   //
   // Zap the effect too.
   //
   ids = ob->effects_matching("/std/effects/object/no_save"->query_classification());
   foreach (id in ids) {
      ob->delete_effect(id);
   }

   id = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[1];
   approve = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[0];
   i = member_array(id, approve->saved);
   approve->checkout[i] = 0;

   ob->remove_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
   create_auto_load_file(ob, id);
   event_save(this_object());
   _something_checkedout--;
   if (_something_checkedout < 0) {
       _something_checkedout = 0;
   }
   return 1;
} /* destroy_checkout_object() */

/**
 * This method checks to see if the specified item is a checked out
 * item.
 * @param ob the object to check
 * @return 1 if it is, 0 if not
 */
int is_checkout_object(object ob) {
   return ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
} /* is_checkout_object() */

/**
 * This method adds an item to the list of items that need to be approved.
 * @param seller name of the player
 * @param sellables the list of items to sell
 * @param value the cost of the item
 * @param name the name of the items
 * @param category the category of the item
 * @param approved a flag to say if this was approved or not
 * @return obs the objects we bought
 */
object* add_to_approval_list(string seller, object* sellables, int value,
                          string name, string category, int approved) {
   class approval_obs stuff;
   object ob;
   object* obs;

   obs = ({ });
   foreach (stuff in query_approval_list(approved)) {
      if (lower_case(stuff->name) == lower_case(name) &&
          stuff->seller == seller &&
          stuff->value == value) {
         stuff->category = category;
         foreach (ob in sellables) {
            if (ob->move("/room/rubbish") == MOVE_OK) {
               stuff->saved += ({ create_auto_load_file(ob, 0) });
               stuff->checkout += ({ 0 });
               stuff->shorts += ({ ob->query_short() });
               obs += ({ ob });
            }
         }
         if (sizeof(obs)) {
            event_save(this_object());
         }
         return obs;
      }
   }


   stuff = new(class approval_obs);
   stuff->seller = seller;
   stuff->value = value;
   stuff->name = name;
   stuff->category = category;
   stuff->saved = ({ });
   stuff->shorts = ({ });
   stuff->enter_time = time();
   foreach (ob in sellables) {
      if (ob->move("/room/rubbish") == MOVE_OK) {
         stuff->saved += ({ create_auto_load_file(ob, 0) });
         stuff->shorts += ({ ob->query_short() });
         obs += ({ ob });
      }
   }
   stuff->checkout = allocate(sizeof(stuff->saved));
   if (sizeof(obs)) {
      if (approved) {
         _approved += ({ stuff });
      } else {
         _waiting_for_approval += ({ stuff });
      }
      event_save(this_object());
   }
   return obs;
} /* add_to_approval_list() */

/**
 * This method removes the item from the approval list.
 * @param approve the item to remove
 */
void remove_from_approval_list(class approval_obs approve) {
   int i;
   int pos;

   for (i = 0; i < sizeof(_approved); i++) {
      if (_approved[i] == approve) {
         //
         // Zap the files...
         //
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _approved = _approved[0..i-1] + _approved[i+1..];

         event_save(this_object());
         return ;
      }
   }
   for (i = 0; i < sizeof(_waiting_for_approval); i++) {
      if (_waiting_for_approval[i] == approve) {
         //
         // Zap the files...
         //
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _waiting_for_approval = _waiting_for_approval[0..i-1] + _waiting_for_approval[i+1..];

         event_save(this_object());
         return ;
      }
   }
} /* remove_from_approval_list() */

/**
 * This method adds in transaction into the transaction list.
 * @param person the person doing the thing
 * @param objects the string name of the objects
 * @param type the type of the transaction
 * @param amount the cost of the transaction
 * @param name_cat the name/category of the item
 * @param extra anything extra about the transaction
 */
void add_transaction(string person, object* objects, int type, int amount,
                     string name_cat, mixed extra) {
#if USE_TRANSACTIONS
   class shop_transaction bing;
   string str;

   str = query_multiple_short(objects, 0, 1);

   bing = new(class shop_transaction);
   bing->time = time();
   bing->person = person;
   bing->objects = str;
   bing->type = type;
   bing->amount = amount;
   bing->name_cat = name_cat;
   bing->extra = extra;
   _transactions += ({ bing });
   event_save(this_object());
#endif
} /* add_transaction() */

#if USE_TRANSACTIONS
/**
 * This method truns a transaction into a string.
 * @param trans the transaction
 * @return the transaction as a string
 */
string query_transaction_string(class shop_transaction trans) {
   string ret;
   string amt;
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   amt = MONEY_HAND->money_value_string(trans->amount, place);
   ret = ctime(trans->time)[4..<9] + ": " + trans->person;
   switch (trans->type) {
   case PLAYER_CRAFT_SHOP_SELL :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_SELL_AUTO :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") [accepted] for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_APPROVE :
      ret += " approves " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_BUY :
      ret += " buys " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   }
   return ret;
} /* query_transaction_string() */
#endif

/**
 * This method is called to complete the sale completely.  It is split
 * up into a second function to allow the extra sell stuff
 * to work neatly.
 * @param value the value of the objects to sell
 * @param name the list name
 * @param sellable the list of objects to sell
 * @param category the category of the object, 0 if none
 * @ignore yes
 */
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   string place;
   object *bought;
   mixed approve;
   int final_cost;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   //
   // Make sure we mess with the price before we do any of the approval
   // things.
   //
   _num_checked_so_far = ([ ]);
   approve = is_item_approved(this_player()->query_name(),
                        value, name, sellable, category, ref final_cost);
   if (approve == -1) {
      write("This item is denied sale here, it is not something the "
            "owner wishes to buy.\n");
      say(this_player()->query_cap_name() + " finished attempting to sell " +
                query_multiple_short(sellable) + " to " + the_short() + ".\n");
      return ;
   }

   if (approve == 1 || stringp(approve)) {
      if (stringp(approve)) {
         name = approve;
      }

   }

   write("Waiting for approval from the shop owner for the items " +
         query_multiple_short(sellable) + " with the name '" +
         name + "' selling for " +
         MONEY_HAND->money_value_string(value, place) +
         " in category " + category + ".\nIf the item is accepted the "
         "money will be paid into your royalty pool.\n");

   bought = add_to_approval_list(this_player()->query_cap_name(), sellable,
                        value, name, category, approve != 0);
   if (sizeof(bought)) {
      add_transaction(this_player()->query_name(),
                   bought,
                   PLAYER_CRAFT_SHOP_SELL,
                   value * sizeof(sellable),
                   name + " in " + category,
                   0);
      if (sizeof(bought) != sizeof(sellable)) {
         write("Unable to sell " + query_multiple_short(sellable - bought) +
                  " to " + the_short() + ".\n");
      }
      say(this_player()->the_short() + " completes selling something "
       "to the shop.\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + " to " +
            the_short() + ".\n");
   }
} /* complete_sale() */

/**
 * This method returns the position as a two letter value.
 * @param pos the position to mangle
 * @return the letter value
 */
string query_letter_value(int pos) {
   return sprintf("%c%c", 'A' + (pos / 26), 'A' + (pos % 26));
} /* query_letter_value() */

/**
 * This method goes from a letter value to a number.
 * @param letter the letters
 * @return the number
 */
int query_number_value(string letter) {
   if (!strlen(letter)) {
      return -1;
   }

   letter = lower_case(letter);
   if (strlen(letter) < 2) {
      if (letter[0] >= 'a' && letter[0] <= 'z') {
         return letter[0] - 'a';
      }
   }
   if (strlen(letter) > 2) {
      return -1;
   }
   if (letter[0] >= 'a' && letter[0] <= 'z') {
      if (letter[1] >= 'a' && letter[1] <= 'z') {
         return (letter[0] - 'a') * 26 + (letter[1] - 'a');
      }
   }
   return -1;
} /* query_number_value() */

/**
 * This method returns the approval class from the string name.  THis is
 * assumed to be called from inside a command.
 * @param name the string name
 * @param approved from the approved or waiting list
 * @return the approval object
 */
class approval_obs query_approval_class(string name) {
   int pos;

   if (name[0] == '-') {
      pos = query_number_value(name[1..]);
   } else {
      pos = query_number_value(name);
   }
   if (pos == -1) {
      add_failed_mess(name + " is not a valid number.\n");
      return 0;
   }

   if (name[0] == '-') {
      if (!sizeof(query_approval_list(0))) {
         add_failed_mess("There is nothing in the approval list currently.\n");
         return 0;
      }
      if (pos >= sizeof(query_approval_list(0))) {
         add_failed_mess("The " + name + " is out of range, must be "
                         "between -AA and -" +
                         query_letter_value(sizeof(query_approval_list(0)) - 1) +
                         ".\n");
         return 0;
      }

      return query_approval_list(0)[pos];
   }

   if (pos >= sizeof(query_approval_list(1))) {
      add_failed_mess("The " + name + " is out of range, must be between AA-" +
                      query_letter_value(sizeof(query_approval_list(1)) - 1) +
                      ".\n");
      return 0;
   }

   return query_approval_list(1)[pos];
} /* query_approval_class() */

/** @ignore yes */
int ownership_change(string old_owner, string new_owner) {
   class parse_node* expr;

   if (old_owner == new_owner) {
      return 0;
   }

   //
   // Setup all the defaults.
   //
   _automatic_approval = new(class approval);
   //_automatic_approval->sellers = ({ });
   //_automatic_approval->categories = ([ ]);
   _automatic_approval->items = ([ ]);
   _automatic_approval->expressions = ({ });
   _automatic_percentage = 10;
#if USE_TRANSACTIONS
   _transactions = ({ });
#endif
   _sold_stats = ([ ]);
   _stats_start = time();
   _sellers = ([ ]);
   expr = parse_boolean_string("false");
} /* ownership_change() */

/** @ignore yes */
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
   string name_cat;
   int i;
   class shop_stats stat;

   _total_ingoing += value;
   adjust_royalty(query_owner(), value);
   for (i = 0; i < sizeof(obs); i++) {
      name_cat = names[i] + " in " + cats[i];
      add_transaction(this_player()->query_name(),
                      obs[i..i],
                      PLAYER_CRAFT_SHOP_BUY,
                      values[i],
                      name_cat,
                      sellers[i]);
      if (!_sold_stats) {
         _sold_stats = ([ ]);
      }
      stat = _sold_stats[sellers[i] + " - " + name_cat];
      if (!stat) {
         stat = new(class shop_stats);
         stat->name = name_cat;
         stat->seller = sellers[i];
      }
      stat->num_sold++;
      stat->value_sold += values[i];
      _sold_stats[sellers[i] + " - " + name_cat] = stat;

      // Weekly stats.
/*
      if (!_weekly_stats->items[names[i]]) {
         _weekly_stats->items[names[i]] = new(class item_stats);
      }
      _weekly_stats->items[names[i]]->num_sold++;
      _weekly_stats->items[names[i]]->total_made += values[i];
 */
   }

   //
   // Weekly stats data management.
   //
   _weekly_stats->total_made += value;
} /* inform_of_buy() */

/** @ignore yes */
object* check_for_checkout(object ob) {
   object* obs = ({ });

   if (_something_checkedout && ob) {
      //
      // Give them a look.
      //
      if (living(ob)) {
         obs = filter(deep_inventory(ob), (: is_checkout_object($1) :));
         if (sizeof(obs)) {
            foreach (ob in obs) {
               if (!destroy_checkout_object(ob)) {
                  obs -= ({ ob });
               }
            }
         }
      } else {
         if (is_checkout_object(ob)) {
            call_out("verify_destroy_checkout_object", 2, ob);
            //obs = ({ ob });
         }
      }
      return obs;
   }
   return ({ });
} /* check_for_checkout() */

/** @ignore yes */
void verify_destroy_checkout_object(object ob) {
   // If it is destroyed, tell people about it.
   if (destroy_checkout_object(ob)) {
      tell_room(environment(), ob->the_short() +
                " magically checks itself back in.\n");
   }
}

/** @ignore yes */
void event_exit(object ob, string message, object to) {
   object *obs;

   // Already being checked
   if (ob->query_property("destroy checkout object")) {
      return ;
   }
   obs = check_for_checkout(ob);
   if (sizeof(obs)) {
      tell_object(ob, "You suddenly find the uncheckout items " +
                      query_multiple_short(obs) + " check themselves "
                      "back in.\n");
      obs->move("/room/rubbish");
   }
} /* event_exit() */

/** @ignore yes */
void event_dest_me(object ob) {
   check_for_checkout(ob);
} /* event_dest_me() */

/**
 * This method returns all the checkedout objects to the shop.
 */
void return_all_checkedout_objects() {
   object ob;
   object* obs;

   if (_something_checkedout) {
      obs = filter(deep_inventory(this_object()), (: is_checkout_object($1) :));
      if (sizeof(obs)) {
         foreach (ob in obs) {
            destroy_checkout_object(ob);
         }
      }
      tell_room(this_object(), query_multiple_short(obs) +
                " mysteriously check themselves back in.\n");
   }
} /* return_all_checkedout_objects() */

/** @ignore yes */
void dest_me() {
   ::dest_me();
} /* dest_me() */

/**
 * @ignore yes
 * In a player run shop we change this so that only allowed people can change
 * an item once it is sold.
 */
int is_able_to_change(object ob) {
   return is_allowed(this_player()->query_name()) ||
          is_helper(this_player()->query_name());
} /* is_able_change_ob() */

/**
 * @ignore yes
 */
int do_buy(object *obs, int force) {
   if (!is_open_for("buy", this_player()->query_name()) ||
       !is_open_for("use", this_player()->query_name())) {
      add_failed_mess("You cannot buy anything at this shop.\n");
      return 0;
   }
   return ::do_buy(obs, force);
} /* do_buy() */

/**
 * This method runs through the objects and checks to see what sort of levels
 * they are allowed to sell them for to this shop.
 * @return 1 on success, 0 on failure
 */
int do_check_sell(object *obs) {
   int *stuff;
   object ob;
   string ret;
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "";
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(this_player()->query_name(), ob);
      ret += "$I$5=$C$" + the_short() + ": ";
      if (stuff[0]) {
         ret += "will be queued for more than " +
                MONEY_HAND->money_value_string(stuff[0], place);
      }
      if (stuff[0] && stuff[1]) {
         ret += " and ";
      }
      if (stuff[1]) {
         ret += "will be denied for more than " +
                MONEY_HAND->money_value_string(stuff[1], place);
      }
      ret += ".\n";
   }
   write("$P$Check Sell$P$" + ret);
   add_succeeded_mess(({ "", "$N checks the sale of $I.\n" }), obs);
   return 1;
} /* do_check_sell() */

/**
 * List the items for approval.
 */
int do_list_approval(int approved) {
   class approval_obs approve;
   int pos;
   int shown;
   int allowed;
   int checkout;
   string place;
   string ret;
   object* obs;
   object *current;
   object* result;
   string *possible_names;
   string start;
   mapping result_type;
   int i;
   int fluff;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   allowed = is_allowed(this_player()->query_name()) ||
             is_helper(this_player()->query_name());
   if (!allowed) {
      approved = 1;
   }
   if (!approved) {
      start = "-";
   } else {
      start = "";
   }

   result_type = ([ ]);
   ret = "";
   while (allowed || approved) {
      if (approved == 2) {
         approved = 0;
         start = "-";
      }
      foreach (approve in query_approval_list(approved)) {
         if (lower_case(approve->seller) == this_player()->query_name() ||
             allowed) {
            checkout = sizeof(filter(approve->checkout, (: $1 :)));
/*
            if (sizeof(approve) == 7) {
                possible_names = ({ "womble" });
            } else {
                possible_names = approve->shorts;
            }
 */

            obs = ({ });
            for (i = 0; i < sizeof(approve->saved); i++) {
               fluff = approve->saved[i];
               obs += ({ create_real_auto_load_object(fluff, this_player()) });
            }
            obs -= ({ 0 });
            possible_names = obs->query_short();
            obs->move("/room/rubbish");
            if (!result_type[lower_case(approve->name)]) {
               if (!current) {
                  current = map(query_controller()->query_sell_list_obs(),
                                (: query_controller()->query_short_of_shop_object($1) :));
               }
               // Intersection.
               result = current & possible_names;
/*
                          filter(current,
                        (: member_array($1->query_short(),
                                        $(possible_names)) > -1 :)); 
 */
               result_type[lower_case(approve->name)] = sizeof(result);
            }
            ret += start + query_letter_value(pos) + ") " +
                  approve->seller + "'s " + approve->name + " for " +
                  MONEY_HAND->money_value_string(approve->value, place) +
                  " in " + approve->category + ", " +
                  sizeof(approve->saved) + " objects (" +
                  query_multiple_short(obs) + ") " +
                  result_type[lower_case(approve->name)] + " in stock";
   
            if (checkout) {
               ret += " and " + checkout + " checked out.\n";
            } else {
               ret += ".\n";
            }
            shown++;
         }
         pos++;
      }
      if (!allowed && approved) {
         approved = 2;
         pos = 0;
      } else {
         break;
      }
   }
   if (sizeof(current)) {
      current->dest_me();
   }

   if (!shown) {
      add_failed_mess("No items to approve at the moment.\n");
      return 0;
   }

   write("$P$Approval list$P$The current approval items are:\n" + ret);
   return 1;
} /* do_list_approval() */

/**
 * This method returns the item to the person that started to sell it.
 * This only works before the item has been approved.
 * @param name the name of the item to return
 */
int do_return(string name) {
   object *obs;
   object *ok;
   object *here;
   object *fail;
   object *checkout;
   object money;
   class approval_obs approve;
   object ob;
   int pos;
   int i;
   int value;
   string place;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) != this_player()->query_name()) {
      add_failed_mess("You must be the one that sold the item to return "
                      "it.\n");
      return 0;
   }

   obs = ({ });
   checkout = ({ });
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      //
      // Try and return it.
      //
      return_all_checkedout_objects();
   }

   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }

   obs -= ({ 0 });
   checkout -= ({ 0 });

   if (sizeof(checkout)) {
      place = query_property("place");
      if (!place) {
         place = "default";
      }

      write("The items " + query_multiple_short(checkout) +
            " are currently checked out.  You are reimbused the amount "
            "they would have cost to sell.\n");
      value = approve->value * sizeof(checkout);
      money = MONEY_HAND->make_new_amount( value, place);
      money->move(this_player());
      _total_outgoing += approve->value * sizeof(checkout);
   }

   ok = ({ });
   here = ({ });
   fail = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) == MOVE_OK) {
         ok += ({ ob });
      } else if (ob->move(environment(this_player()))) {
         here += ({ ob });
      } else {
         fail += ({ ob });
      }
   }
   remove_from_approval_list(approve);

   if (sizeof(ok)) {
      add_succeeded_mess("$N return$s $I.\n", map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(here)) {
      add_succeeded_mess("$N $V their $I and they get put on the floor.\n",
                         map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(fail)) {
      add_succeeded_mess( ({ "You find that $I do not want to be moved.\n",
                             "" }), fail);
   }
   return 1;
} /* do_return() */

/**
 * This method approves the specified item.
 */
int do_approve_item(string name, string money_str) {
   int cost;
   object *obs;
   class approval_obs approve;
   string place;
   int final_cost;
   int num;

   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(approve->saved) > query_maximum_inventory_size()) {
      add_failed_mess("You cannot approve anything, the shop is already "
                      "at the maximum number allowed.\n");
      return 0;
   }

   cost = approve->value * sizeof(obs);
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to put this into the shop.\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess("The amount " + money_str + " is not a valid "
                         "money cost.\n");
         return 0;
      }
   }

   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      //
      // Try and return it.
      //
      write("One of these objects is still checkedout, do you wish to "
            "continue this without these items? ");
      input_to("confirm_approval", 0, approve, final_cost);
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      return 1;
   }


   confirm_approval("y", approve, final_cost);
   return 1;
} /* do_approve_item() */

/**
 * This method resets all the weekly stats information back to zero.
 */
void reset_weekly_status() {
   _weekly_stats = new(class weekly_stats);
   _weekly_stats->num_sold = 0;
   _weekly_stats->total_cost = 0;
   _weekly_stats->total_made = 0;
   _weekly_stats->num_bought = 0;
   //_weekly_stats->items = ([ ]);
   _weekly_stats->helper = ([ ]);
} /* reset_weekly_stats() */

/**
 * This method returns a nice string representation of the weekly stats.
 * @return the string representation of the weekly stats
 */
string query_weekly_status_string() {
   string ret;
   string place;
   string player;
   class helper_stats helpers;
   class item_stats items;
   string* item_bits;
   string item;
   int num;

   place = query_property("place");
   ret = "$I$0=Total Outgoing  : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_cost, place) + "\n";
   ret += "$I$0=Total Incoming : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_made, place) + "\n";
   if (_weekly_stats->total_made > _weekly_stats->total_cost) {
      ret += "$I$0=Profit of      : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_made - _weekly_stats->total_cost, place) + "\n";
   } else {
      ret += "$I$0=Loss of        : " +
          MONEY_HAND->money_value_string(-(_weekly_stats->total_made - _weekly_stats->total_cost), place) + "\n";
   }
   ret += "$I$0=Items             : " +
          _weekly_stats->num_sold + " sold and " +
          _weekly_stats->num_bought + " bought.\n";

   ret += "\n$I$0=Player summaries:\n";
   foreach (player, helpers in _weekly_stats->helper) {
      item_bits = ({ });
      if (sizeof(helpers->items_approved)) {
         foreach (item, num in helpers->items_approved) {
            item_bits += ({ num + " " + item });
         }
      } else {
         item_bits = ({ "nothing" });
      }
      ret += "$I$6=   " + player + ": " + helpers->num_approved +
             " approved, " + helpers->num_rejected + " rejected, " +
             MONEY_HAND->money_value_string(helpers->total_cost, place) +
             " approved " + query_multiple_short(item_bits) + "\n";
   }

/*
   ret += "\n$I$0=Item Summaries:\n";
   foreach (item, items in _weekly_stats->items) {
      ret += "$I$6=   " + item + ": " + items->num_sold + " sold, " +
             items->num_bought + " bought.  Cost " +
             MONEY_HAND->money_value_string(items->total_cost, place) +
             ", made " +
             MONEY_HAND->money_value_string(items->total_made, place) +
             ", profit " +
             MONEY_HAND->money_value_string(items->total_made - items->total_cost, place) + "\n";
   }
 */

   return ret;
} /* query_weekly_stats_string() */

/**
 * This method is called when an item is approved so people can do whatever
 * they want to about it.  In this case, we keep track of statistics.
 * @param name the name of the peron doing the approval
 * @param cost the cost it ws approved for
 * @param approve the approval class
 */
protected void inform_of_approved_item(string name,
                            int cost,
                            class approval_obs approve) {
   string str;

   //
   // Weekly stats data management.
   //
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }

   _weekly_stats->total_cost += cost;
   str = approve->name; // + " in " + approve->category;
/*
   if (!_weekly_stats->items[str]) {
      _weekly_stats->items[str] = new(class item_stats);
   }
   _weekly_stats->items[str]->num_bought++;
   _weekly_stats->items[str]->total_cost += cost;
 */

   name = this_player()->query_name();
   if (!_weekly_stats->helper[name]) {
      _weekly_stats->helper[name] = new(class helper_stats);
      _weekly_stats->helper[name]->items_approved = ([ ]);
   }
   _weekly_stats->helper[name]->num_approved++;
   _weekly_stats->helper[name]->total_cost += cost;
   if (!mapp(_weekly_stats->helper[name]->items_approved)) {
      _weekly_stats->helper[name]->items_approved = ([ ]);
   }
   _weekly_stats->helper[name]->items_approved[str]++;
} /* inform_of_approved_items() */

/**
 * This method is called when an item is rejected so people can do whatever
 * they want to about it.  In this case, we keep track of statistics.
 * @param name the name of the peron doing the rejection
 * @param approve the approval class
 */
protected void inform_of_rejected_item(string name,
                            class approval_obs approve) {
   //
   // Weekly stats data management.
   //
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }

   name = this_player()->query_name();
   if (!_weekly_stats->helper[name]) {
      _weekly_stats->helper[name] = new(class helper_stats);
   }
   _weekly_stats->helper[name]->num_rejected++;
} /* inform_of_rejected_items() */

/** @ignore yes */
protected void confirm_approval(string answer,
                                class approval_obs approve,
                                int final_cost) {
   int pos;
   int i;
   int bing;
   int cost;
   object *obs;
   object *bought;
   object *checkout;
   string place;

   if (strlen(answer) < 1 || lower_case(answer)[0] != 'y') {
      write("Ok, canceled the approval of the item.\n");
      return ;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   //
   // Approval means we create all the objects, remove them, and then
   // send them off to the main engine...
   //
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }

   obs -= ({ 0 });
   checkout -= ({ 0 });

   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and therefore lost.\n");
   }

   if (!final_cost) {
      final_cost = ((approve->value * (100 + _automatic_percentage)) / 100);
   }
   final_cost -= final_cost % _round_value;
   obs->remove_property("dropped");
   bought = query_controller()->buy_objects(obs, approve->name,
                                   final_cost,
                                   approve->seller, approve->category, 1);
   if (sizeof(bought)) {
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      _total_outgoing += cost;
      remove_from_approval_list(approve);
      adjust_royalty(lower_case(approve->seller), cost);
      //
      // Try and remove from the cash float first.
      //
      if (query_owners_money() > 0) {
         if (query_owners_money() > cost) {
            adjust_owners_money(-cost);
            cost = 0;
         } else {
            cost -= query_owners_money();
            adjust_owners_money(-query_owners_money());
         }
      }
      if (cost > 0) {
         if (this_player()->query_value_in(place) > 0) {
            bing = this_player()->query_value_in(place);
            if (bing > cost) {
               bing = cost;
               cost = 0;
            } else {
               cost -= bing;
            }
            if (bing) {
               this_player()->pay_money(MONEY_HAND->create_money_array(bing, place), place);
            }
         }
         if (cost > 0) {
            adjust_owners_money(-cost);
         }
      }
      write("You approve " + query_multiple_short(obs) + " to be sold as " +
            approve->name + " in " + approve->category + " for " +
            MONEY_HAND->money_value_string(approve->value, place) + ".\n");
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );

      // Statistics collection.
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      inform_of_approved_item(this_player()->query_name(),
                              cost, approve);
      add_transaction(this_player()->query_name(),
                      obs,
                      PLAYER_CRAFT_SHOP_APPROVE,
                      approve->value * (sizeof(obs) + sizeof(checkout)),
                      approve->name + " in " + approve->category,
                      approve->seller);
   } else {
      write("Unable to move the items into the shops inventory, you "
            "will need to reject this item.\n");
   }
   return ;
} /* do_approve_item() */

/**
 * This method rejects the specified item.
 */
int do_approve_reject(string name, string mess, int reject_pos) {
   object *obs;
   object *ok;
   object *here;
   object *checkout;
   object ob;
   object play;
   class approval_obs approve;
   int pos;
   int i;
   int ret;
   string ob_mess;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) == this_player()->query_name()) {
      //
      // Return the stuff to them.
      //
      return do_return(name);
   }

   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You're not allowed to reject items.\n");
      return 0;
   }


   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      //
      // Try and return it.
      //
      return_all_checkedout_objects();
   }

   if (reject_pos != -1 &&
       (reject_pos <= 0 ||
       reject_pos > sizeof(approve->saved))) {
      add_failed_mess("You cannot reject the item of position " + reject_pos +
                      " since there are only " + sizeof(approve->saved) +
                      " items.\n");
      return 0;
   }

   if (reject_pos != -1) {
      reject_pos--;
   }

   //
   // Approval means we create all the objects, remove them, and then
   // send them off to the main engine...
   //
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      if (reject_pos == -1 ||
          reject_pos == i) {
         pos = approve->saved[i];
         if (!approve->checkout[i]) {
            obs += ({ create_real_auto_load_object(pos, this_player()) });
         } else {
            checkout += ({ create_real_auto_load_object(pos, this_player()) });
         }
      }
   }

   obs = filter(obs, (: $1 && objectp($1) :));
   checkout = filter(checkout, (: $1 && objectp($1) :));

   if (member_array(0, obs) != -1) {
      add_failed_mess("There seems to be a problem with this rejection set, "
                      "one of the items is 0.\n");
      return 0;
   }

   if (reject_pos != -1 && sizeof(checkout)) {
      add_failed_mess("The item $I has been checked out, you cannot reject "
                      "it.\n", checkout);
      return 0;
   }

   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and lost.\n");
      adjust_royalty(lower_case(approve->seller),
                     approve->value * sizeof(checkout));
      AUTO_MAILER->auto_mail(lower_case(approve->seller),
                            this_player()->query_name(),
                            "Rejected items", "",
                            sprintf("%-=75s",
                                   this_player()->query_name() + " lost your " +
                                   query_multiple_short(checkout, "the", 1) +
                                   ",so you have been paid but the items "
                                   "were not returned.\n"));
   }

   inform_of_rejected_item(this_player()->query_name(), approve);
   if (!sizeof(obs)) {
      write("Nothing to give back or send off.\n");
   } else {
      //
      // They are here, so give it back.
      //
      play = find_player(lower_case(approve->seller));
      if (play  &&  environment(play) == this_object()) {
         ok = ({ });
         here = ({ });
         foreach (ob in obs) {
            if (ob) {
               if (ob->move(play) == MOVE_OK) {
                  ok += ({ ob });
               } else if (ob->move(environment(play)) == MOVE_OK) {
                  here += ({ ob });
               }
            }
         }
         if (sizeof(ok)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed in your inventory.\n");
         }
         if (sizeof(here)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed on the floor here.\n");
         }
         write("You reject the item.\n");
      } else {
         if (!query_parcel_post()) {
            add_failed_mess("Eeek!  No parcel post defined on this room.\n");
            return 0;
         } else if(!load_object(query_parcel_post())) {
           add_failed_mess("Eeek!  Parcel post cannot be loaded.\n");
           return 0;
         }

         ob_mess = "The shop " + this_player()->convert_message(the_short()) +
                   " rejected " + query_multiple_short(obs, "the", 1) +
                   " because:\n";
         if (!mess) {
            mess = "They didn't want to add a reject message.";
         }
         ret = query_parcel_post()->deposit_parcel(obs, lower_case(approve->seller), 1);
         if (ret != 1) {
            if (ret == -5) {
               write("The player " + approve->seller + " has been denied use "
                     "of the parcel post system, tossing objects away.\n");
               obs->move("/room/rubbish");
               if (mess) {
                  write("Still sending the message to the person.\n");
                  mess += "\nYou were denied use of the parcel post system "
                          "so your objects were thrown away.\n";
               }
            } else if (ret == -4) {
               write("You have been denied use of the postal system, perhaps "
                     "you could try clearing this up with the creators?\n");
               obs->move("/room/rubbish");
               return 1;
            } else if (ret == -2) {
               write("The player " + approve->seller + " no longer exists, "
                     "tossing objects away.\n");
               obs->move("/room/rubbish");
            } else {
               add_failed_mess("Unable to send the parcel for some reason (" +
                            ret + ").\n");
                  obs->move("/room/rubbish");
               return 0;
            }
         }
         if (ret != -2) {
            if (mess) {
               AUTO_MAILER->auto_mail(approve->seller, this_player()->query_name(),
                               "Rejected items", "",
                               ob_mess + mess);
            } else {
               write("You reject the item and it is parcel posted back to the "
                  "person who "
                  "sent it.\nWould you like to send them a note about it as well? ");
               obs -= ({ 0 });
               input_to("check_reject_note", 0, ob_mess,
                        approve->seller);
            }
         }
      }
   }

   if (reject_pos != -1) {
      approve->saved = approve->saved[0..reject_pos-1] + approve->saved[reject_pos+1..];
      event_save(this_object());
      if (!sizeof(approve->saved)) {
         reject_pos = -1;
      }
   }

   if (reject_pos == -1) {
      remove_from_approval_list(approve);
   }
   add_succeeded_mess(({ "", "$N reject$s a sellable object.\n" }));
   return 1;
} /* do_approve_reject() */

/**
 * @ignore yes
 */
void check_reject_note(string str, string ob_str, string name) {
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' &&
        str[0] != 'n')) {
      write("Please answer yes or no.\nWould you like to send them "
            "a note about it as well?");
      input_to("check_reject_note", 0, ob_str, name);
      return ;
   }
   if (str[0] == 'n') {
      write("ok, bye then!\n");
      return ;
   }
   this_player()->do_edit("Your items " + ob_str + " were rejected "
                         "from " + the_short() + ".\n\n",
                         "send_reject_note", this_object(), 0, name);
} /* check_reject_note() */

/** @ignore yes */
void send_reject_note(string mess, string name) {
   if (!mess) {
      write("Aborted.\n");
      return ;
   }
   //write("Sending to " + name + ".\n");
   AUTO_MAILER->auto_mail(name, this_player()->query_name(),
                            "Rejected items", "", mess);
} /* send_reject_note() */

/**
 * This method browses the specified item.
 */
int do_approve_browse(string name) {
   object *obs;
   object ob;
   string read;
   string ret;
   string bits;
   class approval_obs approve;
   int pos;
   string place;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) == this_player()->query_name()) {
      //
      // Return the stuff to them.
      //
      return do_return(name);
   }

   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }


   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   //
   // Create the objects, browse them, kill them.
   //
   obs = ({ });
   foreach (pos in approve->saved) {
      obs += ({ create_real_auto_load_object(pos, this_player()) });
   }

   obs -= ({ 0 });

   ret = "";
   foreach (ob in obs) {
      ret += ob->the_short() + ": (Base cost " +
             MONEY_HAND->money_value_string(ob->query_base_value(), place) +
             "; scaled cost " +
             MONEY_HAND->money_value_string(ob->query_value(), place) +
             ")\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         bits = ob->query_read_short(this_player());
         if (!bits) {
            bits = "$name$";
         }
         ret += "You read " +
                 replace_string(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }

   obs->move("/room/rubbish");

   write("$P$Browse list$P$" + ret);

   add_succeeded_mess("$N browse$s an item waiting for approval.\n");
   return 1;
} /* do_approve_browse() */

/**
 * This method checks out the specified item.
 */
int do_approve_checkout(string name) {
   object *obs;
   object *bad;
   object *checkout;
   object ob;
   class approval_obs approve;
   int pos;
   int i;

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (lower_case(approve->seller) == this_player()->query_name() &&
       lower_case(approve->seller) != "pinkfish") {
      //
      // Return the stuff to them.
      //
      return do_return(name);
   }

   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }


   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   //
   // Create the objects, browse them, kill them.
   //
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         ob = create_checkout_object(approve, pos, this_player());
         if (!ob) {
            write("Unable to create " + pos + approve->name + ", weird...\n");
         } else {
            obs += ({ ob });
         }
      } else {
         checkout += ({ create_checkout_object(approve, pos, this_player()) });
      }
   }

   checkout->move("/room/rubbish");

   if (!sizeof(obs) &&
       sizeof(checkout)) {
      if (sizeof(checkout) > 0) {
         add_failed_mess("$I are already checked out.\n", checkout);
      } else {
         add_failed_mess("$I is already checked out.\n", checkout);
      }
      return 0;
   }

   bad = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) != MOVE_OK) {
         bad += ({ ob });
         destroy_checkout_object(ob);
      }
   }

   if (sizeof(bad)) {
      write("Unable to move " + query_multiple_short(bad) + " into your "
            "inventory for you to check.\n");
   }

   obs -= bad;
   if (sizeof(obs)) {
      write("Moved " + query_multiple_short(obs) + " into your inventory "
            "for you to check.\n");
      add_succeeded_mess("$N check$s out $I.\n", obs);
   }

   return 1;
} /* do_approve_checkout() */

/**
 * This method checks in a checked out object.
 */
int do_approve_checkin(object* obs) {
   object ob;
   object* ok;

   ok = ({ });
   foreach (ob in obs) {
      if (is_checkout_object(ob)) {
         destroy_checkout_object(ob);
         ok += ({ ob });
      }
   }

   if (!sizeof(ok)) {
      add_failed_mess("None of $I have been checked out.\n", obs);
      return 0;
   }

   add_succeeded_mess("$N check$s $I back in.\n", ok);
   return 1;
} /* do_approve_checkin() */

/**
 * This method changes the name of the item to be approved.
 * @param name the reference
 * @param new_name the new name for the item
 */
int do_approve_name_change(string name, string new_name) {
   class approval_obs approve;

   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   approve = query_approval_class(name);
   if (!approve)  return 0;
   write("You change the name of the item waiting to be approved from " +
         approve->name + " to " + new_name + ".\n");
   approve->name = new_name;
   add_succeeded_mess( ({ "", "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
} /* do_approve_name_change() */

/**
 * This method changes the category of the item waiting to be approved.
 * @param name the reference
 * @param new_category the new category for the item
 */
int do_approve_category_change(string name, string new_category) {
   class approval_obs approve;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }

   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }

   approve->category = new_category;
   add_succeeded_mess(({
      "You change the category of the approval item " + name + ".\n",
      "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
} /* do_approve_category_change() */

/**
 * This method sets the automatic low acception level.
 * @param cost the cost to use a low level
 */
int do_approve_auto_low(string cost) {
   string place;
   int value;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = value_from_string(cost, place);
   _automatic_approval->low_cost = value;
   event_save(this_object());
   if (!value) {
      add_succeeded_mess(({ "You disable the automatic acception of items of "
                            "low value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }

   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "costing less than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_low() */

/**
 * This method sets the automatic high cut off level.
 * @param cost the cost to use a high cut off level
 */
int do_approve_auto_high(string cost) {
   string place;
   int value;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost = value;
      add_succeeded_mess(({ "You disable the automatic placing items into the "
                            "approve list of items of high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }

   _automatic_approval->high_cost = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically put any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) +
                         " into the approve list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_high() */

/**
 * This method sets the automatic high cut off level for denying sales.
 * @param cost the cost to use a high cut off level
 */
int do_approve_auto_high_deny(string cost) {
   string place;
   int value;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost_deny = 0;
      add_succeeded_mess(({ "You disable the automatic denying of items of "
                            "high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }

   _automatic_approval->high_cost_deny = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_high() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add(string item, string money, string list_name,
                             int markup, string money_str) {
   int value;
   string place;
   int final_cost;
   mixed app_item;
   class approval_item new_app_item;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }

   if (markup < 0) {
      markup = 0;
   }

   item = strip_quotes(item);
   list_name = strip_quotes(list_name);

   if (classp(_automatic_approval->items[item])) {
      app_item = ((class approval_item)_automatic_approval->items[item])->value;
   } else {
      app_item = _automatic_approval->items[item];
   }
   if (app_item == value) {
      add_failed_mess("The item " + item + " already has a cut off "
                      "value of " +
                      MONEY_HAND->money_value_string(value, place) + ".\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;

   place = query_property("place");

   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_add() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add_object(object *obs, string money,
                                    string list_name, int markup,
                                    string money_str) {
   int value;
   string place;
   object ob;
   string name;
   object *ok;
   object *bad;
   mixed item;
   class approval_item new_item;
   int final_cost;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   if (markup < 0) {
      markup = 0;
   }
   bad = ({ });
   ok = ({ });

   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      if (classp(_automatic_approval->items[name])) {
         item = ((class approval_item)_automatic_approval->items[name])->value;
      } else {
         item = _automatic_approval->items[name];
      }
      if (item == value) {
         bad += ({ name });
      } else {
         new_item = new(class approval_item);
         new_item->value = value;
         new_item->list_name = list_name;
         new_item->markup = markup;
         new_item->final_cost = final_cost;
         _automatic_approval->items[name] = new_item;
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You set the shop to automatically accept any of "
                         "$I up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   } else {
      add_failed_mess("You cannot set $I to a value limit of " +
                      MONEY_HAND->money_value_string(value, place) +
                      " since it already has this limit.\n");
      return 0;
   }
} /* do_approve_auto_item_add_object() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add_expr(string item, string expr,
                                  string list_name, int markup,
                                  string money_str) {
   class approval_item new_app_item;
   class parse_node* value;
   string place;
   int final_cost;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }

   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   if (markup < 0) {
      markup = 0;
   }

   item = strip_quotes(item);
   list_name = strip_quotes(list_name);

   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;

   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " with an expression "
                         "of " + query_expression_string(value, 1) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_add_expr() */

/**
 * This method sets the automatic items to allow.
 * @param item the items short to allow
 */
int do_approve_auto_item_add_object_expr(object *obs, string expr,
                          string list_name, int markup, string money_str) {
   class parse_node* value;
   object ob;
   string name;
   class approval_item new_item;
   int final_cost;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }

   if (money_str) {
      place = query_property("place");
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }

   if (markup < 0) {
      markup = 0;
   }
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      new_item = new(class approval_item);
      new_item->value = value;
      new_item->list_name = list_name;
      new_item->markup = markup;
      new_item->final_cost = final_cost;
      _automatic_approval->items[name] = new_item;
   }
   event_save(this_object());

   add_succeeded_mess(({ "You set the shop to automatically accept any of "
                      "$I with an expression "
                      "of " + query_expression_string(value, 1) +
                      (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                       "$N fiddle$s with something in the shop.\n" }), obs );
   return 1;
} /* do_approve_auto_item_add_object_expr */

/**
 * This method checks to see if the specified object can really be sold or
 * not automatically.
 * @param obs the objects to test
 */
int do_approve_auto_item_test(object* obs) {
   object ob;
   string place;
   mixed cost;
   int found;
   int allowed;
   class expression_type stuff;
   class parse_node frog;

   allowed = is_allowed(this_player()->query_name()) ||
             is_helper(this_player()->query_name());

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   foreach (ob in obs) {
      found = 0;
      cost = _automatic_approval->items[ob->query_short()];
      if (classp(cost)) {
         cost = ((class approval_item)cost)->value;
      }
      if (cost) {
         if (pointerp(cost)) {
            frog = evaluate_expression(cost, this_player()->query_name(),
                                        0, ({ ob }), 0, 0);
            if (allowed) {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  query_expression_string(cost, 1) +
                  ";\n" + ob->query_short() + " - " +
                  MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            } else {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  " " + MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            }
         } else {
            write("$I$5=The item " + ob->the_short() + " can be sold if it "
              "costs less than " +
               MONEY_HAND->money_value_string(cost, place) +
               " (" + ob->query_short() + ").\n");
         }
         found |= 1;
      }

      foreach (stuff in _automatic_approval->expressions) {
         frog = evaluate_expression(stuff->condition,
                                    this_player()->query_name(),
                                    0, ({ ob }), 0, 0);
         if (frog->value) {
            if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
               frog = evaluate_expression(stuff->value,
                                      this_player()->query_name(),
                                      0, ({ ob }), 0, 0);
               if (allowed) {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        query_expression_string(stuff->value, 1) +
                        ";\n" + ob->query_short() + " - " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               } else {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               }
               found |= 2;
            } else {
               // Denied!
               found |= 4;
            }
         }
      }
      if (found & 4)  {
         write("$I$5=The item " + ob->the_short() + " will be denied sale.\n");
      }
      else if (!found) {
         write("$I$5=The item " + ob->the_short() + " will not be "
               "automatically accepted.\n");
      }
   }
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_test() */

/**
 * This method sets the automatic items to allow.
 * @param item the item to accept
 */
int do_approve_auto_item_remove(string item) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   item = strip_quotes(item);
   if (!_automatic_approval->items[item]) {
      add_failed_mess("The item " + item + " is not in the list.\n");
      return 0;
   }

   map_delete(_automatic_approval->items, item);
   event_save(this_object());
   add_succeeded_mess(({ "You remove the item " + item +
                         " from the list of automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_remove() */

/**
 * This method sets the automatic items to allow.
 * @param item the item to accept
 */
int do_approve_auto_item_remove_object(object *obs) {
   object ob;
   object *bad;
   object *ok;
   string name;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   ok = ({ });
   bad = ({ });
   foreach (ob in obs) {
      name = ob->query_short();
      if (!_automatic_approval->items[name]) {
         bad += ({ ob });
      } else {
         ok += ({ ob });
         map_delete(_automatic_approval->items, name);
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You remove $I from the list of "
                            "automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   }
   add_failed_mess("None of $I are in the shops allow item list for you "
                   "to remove.\n", bad);
   return 0;
} /* do_approve_auto_item_remove() */

/**
 * This method sets the automatic expressions to allow.
 * @param expression the expressions short to allow
 */
int do_approve_auto_expression_add(string expression, string value_str,
                                   int type, string list_name) {
   class parse_node* expr;
   class parse_node* value;
   class expression_type bing;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }

   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      value = parse_money_string(value_str);
      if (!sizeof(value)) {
         add_failed_mess(query_last_expression_error() + ".\n");
         return 0;
      }
   }

   list_name = strip_quotes(list_name);
   bing = new(class expression_type);
   bing->type = type;
   bing->condition = expr;
   bing->value = value;
   bing->list_name = list_name;
   _automatic_approval->expressions += ({ bing });

   event_save(this_object());
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + " with a cost "
                         "of " + query_expression_string(value, 0) +
                         " as '" + list_name + "'.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
} /* do_approve_auto_expression_add() */

/**
 * This method removes an allowed expression
 * @param id the expression id to remove
 */
int do_approve_auto_expression_remove(string idstr) {
   class expression_type expr;
   int id;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   id = query_number_value(idstr);
   if (id == -1 || id >= sizeof(_automatic_approval->expressions)) {
      add_failed_mess("The id " + idstr + " is invalid.\n");
      return 0;
   }

   expr = _automatic_approval->expressions[id];
   _automatic_approval->expressions = _automatic_approval->expressions[0..id - 1] +
                                      _automatic_approval->expressions[id + 1..];

   event_save(this_object());
   add_succeeded_mess(({ "You remove the expression " +
                         query_expression_string(expr->condition, 1) +
                         " cost: " +
                         query_expression_string(expr->value, 1) +
                         " from the list of allowed expressions.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_auto_item_remove() */

/**
 * This method sets the percentage to add to the sell price.
 * @param num the number to set the percentage to
 */
int do_approve_percentage(mixed num) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }

   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }

   if (num <= 0) {
      add_failed_mess("The percentage to add must be greator than 0.\n");
      return 0;
   }

   _automatic_percentage = num;
   add_succeeded_mess(({ "You set the percentage to add to the sale price "
                         "to " + _automatic_percentage + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_percentage() */

/**
 * This method sets the limit on number of items sellable by all the players.
 * @param limit the default limit
 */
int do_approve_limit(string limit) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   if (limit == "disable")  {
      _automatic_approval->num_allowed = 0;
      add_succeeded_mess(({ "You disable the default number of sold items "
                         "per person.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   else if (to_int(limit) > 0)  {
      _automatic_approval->num_allowed = to_int(limit);
      add_succeeded_mess(({ "You set the default number of sold items per "
                            "person to " + _automatic_approval->num_allowed + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   return 0;
} /* do_approve_limit() */

/**
 * This method sets the limit per person to be a specified value.
 * @param person the person to set a limit on
 * @param value the limit to set
 */
int do_approve_limit_person_items(string name, string value) {
   int amt;
   class seller_information info;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return 0;
   }

   amt = to_int(value);
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->max_sellable = amt;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }

   if (amt)
      add_succeeded_mess(({ "You set the maximum number of items sellable by " +
                            name + " to " + info->max_sellable + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
   else
      add_succeeded_mess(({ "You remove the limit for the maximum number of "
         "items sellable by " + name + ".\n",
         "$N fiddle$s with something in the shop.\n" }));
   return 1;
} /* do_approve_limit_person_items() */

/**
 * This method sets the limit at which a person can automatically sell
 * to the shop.
 * @param person the person to set a limit on
 * @param money the limit to set it to
 */
int do_approve_limit_person_value(string name, string money) {
   class seller_information info;
   int value;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }

   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }

      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }

   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->value_limit = value;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }

   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items automatically "
                            "approved by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items "
                         "automatically approved by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
} /* do_approve_limit_person_value() */

/**
 * This method sets the limit at which a person can automatically sell
 * to the shop (deny limit).
 * @param person the person to set a limit on
 * @param money the limit to set it to
 */
int do_approve_limit_person_value_deny(string name, string money) {
   class seller_information info;
   int value;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }

   name = lower_case(name);

   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }

   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }

      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }

   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->deny_value_limit = value;
   if (info->deny_value_limit || info->max_sellable || info->value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }

   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items accepted by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->deny_value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items to be sold by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
} /* do_approve_limit_person_value() */

/**
 * This method removes any limits set on the player.
 * @param person the person to remove the limit on
 */
int do_approve_limit_person_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove limits "
                      "off someone.\n");
      return 0;
   }

   name = lower_case(name);

   if (!_sellers[name]) {
      add_failed_mess("The person " + name + " does not have any limits placed "
                      "on them.\n");
      return 0;
   }
   map_delete(_sellers, name);
   event_save(this_object());
   add_succeeded_mess(({ "You remove any limits set on " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_approve_limit_person_remove() */

/**
 * This method shows the current status of the shop.
 * @param hint show the hints
 * @return return main status string
 */
string query_main_status(int hint) {
   string ret;
   string place;
   string name;
   class seller_information stuff;
   string *bits;

   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "$I$0=" + the_short() + "\n";
   ret += "$I$6=   The current percentage to automatically add to the buy price is: " +
          _automatic_percentage + "%\n";
   if (hint) {
      ret += "$I$0=       Hint: markup <percent>\n";
   }
   ret += "$I$6=   Limits on what can be sold.\n";
   ret += "$I$6=   Maximum number of items allowed in the shop : ";
   if (query_maximum_inventory_size()) {
      ret += query_maximum_inventory_size() + " currently " +
             sizeof(query_controller()->query_sell_list_obs()) + " (fixed).\n";
   } else {
      ret += "disabled (fixed).\n";
   }
   ret += "$I$6=   Maximum number of items allowed per player  : ";
   if (_automatic_approval->num_allowed) {
      ret += _automatic_approval->num_allowed + ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set max number <number|disable>\n";
   }
   ret += "$I$6=   Automatically queue sales more than         : ";
   if (_automatic_approval->high_cost) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set high queue cost <cost|disable>\n";
   }
   ret += "$I$6=   Automatically deny sales more than          : ";
   if (_automatic_approval->high_cost_deny) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost_deny, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set high deny cost <cost|disable>\n";
   }
   ret += "$I$6=   Helpers     : ";
   if (sizeof(_helpers)) {
      ret += query_multiple_short(_helpers) + "\n";
   } else {
      ret += "None at all.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: helper add <name>\n";
      ret += "$I$0=       Hint: helper remove <name>\n";
      ret += "$I$0=       Hint: helper list\n";
   }
   if (sizeof(_sellers)) {
      ret += "$I$6=   Limits set per player.\n";
      ret += sprintf("   %-15s %-15s %-20s %s\n", "Name", "Max Sellable",
                     "Approve Limit", "Deny limit (per item)");
      bits = sort_array(keys(_sellers), 0);
      foreach (name in bits) {
         stuff = _sellers[name];
         ret += sprintf("   %-15s %-15s %-20s %s\n", name,
                    (stuff->max_sellable?stuff->max_sellable+"":"disabled"),
                    (stuff->value_limit?MONEY_HAND->money_value_string(stuff->value_limit, place):"disabled"),
                    (stuff->deny_value_limit?MONEY_HAND->money_value_string(stuff->deny_value_limit, place):"disabled"));
      }
   } else {
      ret += "$I$6=   No limits set per player.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set max number <max sellable|disable> for <player>\n";
      ret += "$I$0=       Hint: set high queue cost <cost|disable> for <player>\n";
      ret += "$I$0=       Hint: set high deny cost <cost|disable> for <player> to <cost|disable>\n";
      //ret += "$I$0=       Hint: approve limit remove <player>\n";
   }

   ret += "\n$I$6=   Automatically approve sales less than       : ";
   if (_automatic_approval->low_cost) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->low_cost, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set low approve cost <cost|disable>\n";
   }
   ret += "$I$0=Use 'expressions' to see the expressions.\n";
   ret += "$I$0=Use 'functions shop' to see the user defined "
          "functions.\n";

   return ret;
} /* query_main_status() */

/**
 * Returns all the rexpression stuff as a string.
 * @param hint show the hitns
 * @return a string with the expression status in it
 */
string query_expression_status(int hint) {
   string ret;
   string place;
   mixed expr;
   string str;
   int pos;
   class expression_type bing;
   class expression_type binger;
   class approval_item approval;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "";
   if (sizeof(_automatic_approval->items)) {
      ret += "$I$0=%^BOLD%^Automatically accept sales of items%^RESET%^\n";
      foreach (str, expr in _automatic_approval->items) {
         if (classp(expr)) {
            approval = (class approval_item)expr;
            expr = ((class approval_item)expr)->value;
         } else {
            approval = new(class approval_item);
         }
         if (pointerp(expr) && intp(expr[0])) {
            map_delete(_automatic_approval->items, str);
         } else {
            ret += sprintf("$I$10=   %-20s", "* " + str);
            if (sizeof(approval) == 3) {
               approval = new(class approval_item,
                      markup : approval->markup,
                      value : approval->value,
                      list_name : approval->list_name,
                      final_cost : 0);
            }
            if (approval->list_name) {
               ret += " listed as '" + approval->list_name + "'";
            }
            if (approval->markup) {
               ret += " markup of " + approval->markup;
            }
            if (approval->final_cost) {
               ret += " final cost of " +
               MONEY_HAND->money_value_string(approval->final_cost, place);
            }
            ret += " max value:";
            if (pointerp(expr)) {
               str = query_expression_string(expr, 0);
               if (strsrch(str, "\n") != -1) {
                  ret += "\n" + str;
               } else {
                  ret += str;
               }
            } else {
               ret += MONEY_HAND->money_value_string(expr, place);
            }
            ret += "\n";
         }
      }
   } else {
      ret += "Automatically accept sales of               : (none setup)\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: auto add name <name> up to <value>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> and markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> and value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto remove name <name>\n";
      ret += "$I$0=       Hint: auto remove object <object>\n";
   }
   ret += "\n$I$0=%^BOLD%^Automatic approval expressions.%^RESET%^\n";
   if (sizeof(_automatic_approval->expressions)) {
      //ret += "$I$0=Automatic approval expressions (if any of these evaluate as "
             //"true the item is accepted):\n";
      pos = 0;
      foreach (bing in _automatic_approval->expressions) {
         if (sizeof(bing) == 3) {
            binger = new(class expression_type);
            binger->type = bing->type;
            binger->condition = bing->condition;
            binger->value = bing->value;
            bing = binger;
            event_save(this_object());
         }

         if (bing->type != PLAYER_CRAFT_SHOP_EXPR_DENY) {
            str = query_expression_string(bing->value, 0);
            if (strsrch(str, "\n") != -1) {
               str = "\n" + str;
            }
            str = " accept value: " + str;
            if (bing->list_name) {
               str += " as " + bing->list_name;
            }
         } else {
            str = " -- deny item";
         }
         ret += "$I$5=" + query_letter_value(pos) + ") " +
                query_expression_string(bing->condition, 0) + str + ".\n";
         pos++;
      }

   } else {
      ret += "$I$0=No automatic approval expressions setup.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: auto add approve expression <condition> cost <value> as <list name>\n";
      ret += "$I$0=       Hint: auto deny expression <expression>\n";
      ret += "$I$0=       Hint: auto remove expression <id>\n";
   }

   ret += "\n$I$0=";
   ret += "$I$0=Use 'functions shop' to see the user defined "
          "functions.\n";
   return ret;
} /* query_expression_status() */

/**
 * This method prints out the main status.
 */
int do_main_status(int hint) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Cannot do that!\n");
      return 0;
   }
   write("$P$Status$P$" + query_main_status(hint));

   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_main_status() */

/**
 * This method prints out the expressions status.
 */
int do_expression_status(int hint) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Cannot do that!\n");
      return 0;
   }
   write("$P$Status$P$" + query_expression_status(hint));

   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
} /* do_expression_status() */

/**
 * This method pays off the cash deficit (if one exists).
 */
int do_approve_pay_deficit() {
   int cost;
   string place;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to pay off the deficit for " +
                      the_short() + ".\n");
      return 0;
   }

   if (query_owners_money() >= 0) {
      add_failed_mess("There is no deficit here to pay off.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   cost = -query_owners_money();
   if (this_player()->query_value_in(place) >= cost) {
      adjust_royalty(query_owner(), cost);

      this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
      add_succeeded_mess("$N pay$s off the deficit in " + the_short() + ".\n");
      return 1;

   }
   add_failed_mess("You do not have enough money to pay off the deficit "
                   "of " + MONEY_HAND->money_value_string(cost, place) +
                   ".\n");
   return 0;
} /* do_approve_pay_deficit() */

/**
 * This method allows the player to add a new category to the list.
 * @param category the new category name
 */
int do_category_description(string category, string desc) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }

   if (!query_controller()->is_valid_category(category)) {
      add_failed_mess("The category doesn't exists.\n");
      return 0;
   }

   set_category_description(category, desc);
   add_succeeded_mess("$N set$s the description of " + category + ".\n");
   return 1;
} /* do_add_new_category() */

/**
 * This method allows the player to add a new category to the list.
 * @param category the new category name
 */
int do_category_information(string category, string desc) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }

   if (!query_controller()->is_valid_category(category)) {
      add_failed_mess("The category doesn't exists.\n");
      return 0;
   }

   set_category_information(category, desc);
   add_succeeded_mess("$N set$s the description of " + category + ".\n");
   return 1;
} /* do_add_new_category() */

/**
 * This method allows the player to add a new category to the list.
 * @param category the new category name
 */
int do_add_new_category(string category) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }

   if (query_controller()->is_valid_category(category)) {
      add_failed_mess("The category already exists.\n");
      return 0;
   }

   add_shop_category(category);
   add_succeeded_mess("$N add$s a new category.\n");
   return 1;
} /* do_add_new_category() */

/**
 * This method allows the player to remove a category from the list.
 * @param category the category to remove
 */
int do_remove_category(string category) {
   object* obs;
   string old_cat;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove categories.\n");
      return 0;
   }

   old_cat = category;
   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + old_cat + " does not exist.\n");
      return 0;
   }

   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }


   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );

   if (sizeof(obs)) {
      add_failed_mess("The category '" + category + "' is not empty "
                     "and cannot be removed.\n");
      return 0;
   }

   write("Do you wish to remove the category " + category + " from " +
         the_short() + " (y/n)?");
   input_to("check_remove_category", 0, category);
   add_succeeded_mess(({ "", "$N removes a category from the shop.\n" }));
   return 1;
} /* do_remove_category() */

/**
 * This method allows the player to remove a category from the list.
 * @param category the category to rename
 * @param new_category the new name of a category
 */
int do_rename_category(string category, string new_category) {
   object* obs;
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to rename categories.\n");
      return 0;
   }

   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }

   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }

   add_shop_category(new_category);
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );

   if (sizeof(obs)) {
      foreach (ob in obs) {
         query_controller()->change_category_of_shop_object(ob, new_category);
      }
   }
   remove_shop_category(category);

   add_succeeded_mess("$N rename$s category " + category + " to " +
                      new_category + ".\n");
   return 1;
} /* do_rename_category() */

/**
 * This method is called into to check to see if we can remove the category.
 * @param answer their answer
 * @param category the category to remove
 */
protected void check_remove_category(string answer, string category) {
   class approval_obs approve;

   if (!strlen(answer) ||
       lower_case(answer)[0] != 'y') {
      write("Aborting deleting the category " + category + ".\n");
      return ;
   }

   remove_shop_category(category);
   write("Removed the shop category " + category + ".\n");
   foreach (approve in query_approval_list(0)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   foreach (approve in query_approval_list(1)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   event_save(this_object());
   return ;
} /* check_remove_category() */

/**
 * This method sets the default category for the place.
 * @param default_cat the default category
 */
int do_set_default_category(string default_cat) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set the default category.\n");
      return 0;
   }

   default_cat = query_real_category_name(default_cat);
   if (!default_cat ||
       !query_controller()->is_valid_category(default_cat)) {
      add_failed_mess("The category " + default_cat + " does not exist.\n");
      return 0;
   }

   set_default_category(default_cat);
   add_succeeded_mess("$N set$s the default category for " + the_short() +
                      ".\n");
   event_save(this_object());
   return 1;
} /* do_set_default_category() */

/**
 * This method lists the current categories and shows us which one is
 * currently the default.
 */
int do_list_categories() {
   string cat;
   string ret;

   ret = "";
   foreach (cat in query_controller()->query_categories()) {
      if (cat == query_default_category()) {
         ret += cat + " (default)\n";
      } else {
         ret += cat + "\n";
      }
   }

   write("$P$Category list$P$The current categories are:\n" + ret);
   add_succeeded_mess(({ "", "$N browses the categories.\n" }));
   return 1;
} /* do_list_categories() */

/**
 * This method shows the stats on all the sold items, the number and value
 * of each one sold.
 * @param type the type of sorting to do
 */
int do_stats_items(int type) {
   class shop_stats stat;
   string ret;
   string *bits;
   string place;
   string name;


   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }

   if (!sizeof(_sold_stats)) {
      add_failed_mess("Nothing has been sold in this transaction section "
                      "yet.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   switch (type) {
   case 1:
      bits = sort_array(keys(_sold_stats), (: _sold_stats[$1]->num_sold - _sold_stats[$2]->num_sold :));
      break;
   case 2:
      bits = sort_array(keys(_sold_stats), (: _sold_stats[$1]->value_sold - _sold_stats[$2]->value_sold :));
      break;
   case 3 :
      bits = sort_array(keys(_sold_stats), (: strcmp(((class shop_stats)_sold_stats[$1])->seller, ((class shop_stats)_sold_stats[$1])->seller) :));
      break;
   case 4 :
      bits = sort_array(keys(_sold_stats), (: strcmp(((class shop_stats)_sold_stats[$1])->name, ((class shop_stats)_sold_stats[$1])->name) :));
      break;
   default :
      bits = sort_array(keys(_sold_stats), 0);
      break;
   }

   ret = "Statistics for items sold since " + ctime(_stats_start) + ".\n";
   foreach (name in bits) {
      stat = _sold_stats[name];
      ret += name + ": " + stat->num_sold + " for " +
             MONEY_HAND->money_value_string(stat->value_sold, place) + ".\n";
   }

   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
} /* do_stats_items() */

#if USE_TRANSACTIONS
/**
 * This method shows a list of all the transactions that have occured in the
 * shop.
 */
int do_stats_transactions() {
   class shop_transaction bing;
   string ret;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }

   ret = "Statistics for transactions since " + ctime(_stats_start) + ".\n";
   foreach (bing in _transactions) {
      ret += "$I$5=" + query_transaction_string(bing) + "\n";
   }

   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
} /* do_stats_transactions() */
#endif

/**
 * This method shows stats about money and stuff in the shop.
 */
int do_stats_money() {
   string ret;
   int stock_value;
   string place;
   object ob;

   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "";
   ret += "\nCurrent money spent " +
          MONEY_HAND->money_value_string(_total_outgoing, place) +
          " and money made " +
          MONEY_HAND->money_value_string(_total_ingoing, place) + ".\n";

   foreach (ob in query_controller()->query_sell_list_obs()) {
      stock_value += ob->query_value();
   }

   ret += "The current stock value is " +
             MONEY_HAND->money_value_string(stock_value, place) +
          ".\n";

   ret += "\n";
   if (query_owners_money() > 0) {
      ret += "The owner current has a cash float (royalties) of " +
             MONEY_HAND->money_value_string(query_owners_money(), place) +
             ".\n";
   } else if (query_owners_money() < 0) {
      ret += "The owner current has a cash deficit of " +
             MONEY_HAND->money_value_string(-query_owners_money(), place) +
             ".\n";
   }

   write(ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
} /* do_stats_money() */

/** @ignore yes */
int do_helper_list() {
   write("$I$3=The current helpers are: " +
         query_multiple_short(_helpers) + ".\n");
   return 1;
} /* do_helper_list() */

/** @ignore yes */
int do_helper_add(string helper) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to mess with the helpers.\n");
      return 0;
   }

   helper = lower_case(helper);
   if (is_helper(helper)) {
      add_failed_mess(capitalize(helper) + " is already a helper.\n");
      return 0;
   }

   if (!PLAYER_HANDLER->test_user(helper)) {
      add_failed_mess(capitalize(helper) + " is not a player.\n");
      return 0;
   }

   _helpers += ({ helper });
   add_succeeded_mess("$N add$s " + capitalize(helper) +
                      " as a helper.\n");
   return 1;
} /* do_helper_add() */

/** @ignore yes */
int do_helper_remove(string helper) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to mess with the helpers.\n");
      return 0;
   }

   helper = lower_case(helper);
   if (!is_helper(helper)) {
      add_failed_mess(capitalize(helper) + " is not a helper to remove.\n");
      return 0;
   }

   _helpers -= ({ helper });
   add_succeeded_mess("$N remove$s " + capitalize(helper) +
                      " as a helper.\n");
   return 1;
} /* do_helper_remove() */


private object* variable_objects(string seller, int cost, object* obs) {
   return obs;
} /* function_object_type() */

private string variable_sale_name(string seller, int cost, object* ob, string name, string category) {
   if (name) {
      return lower_case(name);
   }
   return "";
} /* variable_sale_name() */

private string variable_sale_category(string seller, int cost, object* ob, string name, string category) {
   if (category) {
      return lower_case(category);
   }
   return "";
} /* variable_sale_category() */

private int variable_sale_cost(string seller, int cost, object* ob, string name, string category) {
   return cost;
} /* variable_sale_category() */

void init() {
   expression_util::init();
   craft_shop_category::init();
   add_command("waiting", "", (: do_list_approval(1) :));
   add_command("waiting", "unapproved", (: do_list_approval(0) :));
   add_command("reject", "<string'id'>",
               (: do_approve_reject($4[0], 0, -1) :));
   add_command("retrieve", "<string'id'>", (: do_return($4[0]) :) );
   add_command("return", "<string'id'>", (: do_return($4[0]) :) );
   add_command("value", "<indirect:object>",
               (: do_approve_auto_item_test($1) :));

   if (!is_helper(this_player()->query_name())) {
      return ;
   }

   add_command("approve", "<string'id'>", (: do_approve_item($4[0], 0) :));
   add_command("approve", "<string'id'> for <string'value'>",
               (: do_approve_item($4[0], $4[1]) :));
   add_command("reject", "<string'id'> position <number>",
               (: do_approve_reject($4[0], 0, $4[1]) :));
   add_command("reject", "<string'id'> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[1], -1) :));
   add_command("reject", "<string'id'> position <number> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[2], $4[1]) :));
   add_command("browse", "waiting <string'id'>",
               (: do_approve_browse($4[0]) :));
   add_command("checkout", "<string'id'>",
               (: do_approve_checkout($4[0]) :));
   add_command("checkin", "<indirect:object:me-here>",
               (: do_approve_checkin($1) :));

   if (!is_allowed(this_player()->query_name())) {
      return ;
   }

   add_command("set", "low approve cost <string'cost|disable'>",
               (: do_approve_auto_low($4[0]) :));
   add_command("auto", "add approve expression <string'condition'> cost <string'value'> as <string'list name'>",
               (: do_approve_auto_expression_add($4[0], $4[1],
                            PLAYER_CRAFT_SHOP_EXPR_ACCEPT, $4[2]) :));
   add_command("auto", "add deny expression <string'condition'>",
               (: do_approve_auto_expression_add($4[0], 0,
                            PLAYER_CRAFT_SHOP_EXPR_DENY, 0) :));
   add_command("auto", "remove expression <string'id'>",
               (: do_approve_auto_expression_remove($4[0]) :));
   add_command("markup", "<number'percentage'>",
               (: do_approve_percentage($4[0]) :));
   add_command("auto", "add name <string'name'> up to <string'value'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "remove name <string'name'>",
               (: do_approve_auto_item_remove($4[0]) :));
   add_command("auto", "remove object <indirect:object>",
               (: do_approve_auto_item_remove_object($1) :));
   add_command("set", "high queue cost <string'cost|disable'>",
               (: do_approve_auto_high($4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'>",
               (: do_approve_auto_high_deny($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'>",
               (: do_approve_limit($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'> for <string'player'>",
               (: do_approve_limit_person_items($4[1], $4[0]) :));
   add_command("set", "high queue cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value($4[1], $4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value_deny($4[1], $4[0]) :));
   add_command("approve", "limit remove <string'player'>",
               (: do_approve_limit_person_remove($4[0]) :));
   add_command("expressions", "",
               (: do_expression_status(0) :));
   add_command("expressions", "hints",
               (: do_expression_status(1) :));
   add_command("pay", "deficit",
               (: do_approve_pay_deficit() :));

   add_command("stats", "items by name", (: do_stats_items(4) :));
   add_command("stats", "items by seller", (: do_stats_items(3) :));
   add_command("stats", "items by number", (: do_stats_items(1) :));
   add_command("stats", "items by value", (: do_stats_items(2) :));
#if USE_TRANSACTIONS
   add_command("stats", "transactions", (: do_stats_transactions() :));
#endif
   add_command("stats", "money", (: do_stats_money() :));

   add_command("status", "<direct:object>", (: do_main_status(0) :));
   add_command("status", "<direct:object> hints", (: do_main_status(1) :));

   add_command("check", "sell <indirect:object>",
                (: do_check_sell($1) :));

   add_command("category", "list", (: do_list_categories() :));
   add_command("category", "default <string'category'>",
               (: do_set_default_category($4[0]) :));
   add_command("category", "add <string'category'>",
               (: do_add_new_category($4[0]) :));
   add_command("category", "description <string'category'> <string:quoted'description'>",
               (: do_category_description($4[0], $4[1]) :));
   add_command("category", "description <string'category'> remove",
               (: do_category_description($4[0], 0) :));
   add_command("category", "information <string'category'> <string:quoted'information'>",
               (: do_category_information($4[0], $4[1]) :));
   add_command("category", "information <string'category'> remove",
               (: do_category_information($4[0], 0) :));
   add_command("category", "remove <string'category'>",
               (: do_remove_category($4[0]) :));
   add_command("category", "rename <string'category'> to <string'category'>",
               (: do_rename_category($4[0], $4[1]) :));

   add_command("helper", "list",
               (: do_helper_list() :));
   add_command("helper", "add <string'helper'>",
               (: do_helper_add($4[0]) :));
   add_command("helper", "remove <string'helper'>",
               (: do_helper_remove($4[0]) :));

   add_command("buy", "force <indirect:object:" +
                      file_name(query_controller()->query_sell_list()) + ">",
                (: do_buy($1, 1) :));

} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/player_craft_shop_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/shop_event.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/shop_event.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629731   Available: 13577085
Inodes: Total: 5242880    Free: 4960136
1971 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/shop_event.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629731   Available: 13577085
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This inheritable allows broadcasting of shop events to whoever
 * wants to hear them.  The most useful case of this is broadcasting
 * to yourself so you can tell when shops do specific things.  The
 * shop event will always be called 'event_shop' + type.  For example
 * 'event_shop_failed_buy'.  Each specific
 * shop will setup different parameters to the shop event, except
 * the first three parameters will always be the event name,
 * shop object and the third is the player.
 * @author Pinkfish
 * @started Mon Oct 23 12:23:41 PDT 2000
 */

private nosave object* _events;

void create() {
   _events = ({ });
} /* create() */

/**
 * This method adds an object into the list to receive shop events.
 * @param observer the observer to add
 */
void add_shop_observer(object observer) {
   if (!_events) {
      _events = ({ });
   }
   if (member_array(observer, _events) == -1) {
      _events += ({ observer });
   }
} /* add_shop_observer() */

/**
 * This method removes an object from the list to recieve shop events.
 * @param observer the observer to remove
 */
void remove_shop_observer(object observer) {
   _events -= ({ observer });
} /* remove_shop_observer() */

/**
 * This method sends the event to all the people who have been set to
 * receive shop events.  The shop event function is called
 * event_shop(object shop, ...).
 * <p>
 * If this method returns 1 then the default messages are supressed.
 * @param type the type of the event
 * @param player the player in the event
 * @param args the arguements in the event
 * @return 1 to supress the default messages
 */
int broadcast_shop_event(string type, object player, mixed args ...) {
   debug_printf("Calling %O on %O\n", "event_shop_" + type, _events);
   if (sizeof(filter(call_other(_events, "event_shop_" + type, this_object(),
                                player, args ...),
                    (: $1 :)))) {
      return 1;
   }
   return 0;
} /* broadcast_shop_event() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/shop_event.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/open_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/open_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629730   Available: 13577084
Inodes: Total: 5242880    Free: 4960136
1632 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/open_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629730   Available: 13577084
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the basic inheritable to make things check for being
 * open.
 * @author Pinkfish
 * @started Mon Oct 23 12:04:18 PDT 2000
 */

private nosave function _open_func;

/**
 * This method sets the open function for the room.
 * @param func the open function
 * @see query_open_function()
 * @see check_open()
 * @example
 * // The pub is only open if the barman is alive.
 * set_open_function( (: ( barman ? 1 : 0 ) :) );
 * @example
 * void setup() {
 *    ...
 *    // Setup the open function.
 *    set_open_function( (: do_open_check :) );
 * } /\* setup() *\/
 *
 * int do_open_check( object player, int type ) {
 *    if( !barman ) {
 *       add_failed_mess( "There appears to be no barman here!\n" );
 *       return 2;
 *    }
 *    if( type <= PUB_DESSERT && !chef ) {
 *       add_failed_mess( "The chef isn't here at the moment.\n" );
 *       return 2;
 *    }
 *    return 0;
 * } /\* do_open_check() *\/
 */
void set_open_function(function func) {
   _open_func = func;
} /* set_open_function() */

/**
 * This method queries the open function for the room/.
 * @return the open function
 */
function query_open_function() {
   return _open_func;
} /* query_open_function() */

/**
 * This method checks to see if the shop is open.
 * @param player the player who we are checking to see if it is open for
 */
int is_open(object player, int type) {
   if (_open_func) {
      return evaluate(_open_func, player, type);
   }
   return 1;
} /* is_open() */


/**
 * @ignore yes
 * This method provides backwards compatibility.
 */
int test_open() {
    return is_open( this_player(), 0 );
} /* test_open() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/open_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/craft_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629730   Available: 13577084
Inodes: Total: 5242880    Free: 4960136
42582 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629730   Available: 13577084
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room will handle craft shop like things, where you sell stuff to
 * the store and it will sell it onto other players after taking
 * a margin.  This can be used for potions, pottery, swords, anything!
 * This has a few small hooks in here to handle categories in the
 * sell process.  Most of the category handling code is dealt with in
 * the category based craft shop.
 * @author Pinkfish
 * @started Thu Feb  5 15:39:57 CST 1998
 */
#include <money.h>
#include <shops/craft_shop.h>

inherit "/std/shops/inherit/open_shop";

private nosave object _controller;
private nosave string _save_dir_name;
private nosave function _allowed_to_sell;
private nosave function _when_sold_func;
private nosave int _max_sell_per_person;
private nosave int _cut;
private nosave int _minimum_cost;
private nosave function _extra_sell_check;
private nosave int _always_ask_price;
private nosave int _use_name;
private nosave int _no_royalty_commands;

int do_sell(object *obs);
void set_controller(string name);
int do_buy(object *obs, int force);
int do_delete(string id);
int do_browse(object *obs);
int do_change(object *obs, string str);
int do_change_name(object *obs, string str);
void set_allowed_to_sell(function f);
void set_minimum_cost(int i);
protected void sell_name(string name, object *sellable);
protected void sell_choice(string choice, object *sellable, string *names);
protected void determine_cost(string cost, string name, object *sellable);
protected void confirm_sale(string answer, int value, string name,
                            object *sellable, string category);
protected void confirm_sell_name_choice(string answer, string name,
                                        object *sellable);
protected void complete_sale(int value, string name, object *sellable, string category);
protected void do_confirm_sale(int value, string name, object *sellable);
void set_cut(int value);
int query_cut();
int check_open(object player, string command);
mixed query_property(string name);
string the_short();
string query_craft_shop_save_dir();

void create() {
   /* Always return true. */
   if (!_allowed_to_sell) {
      set_allowed_to_sell((: 1 :));
   }
   /* The default cut is 10% */
   if (!_cut) {
      set_cut(10);
   }
   /* Make it really 12 am pence. */
   if (!_minimum_cost) {
      set_minimum_cost(12 * 4);
   }
   if (!_controller && _save_dir_name) {
      set_controller("/std/shops/controllers/craft_shop_controller");
      _controller->load_it();
   }
} /* create() */

/**
 * This attempts to figure out how much the person is telling us the
 * item costs.
 * @param str the string to get the value of
 */
int value_from_string(string str, string place) {
   return MONEY_HAND->value_from_string(str, place);
} /* value_from_string() */

/**
 * This method handles the saving of the file to the disk.
 * @param type the type of file to save
 * @param value the value to save to it
 * @param fname the file name is optional and only used for data files
 */
protected void do_save_file(int type, mixed value, string fname) {
   string tmp, file;
   string dir;
   
   switch (type) {
   case CRAFT_SHOP_MAIN_SAVE_FILE :
     debug_printf("attempting to write main");
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                          "/save/ramdisk/");
     file = tmp + ".o";
#endif
     if(!file) {
       file = query_craft_shop_save_dir() + ".o";
     }
     
     debug_printf("writing main %s", file);
     tmp = save_variable(value);
     if (file_size(query_craft_shop_save_dir() + ".o") != -1) {
       unguarded( (: rename(query_craft_shop_save_dir() + ".o",
                            query_craft_shop_save_dir() + ".o.bak") :));
     }
     if(unguarded( (: write_file($(file), $(tmp), 1) :) )) {
       unguarded( (: rm($(file) + ".bak") :));
     } else {
       unguarded( (: rename($(file) + ".bak", $(file)) :));
     }
     break;
   case CRAFT_SHOP_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     //file = replace_string(query_craft_shop_save_dir() + "/" + fname, "/save/",
     //                     "/save/ramdisk/");
     dir = replace_string(query_craft_shop_save_dir(), "/save/", "/save/ramdisk/");
     if (file_size(dir) == -2) {
        file = dir + "/" + fname;
     }
#endif
     if(!file) {
       file = query_craft_shop_save_dir() + "/" + fname;
     }

     debug_printf("writing data %s", file);

     tmp = save_variable(value);
     if (!unguarded( (: write_file($(file), $(tmp), 1) :))) {
        debug_printf("failed to write data to %s", file);
     }
     break;
   case CRAFT_SHOP_REMOVE_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     file = replace_string(query_craft_shop_save_dir() + "/" + fname, "/save/",
                          "/save/ramdisk/");
     unguarded( (: rm($(file)) :) );
#endif     
     unguarded((: rm(query_craft_shop_save_dir() + "/" + $(fname)) :));

     break;
   default :
     printf("Unknown file type to write in %O, of %O\n", __FILE__, type);
     break;
   }
} /* do_save_file() */

/**
 * This method handles the reading of the file to the disk.
 * @param type the type of file to read
 * @param fname the file name is optional and only used for data files
 * @return the value read
 */
protected string do_read_file(int type, string fname) {
   string tmp, file;

   switch (type) {
   case CRAFT_SHOP_MAIN_SAVE_FILE :
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                          "/save/ramdisk/");
     if(unguarded((: file_size($(tmp) + ".o") :)) > 0) {
       file = tmp + ".o";
     }
#endif
     if(!file) {
       tmp = query_craft_shop_save_dir();
       if(unguarded((: file_size($(tmp) + ".o") :)) > 0) {
         file = tmp + ".o";
       }
       // Check for the backup.
       if(unguarded((: file_size($(tmp) + ".o.bak") :)) > 0) {
         file = tmp + ".o.bak";
       }
     }

     // No file exists yet.
     if (!file) {
        debug_printf("No file found at %s or %s\n", tmp + ".o", tmp + ".o.bak");
        return 0;
     }
     
     tmp = unguarded( (: read_file($(file)) :) ); 
     if(tmp)
       return restore_variable(tmp);
     return 0;
     
   case CRAFT_SHOP_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir() + "/" + fname,
                           "/save/", "/save/ramdisk/");
     if(unguarded((: file_size($(tmp)) :)) > 0)
       file = tmp;
#endif
     if(!file)
       file = query_craft_shop_save_dir() + "/" + fname;

     debug_printf("reading %s", file);
     tmp = unguarded( (: read_file($(file)) :) );
     if (tmp) {
       return restore_variable(tmp);
     }
     return 0;
   default :
     printf("Unknown file type to read in %O, of %O\n", __FILE__, type);
     break;
   }
} /* do_read_file() */

/**
 * This method allows you to cause the shop to load itself up.
 */
void reload_shop() {
   set_controller("/std/shops/controllers/craft_shop_controller");
   _controller->load_it();
} /* reload_shop() */

/**
 * This method sets the controller object for this shop.
 * @param controller the controller name as a string
 * @see query_controller()
 */
void set_controller(string name) {
   if (_controller) {
      _controller->dest_me();
   }
   _controller = clone_object(name);
   _controller->set_save_function((: do_save_file($1, $2, $3) :));
   _controller->set_load_function((: do_read_file($1, $2) :) );
} /* set_controller() */

/**
 * This method returns the current value of the controller.
 * @return the current controller
 * @see set_controller()
 */
object query_controller() {
   return _controller;
} /* query_controller() */

/**
 * This method sets the save file associated with the controller.  The save
 * file should actually be a directory, the name of the directory plus a
 * .o will be used for the save files.  The directory must exist or weird
 * errors will occur.
 * This should always be set in the setup function of the room.
 * @param fname the save file
 * @see set_controller()
 * @see query_save_dir()
 */
void set_save_dir(string fname) {
   _save_dir_name = fname;
} /* set_save_dir() */

/**
 * This method returns the file name of the save file.
 * @return the file name of the save file
 * @see set_save_dir()
 */
string query_craft_shop_save_dir() {
   return _save_dir_name;
} /* query_craft_shop_save_dir() */

/**
 * This method sets the function to use to check to see if the object
 * is able to be sold here or not.  The function will be called with
 * one parameter, that is the object being check for buyability.
 * @param func the function to check objects with
 * @see query_allowed_to_sell()
 */
void set_allowed_to_sell(function func) {
   _allowed_to_sell = func;
} /* set_allowed_to_sell() */

/**
 * This method returns the function used to check to see if an object
 * is able to be sold here or not.
 * @return func the function to use for checking
 * @see set_allowed_to_sell()
 */
function query_allowed_to_sell() {
   return _allowed_to_sell;
} /* query_allowed_to_sell() */

/**
 * This method sets the maxium allowed number of objects to be sold
 * by each person into the shop.
 * @param num the maximum number to be sold
 * @see query_max_sell_per_person()
 */
void set_max_sell_per_person(int num) {
   _max_sell_per_person = num;
} /* set_max_sell_per_person() */

/**
 * This methods returns the maximum number of allowed objects to be
 * sold by each person into the shop.
 * @return the maximum number to be sold
 * @see set_max_sell_per_person()
 */
int query_max_sell_per_person() {
   return _max_sell_per_person;
} /* query_max_sell_per_person() */

/**
 * This method sets the flag which makes the shop always ask for a price
 * when it attempts to save something.
 * @param ask_price the flag
 */
void set_always_ask_price(int ask_price) {
   _always_ask_price = ask_price;
} /* set_always_ask_price() */

/**
 * This method returns the flag on this object that tells us if the shop
 * will always ask for a price
 * @return the flag
 */
int query_always_ask_price() {
   return _always_ask_price;
} /* query_always_ask_price() */

/**
 * This method sets the flag which makes the shop use the name of the
 * item as the sell type always.
 * @param flag 1 to make it force the use name ability
 */
void set_use_name(int flag) {
   _use_name = flag;
} /* set_always_ask_price() */

/**
 * This method returns the flag for the use name of this shop.
 * @return 1 if the name is used, 0 if not
 */
int query_use_name() {
   return _use_name;
} /* query_always_ask_price() */

/**
 * This method will return the maximum price this item is allowed to
 * be sold for.  This will return 0 if there is no maximum price
 * @return 0 if there is no maximum price, or maximum price
 */
int query_maximum_sale_value(string person, object *obs) {
   return 0;
} /* query_maximum_sale_value() */

/**
 * This method returns any extra information about prices that the
 * shop wants to display before entering a cost.  This can be
 * overridden in higher inherits to control this more effectively.
 * @return an extra string to print
 */
string query_extra_price_information(string person, object *obs) {
   return "";
} /* query_extra_price_information() */

/**
 * @ignore yes
 * Sets this room as a shop, to interface with the shoplift command.
 * @return always returns 1
 */
int query_shop() {
   return 1;
} /* query_shop() */

/**
 * @ignore yes
 * This method returns the list of things that can be shoplifted from this
 * shop based on the input list.
 */
object *query_shop_lift_items(string str, object player) {
   object *stuff;
   object *pk_ok;
   object ob;

   stuff = match_objects_for_existence(str, ({ _controller->query_sell_list() }));
   pk_ok = ({ });
   foreach (ob in stuff) {
      if (!pk_check(_controller->query_owner_of_shop_object(ob),
                      player, 1)) {
         pk_ok += ({ ob });
      }
   }
   if (sizeof(pk_ok) != sizeof(stuff)) {
      player->add_failed_mess(previous_object(),
                      "You cannot shoplift $I since you cannot "
                      "shoplift from non-player killers.\n", stuff);
   }
   return pk_ok;
} /* query_shop_lift_items() */

/**
 * This method is called when something is bought and tells us how much
 * has been spent.
 * @param value of the the items sold
 * @param obs the objects bought
 * @param player who bought them
 * @param sellers the people whose items were bought
 * @param names the names of the items bought
 * @param cats the categories of the items bought
 * @param values the values of each item
 */
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
} /* inform_of_buy() */

/**
 * @ignore yes
 * This place is always marked as 'no steal' for now.
 */
int query_no_steal() {
   return 1;
} /* query_no_steal() */

/**
 * This allows the system to override this for player run shops so the
 * owner can discount peoples items.
 * @param ob the object to test
 * @return 1 if they can modify the item, 0 if not
 */
int is_able_to_change(object ob) {
   return _controller->query_owner_of_shop_object(ob) ==
       this_player()->query_name();
} /* is_able_change_ob() */

/**
 * This method checks to see if this item is allowed to be sold in this shop.
 * It assumes it is called from a add_command() method and sets up fail
 * messages accordingly.
 * @param obs the objects to check
 * @param name the name of the person doing the selling
 * @param sellable_names the names of the items to sell
 */
int is_allowed_to_sell(object* obs, string name, string *sellable_names) {
   if ((sizeof(sellable_names)+sizeof(obs)) > query_max_sell_per_person() &&
       query_max_sell_per_person()) {
      add_failed_mess("Cannot sell $I, since you already have " +
                      number_as_string(sizeof(sellable_names)) +
                      " items listed with a maximum of " +
                      number_as_string(query_max_sell_per_person()) +
                      ".\n", obs);
      return 0;
   }
   return 1;
} /* is_allowed_to_sell() */

/** @ignore yes */
void init() {
   string storeroom;

   add_command("sell", "<indirect:object:me>");
   //add_command("sell", "<indirect:object:me> as <string'item id'>",
   //             (: do_sell_id($0, $4[1]) :));
   add_command("list", "");
   if (query_controller()) {
      storeroom = file_name(_controller->query_sell_list());
      add_command("buy", "<indirect:object:" + storeroom + ">",
                  (: do_buy($1, 0) :));
      add_command("browse", "<indirect:object:" + storeroom + ">",
                  (: do_browse($1) :));
      add_command("change", "price of <indirect:object:" + storeroom +
                            "> to <string>", (: do_change($1, $4[1]) :));
      add_command("change", "name of <indirect:object:" + storeroom +
                            "> to <string>", (: do_change_name($1, $4[1]) :));
   }
   if (!_no_royalty_commands) {
      add_command("collect", "royalties");
      add_command("royalties", "");
   }
   add_command("delete", "<string'sell id'>",
               (: do_delete($4[0]) :));
} /* init() */

/**
 * This method tries to sell an object as a name that already exists in
 * the shop.
 * @param obs the objects to sell
 * @param id the id to sell them as
 * @see do_sell()
 * @see do_list()
 * @see do_buy()
 */
int do_sell_id(object* obs, string id, int force) {
   object *sellable;
   object *cannot;
   object *worn;
   string name;
   string *sellable_names;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "sell")) {
      return 0;
   }

   sellable = filter(obs, query_allowed_to_sell());
   if (!sizeof(sellable)) {
      add_failed_mess("This shop does not deal in $I.\n", obs);
      return 0;
   }

   worn = this_player()->query_holding() + this_player()->query_armours();
   cannot = filter(sellable, (: member_array($1, $2) != -1 :), worn);
   if (sizeof(cannot)) {
       sellable -= cannot;
       tell_object(this_player(), "You decide not to sell " +
         query_multiple_short(cannot, "the") + ", because "
         "you are wearing or holding $V$0=it,them$V$.\n");
      if (!sizeof(sellable))  return 0;
   }

   name = this_player()->query_name();
   if (!is_allowed_to_sell(sellable, name, sellable_names)) {
      return 0;
   }


   if (query_cut() != 100) {
      write("Selling an item to this shop does not automatically give you the "
            "money.  You will get a cut of " + (100 - query_cut()) +
            "% of the sale price once the item has been sold by the shop.\n");   }

   //
   // Ok, find the id and fill in all the needed bits.
   //

} /* do_sell_id() */

/**
 * This method sells an object into the craft shop.
 * @param obs the objects to sell
 * @return 1 on success, 0 on failure
 * @see do_list()
 * @see do_buy()
 * @see do_sell_id()
 */
int do_sell(object *obs) {
   object *sellable;
   object *cannot;
   object *worn;
   string name;
   string *sellable_names;
   int i;
   int cost;
   string place;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "sell")) {
      return 0;
   }

   sellable = filter(obs, query_allowed_to_sell());
   if (!sizeof(sellable)) {
      add_failed_mess("This shop does not deal in $I.\n", obs);
      return 0;
   }

   worn = this_player()->query_holding() + this_player()->query_armours();
   cannot = filter(sellable, (: member_array($1, $2) != -1 :), worn);
   if (sizeof(cannot)) {
       sellable -= cannot;
       tell_object(this_player(), "You decide not to sell " +
         query_multiple_short(cannot, "the") + ", because "
         "you are wearing or holding $V$0=it,them$V$.\n");
      if (!sizeof(sellable))  return 0;
   }

   name = this_player()->query_name();
   if (!is_allowed_to_sell(sellable, name, sellable_names)) {
      return 0;
   }


   if (query_cut() != 100) {
      write("Selling an item to this shop does not automatically give you the "
            "money.  You will get a cut of " + (100 - query_cut()) +
            "% of the sale price once the item has been sold by the shop.\n");
   }

   if (_use_name) {
      // We use the name of the item.
      sell_name(query_multiple_short(sellable, 0, 1), sellable);
      add_succeeded_mess(({ "", "$N starts to sell $I to the shop.\n" }),
                         sellable);
      return 1;
   }

   obs->set_no_join();
   sellable_names = _controller->query_owner_sellables(name);
   sellable_names = uniq_array(sellable_names);
   if (!sizeof(sellable_names)) {
      write("You are not currently selling any items.  What item name "
            "would you like to list " + query_multiple_short(sellable) +
            " under?  (Blank line to quit)\nList name: ");
      input_to((: sell_name :), 0, sellable);
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      write("You currently have the following listed for sale:\n");
      for (i = 0; i < sizeof(sellable_names); i++) {
         cost = _controller->query_list_object_cost(sellable_names[i],
                                   this_player()->query_name());
         write(sprintf("  %c) %s (%s)\n", 'a' + i, sellable_names[i],
                       MONEY_HAND->money_value_string(cost, place)));
      }
      write("Select the letter of the choice to add to the item, or type "
            "'create' to create a new listing name.\n"
            "Your choice ([a-" + sprintf("%c", 'a' + sizeof(sellable_names) -1) +
            "],create) ? ");
      input_to((: sell_choice :), 0, sellable, sellable_names);
   }
   add_succeeded_mess(({ "", "$N starts to sell $I to the shop.\n" }),
                      sellable);
   return 1;
} /* do_sell() */


/**
 * This method makes sure a name is not too long and contains
 * no colour codes.
 * @param name the name to list the object as
 * @return 0 if name is unacceptable, 1 if it's OK
 */
protected int check_sell_name( string name ) {

   if (strlen(name) > CRAFT_SHOP_MAX_NAME_LENGTH) {
      write("Sorry, that name is too long.  It can be a maximum of " +
            CRAFT_SHOP_MAX_NAME_LENGTH + " characters.\n");
      return 0;
   }

   if (strsrch(name, "%^") != -1) {
      write("Sorry, you cannot use colour sequences in names.\n");
      return 0;
   }

   // Name was OK
   return 1;

} // check_sell_name()

/**
 * This method determines the name to list the object under.  This is
 * called when a new name is used.
 * @param name the name to list the object as
 * @param sellable the list of sellable objects
 */
protected void sell_name(string name, object *sellable) {
   if (name == "" || name == 0) {
      write("Ok, cancelling the sale of " + query_multiple_short(sellable) +
            ".\n");
      return ;
   }

   if ( !check_sell_name( name ) ) {
      input_to((: sell_name :), 0, sellable);
      write("What name would you like to list " +
            query_multiple_short(sellable) + " under? ");
      return;
   }

   write("You wish to sell " + query_multiple_short(sellable) +
         " as '" + name + "' (y/n)? ");
   input_to((: confirm_sell_name_choice :), 0, name, sellable);

} /* sell_name() */


/**
 * This method is used to confirm the choice of name to use when
 * selling the object.
 * @param answer the confirmation choice
 * @param name the name to sell it as
 * @param sellable the list of objects to sell
 */
protected void confirm_sell_name_choice(string answer, string name,
                                        object *sellable) {
   answer = lower_case(answer);
   if (strlen(answer) > 0 && ( answer[0] == 'n' || answer[0] == 'q' ) ) {
      write("Ok, cancelling the sale of " + query_multiple_short(sellable) +
            ".\n");
      return ;
   }
   if (!strlen(answer) || answer[0] != 'y') {
      write("Unknown selection.\n");
      write("You wish to sell " + query_multiple_short(sellable) +
            " as '" + name + "' (y/n)? ");
      input_to( (: confirm_sell_name_choice :), 0, name, sellable);
      return ;
   }
   write(query_extra_price_information(this_player()->query_name(), sellable));
   write("How much money do you wish to sell the item '" + name + "' for? ");
   input_to((: determine_cost :), 0, name, sellable);
} /* confirm_sell_name_choice() */

/**
 * This method is used when there is a list of object already listed.  It
 * will check to see if the choice entered is valid and then use that
 * name when selling the object if it is.
 * @param choice the selected choice
 * @param sellable the array of sellable objects
 * @param names the names of choices for name
 */
protected void sell_choice(string answer, object *sellables, string *names) {
   int cost;
   string place;
   int pos;

   if (sizeof(names) >= 17) {
      if (answer == "" || answer[0..1] == "qu") {
         write("Ok, cancelling the sale of " + query_multiple_short(sellables) +
             ".\n");
         return 0;
      }
   } else if (answer == "" || answer[0] == 'q') {
      write("Ok, cancelling the sale of " + query_multiple_short(sellables) +
            ".\n");
      return ;
   }
   answer = lower_case(answer);
   if (answer == "create") {
      write("Please enter the name you wish to list " +
            query_multiple_short(sellables) + " as.\nList name: ");
      input_to((: sell_name :), 0, sellables);
      return ;
   }
   if (strlen(answer) > 1 ||
       (answer[0] < 'a' || answer[0] >= 'a' + sizeof(names))) {
      write(sprintf("Your response must be between 'a' and '%c' or "
                    "'create'.\nChoice? ", 'a' + sizeof(names) - 1));
      input_to((: sell_choice :), 0, sellables, names);
      return ;
   }
   pos = answer[0] - 'a';
   cost = _controller->query_list_object_cost(names[pos],
                                              this_player()->query_name());
   if (!cost || _always_ask_price) {
      /* Hmm, the cost is not working, we need to set a cost as well. */
      write("How much money do you wish to list the item '" + names[pos] +
            "' for? ");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellables));
      input_to((: determine_cost :), 0, names[pos], sellables);
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      do_confirm_sale(cost, names[pos], sellables);
   }
} /* sell_choice() */

/**
 * This method figured out the cost of the item based on the value they
 * type in.
 * @param cost the cost of the item
 * @param name the name of the item
 * @param sellable the array of objects to sell
 */
protected void determine_cost(string cost, string name, object *sellable) {
   int max;
   int value;
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(cost, place);
   if (value < _minimum_cost) {
      if (!strlen(cost) ||
          lower_case(cost)[0] == 'q') {
         write("Aborting.\n");
         return ;
      }
      write("You must list your item as costing more than " +
            MONEY_HAND->money_value_string(_minimum_cost, place) + ".\n");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellable));
      write("What do you wish to list " + name + " for? ");
      input_to("determine_cost", 0, name, sellable);
      return ;
   }

   max = query_maximum_sale_value(this_player()->query_name(), sellable);
   if (value > max && max) {
      write("You must list your item as costing less than " +
            MONEY_HAND->money_value_string(max, place) + ".\n");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellable));
      write("What do you wish to list " + name + " for? ");
      input_to("determine_cost", 0, name, sellable);
      return ;
   }

   do_confirm_sale(value, name, sellable);
} /* determine_cost() */

private void confirm_sale_question(int value,
                                   string name,
                                   object *sellables,
                                   string category) {
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   write("Confirming your sale of " + query_multiple_short(sellables) +
         " as '" + name +
         "' " + (category?"in category " + category + " ":"") +
         "for " + MONEY_HAND->money_value_string(value, place) + " (y/n)? ");
   input_to((: confirm_sale :), 0, value, name, sellables, category);
} /* confirm_sale_question() */

/**
 * This method will ask the person to confirm the sale.  It will check
 * the extra_sell_check function and then call the extra sale thing.
 * @param value the value of the thing being sold
 * @param name the name the thing is sold for
 * @param sellables the things to sell
 */
protected void do_confirm_sale(int value, string name, object *sellables) {
   if (_extra_sell_check) {
      evaluate(_extra_sell_check,
               (: confirm_sale_question :),
               value, name, sellables);
   } else {
      confirm_sale_question(value, name, sellables, 0);
   }
} /* do_confirm_sale() */

/**
 * This method confirms the sale after the cost and name have been
 * determined.
 * @param answer the answer to confirm with
 * @param value the value of the object
 * @param name the name of the object
 * @param sellable the list of sellable objects
 * @param category the category of the object, 0 if none
 */
protected void confirm_sale(string answer, int value, string name,
                            object *sellable,
                            string category) {
   if (answer == "" || answer[0] == 'q' || answer[0] == 'Q' ||
       answer[0] == 'n' || answer[0] == 'N') {
      write("Ok, aborting sale of " + query_multiple_short(sellable) + ".\n");
      return 0;
   }
   if (answer[0] != 'y' && answer[0] != 'Y') {
      write("Please answer yes or no.\n");
      confirm_sale_question(value, name, sellable, category);
      return 0;
   }
   complete_sale(value, name, sellable, category);
} /* confirm_sale() */

/**
 * This method is called to complete the sale completely.  It is split
 * up into a second function to allow the extra sell stuff
 * to work neatly.
 * @param value the value of the objects to sell
 * @param name the list name
 * @param sellable the list of objects to sell
 * @param category the category of the object, 0 if none
 */
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   object *bought;
   string place;
   object ob;

   /* First run them through the when sold function. */
   if (_when_sold_func) {
      foreach (ob in sellable) {
         evaluate(_when_sold_func, ob);
      }
   }
   bought = _controller->buy_objects(sellable, name, value,
                                   this_player()->query_cap_name(), category);
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (sizeof(bought)) {
      write("Sold " + query_multiple_short(bought) + ", listed as '" +
            name + "' " + (category?"in category " + category + " ":"") +
            "for " + MONEY_HAND->money_value_string(value, place) +
            ".\nYou will need to come back later to pick up your royalties "
            "for the sale.\n");
      say(this_player()->query_cap_name() + " sold " +
          query_multiple_short(bought) + " to " + the_short() + ".\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + ".\n");
   }
} /* confirm_sale() */

/**
 * This method will list the current set of objects which are
 * available to buy.
 * @return 1 on success, 0 on failure
 * @see do_sell()
 * @see do_buy()
 */
int do_list() {
   string place;
   object *obs;
   object ob;
   mixed *stuff;
   string ret;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "list")) {
      return 0;
   }

   /* Do a list of the wombles... */
   obs = _controller->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   stuff = unique_array(obs, (: _controller->query_id_of_shop_object($1) :) );
   stuff = sort_array(stuff, (:
                strcmp(_controller->query_id_of_shop_object($1[0]),
                       _controller->query_id_of_shop_object($2[0])) :) );
   ret = "";
   foreach (obs in stuff) {
      ob = obs[0];
      ret += "$I$9=$C$" + _controller->query_id_of_shop_object(ob) +
            ") $C$" + ob->short() + " for " +
            MONEY_HAND->money_value_string(ob->query_value(), place) + "; " +
            query_num(sizeof(obs)) + " left.\n";
   }
   write("$P$Shop list$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
} /* do_list() */

/**
 * This method will attempt to buy an object from the shops inventory.
 * @param str the string to match an object with
 * @return 1 on success, 0 on failure
 * @see do_sell()
 * @see do_list()
 */
int do_buy(object *obs, int force) {
   int value;
   string place;
   int player_money;
   object *bought;
   string *sellers;
   string *names;
   string *cats;
   int *values;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "buy")) {
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   player_money = this_player()->query_value_in(place);
   value = _controller->value_of_objects(obs);
   if (value > player_money) {
      add_failed_mess("You cannot buy $I as "+
                      ( sizeof( obs ) > 1 ? "they cost ":"it costs " )+
                      MONEY_HAND->money_value_string(value, place) +
                      " and you do not have that much money.\n", obs );
      return 0;
   }

   sellers = map(obs, (: _controller->query_owner_of_shop_object($1) :));
   names = map(obs, (: _controller->query_name_of_shop_object($1) :));
   cats = map(obs, (: _controller->query_category_of_shop_object($1) :));
   values = map(obs, (: $1->query_value() :));

   bought = _controller->sell_objects(obs, place, this_player(),
                                     query_cut(), force, ref value);
   if (!sizeof(bought)) {
      if (sizeof(bought) > 1) {
         add_failed_mess("Cannot move any of $I into your inventory, nothing "
                         "bought.\n", obs);
      } else {
         add_failed_mess("Unable to find any objects to buy, the shop "
                         "seems to have some stock problems.\n");
      }
      return 0;
   }
   inform_of_buy(value, bought, this_player(), sellers, names, cats, values);
   add_succeeded_mess(({ "You buy $I for " +
                       MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N buys $I.\n" }), bought);
   return 1;
} /* do_buy() */


/**
 * This method will delete a list entry without the owner getting paid.
 * @param str the string to match an object with
 * @return 1 on success, 0 on failure
 */
int do_delete(string id ) {

   if( !this_player()->query_director() ) {
      add_failed_mess( "This command is reserved for directors.\n", ({ }) );
      return 0;
   }

   if( !id || id == "" ) {
      add_failed_mess( "You have to choose a valid sell id.\n", ({ }) );
      return 0;
   }

   _controller->delete_objects(id);

   add_succeeded_mess( "$N $V some things.\n", ({ }) );

   return 1;
} /* do_delete() */


/**
 * This function browses through the current selected list of items.
 * @param obs the items to browse through
 */
int do_browse(object *obs) {
   object *real_obs;
   object ob;
   string mess;
   string read;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "browse")) {
      return 0;
   }

   if (sizeof(obs) > 10) {
      add_failed_mess("You cannot browse more than 10 things at once.\n");
      return 0;
   }

   real_obs = _controller->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse$P$";
   foreach (ob in real_obs) {
      mess += ob->the_short() + ":\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         mess += "You read " +
                 replace(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }
   real_obs->move("/room/rubbish");
   add_succeeded_mess(({ mess, "$N $V $I.\n" }), obs);
   return 1;
} /* do_browse() */

/**
 * This function changes the list price of an object.
 * @param obs the object to change the list price of
 * @param change the value to change the list price to
 */
int do_change(object *obs, string change) {
   object *frog;
   int value;
   string place;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "change")) {
      return 0;
   }

   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the value of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }

   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = value_from_string(change, place);
   if (value < _minimum_cost) {
      add_failed_mess("You cannot set $I to a value less than " +
                 MONEY_HAND->money_value_string(_minimum_cost, place) + ".\n",
                 obs);
      return 0;
   }

   _controller->change_value_of_shop_object(obs[0], value);
   add_succeeded_mess( ({ "You change the value of $I to " +
         MONEY_HAND->money_value_string(value, place) + ".\n",
         "$N changes the value of $I.\n" }), obs[0..0]);
   return 1;
} /* do_change() */

/**
 * This function changes the list name of an object.
 * @param obs the object to change the list name of
 * @param new_name the value to change the list name to
 */
int do_change_name(object *obs, string new_name) {
   object *frog;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "change")) {
      return 0;
   }

   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the value of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }

   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }

   if( !check_sell_name( new_name ) ) {
      add_failed_mess( "Try another name.\n", ({ }) );
      return 0;
   }

   if (_controller->change_name_of_shop_object(obs[0], new_name,
                               _controller->query_dont_use_name())) {
      add_succeeded_mess(({ "You change the name of $I to " +
                               new_name + ".\n",
                               "$N changes the name of $I.\n" }),
                         ({ obs[0] }) );
   } else {
      add_failed_mess("The name " + new_name + " is already in use.\n", obs);
   }

   return 1;
} /* do_change_name() */

/**
 * This method collects any royalties the current player is owed.
 * @return 1 on succes, 0 on failure
 */
int do_collect() {
   string name;
   string place;
   int value;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "collect")) {
      return 0;
   }

   name = this_player()->query_name();
   value = _controller->query_royalty(name);
   if (!value) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }

   if (value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }


   place = query_property("place");
   if (!place) {
      place = "default";
   }
   _controller->pay_out_royalty(name, place);
   log_file(__FILE__ + ".log",
            name + " collects " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties.\n");
   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
} /* do_collect() */

/**
 * This method shows any royalties that you might be able to collect.
 * @return 1 on succes, 0 on failure
 */
int do_royalties() {
   string name;
   string place;
   int value;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "royalties")) {
      return 0;
   }

   name = this_player()->query_name();
   value = _controller->query_royalty(name);
   if (!value) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }

   if (value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   add_succeeded_mess(({ "You have " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties currently.\n",
                      "$N checks $p royalties.\n" }));
   return 1;
} /* do_royalites() */

/**
 * This method sets the cut for the object.
 * @param new_cut the new cut of the object
 * @see query_cut()
 */
void set_cut(int new_cut) {
   _cut = new_cut;
} /* set_cut() */

/**
 * This method queries the current cut defined for this shop.
 * @return the current cut for the shop
 * @see set_cut()
 */
int query_cut() {
   return _cut;
} /* query_cut() */

/**
 * This method sets the minimum allowed cost for the item in the
 * shop inventory.
 * @param cost the minimum cost
 * @see query_minimum_cost()
 */
void set_minimum_cost(int cost) {
   _minimum_cost = cost;
} /* set_minimum_cost() */

/**
 * This method returns the minimum allowed cost for an item in the
 * shop inventory.
 * @see set_minimum_cost()
 */
int query_minimum_cost() {
   return _minimum_cost;
} /* query_minimum_cost() */

/**
 * This method sets the function to be called on all the objects when
 * they are sold.  For instance this can be used to close all books
 * etc.
 * @param func the function to use
 * @example
 * // Close the book when it is sold.
 * set_when_sold_function( (: $1->set_open_page(0) :) );
 */
void set_when_sold_function(function func) {
   _when_sold_func = func;
} /* set_when_sold_function() */

/**
 * This method returns the when sold function.
 * @return the when sold function
 * @see set_when_sold_function()
 */
function query_when_sold_function() {
   return _when_sold_func;
} /* query_when_sold_function() */

/**
 * This method checks to see if the shop is open or not.  It will setup the
 * default fail message if this is what is needed.
 * @param player
 * @param command the command to check for
 * @see set_open_function()
 */
int check_open(object player, string type) {
   if (!is_open(player, 0)) {
      add_failed_mess("The shop is not open.\n");
      return 0;
   }
   return 1;
} /* check_open() */

/**
 * This method sets the extra sell function for the shop.  The extra sell
 * function is called after the sell process is almost finished.  It can
 * check for extra things needed in the sell process, like which page of
 * the book to browse.
 * @param func the extra sell function
 * @see query_extra_sell_check()
 * @see complete_sell()
 */
void set_extra_sell_check(function func) {
   _extra_sell_check = func;
} /* set_extra_sell_check() */

/**
 * This method returns the extra sell check function.
 * @return the extra sell check function
 * @see set_extra_sell_check()
 */
function query_extra_sell_check() {
   return _extra_sell_check;
} /* query_extra_sell_check() */

/**
 * This method sets the flag that removes the royalty commands from the
 * shop, if the royalty stuff is be handled somewhere else.
 * @param flag the flag to set
 */
void set_no_royalty_commands(int flag) {
   _no_royalty_commands = flag;
} /* set_no_royalty_commands() */

/**
 * This method returns the flagt the removes the royalty commands from the
 * shop.
 * @return the royalty command flag
 */
int query_no_royalty_commands() {
   return _no_royalty_commands;
} /* query_no_royalty_commands() */

void dest_me() {
  if(_controller) {
     _controller->dest_me();
  }
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/craft_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/bank_master.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629719   Available: 13577073
Inodes: Total: 5242880    Free: 4960136
3367 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629719   Available: 13577073
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the bank's main branch inherit.  Allows people to trade in
 * credit notes for the money, or deposit credit notes.
 * @author Pinkfish
 * @started Fri Jun 15 01:05:55 PDT 2001
 */
inherit "/std/shops/inherit/bank_base";
#include <money.h>

int query_float();

/**
 * Processes the specified credit objects to figure out if they need to deposit
 * or withdraw money.
 * @param obs the objects to process
 * @return 1 on success, 0 on failure
 */
int do_process(object *obs) {
   object ob;
   int amount;
   int found;
   object* not_credit;
   object* not_valid;
   string place;

   place = query_money_place();

   not_valid = ({ });
   not_credit = ({ });
   foreach (ob in obs) {
      if (ob->query_credit_note() ||
          ob->query_bank_name() != query_bank_name()) {
         not_credit += ({ ob });
         obs -= ({ ob });
      } else if (ob->is_valid_note()) {
         amount += ob->query_credit_balance();
      } else {
         not_valid += ({ ob });
         obs -= ({ ob });
      }
   }

   if (!sizeof(obs)) {
      if (sizeof(not_credit)) {
         add_failed_mess("None of $I are credit notes.\n", not_credit);
      }
      if (sizeof(not_valid)) {
         add_failed_mess("None of $I are valid credit notes.\n", not_valid);
      }
      return 0;
   }

   foreach (ob in obs) {
      amount = ob->query_amount();
      if (amount > 0) {
         // This means they are depositing money (overall).
         if (this_player()->query_value_in(query_money_place()) < amount) {
            add_failed_mess("You do not have the needed " +
                            MONEY_HAND->money_value_string(amount, place) +
                            " to deposit.\n");
            continue;
         }
         else if (ob->do_process()) {
            this_player()->pay_money(MONEY_HAND->create_money_array(amount,
                   place), place);
            // Tell them all they have been processed.
            add_succeeded_mess("$N $V depositing " +
                               MONEY_HAND->money_value_string(amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      } else if (amount < 0) {
         // They are withdrawing money (overall).
         //if (query_float() < -amount) {
            //add_failed_mess("This place does not have enough money to trade in your "
                            //"slips for " +
                            //MONEY_HAND->money_value_string(-amount, place) +
                            //".\n");
         //}
         if (ob->do_process()) {
            this_player()->adjust_money(MONEY_HAND->create_money_array(-amount, place));
            add_succeeded_mess("$N $V withdrawing " +
                               MONEY_HAND->money_value_string(-amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      }
      ob->move("/room/rubbish");
   }
   return found;
} /* do_process() */

void init() {
   ::init();
   add_command("process", "<indirect:object>");
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/bank_master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/store_close.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/store_close.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629718   Available: 13577072
Inodes: Total: 5242880    Free: 4960136
5960 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/store_close.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629718   Available: 13577072
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:01.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The inherit file for store closings. This should be inherited along with 
 *  /std/shop or /std/item-shop. Or any other room of your choice, really.
 *  @author Rodion
 */

#include <weather.h>
#include <climate.h>
#include <am_time.h>

void open_up();
void close_up();
private string _keeper;
private string *_outside_rooms;
private string *_exits;
private string _burglar;
private string _file;
private int _flag;
private int _open;
private int _closed;
private nosave object _keeper_ob;

/** @ignore */
void event_weather(int whats_changed){
   if(whats_changed >= 8){
      if (_flag) {
         call_out("night_time_check", 1);
      } else {
         call_out("day_time_check", 1);
      }
   }
} /* event_weather() */

/** @ignore */
protected void night_time_check(){
   int bing;

   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 12 && bing < 23 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   }
   if (bing > 0 && bing < 12 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
} /* night_time_check() */

/** @ignore */
protected void day_time_check(){
   int bing;

   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 0 && bing < 12 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   } 
   if (bing > 12 && bing < 23 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
} /* day_time_check() */


/**
 * This function sets up the closing code for stores.  This allows you to 
 *  close and lock up the place, update external rooms, send the shopkeepers 
 *  home, and catch burglars who try to sneak in.
 *  <p>
 *  If the "night" flag is 1, the store will close at night. If it's 0, the 
 * store will close during the day.
 * <p>
 * The shopkeeper name should be the string filename of the shopkeeper. 
 * This can be set to "none" for no shopkeeper (regular 
 * event_person_say stuff will be used to simulate it.)
 * <p>
 * *outside is an array of exit, room path pairs that connect to the shop.  
 * That is, if you moved east to get into the shop, the exit string will be 
 * "east", "/path/of/room/we/got/here/from".  THIS IS REQUIRED, so that 
 * players will be moved to the right place.
 * <p>
 * The burglar_func parameter is the name of a function that will be called 
 * when someone 
 * enters the shop after it is closed.  It will be called with the argument 
 * object ob, where ob is the person who entered.  For no burglar handling, 
 * this argument can be 0.
 *  
 * @param night Whether the store closes during the night or day.
 * @param shopkeeper The file name of the shopkeeper for the store.
 * @param outside The exit, room pairs corresponding to outside rooms.
 * @param burglar_func The function called when store is burgled.
 * @example 
 *    set_night_close(1, "/d/sur/chars/bob", ({"east", PATH+"flibble_room"}), "catch_thief");
 *    ...
 *    set_night_close(0, "none", ({"up", "/d/ram/Snorkle/wibble_room"}));
 */
void set_night_close(int night, string shopkeeper, string *outside, 
    string burglar_func){
   int i;

   _flag = night;
   WEATHER->weather_notify( this_object(), NOTIFY_DAY );
   _keeper = _file = shopkeeper;
   
   //check to see if outside exists.
   if (sizeof(outside) && !(sizeof(outside)%2)) {
      _exits = allocate(sizeof(outside)/2);
      _outside_rooms = allocate(sizeof(outside)/2);
      //split it up so that each room outside has a corresponding
      //exit, in the proper arrays... easier to deal with this way.
      for(i=0; i<sizeof(outside); i++) {
         if(!i%2)
            _outside_rooms[i] = outside[i];
         else
            _exits[i-1] = outside[i];
      }
   }
   _burglar = burglar_func;
} /* set_night_close() */

/**
 * This method closes the shop! It sends the shopkeeper home, changes the 
 * incoming exits to be closed and locked, and moves all players in the store 
 * out.
 */
void close_up(){
   object *obs;
   object *people;
   object bing;
   object *keeper_ob;
   int i;

   if (_keeper == "none") {
     event (this_object(), "person_say", "The shopkeeper says: ", 
       "I'm sorry, it's time to close!", "common");    
     tell_room (this_object(), "The shopkeeper ushers you out of "
          "the store.\n");
   }
   else {
      keeper_ob = children(_keeper);
      if (!sizeof(keeper_ob)) {
         return;
      }
      if (keeper_ob[0]->query_fighting()) {
         call_out("close_up", 60);
         return;
      }
      keeper_ob[0]->do_command("'I'm sorry, it's time to close!");
      keeper_ob[0]->do_command(":ushers you out of the store.");
      keeper_ob[0]->move("/room/rubbish");
   }
   
   obs = all_inventory( this_object() );
   people = filter(obs, (: $1->query_property("player") :));
   
   foreach(bing in people){
      bing->move_with_look(_outside_rooms[0]);
   }
   
   for(i=0; i<sizeof(_outside_rooms); i++){
      _outside_rooms[i]->modify_exit(_exits[i], ({"open", 0, "locked", 1, 
          "difficulty", 4}));
   }
} /* close_up() */

/**
 * This method opens the store, summoning the shopkeeper from the void and
 * unlocking and opening the various exits.
 */
void open_up(){
   int i;

   for(i=0; i<sizeof(_outside_rooms); i++){
     _outside_rooms[i]->modify_exit(_exits[i], ({"open", 1, "locked", 0, 
        "difficulty", 4}));
   }
   if (_keeper == "none") {
      return;
   }
   _keeper_ob = clone_object(_file);
   _keeper_ob->move(this_object());
} /* open_up() */

/** @ignore */
void event_enter(object ob, string message, object from){
   if (!_burglar) {
      return;
   }
   if (!_closed) {
      return;
   }
   if (ob->query_creator()) {
      return;
   }
   if (!ob->query_property("player")) {
      return;
   }
   call_out(_burglar, 1, ob);
} /* event_enter() */

/** @ignore yes */
mapping query_dynamic_auto_load() {
   return ([ "keeper ob" : _keeper_ob ]);
}

/** @ignore yes */
void init_dynamic_arg(mapping map) {
   _keeper_ob = map["keeper ob"];
}
// --- END [/mnt/home2/grok/lib/std/shops/inherit/store_close.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/inherit/bank_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/inherit/bank_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629717   Available: 13577071
Inodes: Total: 5242880    Free: 4960136
15178 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/inherit/bank_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629717   Available: 13577071
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Id: bank_base.c,v 1.25 2003/01/29 03:56:33 pinkfish Exp $
 */
/**
 * This is the bank inheritable.  It handles all the bank transactions
 * and other such exciting stuff.  This is a basic bank bit, does not control
 * any extra tricky bits of bank work.
 * @author Pinkfish
 */
#include <money.h>
#include <move_failures.h>

#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"

private string _franchise;
private int _total_difference;
private nosave int _account_cost;
private nosave int _percentage;
private nosave string _bank_name;

string query_money_place();
void adjust_float(int amount);
int is_open_for(string type, string person);
void event_save(object ob);

void create() {
  _account_cost = 400;
  _total_difference = 0;
  _percentage = 10;
  //_bank_name = "Bing's First";
} /* create() */

/**
 * This method returns true for all banks.
 * @return 1 for a bank
 */
int query_bank() {
   return 1;
} /* query_bank() */

/**
 * This method returns the amount of money it costs to start an account
 * at this bank.
 * @return the account cost
 */
int query_account_cost() { return _account_cost; }

/**
 * This method sets the amount of money that it costs to start an account
 * at this bank.
 * @param number the cost of starting an account
 */
void set_account_cost( int number ) { _account_cost = number; }

/**
 * This method queries the percentage the bank charges on transactions.
 * @return the percentage the bank charges
 */
int query_percentage() { return _percentage; }

/**
 * This method sets the percentage the bank charges on transactions.
 * @param number the percentage to charge
 */
void set_percentage( int number ) { _percentage = number; }

/**
 * This method returns the difference between the deposits and withdrawls.
 * @return the difference between deposits and withdrawls
 */
int query_total_difference() { return _total_difference; }

/**
 * This method changes the total difference by the specified amount.
 * @param amount the amount to change it by
 */
void adjust_total_difference(int amount) {
   _total_difference += amount;
} /* adjust_total_difference() */

/**
 * This method changes the total difference by the specified amount.
 * @param amount the amount to change it by
 */
void set_total_difference(int amount) {
   _total_difference = amount;
} /* set_total_difference() */

/**
 * This is the name of the bank, used in creating bank branches.
 * @return the name of the bank
 */
string query_bank_name() { return _bank_name; }

/**
 * This method sets the name of the bank.
 * @param word the name of the bank
 */
void set_bank_name( string word ) { _bank_name = word; }

/**
 * This method gets the amount of money the person has in their
 * account.
 * @param player the person to get the account for
 * @return the account value
 */
int get_account(string player) {
  return HANDLER->query_account( player, _bank_name );
} /* get_account() */

/**
 * This method set the value of the account for the specified person
 * @param person the person to set the account for
 * @param amount the amount to set the account for
 */
void set_account( string player, int amount ) {
  HANDLER->set_account( player, _bank_name, amount );
} /* set_account() */

/**
 * This method is changed the amouint in the specified account.  This is
 * just an informational thingy.
 * @param person the person to update
 * @param amount the amount to update
 */
void adjust_account(string person, int amount) {
} /* adjust_account() */

/**
 * This method returns the franchise associated with this bank.  For master
 * banks this will always return 0.
 * @return the franchise
 */
string query_franchise() {
   return _franchise;
} /* query_franchise() */

/**
 * This method sets the franchise associated with this bank.  For master
 * banks this will always return 0.
 * @param franchise the franchise address
 */
void set_franchise(string franchise) {
   _franchise = franchise;
} /* set_franchise() */

/**
 * THis should be overridden in higher inherits to control account
 * adjustments.
 * @param person the person whose count is being adjusted
 * @param amount the amount it is adjusted by
 * @return 1 if they can adjust it, 0 if not
 */
int can_adjust_account(string person, int amount) {
   if ( ( get_account( person ) + amount ) >= 0 ) {
      return 1;
   }
   add_failed_mess("You do not have enough money to complete the "
                   "transaction.\n");
   return 0;
} /* can_adjust_account() */

/**
 * This method finds the main bank and returns the object of it.
 * @return the main bank
 */
object find_main_bank() {
   object office;
   string room;

   room = BANK_HANDLER->query_bank_master_office(_bank_name);
   if (!room) {
      return 0;
   }
   office = load_object(room);
   if (!office) {
      return 0;
   }

   if (office->query_bank()) {
      return office;
   }

   return 0;
} /* find_main_bank() */

/**
 * This method returns the owner of the main bank branch.
 * @return the owner name
 */
string query_main_branch_owner() {
   object branch;

   branch = find_main_bank();
   if (!branch) {
      return "no owner";
   }

   if (branch->query_owner()) {
      return lower_case(branch->query_owner());
   }
   return "no owner";
} /* query_main_branch_owner() */

/** @ignore yes */
int do_balance() {
  int amount;

   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }

   if (!is_open_for("bank", this_player()->query_name())) {
      add_failed_mess("The bank is not open for withdrawals.\n");
      return 0;
   }

   amount = get_account(this_player()->query_name());
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     add_succeeded_mess(
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }));
    return 1;
  }
  add_succeeded_mess(
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount,
         query_money_place() ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }));
  return 1;
} /* do_balance() */

/** @ignore yes */
int do_withdraw( string type ) {
  int amount;
  int total;
  object money;

   if (this_player()->query_property("dead"))  {
      add_failed_mess("You are dead.  You know what they say; you can't take "
         "it with you.\n");
      return 0;
   }

   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }

   if (!is_open_for("withdraw", this_player()->query_name())) {
      add_failed_mess("The bank is not open for withdrawals.\n");
      return 0;
   }
   total = get_account(this_player()->query_name());

   if ( total < 0 ) {
      notify_fail( "You do not have an account here.\n" );
      return 0;
   }

   amount = MONEY_HAND->value_from_string(type, query_money_place());

   if ( amount <= 0 ) {
      notify_fail( "You must withdraw something.\n" );
      return 0;
   }

   if ( amount > total ) {
      add_failed_mess( "You don't have that much money in your account!\n" );
      return 0;
   }

   if (!can_adjust_account(this_player()->query_name(), -amount)) {
      add_failed_mess("The bank cannot handle this transaction.\n");
      return 0;
   }

   money = MONEY_VAULT->get_money_ob();
   money->set_money_array(MONEY_HAND->create_money_array(amount,
       query_money_place()));
   if (money->move(this_player()) != MOVE_OK)  {
      if (money->move(this_object()) != MOVE_OK) {
         add_failed_mess("Unable to put the money on the floor, cancelling "
               "the transaction.\n");
         money->move("/room/rubbish");
         return 0;
      } else {
         write("You are carrying too much weight to accept your money, "
               "So it is placed on the floor for you.\n");
      }
   }
   set_account(this_player()->query_name(), total - amount );
   adjust_account(this_player()->query_name(), -amount);
   _total_difference -= amount;
   event_save(this_object());
   add_succeeded_mess( ({
      "You withdraw "
      + MONEY_HAND->money_value_string( amount, query_money_place() )
      +".\nYou have "
      + MONEY_HAND->money_value_string( get_account( this_player()->query_name() ),
                                        query_money_place() )
      + " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
   }) );
   this_player()->save();
   return 1;
} /* do_withdraw() */

/** @ignore yes */
int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   int howmuch;
   mixed money;

   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }

   if (!is_open_for("deposit", this_player()->query_name())) {
      add_failed_mess("The bank is not open for deposits.\n");
      return 0;
   }
   total = get_account(this_player()->query_name());
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }

   money = MONEY_HAND->parse_money(words, this_player(), query_money_place());

   if( money == NO_MATCH ) {
      add_failed_mess( "Deposit what?\n" );
      return 0;
   }
   else if( money == NO_MONEY ) {
      add_failed_mess( "You can't deposit that.\n" );
      return 0;
   }
   else if( money == NO_LEGAL ) {
      // Already got a fail message about which coin you can't deposit.
      add_failed_mess( "You can only deposit legal tender.\n");
      return 0;
   }

   amount = money->query_value_in(query_money_place());

   // Figure out the legal tender
   if(amount < 200) {
      money->move(this_player());
      add_failed_mess("That is too small an amount, you must deposit "
                      "at least " +
                      MONEY_HAND->money_value_string(200, query_money_place()) +
                      ".\n");
      return 0;
   }

   if (!can_adjust_account(this_player()->query_name(), amount)) {
      money->move(this_player());
      add_failed_mess("The bank cannot handle this transaction.\n");
      return 0;
   }

   tmp = ( amount * _percentage ) / 100;
   // This is the amount we get in commision.
   adjust_float(tmp);
   howmuch = amount;
   amount = amount - tmp;
   set_account(this_player()->query_name(), total + amount );
   _total_difference += amount;
   adjust_account(this_player()->query_name(), amount);
   //adjust_float(amount);
   event_save(this_object());
   money->move("/room/rubbish");

   this_player()->save();

   add_succeeded_mess(
       ({  "You give the teller "+ MONEY_HAND->
           money_string(money->query_money_array(), query_money_place()) +
           ", which after expenses leaves "+ MONEY_HAND->
           money_value_string( amount, query_money_place() ) +".\n"
           "This gives a total of " + MONEY_HAND->
           money_value_string(total + amount, query_money_place() ) +
           " in your account.\n",
           "$N deposits some money into $p account.\n" }) );

   return 1;
} /* do_deposit() */

/** @ignore yes */
int do_open() {
  int amount;

  if (!is_open_for("open account", this_player()->query_name())) {
     add_failed_mess("The bank is not open for new accounts.\n");
     return 0;
  }
  if ( get_account(this_player()->query_name()) >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( _account_cost ) {
    amount = this_player()->query_value_in( query_money_place() );
    if ( amount < _account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      _account_cost, query_money_place() ) +
      " to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account(this_player()->query_name(), 0 );
  add_succeeded_mess( "$N $V an account.\n" );
  return 1;
} /* do_open() */

/** @ignore yes */
void check_open( string word ) {
  object money;
  int amount;
  object main;

  word = lower_case( word );
  if (!strlen(word) || word [ 0 ] !=  'y') {
    write( "Okay, not opening an account.\n" );
    return ;
  }
  amount = this_player()->query_value_in( query_money_place() );
  if (amount < _account_cost) {
    write("You lost all your money!\n");
    return ;
  }
  set_account(this_player()->query_name(), 0 );
  write( "You now have an account here.\n" );
  money = this_player()->query_money_object(0);
//  this_player()->pay_money( MONEY_HAND->create_money_array( _account_cost,
//                            query_money_place()), query_money_place());
  money = MONEY_HAND->pay_amount_from( _account_cost, money, query_money_place() );
  if (money  &&  money->move(this_player()) != MOVE_OK)  {
    write("Your change is too heavy and you drop it on the floor.\n");
    money->move(this_object());
  }
  amount = BANK_HANDLER->query_cost_for_new_account(_bank_name,
                                                    query_franchise());
  // Update the float for the main office for the new account
  main = find_main_bank();
  if (main) {
     main->adjust_float(amount);
  }
  adjust_float(_account_cost - amount);
  return ;
} /* check_open() */

/** @ignore yes */
int do_close() {
  int total;
  object money;

  total = get_account(this_player()->query_name());
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }

  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, query_money_place() ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
      adjust_float(-total);
      _total_difference -= total;
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
    }
  } else {
    write( "You close your account.\n" );
  }
  add_succeeded_mess("$N $V an account.\n");
  set_account(this_player()->query_name(), -1 );
  event_save(this_object());
  this_player()->save();
  return 1;
} /* do_close() */

/** @ignore yes */
mixed *stats() {
  return ({
    ({ "account cost", _account_cost }),
    ({ "percentage", _percentage }),
    ({ "total difference", _total_difference }),
    ({ "bank name", _bank_name }),
    ({ "place", query_money_place() }) });
} /* stats() */

void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<string>",
               (: do_withdraw($4[0]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/inherit/bank_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/vault_entry.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/vault_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629713   Available: 13577067
Inodes: Total: 5242880    Free: 4960136
1049 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/vault_entry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629713   Available: 13577067
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: vault_entry.c,v 1.11 2001/11/13 22:00:35 pinkfish Exp $
 */
/**
 * Standard vault inheritable object. There are two inheritables (this one and
 * /std/vault.c) which are provided to make it easy to setup your own
 * vaults.
 * This object should be inherited by your vault entrance area. It is used to
 * define most of the customisation for your vault.
 *
 * You must use set_vault_name and set_vault_entrance. You must also define
 * a vault proprietor NPC and use set_proprietor() to let the system know
 * which NPC it is. You should also check for this proprietors location and
 * existance every reset. You may also want to provide some protection to
 * prevent the NPC being killed too frequently.
 *
 * @author Ceres
 * @see /std/vault_entrance.c
 */
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/vault_entry";

void create() {
   add_help_file("vault_entry");
   basic_room::create();
} /* create() */

/**
 * @ignore yes
 */
void init() {
  basic_room::init();
  vault_entry::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/vault_entry.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/auction_house.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/auction_house.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629712   Available: 13577066
Inodes: Total: 5242880    Free: 4960136
397 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/auction_house.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629712   Available: 13577066
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the main inherit for the auction house.
 * @author Pinkfish
 * @started Tue May  1 00:46:51 PDT 2001
 */
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/auction_house";

void create() {
   auction_house::create();
   basic_room::create();
   add_help_file("auction_house");
} /* create() */

void init() {
   basic_room::init();
   auction_house::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/auction_house.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/money_changer.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/money_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629712   Available: 13577066
Inodes: Total: 5242880    Free: 4960136
4164 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/money_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629712   Available: 13577066
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The money changer inherit.
 */
#include <money.h>
#include <move_failures.h>

inherit "/std/room/basic_room";

int change(string str1, string str2);

void create() {
   add_help_file("money_changer");
   ::create();
} /* create() */

void init() {
  ::init();
  add_command("change", "<string> {into|to} <string>",
                (: change($4[0], $4[2]) :) );
} /* init() */

/**
 * This method changes the money into a specific type of thing.
 * @param words the money to change
 * @param type what to change it into
 */
int change( string words, string type ) {
   int val_index;
   int value;
   int value_type;
   int value_unit;
   int value_change;
   int i;
   string place;
   mixed money;
   object changed;
   object *monies;
   mixed *change;
   mixed *values;

   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }

   values = (mixed *)MONEY_HAND->query_values_in( place );
   MONEY_OBJECT->set_money_array( values );
   val_index = (int)MONEY_OBJECT->find_best_fit( type );
   if ( val_index == -1 ) {
      return notify_fail( "The coin type \""+ type +
            "\" is not legal tender here.\n" );
   }

   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only change money here.\n" );
         default :
            return notify_fail( "You can only change legal tender.\n" );
      }
   }

   /* Pull out the provincial coins otherwise the player gets ripped off */
   if (place != "default")  {
      monies = MONEY_HAND->filter_legal_tender(money, "default");
      if (monies[0])  monies[0]->move(this_player());
      if (!monies[1])  {
         return notify_fail( "You can only change legal tender.\n" );
      }
      money = monies[1];
   }

   value = (int)money->query_value_in( place );
   //
   // Check and see if they have any of the type of money which we are trying
   // to change to in the money object.
   //
/*
   if ( place != "default" ) {
      value += (int)money->query_value_in( "default" );
   }
 */
   i = member_array(values[val_index], money->query_money_array());
   if (i != -1) {
      value_type = money->query_money_array()[i + 1] * values[val_index + 1];
   }
   value_unit = values[val_index + 1] * 100 / query_property("rate");
   //
   // Figure out the end value.
   //
   value_change = (value - value_type) % value_unit;
   value = ( (value - value_type) / value_unit ) * values[val_index + 1] +
           value_type;
   if ( value < values[ val_index + 1 ] ) {
      money->move( this_player() );
      return notify_fail(
        "That is not even worth one "+ values[ val_index ] +" after I "
        "subtract my commission.\n" );
   }

//printf("%O %O %O %O\n", value, value_unit, value_change, value_type);

   changed = clone_object( MONEY_OBJECT );
   changed->set_money_array( ({ values[ val_index ],
                                value / values[ val_index + 1 ] }));
   change = (mixed *)MONEY_HAND->create_money_array( value_change, place );
   this_player()->add_succeeded_mess(this_object(),
    ({ "You changed "+query_multiple_short( money->half_short( 1 ) ) +
         " into "+
         query_multiple_short( changed->half_short( 1 ) ) +".\n",
       "$N $V some money into "+type+".\n" }), ({ }) );
        
   //write( "You get "+ query_multiple_short( (string)money->half_short( 1 ) ) +
         //" changed into "+
         //query_multiple_short( (string)changed->half_short( 1 ) ) +".\n" );
   money->move( "/room/rubbish" );
   if ( sizeof( change ) ) {
      changed->adjust_money( change );
      write( "You were returned "+ (string)MONEY_HAND->money_string( change )
            +" in change.\n" );
   }
   if ( (int)changed->move( this_player() ) != MOVE_OK ) {
      write( "Unfortunately, you're too heavily burdened to accept all that "+
            "money, so it's put on the table for you.\n" );
      changed->move( this_object() );
   }
   return 1;
} /* change() */
// --- END [/mnt/home2/grok/lib/std/shops/money_changer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_pub.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_pub.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629711   Available: 13577065
Inodes: Total: 5242880    Free: 4960136
769 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_pub.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629711   Available: 13577065
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Uses the base pub inheritable to make a player controlled pubs.
 * @author Pinkfish
 * @started Mon Feb 14 23:34:14 PST 2000
 * @see /std/shops/inherit/pub.c
 * @see /include/shops/pub_shop.h
 * @see /include/volumes.h
 */

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/pub";

private mapping _cold_drinks;
private mapping _food;
private mapping _hot_drinks;

/** @ignore */
void create() {
   do_setup++;
   basic_room::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
} /* create() */

/** @ignore */
void init() {
   basic_room::init();
   pub::init();
} /* init() */

/** @ignore */
void dest_me() {
   pub::dest_me();
   basic_room::dest_me();
} /* dest_me() */


// --- END [/mnt/home2/grok/lib/std/shops/player_pub.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/general_shop_close.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/general_shop_close.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629710   Available: 13577064
Inodes: Total: 5242880    Free: 4960136
310 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/general_shop_close.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629710   Available: 13577064
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the general inheritable to make a general shop that will close
 * at night.
 * @author Rodion
 * Fri Oct 13 19:38:02 PDT 2000
 */
inherit "/std/shops/general_shop";
inherit "/std/shops/inherit/store_close";

/** @ignore  done to stop the thing being replaced */
void womble() {
} /* womble() */
// --- END [/mnt/home2/grok/lib/std/shops/general_shop_close.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/item_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/item_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629710   Available: 13577064
Inodes: Total: 5242880    Free: 4960136
1097 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/item_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629710   Available: 13577064
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
/*
 * $Locker:  $
 * $Id: item_shop.c,v 1.4 2003/07/15 11:17:48 taffyd Exp $
 */
/**
 * This is the default item shop code.  An item shop is a shop that only
 * sells specific items.
 * @author Pinkfish
 * @started Wed Oct 14 16:42:21 PDT 1998
 * @see /std/shops/inherit/item_shop
 */
#include <armoury.h>
#include <money.h>
#include <move_failures.h>

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/item_shop";

void create() {
  do_setup++;
  basic_room::create();
  item_shop::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
} /* create() */

/** @ignore yes */
void init() {
   basic_room::init();
   item_shop::init();
} /* init() */

/** @ignore yes */
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {

    basic_room::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen ); 
} /* event_theft() */ 

/** @ignore yes */
void dest_me() {
   item_shop::dest_me();
   basic_room::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/item_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/vault.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/vault.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629710   Available: 13577064
Inodes: Total: 5242880    Free: 4960136
6333 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/vault.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629710   Available: 13577064
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: vault.c,v 1.11 2003/05/23 14:12:40 carmine Exp $
 */

/**
 * Standard vault inheritable object. There are two inheritables (this one and
 * /std/vault_entry.c) which are provided to make it easy to setup your own
 * vaults.
 *
 * This one handles the actual vault room itself. When using this room you
 * must use set_vault_name and set_vault_entrance. You should also define a
 * setup_container function to customise your vault drawers.
 *
 * @author Ceres
 * @see /std/vault_entrance.c
 */
#include <vault.h>

inherit "/std/room/basic_room";

private object _container;
private string _vault_name;
private string _entry;
private string _there;

/**
 * Used to set the exit from this vault room (usually out to the vault entry
 * room. The parameters are just like those of add_exit.
 * @param direction The direction of the exit.
 * @param dest The destination object. Usually the filename of the destination.
 * @param type An exit type as in add_exit.
 * @return void
 * @see add_exit
 */
void set_vault_exit(string direc, mixed dest, string type) {
  _entry = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_done" }) );
  modify_exit( direc, ({ "closed", 1 }) );
}

/**
 * Used to set the name of this vault. The name is used as part of the save
 * file for the vault and should uniquely idenitfy this vault.
 *
 * @param name The name of the vault.
 * @return void
 */
void set_vault_name(string str) { _vault_name = str; }

/**
 * This method initialised a nice container to stuff everything we
 * save into.
 * @param owner the owner to make a container for
 * @return the nice container
 */
object init_container(object person) {
  object container;
  string owner;

  owner = person->query_name();
  container = clone_object( "/obj/cont_save" );
  container->set_max_weight( 1000 );
  container->set_open();
  container->set_stuck( 1 );
  container->set_can_recurse(1);
  container->reset_get();
  container->set_save_file( VAULT_SAVE +_vault_name+ "/"+ owner,
                           person );
  if ( !master()->file_exists( VAULT_SAVE +_vault_name+"/"+ owner +".o" ) ) {
    container->add_property( "owner", owner );
    container->do_save();
  }
  
  container->move(this_object());
  container->add_property("there", "here");
  this_object()->setup_container(container);
  container->add_property( "owner", owner );
  _there = container->query_property("there");
  
  return container;
} /* init_container() */

/* Call this from vault_entry since this_player() cannot be trusted. */
/**
 * @ignore yes
 */
void event_enter(object thing, string mess, object from) {
  string owner;

  if( !userp( thing ) )
    return;

  owner = thing->query_name();

   // If there's already a container here figure out if we need to dest it
   // and create a new one.
   // Don't dest it if the owner is in the vault and the person entering
   // is a creator -- useful for debugging.
  if ( _container ) {
    if((string)_container->query_property( "owner" ) == owner)
      return;
    else if(thing->query_creator() &&
            find_player(_container->query_property( "owner" )) &&
            environment(find_player(_container->query_property( "owner" ))) ==
            this_object())
         return;
      else {
        //remove_hidden_object( _container );
        _container->dest_me();
        _container = 0;
      }
  }

  _container = init_container(thing);
  call_out("fix_owner", 2, owner);
} /* event_enter() */

/**
 * @ignore yes
 *
 * This seems to be necessary coz the drawer's save their properties and some
 * don't have an owner property set! It's a hack but it was the best I could
 * come up with at the time.
 */
void fix_owner(string owner) {
  if (_container) {
     _container->add_property( "owner", owner );
     if(_there) {
       _container->add_property("there", _there);
     }
  }
}

/**
 * @ignore yes
 */
int check_done( string verb, object thing, string special ) {
  if ( thing->query_auto_loading() ) {
    tell_room( this_object(), "The door swings shut.\n" );
    tell_object( thing, "Your vaults's inventory is still being generated.\n"
                "Please wait until it is completed.\n" );
      return notify_fail( "" );
   }
   return 1;
} /* check_done() */

/**
 * @ignore yes
 */
void event_exit( object thing, string message, object to ) {
  if(_container && _container->query_property("owner") == thing->query_name()) {
    //remove_hidden_object(_container);
    _container->move("/room/void");
    call_out((: _container->dest_me() :), 1);
  }
  if(interactive(thing))
    thing->save_me();
}

/**
 * @ignore yes
 */
string query_quit_handler() {
  return _entry;
}

/**
 * Define this function in your vault room to perform setup on the vault
 * container. Use it to customise the name, short, long, size etc. of your
 * drawers (or whatever your vault uses.
 *
 * @param container The object to perform your customisation on.
 * @return void
 */
void setup_container(object container) {
  container->set_name( "drawer" );
  container->set_short( "drawer" );
  container->add_alias( "drawer" );
  container->set_long("The single open drawer is sticking straight "
                      "out of the wall like...  well, like a drawer sticking "
                      "straight out of the wall.  " );
}

/**
 * @ignore yes
 * Make sure they can't draw circles or erect tents here.
 */
int trap_action( string str ) {
   string st1;

   if( sscanf( str,"%s %s", str, st1 ) );
      switch(str) {
      case "circle":
         tell_object( this_player(),
               "Something tells you that drawing a circle in this location "
               "would be a bad idea.\n");
         return 1;
      case "erect":
         tell_object( this_player(),
               "You can't seem to get the tent to unfold properly.  "
               "Perhaps you should try it somewhere else.\n");
         return 1;
      default:
         return 0;
    }
} /* trap_action() */

/** @ignore yes */
void event_net_dead(object ob) {
   // Toss them out...
   ob->move_with_look(_entry);
} /* event_net_dead() */

/**
 * @ignore yes
 */
void init() {
   ::init();
   this_player()->command_override( (: trap_action :) );
} /* init() */


/**
 * @ignore yes
 */
int query_vault_room() {
   return 1;
} /* query_vault_room() */// --- END [/mnt/home2/grok/lib/std/shops/vault.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/objs/counter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/objs/counter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629708   Available: 13577062
Inodes: Total: 5242880    Free: 4960136
974 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/objs/counter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629708   Available: 13577062
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Pub counter for the pub_shop.c inheritable.  It will automatically clear
 * away any empty items on it that have the property "pub item" on them every
 * 3 seconds.
 * @author Lemming
 * @started 28/10/1999
 */

#include <position.h>

inherit "/std/surface";

/** @ignore */
void create() {
   ::create();
   set_name( "counter" );
   set_short( "counter" );
   set_long( "The counter seems to be where you should leave glasses and "
      "plates to be cleared away.\n" );
   reset_get();

   add_property(CAN_POSITION_PROPERTY, 1);

} /* create() */

/** @ignore */
void clear_item( object item ) {
   if( environment( item ) == this_object()
       && !sizeof( all_inventory( item ) ) )
      item->move( "/room/rubbish" );
} /* clear_item() */

/** @ignore */
void event_enter( object ob, string mess, object from ) {
   if( ob->query_property( "pub item" )
       && !sizeof( all_inventory( ob ) ) )
      call_out( "clear_item", 3, ob );

} /* event_enter() */
// --- END [/mnt/home2/grok/lib/std/shops/objs/counter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/real_estate_auction.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/real_estate_auction.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629707   Available: 13577061
Inodes: Total: 5242880    Free: 4960136
10870 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/real_estate_auction.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629707   Available: 13577061
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/shops/auction_house";

#include <housing.h>
#include <money.h>
#include <move_failures.h>
#include <room/auction.h>
#include <nomic_system.h>
#include <morpork.h>

#define AUCTION_LENGTH (3600*24*5)
#define NEW_AGREEMENT_COST 4000

#define REAL_ESTATE_NEW_LOT_BIDDING "new_low_bidding"

private nosave string* _areas;
private nosave string _city;
private nosave string _language;

int add_house(string house);
int check_can_bid(object person,
                  class auction which,
                  int bid_amount);

void create() {
   _areas = ({ });
   _city = "Ankh-Morpork";
   _language = "morporkian";
   ::create();
   add_help_file("real_estate");
} /* create() */

void reset()
{
   call_out("after_reset", 10);
}

/**
 * This method adds in an area to which the real estate office will look
 * for houses.
 * @param area the area to look in
 */
void add_housing_area(string area) {
   _areas += ({ area });
} /* add_housing_area() */

/**
 * This method returns all the areas in which the real estate office will
 * look for houses.
 * @return the areas to look for houses
 */
string* query_housing_areas() {
   return _areas;
} /* query_housing_areas() */

/**
 * This runs through the list of vacant houses and checks to see if it
 * should add them up for auction or not.
 */
void after_reset()
{
   string house;
   string *available;
   int i;
   string area;

   // Find available houses and start an auction for them.
   foreach (area in _areas) {
      available = HOUSING->query_vacant(area);

      if (sizeof(available)) {
        i = 1;
        foreach(house in available) {
          call_out("add_house", i++, house);
        }
      }
   }
}

/**
 * Add a house for auction.
 * @string house the path of the house
 * @return 1 on success, 0 on failure
 */
int add_house(string house)
{
   object agreement;
   string text;
   int tim;

   //Don't auction houses that don't really exist
   if (member_array(house, keys(HOUSING->query_houses())) == -1) {
      return 0;
   }

   // Sanity check to make sure houses are only listed once.
   if(lower_case(HOUSING->query_owner(house)) != "for sale") {
     log_file("REAS", ctime(time()) + ": attempt to add house %s that's "
              "not for sale.\n", house);
     return 0;
   }
   
   // Reset information about the house.
   HOUSING->set_rent(house, 0);
   agreement = clone_object(AGREEMENT);
   agreement->set_city(_city);
   agreement->set_language(_language);
   agreement->set_house(house);
   text = HOUSING->query_address(house);
   tim = query_last_auction_finish_time();
   if (tim + 60 * 60 < time() + query_auction_times()["very long"]) {
      tim = 0;
   } else {
      tim = tim + 60 * 60 - time();
   }
   if (add_item_to_auction(({ agreement }), text,
                           400, "Patrician", tim,
                           "housing_auction", house)) {
      HOUSING->set_under_offer(house);
      broadcast_shop_event(REAL_ESTATE_NEW_LOT_BIDDING, this_player(),
                           house);
      log_file("REAS", ctime(time()) + ": Added house %s\n", house);
      return 1;
   }
}

/**
 * This function is called during the various phases of the housing
 * auction.  When each phase ends this method is called and anything
 * that needs to be done for the end of the phase is sorted out.
 * @param event_type the event that has finished
 * @param auct the auction that just finished
 * @param house the path of the house being auctioned
 * @param buyer the buyer of the house (if sold)
 * @param cost how much the house costs
 * @param obs the things that were sold (rental agreementsin this case)
 */
void housing_auction(int event_type,
                     class auction auct,
                     string house,
                     string buyer,
                     int cost,
                     object *obs)
{
   object book;
   //If we didn't sell it with the first reserve price,
   //try again with a smaller one. If we did sell it,
   //set the new owner!

   switch (event_type) {
   case AUCTION_WITHDRAW_PHASE:
      // Mark the house as For Sale again.
     if(lower_case(HOUSING->query_owner(house)) != "under offer") {
       write("House is not currently under offer!\n");
       log_file("REAS", ctime(time()) + ": attempted to withdraw %s when it "
                "was not 'Under Offer'.\n", house);
     } else {
       HOUSING->set_for_sale(house);
       log_file("REAS", ctime(time()) + ": %s back to For Sale.\n", house);
     }
     break;
   case AUCTION_CLAIM_PHASE:
      HOUSING->set_owner(house, buyer);
      HOUSING->set_value(house, cost);
      obs[0]->set_city(_city);
      obs[0]->set_language(_language);
      obs[0]->set_house(house);
      log_file("REAS", ctime(time()) + ": %O sold to %O for %O.\n",
               house, buyer,
               MONEY_HAND->money_value_string(cost, query_property("place")));
      //Throw in a copy of the home owners guide.
      book = clone_object(BOOK);
      if (book) {
         if (book->move(this_player()) != MOVE_OK) {
            book->move(this_object());
         }
      }
      write("A nice new house owner's guide pops up for you.\n");
      break;
   }
}

/**
 * Request a new rental agreement for a house they might have
 * lost.
 */
int do_agreement()
{
   string *houses;
   int i;
   string place;

   place = query_property("place");
   if (this_player()->query_value_in(place) < NEW_AGREEMENT_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) +
                      " to get a new agreement.\n");
      return 0;
   }

   houses = filter(keys(HOUSING->query_houses()),
                   (: HOUSING->query_owner($1) == $2 :),
                   this_player()->query_name());
   if (!sizeof(houses)) {
      add_failed_mess("You are not renting any houses.\n");
      return 0;
   }
   for (i = 0; i < sizeof(houses); i++) {
      printf("%c) %s %s\n", i + 'A',
             HOUSING->query_address(houses[i]),
             HOUSING->query_region(houses[i]));
   }
   write("It will cost you " + MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) + " for a new "
         "agreement.\n");
   write("Which house to choose? ");
   input_to("new_agreement_choice", 0, houses);
   add_succeeded_mess(({ "",
                         "$N enquires about a new rental agreement.\n" }));
   return 1;
}                               /* do_agreement() */

/** @ignore yes */
protected void new_agreement_choice(string choice,
                          string *houses)
{
   int index;
   object agreement;
   string place;

   place = query_property("place");
   choice = lower_case(choice);
   if (!strlen(choice)) {
      write("Ok, canceling agreement check.\n");
      return;
   }

   index = choice[0] - 'a';
   if (index < 0 || index >= sizeof(houses)) {
      write("Choice out of bounds.\n");
      return;
   }

   if (this_player()->query_value_in(place) < NEW_AGREEMENT_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) +
                      " to get a new agreement.\n");
      return 0;
   }

   this_player()->pay_money(MONEY_HAND->
                            create_money_array(NEW_AGREEMENT_COST, place));
   agreement = clone_object(AGREEMENT);
   agreement->set_city(_city);
   agreement->set_language(_language);
   agreement->set_house(houses[index]);
   if (agreement->move(this_player()) != MOVE_OK) {
      write("Unable to move the agreement into your inventory.\n");
      return 0;
   }
   write("Created a new agreement for " +
         HOUSING->query_address(houses[index]) + ".\n");
}                               /* new_agreement_choice() */

/**
 * This method checks to make sure they have enough money in their bank
 * accounts to make the bid.  This function should be setup to be called
 * as the big checking function in the inherit of this room.
 * @param person the person being checked for bidding
 * @param which the auction being tested to be bid on
 * @param bid_amount how much they are bidding
 */
int check_can_bid(object person,
                  class auction which,
                  int bid_amount)
{
   int total_money,
     total_bids;
   string *accounts;
   string account;
   class auction auction;

   accounts = "/obj/handlers/bank_handler"->query_accounts(person->
                                                           query_name());
   foreach(account in accounts) {
      total_money += "/obj/handlers/bank_handler"->query_account(person->
                                                                 query_name(),
                                                                 account);
   }

   foreach(auction in query_auctions()) {
      if (auction->current_bidder &&
          lower_case(auction->current_bidder) == person->query_name()) {
         total_bids += auction->bid;
      }
   }

   if (total_bids + bid_amount > total_money * 3) {
      add_failed_mess
         ("You do not have sufficient funds in your bank accounts "
          "to cover such a bid.\n");
      return 0;
   }

   return 1;
}                               /* check_can_bid() */

/** @ignore yes */
void init()
{
   ::init();
   add_command("request", "[agreement]", (: do_agreement() :));
}                               /* init() */

/**
 * This function runs down the list of current auctions and makes sure they 
 * are all registered as "Under Offer" so if for some reason they are not, 
 * they won't be put up for sale again.
 */
void reset_auctions_to_under_offer() {
    class auction auc;
    
    foreach( auc in query_auctions() ) {
        HOUSING->set_under_offer(auc->extra);
    }
    
} /* reset_auctions_to_under_offer() */

/**
 * This is just a cosmetic function to help set up the agreements. 
 *
 * @param where the city to which the agreements will say the property 
 * defaults to when you cease to own it
 */
void set_city( string where ) {
    _city = where;
} /* set_city() */

/**
 * This is just a cosmetic function to help set up the agreements. 
 *
 * @param the agreements be written in
 */
void set_language( string lang ) {
    _language = lang;
} /* set_language() */

/**
 * Returns the city the real estate place thinks it lives in.
 */
string query_city() {
    return _city;
} /* query_city() */

/**
 * Returns the language the real estate place will use for its agreements.
 */
string query_language() {
    return _language;
} /* query_language() */

mixed *stats() {
  return ::stats() +
    ({ 
        ({ "areas", _areas }),
        ({ "city", _city }),
        ({ "language", _language }),
    });
}
// --- END [/mnt/home2/grok/lib/std/shops/real_estate_auction.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/general_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/general_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629705   Available: 13577059
Inodes: Total: 5242880    Free: 4960136
62227 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/general_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629705   Available: 13577059
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
/*
 * $Locker:  $
 * $Id: general_shop.c,v 1.19 2002/08/03 05:09:38 presto Exp $
 *
 */

/**
 * This the base shop.  It buys and sells stuff form players.
 * <p>
 * A storeroom must be set for the shop!
 * <p>
 * Original made who knows when.
 * @author Pinkfish
 * @see set_storeroom()
 * @change bil
 * to make the list a lot nicer.
 * @change Pinkfish
 * to give shops types and make them send out
 * reps to sell/buy things from other shops.
 * @change Ceres
 * to add burglable storerooms.
 * @change 23-11-97, Gototh
 * to add buy, sell, list, browse, value,
 * cost_too_muchy and not_worthy functions.
*/

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shop.h>
#include <tasks.h>

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/open_shop";

private mixed our_storeroom;
private mixed buy_mess;
private mixed sell_mess;
private mixed list_mess;
private mixed value_mess;
private mixed too_costly_mess;
private mixed not_worthy_mess;
private mixed browse_mess;
private mixed *other_shops;

private int amount_sold;
private int amount_bought;
private int strict_shop;
private int no_steal;
private int sell_stolen;
private int steal_difficulty;
private int min_amount;
private int max_inventory;
private int sell_large;

private mixed shop_type;
private mixed buy_func;
private mixed sell_func;
private mixed value_func;
private mixed too_costly_func;
private mixed cannot_sell_func;
private mixed browse_func;
private mixed list_func;

private nosave string shoplift_handler;

private string original_storeroom;

private int _strict_currency;

private nosave mapping elist = (["north" : "south", "south" : "north", 
  "east" : "west", "west" : "east", "up" : "down", "down" : "up"]);

string shop_list(mixed arr, int detail);
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which);
string find_free_exit();
int do_buy(object *ob);
int do_list_these(object *obs);
void do_buy_things( object *obs, int cost, object pl );
void do_parse(mixed arr, mixed ob, object client, string money, 
  string extra);
object create_mercenary(object rep);
void event_shoplift(object command_ob, object thief, object victim);
object query_store_room();
int creator_object (object);

void create() {
    buy_mess = ({
      "You buy $ob$ for $money$.\n",
      "$client$ buys $ob$.\n"});
    sell_mess = ({
      "You sell $ob$ for $money$.\n",
      "$client$ sells $ob$.\n"});
    list_mess = "$extra$";
    value_mess = "$ob$ is valued at $money$.\n";
    too_costly_mess = "$ob$ is worth too much to be sold here.\n";
    not_worthy_mess = "$ob$ is not worth enough to be sold here.\n";
    browse_mess = "$ob$ costs $money$, it looks like:\n$extra$";
    other_shops = ({ });
    max_inventory = MAX_INVENTORY;
    min_amount = 50;
    add_help_file("shop");
    _strict_currency = 1;
    ::create();
} /* create() */

/** @ignore yes */
void reset() {
    if(!random(3)) {
        remove_property("inventory_loss"); // This is incremented by shoplifting
    }
    call_out("send_out_reps", 2);
} /* reset() */

/**
 * This method sets the function to call when buying something.  The
 * function will be called with two elements, the first being the
 * player doing the buying and the second being the array
 * of objects being bought.
 * <p>
 * If the function is a string then the function of that name
 * will be called on the shop, if it is a function pointer
 * then the function pointer will be evaluated.
 * @param func the function to call
 * @see set_sell_function()
 * @see set_value_function()
 * @see set_too_costly_function()
 * @see set_cannot_sell_function() 
 * @see set_browse_function()
 * @see set_list_function()
 */
void set_buy_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        buy_func = func;
    }
} /* set_buy_function() */

/**
 * This method sets the function to call when selling something.  The
 * function will be called with two elements, the first being the
 * player doing the selling and the second being the array
 * of objects being sold.
 * <p>
 * If the function is a string then the function of that name
 * will be called on the shop, if it is a function pointer
 * then the function pointer will be evaluated.
 * @param func the function to call
 * @see set_buy_function()
 * @see set_value_function()
 * @see set_too_costly_function()
 * @see set_cannot_sell_function() 
 * @see set_browse_function()
 * @see set_list_function()
 */
void set_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        sell_func = func;
    }
} /* set_sell_function() */

/**
 * This method sets the function to call when an item(*s) are being
 * valued.  The
 * function will be called with three elements, the first being the
 * player doing the valueing and the second being the array
 * of objects being valued and the third being the string
 * value of the objects.
 * <p>
 * If the function is a string then the function of that name
 * will be called on the shop, if it is a function pointer
 * then the function pointer will be evaluated.
 * @param func the function to call
 * @see set_sell_function()
 * @see set_buy_function()
 * @see set_too_costly_function()
 * @see set_cannot_sell_function() 
 * @see set_browse_function()
 * @see set_list_function()
 */
void set_value_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        value_func = func;
    }
} /* set_value_function() */

/**
 * This method sets the function to call when buying something and it
 * costs too much.  The
 * function will be called with two elements, the first being the
 * player doing the buying and the second being the array
 * of objects which cost too much.
 * <p>
 * If the function is a string then the function of that name
 * will be called on the shop, if it is a function pointer
 * then the function pointer will be evaluated.
 * @param func the function to call
 * @see set_sell_function()
 * @see set_value_function()
 * @see set_buy_function()
 * @see set_cannot_sell_function() 
 * @see set_browse_function()
 * @see set_list_function()
 */
void set_too_costly_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        too_costly_func = func;
    }
} /* set_too_costly_function() */

/**
 * This method sets the function to call when selling something
 * which fails for some reason.  The
 * function will be called with two elements, the first being the
 * player doing the selling and the second being the array
 * of objects being sold.
 * <p>
 * If the function is a string then the function of that name
 * will be called on the shop, if it is a function pointer
 * then the function pointer will be evaluated.
 * @param func the function to call
 * @see set_sell_function()
 * @see set_value_function()
 * @see set_too_costly_function()
 * @see set_buy_function() 
 * @see set_browse_function()
 * @see set_list_function()
 */
void set_cannot_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        cannot_sell_func = func;
    }
} /* set_cannot_sell_function() */

/**
 * This method sets the function to call when browsing something.  The
 * function will be called with two elements, the first being the
 * player doing the browsing and the second being the array
 * of objects being browsed.
 * <p>
 * If the function is a string then the function of that name
 * will be called on the shop, if it is a function pointer
 * then the function pointer will be evaluated.
 * @param func the function to call
 * @see set_sell_function()
 * @see set_value_function()
 * @see set_too_costly_function()
 * @see set_cannot_sell_function() 
 * @see set_browse_function()
 * @see set_list_function()
 */
void set_browse_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        browse_func = func;
    }
} /* set_browse_function() */

/**
 * This method sets the function to call when listing something.  The
 * function will be called with two elements, the first being the
 * player doing the listing and the second being the array
 * of objects being listed.
 * <p>
 * If the function is a string then the function of that name
 * will be called on the shop, if it is a function pointer
 * then the function pointer will be evaluated.
 * @param func the function to call
 * @see set_sell_function()
 * @see set_value_function()
 * @see set_too_costly_function()
 * @see set_cannot_sell_function() 
 * @see set_browse_function()
 * @see set_list_function()
 */
void set_list_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        list_func = func;
    }
} /* set_list_function() */

/**
 * This sets the message which will be told to the players when
 * they sell something at the shop.  If the parameter is a string
 * then that message is sent to the player and nothing is sent to
 * the other people in the room.  If the message is a two element
 * array, the first element is sent to the player and the second
 * element is sent to the others in the room.  In both these
 * cases the pattersn $ob$ will be replaces with the objects
 * being sold, $client$ will be replaced with the client, $money$
 * will be replaced with the money information, $extra$ will be replaces
 * with any extra information.
 * <p>
 * If the parameter is a function pointer, then this is called with
 * the parameter func(obs, client, money, extra);
 * @param str the message to print
 * @see set_buy_message()
 * @see query_sell_message()
 * @see set_set_value_message()
 * @see set_too_costly_message()
 * @see set_no_worthy_message()
 * @see set_browse_message() 
 * @see set_list_message()
 * @example
 * set_sell_message("You sell $ob$ for $money$.\n");
 * @example
 * set_sell_message( ({ "You sell $ob$ for $money$.\n",
 *                      "$client$ sells $ob$.\n"});
 */
void set_sell_message(mixed str) {
    sell_mess = str;
} /* set_sell_message() */

/**
 * This sets the message which will be told to the players when
 * they buy something at the shop.  If the parameter is a string
 * then that message is sent to the player and nothing is sent to
 * the other people in the room.  If the message is a two element
 * array, the first element is sent to the player and the second
 * element is sent to the others in the room.  In both these
 * cases the pattersn $ob$ will be replaces with the objects
 * being sold, $client$ will be replaced with the client, $money$
 * will be replaced with the money information, $extra$ will be replaces
 * with any extra information.
 * <p>
 * If the parameter is a function pointer, then this is called with
 * the parameter func(obs, client, money, extra);
 * @param str the message to print
 * @see set_sell_message()
 * @see query_buy_message()
 * @see set_set_value_message()
 * @see set_too_costly_message()
 * @see set_no_worthy_message()
 * @see set_browse_message() 
 * @see set_list_message()
 * @example
 * set_buy_message("You buy $ob$ for $money$.\n");
 * @example
 * set_buy_message( ({ "You buy $ob$ for $money$.\n",
 *                      "$client$ buys $ob$.\n"});
 */
void set_buy_message(mixed str) {
    buy_mess = str;
} /* set_buy_message() */

/**
 * This sets the message which will be told to the players when
 * they value something at the shop.  If the parameter is a string
 * then that message is sent to the player and nothing is sent to
 * the other people in the room.  If the message is a two element
 * array, the first element is sent to the player and the second
 * element is sent to the others in the room.  In both these
 * cases the pattersn $ob$ will be replaces with the objects
 * being sold, $client$ will be replaced with the client, $money$
 * will be replaced with the money information, $extra$ will be replaces
 * with any extra information.
 * <p>
 * If the parameter is a function pointer, then this is called with
 * the parameter func(obs, client, money, extra);
 * @param str the message to print
 * @see set_buy_message()
 * @see query_value_message()
 * @see set_set_value_message()
 * @see set_too_costly_message()
 * @see set_no_worthy_message()
 * @see set_browse_message() 
 * @see set_list_message()
 * @example
 * set_value_message("$ob$ is valued at $money$.\n");
 * @example
 * set_sell_message( ({ "$ob$ is valued at $money$.\n",
 *                      "$client$ values $ob$.\n"});
 */
void set_value_message(mixed str) {
    value_mess = str;
} /* set_value_message() */

/**
 * This sets the message which will be told to the players when
 * they buy something at the shop and it costs too much.
 * If the parameter is a string
 * then that message is sent to the player and nothing is sent to
 * the other people in the room.  If the message is a two element
 * array, the first element is sent to the player and the second
 * element is sent to the others in the room.  In both these
 * cases the pattersn $ob$ will be replaces with the objects
 * being sold, $client$ will be replaced with the client, $money$
 * will be replaced with the money information, $extra$ will be replaces
 * with any extra information.
 * <p>
 * If the parameter is a function pointer, then this is called with
 * the parameter func(obs, client, money, extra);
 * @param str the message to print
 * @see set_buy_message()
 * @see query_too_costly_message()
 * @see set_set_value_message()
 * @see set_browse_message()
 * @see set_no_worthy_message()
 * @see set_sell_message() 
 * @see set_list_message()
 * @example
 * set_browse_message("$ob$ is worth too much to be sold here.\n");
 * @example
 * set_browse_message( ({ "$ob$ is worth too much to be sold here.\n",
 *                      "$client$ tries to sell the terribly expensive $ob$.\n"});
 */
void set_too_costly_message(mixed str) {
    too_costly_mess = str;
} /* set_too_costly_message() */

/**
 * This sets the message which will be told to the players when
 * they sell soemthign that is not worth enough at the shop. 
 * If the parameter is a string
 * then that message is sent to the player and nothing is sent to
 * the other people in the room.  If the message is a two element
 * array, the first element is sent to the player and the second
 * element is sent to the others in the room.  In both these
 * cases the pattersn $ob$ will be replaces with the objects
 * being sold, $client$ will be replaced with the client, $money$
 * will be replaced with the money information, $extra$ will be replaces
 * with any extra information.
 * <p>
 * If the parameter is a function pointer, then this is called with
 * the parameter func(obs, client, money, extra);
 * @param str the message to print
 * @see set_buy_message()
 * @see query_not_worthy_message()
 * @see set_set_value_message()
 * @see set_too_costly_message()
 * @see set_browse_message()
 * @see set_sell_message() 
 * @see set_list_message()
 * @example
 * set_not_worthy_message("$ob$ is not worth enough to be sold here.\n");
 * @example
 * set_not_worthy_message( ({ "$ob$ is not worth enough to be sold here.\n",
 *                      "$client$ tries to sell the rubbishy $ob$.\n"});
 */
void set_not_worthy_message(mixed str) {
    not_worthy_mess = str;
} /* set_not_worthy_message() */

/**
 * This sets the message which will be told to the players when
 * they browse something at the shop.  If the parameter is a string
 * then that message is sent to the player and nothing is sent to
 * the other people in the room.  If the message is a two element
 * array, the first element is sent to the player and the second
 * element is sent to the others in the room.  In both these
 * cases the pattersn $ob$ will be replaces with the objects
 * being sold, $client$ will be replaced with the client, $money$
 * will be replaced with the money information, $extra$ will be replaces
 * with any extra information.  In the case oif a browse the
 * extra information is the long description of the object.
 * <p>
 * If the parameter is a function pointer, then this is called with
 * the parameter func(obs, client, money, extra);
 * @param str the message to print
 * @see set_buy_message()
 * @see query_browse_message()
 * @see set_set_value_message()
 * @see set_too_costly_message()
 * @see set_no_worthy_message()
 * @see set_sell_message() 
 * @see set_list_message()
 * @example
 * set_browse_message("$ob$ costs $money$, it looks like:\n$extra$");
 * @example
 * set_browse_message( ({ "$ob$ costs $money$, it looks like:\n$extra$",
 *                      "$client$ browses $ob$.\n"});
 */
void set_browse_message(mixed str) {
    browse_mess = str;
} /* set_browse_message() */

/**
 * This sets the message which will be told to the players when
 * they list something at the shop.  If the parameter is a string
 * then that message is sent to the player and nothing is sent to
 * the other people in the room.  If the message is a two element
 * array, the first element is sent to the player and the second
 * element is sent to the others in the room.  In both these
 * cases the pattersn $ob$ will be replaces with the objects
 * being sold, $client$ will be replaced with the client, $money$
 * will be replaced with the money information, $extra$ will be replaces
 * with any extra information.  In the case of a list,
 * the extra information *is* the list.
 * <p>
 * If the parameter is a function pointer, then this is called with
 * the parameter func(obs, client, money, extra);
 * @param str the message to print
 * @see set_buy_message()
 * @see query_buy_message()
 * @see set_set_value_message()
 * @see set_too_costly_message()
 * @see set_no_worthy_message()
 * @see set_browse_message() 
 * @see set_list_message()
 * @example
 * set_list_message("$extra$.\n");
 * @example
 * set_list_message( ({ "You list $ob$ for $money$.\n",
 *                      "$client$ lists $ob$.\n"});
 */
void set_list_message(mixed str) {
    list_mess = str;
} /* set_list_message() */

/**
 * This sets the conditons which the shop will be open during.  If this
 * is set to an integer the shop will always be in that state, so
 * if you set the open condition to 0, it would always be closed.
 * If it is set to a string, then that function will be called on
 * this object to test to see if it is open.  If it iset to 
 * function pointer, the function pointer will be evaluated.  If it
 * is set to an array, the first element specifies the object and the
 * second specifies the function to call.
 * @see query_open_condition()
 * @see is_open()
 */
void set_open_condition(mixed str) {
   if (functionp(str)) {
      ::set_open_function(str);
   } else if (intp(str)) {
      ::set_open_function( (: $(str) :) );
   } else if (pointerp(str)) {
      ::set_open_function( (: call_other($(str[0]), $(str[1]), $1) :) );
   } if ( stringp(str) ) {
      ::set_open_function( (: call_other( this_object(), $(str), $1 ) :) );
   }
} /* set_open_condition() */

/**
 * This method sets the no steal property.  If a shop is set
 * as no steal, then it cannot be shoplifted.
 * @param i the new value of the no_steal property
 * @see set_steal_difficulty()
 * @see query_no_steal()
 * @see set_sell_stolen()
 */
void set_no_steal(int i) {
    no_steal = i;
} /* set_no_steal() */

/**
 * This method sets the difficulty at which to steal stuff from
 * this shop.
 * @see set_no_steal()
 * @see set_sell_stolen()
 * @see query_steal_difficulty()
 * @param i the new value for the steal difficulty
 */
void set_steal_difficulty(int i) {
    steal_difficulty = i;
} /* set_steal_difficulty() */

/**
 * This method sets the shop as a place which will receive and
 * seel stolen goods.  It automaticly sets the no_steal property
 * to 1.
 * @see set_no_steal()
 * @see set_steal_difficulty()
 * @see query_sell_stolen()
 * @param i the new value for the stolen property
 */
void set_sell_stolen(int i) {
    sell_stolen = i;
    no_steal = 1;
} /* set_sell_stolen() */

/**
 * This method sets the shop to sell very large objects. ie. If a player
 * cannot carry items they are placed in the room for the player rather
 * than not being sold to the player.
 */
void set_sell_large(int i) { sell_large = i; }

/**
 * This method returns the current sell message of the shop.
 * @see set_sell_mess()
 * @return the current sell message of the shop
 */
mixed query_sell_mess() {
    return sell_mess;
} /* query_sell_mess() */

/**
 * This method returns the current list message of the shop.
 * @see set_list_mess()
 * @return the current list message of the shop
 */
mixed query_list_mess() {
    return list_mess;
} /* query_list_mess() */

/**
 * This method returns the current value message of the shop.
 * @see set_value_mess()
 * @return the current value message of the shop
 */
mixed query_value_mess() {
    return value_mess;
} /* query_value_mess() */

/**
 * This method returns the current too costly message of the shop.
 * @see set_too costly_mess()
 * @return the current too costly message of the shop
 */
mixed query_too_costly_mess() {
    return too_costly_mess;
} /* query_too_costly_mess() */

/**
 * This method returns the current not worthy message of the shop.
 * @see set_not worthy_mess()
 * @return the current not worthy message of the shop
 */
mixed query_not_worthy_mess() {
    return not_worthy_mess;
} /* query_not_worthy_mess() */

/**
 * This method returns the current buy message of the shop.
 * @see set_buy_mess()
 * @return the current buy message of the shop
 */
mixed query_buy_mess() {
    return buy_mess;
} /* query_buy_mess() */

/**
 * This method returns the current browse message of the shop.
 * @see set_browse_mess()
 * @return the current browse message of the shop
 */
mixed query_browse_mess() {
    return browse_mess;
} /* query_browse_mess() */

/**
 * This method returns the current no steal property.
 * @see set_no_steal_mess()
 * @return the current no steal properyt of the shop
 */
int query_no_steal() {
    return no_steal;
} /* query_no_steal() */

/**
 * This method returns the current steal difficulty of the shop.
 * @see set_steal_difficulty_mess()
 * @return the current steal difficulty message of the shop
 */
int query_steal_difficulty(int i) {
    return steal_difficulty;
} /* query_steal_difficulty() */

/**
 * This method returns the shop lift response handler for the shop.
 * This allows the shop to respond in someway to someone shop
 * lifting stuff, like the heavys in Ankh-Morpork.
 * @returns the shop lift response handler
 * @see set_shoplift_response_handler()
 * @see set_no_steal()
 * @see set_sell_stolen()
 * @see set_steal_difficulty()
 */
string query_shoplift_response_handler() {
    return shoplift_handler;
} /* query_shoplift_response_handler() */

/**
 * This method tells us if the shop is really a shop or not.
 * @return 1 always
 */
int query_shop() {
    return 1;
} /* query_shop() */

/**
 * This method returns the items which can potentially be shop lifted
 * with the passed in string.
 * @param str the name for the object to attempt to shop lift
 * @return the array of matching objects
 * @see query_steal_difficulty()
 * @see query_shoplift_response_handler()
 */
object *query_shop_lift_items(string str, object player) {
    return match_objects_for_existence(str, ({ query_store_room() }));
} /* query_shop_lift_items() */

/**
 * This method turns the objects into real objects (if that is
 * nessessary, it is not with a normal shop).
 * @param ob the object to turn into a normal object
 */
object shoplift_success(object ob) {
    return ob;
} /* shoplift_success() */

/**
 * This method sets the shop lift response handler for the shop.
 * This allows the shop to respond in someway to shop lifting
 * stuff, like the heavies in Ankh-Morpork.  The function
 * 'handle_shoplift' will be called on the handler when the
 * shop lift is attempted.  It will be passed two arguments
 * the first is the thief, the second is the room being
 * shoplifted.  This can be set to  afucntion pointer
 * which will be evaluated and passed in two arguemtns
 * when  a shoplift occurs.
 * @see query_shoplift_response_handler()
 * @see set_no_steal()
 * @see set_sell_stolen()
 * @see set_steal_difficulty()
 * @param word the new shop lift response handler
 */
void set_shoplift_response_handler(string word) {
    shoplift_handler = word;
} /* set_shoplift_response_handler() */

/**
 * This method sets the minimum value of items that can be sold here.
 * @see query_min_amount()
 */
void set_min_amount(int i) { min_amount = i; }

/**
 * This method sets the maximum number of inventory items this shop will
 * take before it starts to refuse to purchase items from players and
 * deleting items from its inventory.
 * The default for this is defined as MAX_INVENTORY in shop.h
 */
void set_max_inventory(int i) { max_inventory = i; }

/** @ignore yes */
void init() {
    string room;

    ::init();
    if(stringp(our_storeroom)) {
        room = our_storeroom;
    } else if(our_storeroom) {
        room = file_name(our_storeroom);
    } else {
      tell_room(this_object(),
                "Oh dear, we don't seem to have a storeroom.\n");
    }
    add_command("sell", "<indirect:object:me>");
    add_command("buy", "<indirect:object:"+room+">");
    add_command("list", "[all]");
    add_command("list", "<indirect:object:"+room+">",
      (: do_list_these($1) :));
    add_command("browse", "<indirect:object:"+room+">");
    add_command("value", "<indirect:object:me>");
} /* init() */

/**
 * This method returns the maximum value oif an object that can
 * be sold here.
 * @see query_min_amount()
 * @return the maximum amount
 * @see /obj/handlers/money_handler.c
 */ 
int query_max_amount() {
    return MAX_AMOUNT;
} /* query_max_amount() */


/**
 * This method returns the minimum value oif an object that can
 * be sold here.
 * @see query_max_amount()
 * @return the minimum amount
 * @see /obj/handlers/money_handler.c
 */ 
int query_min_amount() {
    return min_amount;
} /* query_min_amount() */

/**
 * This method returns the value of the object in this shop.
 * @return the value of the object here
 * @param thing the thing to value
 * @param sell are we selling it?
 * @see query_max_amount()
 * @see query_min_amount()
 */
varargs int query_value(object thing, int sell) {

     // Only use the cost here property if we're not selling.
     if ( thing->query_property("cost here") && !sell ) {
         return (int)thing->query_property("cost here");
     }
     else {
        return (int)thing->query_value_at( this_object() );
     }
} /* query_value() */


/**
 * This returns the amount of money you can sell and object for
 * which is less than the amount it will be sold for).
 * @param n the value to scale
 * @return the sell value
 */
int scaled_value(int n) {
    int i, tot, *fish;

    fish = PAY_RATES;
    if(n < fish[0]) {
        return n;
    } else {
        tot = fish[0];
        n -= fish[0];
    }
    i = 0;
    while(n && ((i + 1) < sizeof(fish))) {
        if(n >= fish[i]) {
            tot += fish[i + 1] * fish[i] / 100;
            n -= fish[i];
        } else {
            tot += fish[i + 1] * n / 100;
            n = 0;
        }
        i += 2;
    }
    if(n) {
        tot += (n * fish[sizeof(fish) - 1]) / 100;
    }
    return tot;
} /* scaled_value() */

/**
 * This method does the actual selling.
 * @param in_obs the objects to sell
 * @return 1 on success, 0 on failure
 */
int do_sell(object *in_obs) {
    int i, amt, total_amt;
    string place, filename, *text = ({ });
    object money, *obs, *selling, *cannot, *stolen, storeob, one_item, *cre;
    object thing;
    mixed *m_array;

    if(!is_open(this_player(), 0)) {
        return 0;
    }
    
    in_obs = uniq_array( in_obs );

    obs = filter_array(in_obs, (: !$1->query_keep() :));
    cre = filter (obs, (: creator_object ($1) :));
    
    if (sizeof (cre) && strsrch (file_name (this_object()), 
      "_dev") == -1) {
      
      if (!this_player()->query_creator()) {
        tell_object (this_player(), "Oh dear, you shouldn't have " + 
          query_multiple_short (cre) + "!  They disappear with a flash "
          "of octarine light.\n");
        cre->move ("/room/rubbish");
      }
      else {
        tell_object (this_player(), "Oh dear, you shouldn't be trying to sell " + 
          query_multiple_short (cre) + "!\n");
      }        

      foreach (thing in cre) {
        if ( thing->query_property( "virtual name" ) ) {
          filename = thing->query_property( "virtual name" );
        } else {      
          filename = base_name (thing);          
        }
        
        text += ({filename});
      }
      
      log_file ("ILLEGAL_OBJECT", sprintf ("%s: %s tried to sell %s at "
        "%s.\n\n", ctime (time()), this_player()->query_name(),
        query_multiple_short (text), file_name (this_object())));


      obs -= cre;
   }
   
    if(!sizeof(obs)) {
        this_player()->add_failed_mess(this_object(),
          "You previously decided to keep $I.\n", in_obs);
        return 0;
    }

    in_obs = this_player()->query_holding() + this_player()->query_armours();
    cannot = filter(obs, (: member_array($1, $2) != -1 :), in_obs);
    if (sizeof(cannot)) {
        obs -= cannot;
        tell_object(this_player(), "You decide not to sell " + 
          query_multiple_short(cannot, "the") + ", because "
          "you are wearing or holding $V$0=it,them$V$.\n");
        /*     add_failed_mess("You cannot sell $I since you are wearing or holding "
                             "them.\n",
                             cannot);
             return 0; */
    }

    // If there are more items in the storeroom than max_inventory allows
    // return a failure message.
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) > max_inventory) {
        this_player()->add_failed_mess(this_object(),
          "Sorry, the shop is full up and isn't buying items!\n", ({ }));
        call_out("tidy_inventory", random(20));
        return 0;
    }

    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS - 1];
    }
    selling = cannot = stolen = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(!sell_stolen && obs[i]->query_property("stolen")) {
            stolen += ({obs[i]});
            continue;
        } else {
            obs[i]->remove_property("stolen");
        }
        if((this_object()->query_value(obs[i], 1) > 0) && 
          !obs[i]->do_not_sell() && 
          !this_object()->do_not_buy(obs[i]) && (!strict_shop || 
            shop_type == obs[i]->query_property("shop type")) && 
          environment(obs[i]) == this_player()) {
            if(obs[i]->move(our_storeroom)) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                continue;
            }
            amt = (int)this_object()->query_value(obs[i], 1);
            if(!(obs[i]->query_property("sale_value"))) {
                amt = scaled_value( amt );
            }
            if((amt <= (int)this_object()->query_max_amount()) &&
              (amt >= (int)this_object()->query_min_amount())) {
                if(shop_type != obs[i]->query_property("shop type")) {
                    amt = (amt * 90) / 100;
                }
                total_amt += amt;
                selling += ({obs[i]});
                obs[i]->being_sold();
            } else {
                if(obs[i]->short())
                    cannot += ({obs[i]});
                obs[i]->move(this_player());
            }
        } else {
            if(obs[i]->short()) {
                cannot += ({obs[i]});
            }
        }
    }
    if (!sizeof(selling)) {
        if (sizeof(cannot)) {
            if (stringp(cannot_sell_func)) {
                call_other(this_object(), cannot_sell_func, this_player(), cannot);
            } else if (functionp(cannot_sell_func)) {
                evaluate(cannot_sell_func, this_player(), cannot);
            }
            this_player()->add_failed_mess(this_object(),
              "You cannot sell $I.\n", cannot);
        } else if(sizeof(stolen)) {
            if(sizeof(stolen) > 1) {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because they're stolen!\n", stolen);
            } else {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because it's stolen!\n", stolen);
            }
            foreach(one_item in obs) {
                if(one_item->query_property("stolen") == this_player()->query_name()) {
                    event_shoplift(this_object(), this_player(), this_object());
                    break;
                }
            }
        } else {
            this_player()->add_failed_mess(this_object(),
              "You have nothing to sell.\n", ({ }));
        }
        return 0;
    }
    if(this_object()->cannot_afford(total_amt)) {
        selling->move(this_player());
        this_player()->add_failed_mess(this_object(),
          "The shop cannot afford to buy $I from you.\n", selling);
        return 0;
    }
    amount_sold += total_amt;
    m_array = (mixed *)MONEY_HAND->create_money_array(total_amt, place);
    money = clone_object(MONEY_OBJECT);
    money->set_money_array(m_array);
    if(sizeof(cannot)) {
        if(stringp(cannot_sell_func)) {
            call_other(this_object(), cannot_sell_func, this_player(), cannot);
        } else if (functionp(cannot_sell_func)) {
            evaluate(cannot_sell_func, this_player(), cannot);
        }
        write("You cannot sell "+query_multiple_short(cannot)+".\n");
        cannot->move(this_player());
    }
    if(stringp(sell_func)) {
        call_other(this_object(), sell_func, this_player(), obs);
    } else if (functionp(sell_func)) {
        evaluate(sell_func, this_player(), obs);
    }
    do_parse(sell_mess, selling, this_player(), 
      (string)MONEY_HAND->money_string(m_array), "");
    if((int)money->move(this_player()) != MOVE_OK) {
        tell_object(this_player(), 
          "You're too heavily burdened to accept all that money, "
          "so the shopkeeper puts it on the floor.\n");
        money->move(this_object());
    }
    this_object()->made_transaction(-total_amt, selling);
    return 1;
} /* do_sell() */

/**
 * This method does the actual buying.
 * @param obs the objects to buy
 * @return 1 on success, 0 on failure
 */
/**
 * This method determines whether or not a given object is a creator object
 * and should be in this shop or not. 
 * @param ob the object to check
 * @return 1 if the object is not allowed, 0 if it is.
 */
int creator_object( object ob ) {
    string path;

    if ( file_name( ob )[0..2] == "/w/" ) {
        return 1;
    }

    if ( ( path = ob->query_property( "virtual name" ) ) && 
      path[0..2] == "/w/" ) {
        return 1;
    }

    return 0;
} /* creator_object() */

int do_buy(object *obs) {
    int i, amt, ob_amt, total_cost;
    string place;
    object money, *to_buy, *cannot, *too_much;
    object *creator_obs;

    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS-1];
    }
    creator_obs = filter( obs, (: creator_object( $1 ) :) );
    if ( sizeof( creator_obs ) && file_name()[0..2] != "/w/" ) {
        tell_object( this_player(), "You cannot buy " + 
          query_multiple_short( creator_obs, "the" ) + 
          " because they shouldn't be in the game!\n" );
        obs -= creator_obs;
    }

    to_buy = too_much = cannot = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, this_player());
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You have no money.\n", obs);
        return 0;
    }
    amt = money->query_value_in(place);
    if(place != "default" && !_strict_currency ) {
        amt += money->query_value_in("default");
    }
    while(i < sizeof(obs)) {
        ob_amt = this_object()->query_value(obs[i], 0);
        if(ob_amt > amt) {
            if(obs[i]->short()) {
                too_much += ({obs[i]});
            }
            obs = delete(obs, i, 1);
            continue;
        }
        if(obs[i]->move(this_player())) {
            if(!sell_large) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                i++;
                continue;
            } else {
                obs[i]->move(this_object());
            }
        }
        amt -= ob_amt;
        total_cost += ob_amt;
        to_buy += ({obs[i]});
        i++;
    }
    amount_bought += total_cost;
    if(sizeof(cannot)) {
        this_player()->add_failed_mess(this_object(),
          "You cannot pick up $I.\n", cannot);
    }
    if(sizeof(too_much)) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), cannot);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), cannot);
        }
        this_player()->add_failed_mess(this_object(),
          "$I costs too much.\n", too_much);
    }
    if(!sizeof(to_buy)) {
        return 0;
    }
    do_buy_things(to_buy, total_cost, this_player());
    return 1;
} /* do_buy() */

/** @ignore yes */
void do_buy_things(object *obs, int cost, object pl) {
    int i, j;
    string place;
    object money, change;
    mixed m_array, p_array;

    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, pl);
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_object(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You don't have any money.\n", obs);
        return 0;
    }
    change = clone_object(MONEY_OBJECT);
    m_array = (int)MONEY_HAND->create_money_array(cost, place);
    for(i = 0; i < sizeof(m_array); i += 2) {
        p_array = (mixed *)MONEY_HAND->make_payment(m_array[i],
          m_array[i + 1], money, place);
        if(!pointerp(p_array)) {
            continue;
        }
        for(j = 0; j < sizeof(p_array[0]); j += 2) {
            money->adjust_money(-p_array[0][j + 1], p_array[0][j]);
        }
        change->adjust_money(p_array[1]);
    }
    do_parse(buy_mess, obs, pl, 
      (string)MONEY_HAND->money_string(m_array), "");
    if(stringp(buy_func)) {
        call_other(this_object(), buy_func, pl, obs);
    } else if (functionp(buy_func)) {
        evaluate(buy_func, pl, obs);
    }
    if((int)change->move(pl) != MOVE_OK) {
        tell_object(pl, "You are too heavily burdened to accept "
          "your change, so the shopkeeper puts it on the floor.\n");
        change->move(this_object());
    }
    this_object()->made_transaction(cost, obs);
} /* do_buy() */

/**
 * This method lists all the objects in stock.
 * @return 1 on succes, 0 on failure
 * @param do_list_these()
 */
int do_list() {
    object ob;

    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(objectp(our_storeroom)) {
        ob = our_storeroom;
    } else {
        if ( original_storeroom ) {
            our_storeroom = load_object( original_storeroom );
            ob = our_storeroom;
        }
        else {
            add_failed_mess( "Please notify a creator: the storeroom for "
                "this shop cannot load or has gone missing.\n" );
            return 0;
        }
    }
    if(stringp(list_func)) {
        call_other(this_object(), list_func, this_player());
    } else if (functionp(list_func)) {
        evaluate(list_func, this_player());
    }
    do_parse(list_mess, ({ this_object() }), this_player(), "",
      shop_list(all_inventory(ob), 0));
    return 1;
} /* do_list() */

/**
 * This method lists only the specified objects
 * @return 1 on success, 0 on failure
 * @see do_list()
 */
int do_list_these(object *obs) {
    if(!is_open(this_player(), 0)) {
        return 0;
    }

    do_parse(list_mess, ({this_object()}), 
      this_player(), "", shop_list(obs, 1));
    return 1;
} /* do_list_these() */

/**
 * This method is called when the player is browseing stuff.
 * @param obs the objects to browse
 * @return 1 on success, 0 on failure
 */
int do_browse(object *obs) {
    int i, value;
    string place;

    if (!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    if(stringp(browse_func)) {
        call_other(this_object(), browse_func, this_player(), obs);
    } else if (functionp(browse_func)) {
        evaluate(browse_func, this_player(), obs);
    }
    for(i = 0; i < sizeof(obs); i++) {
        value = (int)this_object()->query_value(obs[i], 0);
        do_parse(browse_mess, obs[i..i], this_player(),
          (string)MONEY_HAND->money_value_string(value, place),
          (string)obs[i]->long());
    }
    return 1;
} /* do_browse() */

/**
 * This method is called when the player is valueing stuff.
 * @param obs the objects to value
 * @return 1 on success, 0 on failure
 */
int do_value(object *obs) {
    int i;
    int val;
    int total;
    string place;
    int obnum;

    if(!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->do_not_sell() || this_object()->do_not_buy(obs[i]) ||
          (environment(obs[i] ) != this_player()) ||
          (strict_shop &&
            (shop_type != (string)obs[i]->query_property("shop type")))) {
            val = 0;
        } else {
            val = (int)this_object()->query_value(obs[i], 1);
            if (shop_type != (string)obs[i]->query_property("shop type")) {
                val = (val * 90) / 100;
            }
        }
        val = scaled_value(val);
        total += val;
        if(val > (int)this_object()->query_max_amount()) {
            do_parse(too_costly_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else if(val < (int)this_object()->query_min_amount()) {
            do_parse(not_worthy_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else {
            do_parse(value_mess, obs[i..i], this_player(),
              (string)MONEY_HAND->money_value_string(val, place),
              (string)obs[i]->do_not_sell());
            if(stringp(value_func)) {
                call_other(this_object(), value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            } else if (functionp(value_func)) {
                evaluate(value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            }
        obnum++;
        }
    }

    if (obnum > 1) {
        write("This gives you a total value of " +
          MONEY_HAND->money_value_string(total, place) +
          ".\n");
        return 1;
    }
    this_player()->add_failed_mess( this_object(), "None of your items are "
        "suitable for sale here!\n", obs );
    return obnum;
} /* do_value() */

/**
 * This method creates the list  for the shop.
 * @param arr the array of objecsts to list
 * @param detail display them in detail?
 * @return the string list
 */
string shop_list(mixed arr, int detail) {
    int i, j, value, num;
    string s, mon, place, *shorts, *vals;
    object *list;
    mapping inv, costs;
    mixed ind;

    if(pointerp(arr)) {
        list = arr;
    } else {
        list = all_inventory(this_object());
    }
    // Only keep track of things with shorts.
    inv = ([ ]);
    for(i = 0; i < sizeof(list); i++) {
        s = (string)list[i]->short();
        if(!s || !this_object()->query_value(list[i], 1)) {
            continue;
        }
        if(!stringp(s)) {
            s = "get a creator for this one!";
        }
        if(inv[s]) {
            inv[s] += ({list[i]});
        } else {
            inv[s] = ({list[i]});
        }
    }
    // Okay, print it.
    s = "";
    shorts = m_indices(inv);
    if(!sizeof(shorts)) {
        if(detail) {
            return "The shop is all out of what you wanted.\n";
        } else {
            return "The shop is totally out of stock.\n";
        }
    }
    s = "You find on offer:\n";
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(shorts); i++) {
        ind = inv[shorts[i]];
	num = sizeof(ind);
	if(num == 1 && ind[0]->query_collective())
	  num = ind[0]->query_amount();

        switch(num) {
        case 1:
            s += "Our very last " + shorts[i];
            break;
        case 2..5 :
            s += capitalize(query_num(num, 0)+" "+
			    (string)ind[0]->query_plural());
            break;
        default:
            if(detail) {
                s += capitalize(query_num(num, 0) + " " +
                  (string)ind[0]->query_plural());
            } else {
                s += "A large selection of "+
                (string)ind[0]->query_plural();
            }
        }
        if(detail) {
            costs = ([ ]);
            for(j = 0; j < sizeof(ind); j++) {
                value = (int)this_object()->query_value(ind[j], 0);
                mon = (string)MONEY_HAND->money_value_string(value, place);
                if(!costs[mon]) {
                    costs[mon] = ({""+(j + 1)});
                } else {
                    costs[mon] += ({""+(j + 1)});
                }
            }
            if(m_sizeof(costs) == 1) {
                s += " for "+m_indices(costs)[0];
                if(sizeof(m_values(costs)[0]) > 1) {
                    s += " each.\n";
                } else {
                    s += ".\n";
                }
            } else {
                s += ":-\n";
                vals = m_indices(costs);
                for(j = 0; j < sizeof(vals); j++) {
                    s += "  [#"+implode(costs[vals[j]], ",")+"] for "
                    +vals[j]+".\n";
                }
            }
        } else {
            s += ".\n";
        }
    }
    return s;
} /* shop_list() */

/**
 * This method sets the current store room associated with
 * the shop.  This is important!  A shop needs a storeroom.
 * @param ob the storeroom to set
 * @example
 * set_store_room(PATH+"store_room");
 */
void set_store_room(mixed ob) {
    if(stringp(ob)) {
        original_storeroom = ob;
        our_storeroom = find_object(ob);
        if(!our_storeroom) {
            our_storeroom = load_object(ob);
        }
    }
    else our_storeroom = ob;  
} /* set_store_room() */

/** @ignore yes */
void guards(object tp) {
    object ob;

    if(environment(tp) != this_object() && environment(tp) != our_storeroom) {
        return;
    }
    while(!random(6)) {
        ob = create_mercenary(0);
        ob->move(environment(tp));
        ob->attack_ob(tp);
    }
} /* guards() */

/**
 * This method returns the storeroom associated with the shop.
 * @see set_store_room()
 * @return the current store room
 */
object query_store_room() {
    return our_storeroom;
} /* query_store_room() */

/**
 * This method is the major message processing function for
 * the buye messages, sell messages etc.  It handles calling
 * the functions and setting the results back onto the
 * player.
 * @param arr the value of the message
 * @param ob the objects to process
 * @param money the money string
 * @param extra the extra string
 */
void do_parse(mixed arr, object *ob, object client,
  string money, string extra) {
    if(stringp(arr)) {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr, 
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(), "", ob);
    } else if (functionp(arr)) {
        evaluate(arr, ob, client, money, extra);
    } else {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr[0],
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(),
          ({"", replace(arr[1], ({"$ob$", "$I", "$client$",
                "$N", "$money$", money, "$extra$", extra}))}), ob);
    }
} /* do_parse() */

/** 
 * This is a minature version of do_parse(), which can be used when you
 * set the money array to a function pointer in order to make message
 * processing go smoother. 
 * @param str the value of the message
 * @param ob the objects to process
 * @param money the money string
 * @param extra the extra string
 * @return a parsed string
 */
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which) {
    if(sizeof(ob)) {
        str = replace(str, "$ob$", query_multiple_short(ob, which));
    } else {
        str = replace(str, "$ob$", call_other(ob, which +"_short"));
    }
    if(client) {
        str = replace(str, "$client$", client->the_short());
    }
    str = replace(str, ({"$money$", money, "$extra$", extra}));
    return str;
} /* shop_parse() */

/**
 * This method adds a shop with shich we will exchange inventories
 * of certain types.  So the main shop can sell off its swords and
 * stuff to the sword shop.
 * @param shop the other shop
 */
void add_other_shop(mixed shop) {
    // Should give a nice string telling us the other room.
    other_shops += ({shop});
} /* add_other_shop() */

/**
 * This method returns the type of the shop.  This conttrols what sort
 * of merchandise the shop will buy and sell.
 * <p>The types of allowed shops are:
 * <ul>
 * <li>  jewelery
 * <li>  armoury
 * <li>  clothes
 * <li>  magic
 * <li>  none set (ie: 0, general type)
 * </ul>
 * @return the shop type
 * @see set_shop_type()
 * @see set_strict_shop()
 */
string query_shop_type() {
    return shop_type;
} /* query_shop_type() */

/**
 * This method sets the type of the shop.  This controls what sort of
 * mechandise the shop will buy and sell.
 * <p>The types of allowed shops are:
 * <ul>
 * <li>  jewelery
 * <li>  armoury
 * <li>  clothes
 * <li>  magic
 * <li>  none set (ie: 0, general type)
 * </ul>
 * @see query_shop_type()
 * @see set_strict_shop()
 * @param ty the type of the shop
 */
void set_shop_type(string ty) {
    shop_type = ty;
} /* set_shop_type() */

/**
 * This method sets the strictness of the shop, if the shop is strict
 * it will not deal in items of other types at all.
 * @param i the new strict value
 * @see set_shop_type()
 * @see query_strict_shop()
 */
void set_strict_shop(int i) {
    strict_shop = i;
} /* set_strict_shop() */

/**
 * This method returns the structness of the shop, if the shop is strict
 * it will not deal in items of other types at all.
 * @return the current strict value
 * @see set_shop_type()
 * @see set_strict_shop()
 */
int query_strict_shop() {
    return strict_shop;
} /* query_strict_shop() */

/**
 * This method creates the sales representative which is sent off
 * to exchange goods with other shops.
 * @return the sales representative
 * @see add_other_shop()
 * @see send_out_reps()
 */
object create_rep() {
    object ob;

    ob = clone_object("/obj/monster");
    ob->set_name("rep");
    ob->set_short("sales rep");
    ob->add_adjective("sales");
    ob->set_long("This is tall strong looking sales rep.  He "
      "stares at you with bright piercing eyes.\n");
    ob->add_alias("Sales rep alias");
    ob->set_guild("fighter");
    ob->set_race("human");
    ob->adjust_bon_str(15);
    ob->set_level(60);
    ARMOURY->request_weapon("dagger", 100)->move(ob);
    ARMOURY->request_armour("cloth robe", 100)->move(ob);
    ob->init_equip();
    ob->add_property("rep type", shop_type);
    all_inventory(ob)->add_property("mine", 1);
    return ob;
} /* create_rep() */

// Send out the reps.

/**
 * This method checks to see if there are any other shops
 * associated with ours and sends out representatives to them
 * to exchange goods.
 * @see create_rep()
 * @see add_other_shop()
 */
void send_out_reps() {
    int i;
    object ob;

    for(i = 0; i < sizeof(other_shops); i++) {
        ob = (object)this_object()->create_rep();
        ob->add_property("goto destination", other_shops[i]);
        ob->add_property("goto property", "shop");
        ob->move(this_object(),
          "$N stride$s determinedly into the room.");
        ob->add_triggered_action("froggy", "goto_destination",
          file_name(this_object()), "rep_made_it");
    }
} /* send_out_reps() */

/**
 * This method is called onces the representative
 * reaches its destination.
 * @param bing we mkde it ok
 */
void rep_made_it(int bing) {
    object *obs, rep;
    int i, cost;

    if(!bing) {
        previous_object()->init_command("'Oh no!  I am utterly lost!");
        previous_object()->init_command("sigh");
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = (previous_object()->query_current_room())->query_stock(shop_type);
    if(!obs) {
        obs = ({ });
    }
    if(!sizeof(obs)) {
        this_object()->none_to_sell();
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]) {
            cost += (int)this_object()->query_value( obs[ i ], 1 ) * 2 / 3;
        }
    }
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    cost += (int)this_object()->query_value(obs[i], 1) * 2 / 3;
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    previous_object()->adjust_value(cost);
} /* rep_made_it() */

/**
 * This method creates a mercenaries to wander along with the
 * sales rep to get the stuff to the destination.
 * @param rep the representative to protect
 * @return the new mercenary
 */
object create_mercenary(object rep) {
    object ob;
    string nam;

    if(rep) {
        nam = implode(rep->query_adjectives(), " ")+" "+rep->query_name();
    }
    ob = clone_object("/obj/monster");
    ob->set_name("mercenary");
    ob->add_alias("troll");
    ob->add_adjective("troll");
    ob->set_short("troll mercenary");
    ob->set_main_plural("troll mercenaries");
    ob->set_race("troll");
    ob->set_class("fighter");
    ob->set_level(200 + random(200));
    ob->set_long("This is a large, hulking troll.  He looks "
      "quite competent and capable of mashing you with or "
      "without a weapon.\n");
    if(rep) {
        ob->move(environment(rep));
        ob->do_command("follow "+nam);
        ob->do_command("protect "+nam);
        ob->add_property("merchant", rep);
    } else {
        ARMOURY->request_weapon("spiked club", 100)->move(ob);
    }
    ob->set_natural(1);
    ob->init_equip();
    ob->set_join_fights("Troll yells something incomprehensible.\n");
    ob->set_join_fight_type(0); // So they only beat up players.
    return ob;
} /* create_mercenry() */

/* The shop types are:
 *   jewelery
 *   armoury
 *   clothes
 *   magic
 *   none set (ie: 0, general type)
 */

/**
 * This method returns alkl the stock in the shop of various
 * types.  The types are:
 * <ul>
 * <li>  jewelery
 * <li>  armoury
 * <li>  clothes
 * <li>  magic
 * <li>  none set (ie: 0, general type)
 * </ul>
 * @param type the type of stock to return
 * @return the array of objects of the type
 */
object *query_stock(string type) {
    mapping blue;

    blue = (mapping)our_storeroom->query_shop_type_mapping();
    if(!blue[type]) {
        return ({ });
    }
    return blue[type];
} /* query_stock() */

/**
 * This method is called when the rep tries to buy stuff.
 * @param bing the stuff to buy
 */
void do_rep_buy(mixed *bing) {
    object rep, *obs;
    int cost;

    rep = bing[0];
    obs = bing[1];
    cost = bing[2];
    rep->adjust_money(cost, "brass");
    rep->query_current_room()->do_buy(obs, cost, rep);
    obs->move(present("Sales rep alias", rep->query_current_room()));
    call_out("set_up_return", 5, rep);
} /* do_rep_buy() */

/**
 * This method sets up the rep to return home.
 * @param rep the rep to return home
 */
void set_up_return(object rep) {
    rep->add_property("goto destination", file_name(this_object()));
    rep->add_triggered_action("froggy", "goto_destination",
      this_object(), "rep_came_back");
} /* set_up_return() */

/**
 * This method is called when the rep gets back home.
 */
void rep_came_back() {
    int i;
    object *obs, *obs2, rep;

    obs = previous_object()->find_inv_match("all", previous_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->query_property("mine")) {
            continue;
        }
        if(obs[i]->query_property("money")) {
            continue;
        }
        obs[i]->move(our_storeroom);
        obs2 += ({obs[i]});
    }
    if(sizeof(obs2)) {
        tell_room(this_object(), previous_object()->short()+" puts "+
          query_multiple_short(obs2)+" into the stock.\n");
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = all_inventory(this_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if((object)obs[i]->query_property("merchant") == rep) {
            obs2 += ({ obs[i] });
        }
    }
    if(sizeof(obs2)) {
        tell_room(this_object(), 
          query_multiple_short(obs2+({previous_object()}), "one")+" go away.\n");
    } else {
        tell_room(this_object(), previous_object()->short()+" goes away.\n");
    }
    obs2->dest_me();
    previous_object()->dest_me();
} /* rep_came_back() */

// Used to create guards to protect the shop.

/**
 * This method is yused to handle guards to protect the shop.
 * @param tp the object which is shop lifting
 * @see event_shoplift()
 * @see set_shoplift_handler()
 */
void summon_guards(object tp) {
    object ob;
    int i;

    if(environment(tp) != this_object()) {
        return;
    }
    ob = environment(tp)->create_mercenary(0);
    if(!ob) {
        return;
    }
    ob->move(this_object(),
      "$N charge$s in to protect the shop!");
    ob->attack_ob(tp);
    for(i = 0; i < random(5); i++) {
        ob = create_mercenary(0);
        ob->move(this_object(),
          "$N charge$s in to protect the shop!");
        ob->attack_ob(tp);
    }
} /* summon_guards() */

/**
 * This method controls whether or not a shop will accept currency
 * from the "default" area.
 * @param new_strict set this to 1 if the shop should only accept currency
 * from the current area it is in (determined by the "place" property).
 */
void set_strict_currency( int new_strict ) {
    _strict_currency = new_strict;
} /* set_strict_currency() */

/** 
 * This returns the value of the strict currency variable.
 * @return 0 if default currency is accepted, 1 if it is not.
 */
int query_strict_currency() {
    return _strict_currency;
} /* query_strict_currency() */
    

/**
 * This method is called when a shop lift is done on the shop.
 * @param command_ob the command object
 * @param thief the theif doing the shop lifting
 * @param victim the victim of the shoplifiting, us I guess :)
 * @see event_shoplift()
 * @see set_shoplift_handler()
 */
void event_shoplift(object command_ob, object thief, object victim) {
    if(stringp(shoplift_handler)) {
        if(shoplift_handler != "none") {
            shoplift_handler->handle_shoplift(thief, victim);
        }
    } else if (functionp(shoplift_handler)) {
        evaluate(shoplift_handler, thief, victim);
    } else {
        "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
    }
} /* event_shoplift() */

/**
 * This method is used by the shop to tidyup its inventory.  It does this by
 * desting objects at random until it has reduced the inventory to 3/4 of its
 * maximum.
 */
void tidy_inventory() {
    object storeob;
    object *inventory;
    int i, inv_to_leave;
    int count;

    inv_to_leave = max_inventory - (max_inventory / 4);

    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }

    if(sizeof(all_inventory(storeob)) < inv_to_leave)
        return;

    inventory = all_inventory(storeob);

    while(sizeof(inventory) > inv_to_leave) {
        i = random(sizeof(inventory));
        if(inventory[i])
            inventory[i]->dest_me();

        // safety code.
        if(count++ > 500)
            break;

        inventory = all_inventory(storeob);    
    }

}


/** @ignore yes */
void dest_me() {
    if(our_storeroom)
        our_storeroom->dest_me();
    ::dest_me();
}

/** @ignore yes */
mixed *stats() {
    return ::stats()+({
      ({"total sold", amount_sold}),
      ({"total bought", amount_bought}),
      ({"shop type", shop_type}),
      ({"shoplift handler", shoplift_handler }),
      ({"strict shop", strict_shop})});
} /* stats() */

// --- END [/mnt/home2/grok/lib/std/shops/general_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/item_shop_outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/item_shop_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629689   Available: 13577043
Inodes: Total: 5242880    Free: 4960136
1018 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/item_shop_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629689   Available: 13577043
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
/*
 * $Locker:  $
 * $Id: item_shop_outside.c,v 1.3 2003/07/15 11:17:34 taffyd Exp $
 */
/**
 * This is the default item shop code.  An item shop is a shop that only
 * sells specific items.  This is the outside version of it.
 * @author Pinkfish
 * @started Wed Oct 14 16:42:21 PDT 1998
 * @see /std/shops/inherit/item_shop
 */
#include <armoury.h>
#include <money.h>
#include <move_failures.h>

inherit "/std/room/outside";
inherit "/std/shops/inherit/item_shop";

void create() {
   item_shop::create();
   outside::create();
} /* create() */

/** @ignore yes */
void init() {
   outside::init();
   item_shop::init();
} /* init() */

/** @ignore yes */
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {

    outside::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen ); 
} /* event_theft() */ 

/** @ignore yes */
void dest_me() {
   item_shop::dest_me();
   outside::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/item_shop_outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/bank_franchise.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/bank_franchise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629689   Available: 13577043
Inodes: Total: 5242880    Free: 4960136
4855 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/bank_franchise.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629689   Available: 13577043
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the bank inheritable.  It handles all the bank transactions
 * and other such exciting stuff.
 * @author Pinkfish
 */
#include <money.h>
#include <move_failures.h>

nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_franchise";

private int _total_account;
private int _total_made;
private nosave string _place;

nosave string _save_file;

void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
} /* create() */

/** @ignore yes */
int query_float() {
   return 2400000;
} /* query_float() */

/** @ignore yes */
void adjust_float(int amt) {
} /* adjust_float() */

/** @ignore yes */
string query_franchise() {
   return file_name(this_object());
} /* query_franchise() */

/** @ignore yes */
int is_open_for(string type, string person) {
   return 1;
} /* is_open_for() */

/**
 * This method retuns the money place for the bank.
 * @return the money place
 */
string query_money_place() { return _place; }

/**
 * This method sets the place that the money will be setup from.
 * @param word the place to set
 */
void set_place( string word ) { _place = word; }

/**
 * This method returns the save file used for the room.
 * @return the save file used
 */
string query_save_file() { return _save_file; }

/**
 * This method sets the save file for the bank.
 * @param word the save file name for the bank
 */
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
} /* set_save_file() */

/**
 * This method does the actual save.
 */
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
} /* event_save() */

mixed *stats() {
  return basic_room::stats() + 
         bank_franchise::stats() + ({
         ({ "save file", query_save_file() }) });
} /* stats() */

int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  //total_account -= total;
  amount = total / 3;
  //total_made += 2 * amount;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
} /* make_bank_robbers() */

void init() {
   basic_room::init();
   bank_franchise::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/bank_franchise.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/craft_shop_category.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/craft_shop_category.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629687   Available: 13577041
Inodes: Total: 5242880    Free: 4960136
765 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/craft_shop_category.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629687   Available: 13577041
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room will handle craft shop like things, where you sell stuff to
 * the store and it will sell it onto other players after taking
 * a margin.  This can be used for potions, pottery, swords, anything!
 * @author Pinkfish
 * @started Thu Feb  5 15:39:57 CST 1998
 */
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop_category";

/** @ignore yes */
void create() {
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   basic_room::create();
   craft_shop_category::create();
} /* create() */

/** @ignore yes */
void init() {
   basic_room::init();
   craft_shop_category::init();
} /* init() */

/** @ignore yes */
void dest_me() {
   craft_shop_category::dest_me();
   basic_room::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/craft_shop_category.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/binding.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/binding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629687   Available: 13577041
Inodes: Total: 5242880    Free: 4960136
2601 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/binding.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629687   Available: 13577041
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A binding shop, where people can come and get books bound.
 * @author Pinkfish
 * @started Fri Apr  7 13:19:40 PDT 2000
 */
inherit "/std/room/basic_room";

#include <money.h>
#include <language.h>

private int _cost_per_book;
private int _cost_per_page;

void create() {
   _cost_per_book = 4000;
   _cost_per_page = 400;
} /* create() */

void init() {
   add_command("bind", "<object:indirect:me'pages'> into book");
} /* init() */

/**
 * Checks to see if the object has any magic writing on it.
 * @return 1 if there is magic writing, 0 if not.
 * @see find_book_or_paper()
 * @see /obj/handlers/language->query_language_magic()
 */
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;

   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
} /* check_for_magic_writing() */

/**
 * This method binds up a book from a bunch of pages.
 * @param obs the pages to bind up
 * @return 1 on success, 0 on failure
 */
int do_bind(object *obs) {
   object *magic;
   object *paper;
   object *fail;
   object ob;
   object book;
   string place;
   int cost;

   foreach (ob in obs) {
      if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      }
   }
   if (sizeof(fail) || sizeof(magic)) {
      if (sizeof(magic)) {
         add_failed_mess("Cannot bind up $I with magic stuff into "
                         "a book.\n", magic);
      }
      if (sizeof(fail)) {
         add_failed_mess("$I are not pieces of paper and cannot be "
                         "bound into a book.\n", fail);
      }
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   cost = _cost_per_book + _cost_per_page * sizeof(paper);

   //
   // Check to see if they have enough money.
   //
   if (this_player()->query_value(place) > cost) {
      add_failed_mess("You do not have enough money, you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to bind $I into a book.\n", paper);
      return 0;

   }

   //
   // Ok, do the binding.
   //
   book = clone_object("/std/book");
   foreach (ob in paper) {
      book->add_page_after(ob, book->query_num_pages() + 1);
   }

   book->move(this_player());

   this_player()->pay_money( MONEY_HAND->create_money_array(cost, place),
                             place);
   return 1;
} /* do_bind() */
// --- END [/mnt/home2/grok/lib/std/shops/binding.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/book_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/book_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629686   Available: 13577040
Inodes: Total: 5242880    Free: 4960136
4865 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/book_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629686   Available: 13577040
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a specialisation of the craft shop inheritable.  It adds in the
 * ability to read specified pages from books.
 * @author Pinkfish
 * @started Thu Sep 10 23:51:01 PDT 1998
 */
#include <shops/craft_shop.h>
inherit CRAFT_SHOP_INHERIT;

#define READ_PAGE_PROPERTY "browse page"

int browse_pages(object *obs);
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables);
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables);

/** @ignore yes */
void init() {
   string storeroom;

   ::init();
   storeroom = file_name(query_controller()->query_sell_list());
   add_command("browse", "page of <indirect:object:" + storeroom + ">",
               (: browse_pages($1) :) );
   set_extra_sell_check((: choose_which_page :));
} /* init() */

/**
 * This is like a normal browse, but it allows us to look at specific pages
 * in the book.
 * @param number the page number to browse
 * @param obs the objects whose pages to browse
 * @return 0 on failure, 1 on success
 */
int browse_pages(object *obs) {
   object *real_obs;
   object ob;
   int number;
   string mess;
   string read;
   object *no_pages;
   object *ok;
   int i;

   // Check to make sure the shop is open.
   if (!check_open(this_player(), "browse")) {
      return 0;
   }

   real_obs = query_controller()->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse page$P$";
   no_pages = ({ });
   ok = ({ });
   for (i = 0; i < sizeof(obs); i++) {
      ob = real_obs[i];
      number = ob->query_property(READ_PAGE_PROPERTY);
      if (undefinedp(number)) {
         number = random(ob->query_num_pages() - 1) + 1;
         ob->add_property(READ_PAGE_PROPERTY, number);
         query_controller()->update_craft_object(obs[i], real_obs[i]);
      }
      if (number > ob->query_num_pages()) {
         no_pages += ({ ob });
      } else {
         ob->set_open_page(number);
         mess += ob->the_short() + ":\n" + ob->long();
         read = ob->query_readable_message();
         if (read) {
            mess += "You read " +
                    replace(ob->query_read_short(this_player()), "$name$",
                            ob->a_short()) + ":\n" +
                    ob->query_readable_message();
         }
         ok += ({ ob });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess(({ mess, "$N browses a page of $I.\n" }), ok);
      return 1;
   } else {
      add_failed_mess("There are not enough pages in $I to open to " +
                      " page " + number + ".\n", no_pages);
      return 0;
   }
} /* browse_pages() */

/**
 * This method gets the player to choose a page to allow to browse
 * @param end_func the function to evaluate when finished
 * @param value the value of the sellables
 * @param name the name to sell the object for
 * @param sellables the objects to sell
 */
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables) {
   write("Which page of " + query_multiple_short(sellables) + 
         " would you like to let people browse (0 for the cover only)? ");
   input_to((: finish_choose :), 0, end_func, value, name, sellables);   
} /* choose_which_page() */

/**
 * This finishes the choose page thingy.
 */
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables) {
   int page;
   object *invalid;

   if (page_num == "quit" ||
       page_num == "q") {
      write("Aborting sale.\n");
      return ;
   }
   if (sscanf(page_num, "%d", page) != 1) {
      write("Need to actually enter a number.\n");
      write("Which page of " + query_multiple_short(sellables) + 
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   if (page < 0) {
      write("Need to specify a page number greator than zero.\n");
      write("Which page of " + query_multiple_short(sellables) + 
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;      
   }
   invalid = filter(sellables, (: $1->query_num_pages() < $(page) :) );
   if (sizeof(invalid)) {
      write("Page Number " + page + " is larger the number of pages in " +
            query_multiple_short(invalid) + ".\n");
      write("Which page of " + query_multiple_short(sellables) + 
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;      
   }
   sellables->add_property(READ_PAGE_PROPERTY, page);
   sellables->set_open_page(0);
   evaluate(end_func, value, name, sellables);
} /* finish_choose() */
// --- END [/mnt/home2/grok/lib/std/shops/book_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/pub_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/pub_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629685   Available: 13577039
Inodes: Total: 5242880    Free: 4960136
2028 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/pub_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629685   Available: 13577039
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Based on the original "pub.c" code, this version allows you to buy an
 * actual drink (inna glass) instead of just forcefeeding you with whatever
 * you purchase.  You can also create food and serve it on plates, in boxes,
 * or whatever.
 * <p>
 * The items on sale are either cloned from the armoury, cloned from a file
 * or cloned in the "create_item()" code in the pub code itself.  Containers
 * for these items are done in the same way, using the "create_container()"
 * function.  This is the same as the "create_object()" system in
 * "item_shop.c".  You can also buy items for other people (or groups of
 * other people) in the pub.
 * <p>
 * There are several standard glasses and plates available for drinks and
 * food in the "pub_shop.h" header file, if you don't want to create the
 * glasses and plates yourself.  These plates use the "/obj/misc/plate.c"
 * inheritable file.
 * <p>
 * A "counter" will automatically be placed in the pub.  If any item cannot
 * be moved into the person who ordered it (i.e they are carrying too much )
 * it will be placed on the counter.  Empty glasses and so on will be
 * cleared from the counter after 3 seconds.  To ensure that this happens,
 * make sure that the container object you use has the property "pub item"
 * added to it.  Items will only be cleared if they are empty.
 * @author Lemming
 * @started 23/10/1999
 * @see /std/shops/inherit/pub.c
 * @see /include/shops/pub_shop.h
 * @see /include/volumes.h
 *
 * Added help file as requested by Gin on August 2001
 */

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/pub";

/** @ignore */
void create() {
   add_help_file("pub_shop");
   do_setup++;
   basic_room::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   
   }

} /* create() */

/** @ignore */
void init() {
   basic_room::init();
   pub::init();
} /* init() */

/** @ignore */
void dest_me() {
   pub::dest_me();
   basic_room::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/pub_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/print_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/print_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629684   Available: 13577038
Inodes: Total: 5242880    Free: 4960136
36665 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/print_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629684   Available: 13577038
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A printing workshop so that players can create their own books runs.
 * <P>
 * This can be divided up into two rooms, an office (where you pay for
 * the printing to be done) and a collection room (where you do the collection).
 * To enable this behaviour the collection room needs to know about the
 * office.  The office stores all the information, so you call
 * set_office_room(room_path); on the collection room and
 * set_no_collection() on the office.
 *
 * @author Pinkfish
 * @started Thu Jan 29 17:55:47 CST 1998
 * @see set_office_room()
 * @see set_no_collection();
 */

#include <language.h>
#include <money.h>
#include <book_handler.h>

inherit "/std/room/basic_room";


#define COPYRIGHT_NUMBER 3

nosave mixed *discount_schedule;
mapping collectables;
int current_save_number;
nosave int letter_cost;
nosave int time_to_collect;
nosave int time_per_copy;
nosave string save_dir;
nosave string office_room;
nosave int no_collection;
nosave function open_func;
nosave string default_language;
nosave mapping translation_costs;
nosave string print_shop_name;

#define SCHEDULE_NUM 1
#define SCHEDULE_PERCENTAGE 0

#define COLLECT_TIME 0
#define COLLECT_NUM  1
#define COLLECT_OB_NAME 2
#define COLLECT_LANGUAGE 3
#define COLLECT_AUTO_LOAD_NUM 4
#define COLLECT_ARR_SIZE 5

#define BINDING_COST 600
// This is the cost for every 10 letters.
#define DEFAULT_LETTER_COST 1
#define DEFAULT_TIME_TO_COLLECT (8*60*60)
#define DEFAULT_TIME_PER_COPY (20*60)

/* 100 copies.  Wheee... */
#define MAX_NUMBER 30

int price_object(object ob, int num, string language);
protected int do_print_copies(object *obs, int num, string language);
protected int do_print(object *obs, string language);
protected int do_claim(object *obs);
protected int do_collect();
void do_print_run(object ob, int number, int cost, string language);
void print_pricing(object ob, string language);
void remove_print_run(string name, mixed *info);
mixed *query_print_run(string name);
void add_print_run(string name, object ob, int number, string language);
void load_it();
void save_it();
string query_print_shop_name();
string query_static_auto_load_info(int num);
mapping query_dynamic_auto_load_info(int num);
protected int add_auto_load_info(string static, string dynamic);
private object create_fly_leaf(object book, string language);
private void remove_auto_load_info(int num);

void create() {
   letter_cost = DEFAULT_LETTER_COST;
   time_to_collect = DEFAULT_TIME_TO_COLLECT;
   time_per_copy = DEFAULT_TIME_PER_COPY;
   collectables = ([ ]);
   discount_schedule = ({ ({ 100, 5 }),
                          ({ 95, 10 }),
                          ({ 90, 20 }),
                          ({ 80, 101 }) });
   default_language = "common";
   translation_costs = ([ ]);
   print_shop_name = "Rabbits happy little printing press";
   ::create();
   load_it();
   add_help_file("print_shop");
} /* setup() */

/** @ignore yes */
void init() {
   string languages;

   if (!office_room) {
      add_command("print", "<indirect:object>",
                   (: do_print($1, default_language) :));
      add_command("print", "<number> [copies] of <indirect:object>",
                      (: do_print_copies($1, $4[0], default_language) :) );
      add_command("claim", "copyright on <indirect:object>", (: do_claim :));
      if (sizeof(translation_costs)) {
         /* If there are some languages we can translate to. */
         languages = implode(keys(translation_costs) + ({ default_language }), "|");
         add_command("print", "<indirect:object> in {" + languages + "}",
                   (: do_print($1, $4[1]) :));
         add_command("print", "<number> [copies] of <indirect:object> in "
                              "{" + languages + "}",
                         (: do_print_copies($1, $4[0], $4[2]) :) );
      }
   }
   if (!no_collection) {
      add_command("collect", "", (: do_collect :));
   }
} /* init() */

/**
 * This method checks to make sure that the player is the correct holder
 * of the copyright and that the book is still copyright.
 * @param book the book to check
 * @return 1 if it is copyright
 */
protected int is_copyright(object book) {
  if (BOOK_HANDLER->check_book_same(book, book->query_book_num())) {
     return 1;
  }
  return 0;
} /* is_copyright() */

/**
 * This method returns the current copyright holder of the object.
 * @param book the book to get the copyright of
 * @return the name of the copyright holder, 0 if none
 */
protected string copyright_holder(object book) {
   return BOOK_HANDLER->query_book_owner(book->query_book_num());
} /* copyright_holder() */

/**
 * This method sets up the copyright for the objects.  This will check for
 * existing copyright status and then check with the book handler to see
 * if it still fits the criteria.  If it does not then it will add itself
 * as a new book.
 * @param obs the objects to claim copyright on
 */
protected int do_claim(object *obs) {
   object ob;
   object *already_copyright;
   object *new_copyright;
   object *cannot_copyright;
   string name;
   string place;
   int value;
   int player_money;

   already_copyright = ({ });
   new_copyright = ({ });
   cannot_copyright = ({ });
   name = this_player()->query_name();
   foreach (ob in obs) {
      if (!ob->query_book()) {
         cannot_copyright += ({ ob });
      } else if (is_copyright(ob)) {
         already_copyright += ({ ob });
      } else {
         new_copyright += ({ ob });
      }
   }

   if (!sizeof(new_copyright)) {
      if (sizeof(cannot_copyright)) {
         add_failed_mess("You cannot copyright $I.\n", cannot_copyright);
      }
      if (sizeof(already_copyright) == 1) {
         add_failed_mess("$I is copyrighted.\n",
                         already_copyright);
      } else {
         add_failed_mess("$I are copyrighted.\n",
                         already_copyright);
      }
      return 0;
   }

   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }

   /* Otherwise we will try for the new copyright value on these guys. */
   value = 0;
   foreach (ob in new_copyright) {
      value += price_object(ob, COPYRIGHT_NUMBER, default_language);
   }

   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }

   write("It will cost you " + MONEY_HAND->money_value_string( value, place ) +
         " to make " + query_multiple_short(new_copyright) + 
         " copyright.\n");
   if (player_money > value) {
      write("Do you wish to continue? ");
      input_to("check_copyright", 0, new_copyright, value);
   } else {
      write("Although you do not currently have enough money.\n");
   }
   add_succeeded_mess( ({ "", "$N enquires about copyrighting $I.\n" }),
                       new_copyright);
   return 1;
} /* do_claim() */

/** @ignore yes */
protected void check_copyright(string str, object *new_copyright, int value) {
   int new_num;
   object ob;
   string place;

   if (!strlen(str) || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, never mind.  See you again soon.\n");
      return ;
   }

   /* Make them pay for it. */
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               value, place ), place );

   /* Add the books to the book handler. */
   foreach (ob in new_copyright) {
      new_num = BOOK_HANDLER->add_book(ob, 0, this_player()->query_name());
      ob->set_book_num(new_num);
      ob->add_property(BH_COPYRIGHT, this_player()->query_name());
   }
   write("Ok, added " + query_multiple_short(new_copyright) +
         " as a copyright book.\n");
} /* check_copyright() */

/**
 * This is when the player comes back to collect the book they have
 * printed.
 * @return 1 on success, 0 on failure
 */
protected int do_collect() {
   object new_ob;
   object page;
   object fly_leaf;
   int i;
   int j;
   int number;
   int no_printed;
   string ob_name;
   mixed static_arg;
   mixed dynamic_arg;
   string language;
   mixed *info;
   mixed *stuff;
   mixed *collectables;
   mixed room;
   int auto_load_num;

   if (open_func) {
      if (!evaluate(open_func)) {
         return 0;
      }
   }

   if (office_room) {
      room = office_room;
   } else {
      room = this_object();
   }
   collectables = room->query_print_run(this_player()->query_name());
   if (!collectables) {
      add_failed_mess("No books available for collection.\n");
      return 0;
   }

   /* Ok, now see if they have waited long enough. */
   no_printed = 0;
   foreach (info in collectables) {
      if (time() < info[COLLECT_TIME]) {
         add_failed_mess("You need to wait until " +
                         amtime(info[COLLECT_TIME]) +
                         " to collect your book.\n");
         continue;
      }
   
      /* Ok, they are here.  Whoo.  Lets do it. */
      auto_load_num = info[COLLECT_AUTO_LOAD_NUM];
      static_arg = room->query_static_auto_load_info(auto_load_num);
      dynamic_arg = room->query_dynamic_auto_load_info(auto_load_num);
      ob_name = info[COLLECT_OB_NAME];
      number = info[COLLECT_NUM];
      language = info[COLLECT_LANGUAGE];

      /* Remove the run now... */
      if (office_room) {
         office_room->remove_print_run(this_player()->query_name(), info);
      } else {
         remove_print_run(this_player()->query_name(), info);
      }

      /* First create ourselves a book. */
      new_ob = clone_object(ob_name);
      if (static_arg) {
         new_ob->init_static_arg(static_arg);
      }
      if (dynamic_arg) {
         new_ob->init_dynamic_arg(dynamic_arg);
      }

      /* Close the book first. */
      new_ob->set_open_page(0);

      /* Add in the fly leaf and fix the languages. */
      for (j = 0; j < new_ob->query_num_pages(); j++) {
         if (j > 0) {
            page = new_ob->query_selected_page(j);
         } else {
            new_ob->set_open_page(0);
            page = new_ob;
         }

         /* See if we have a fly leaf... */
         if (j == 1) {
             fly_leaf = create_fly_leaf(new_ob, language);
             if (page->query_property(BH_IGNORE_PAGE)) {
                /* Replace it with our one... */
                new_ob->replace_page_with(fly_leaf, j);
             } else {
                /* Add a new page. */
                new_ob->add_page_after(fly_leaf, j - 1);
             }
             page = new_ob->query_selected_page(j + 1);
         }

         /* Fix up the language for all the messages. */
         stuff = page->query_read_mess();
         foreach (info in stuff) {
            if (info[READ_LANG] != language) {
               /*
                * Hopefully this allows the evil array changing stuff
                * to occur...
                */
               info[READ_LANG] = language;
            }
         }
         page->set_read_mess(stuff);
      }
   
      static_arg = new_ob->query_static_auto_load();
      dynamic_arg = new_ob->query_dynamic_auto_load();
      /* Kill the sample one. */
      new_ob->dest_me();

      for (i = 0; i < number; i++) {
         new_ob = clone_object(ob_name);
         new_ob->set_player(this_player());
         if (static_arg) {
            new_ob->init_static_arg(static_arg, this_player());
         }
         if (dynamic_arg) {
            new_ob->init_dynamic_arg(dynamic_arg, this_player());
         }
   
         new_ob->move(this_object());
      }

      if (number > 1) {
         write("Ok, your " + query_num(number, 1000) + " copies of " +
               new_ob->the_short() +
               " have been placed on the floor here.\n");
      } else {
         write("Ok, your copy of " + new_ob->the_short() +
               " has been placed on the floor here.\n");
      }
      no_printed++;
   }
   return no_printed;
} /* do_collect() */

private object create_fly_leaf(object book, string language) {
    object page;

    page = book->create_default_page_object();
    if (is_copyright(book)) {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n\nCopyright " + 
                             this_player()->query_name(), 0,
                             language);
    } else {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n", 0,
                             language);
    }
    page->add_property(BH_IGNORE_PAGE, 1);
    return page;
} /* create_fly_leaf() */

/**
 * Checks to see if the object has any magic writing on it.
 * @return 1 if there is magic writing, 0 if not.
 * @see find_book_or_paper()
 * @see /obj/handlers/language->query_language_magic()
 */
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;

   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
} /* check_for_magic_writing() */

/**
 * Checks to see if the book contains a language we cannot translate.
 * @param ob the book to check for languages
 * @return 1 if there is a language we cannot deal with
 * @see check_magic_writing()
 * @see find_book_or_paper()
 * @see set_default_language()
 * @see add_translation_cost()
 */
int check_for_untranslatable_language(object ob) {
   mixed *stuff;
   int i;
   string lang;

   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      lang = stuff[i][READ_LANG];
      if (lang != default_language &&
          !translation_costs[lang]) {
         return 1;
      }
   }
   return 0;
} /* check_for_untranslatable_language() */

/**
 * This method finds a single book or piece of paper to work on.  It will
 * return 0 if multiple objects are found, or none are found.  It will
 * set the error message appropriately.
 * @param obs the objects to check for a book or paper
 * @return the book or paper found
 * @see check_magic_writing()
 */
object find_book_or_paper(object *obs) {
   object *paper;
   object *books;
   object *magic;
   object *torn_out;
   object *nothing;
   object ob;
   int page;
   int old_page;
   string owner;

   paper = ({ });
   books = ({ });
   magic = ({ });
   torn_out = ({ });
   nothing = ({ });
   foreach (ob in obs) {
      owner = copyright_holder(ob);
      if (is_copyright(ob) && owner != this_player()->query_name()) {
         add_failed_mess("$I has been copyrighted by " + owner +
                         " and cannot be copied.\n", ({ ob }));
      } else if (ob->query_book()) {
         if (ob->query_spell_book()) {
            magic += ({ ob });
         } else {
            /* Check to see if it has any magic writting... */
            old_page = ob->query_open_page();
            for (page = 0; page <= ob->query_num_pages(); page++) {
               ob->set_open_page(page);
               if (ob->is_current_page_torn_out()) {
                  torn_out += ({ ob });
                  break;
               }
               if (check_for_magic_writing(ob)) {
                  magic += ({ ob });
                  break;
               }
            }
            ob->set_open_page(old_page);
            if (page == ob->query_num_pages() + 1) {
               books += ({ ob });
            }
         }
      } else if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      } else {
         nothing += ({ ob });
      }
   }

   if (sizeof(magic)) {
      add_failed_mess("$I have magic writing in them and cannot be copied.\n",
                      magic);
   }

   if (sizeof(torn_out)) {
      add_failed_mess("$I have pages torn out and cannot be copied.\n",
                      torn_out);
   }

   if (!sizeof(books) && !sizeof(paper)) {
      if (sizeof(nothing)) {
         add_failed_mess("Unable to print $I as they are not a book or paper.\n", nothing);
      }
      return 0;
   }

   if (sizeof(books + paper) > 1) {
      add_failed_mess("Can only do print one book or piece of paper at a time.  "
                  "Please be more specific and choose from " +
                  query_multiple_short(books + paper) + ".\n");
      return 0;
   }

   if (sizeof(books) > 0) {
      return books[0];
   }
   return paper[0];
} /* find_book_or_paper() */

/**
 * This method will be called by the print add_command.  It will print out
 * the pricing schedule and how long the item will take to make.
 * @param obs the objects which have been matched
 * @param language the language to print the book in
 * @return 1 on success, 0 on failure
 * @see do_print_copies()
 */
int do_print(object *obs, string language) {
   object ob;

   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }

   /* Ok, now we have our book or bit of paper... */
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }

   print_pricing(ob, language);
   write("Use: print <number> of <book>\n");
   add_succeeded_mess(({ "",
                       "$N enquires about the cost of printing a book.\n" }));
   return 1;
} /* do_print() */

/**
 * This method will be called when the player tries to print a certain
 * number of copies of a book.
 * @param obs the objects which have been matched
 * @param number the number of prints to do
 * @param language the language to print the book in
 * @return 1 on success, 0 on failure
 * @see do_print()
 */
int do_print_copies(object *obs, int number, string language) {
   object ob;
   int cost;
   int player_money;
   string place;

   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }

   if (number < 1) {
      add_failed_mess("Must print at least one copy.\n", obs);
      return 0;
   }

   if (number > MAX_NUMBER) {
      add_failed_mess("Cannot print more than " + MAX_NUMBER +
                      " copies.\n", obs);
      return 0;
   }

   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
 
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }

   cost = price_object(ob, number, language);

   /* Check to see if they can afford it. */
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }

   if (player_money < cost) {
      add_failed_mess("This will cost you " + 
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) + " and you do not have enough "
                  "money to afford it.\n", ({ ob }));
      return 0;
   }

   if (is_copyright(ob)) {
      write("NOTE:  You are printing a copyright document.\n");
   } else {
      write("NOTE:  Please use 'claim copyright' to claim copyright "
            "on a document.\n");
   }

   add_succeeded_mess(({ "This will cost you " +
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) +
                       " to do, do you wish to continue? ",
                       "$N starts to do some printing.\n" }));

   input_to("check_cost", 0, ob, number, cost, language);

   return 1;
} /* do_print_copies() */

/** @ignore yes */
void check_cost(string str, object ob, int number, int cost, string language) {
   if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, don't worry.  See you again.\n");
      return ;
   }
   do_print_run(ob, number, cost, language);
} /* check_cost() */

/**
 * This method does the actual print run.  It creates all the objects
 * and makes the player pay for them all.
 * @param ob the object to print
 * @param number the number to print
 * @param cost the cost of the object
 * @param the language to translate things to
 * @see do_print_copies()
 */
void do_print_run(object ob, int number, int cost, string language) {
   string place;
   int player_money;
   mixed *stuff;

   /* Does the print run...  First we make the players pay! */
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }

   /* Check to see if they can afford it. */
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }

   if (player_money < cost) {
      write("You do not seem to have enough money any more.\n");
      return ;
   }

   /* Get them to give us the money first :) */
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );

   add_print_run(this_player()->query_name(),
                 ob,
                 number,
                 language);

   stuff = query_print_run(this_player()->query_name());
   if (no_collection) {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion at the "
            "collection office.\n");
   } else {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion.\n");
   }
} /* do_print_run() */

/**
 * Figure out how much this object will cost to make.
 * @param ob the object to price
 * @param num the number of them to print
 * @return the cost of the item
 */
int price_object(object ob, int num, string to_language) {
   int i;
   int num_letters;
   int multiplier;
   int cost;
   mixed *stuff;

   if (num <= 0 || !ob) {
     return 0;
   }

   /* If it is a book, make sure we count the title... */
   ob->set_open_page(0);
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      /* Figure out how many letters we have. */
      num_letters += strlen(stuff[i][READ_MESS]);
      if (stuff[i][READ_LANG] != default_language) {
         cost = translation_costs[stuff[i][READ_LANG]];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
      if (to_language != default_language) {
         cost = translation_costs[to_language];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
   }

   cost = ob->query_value() + (num_letters / 10) * letter_cost;

   if (ob->query_book()) {
      for (i = 1; i < ob->query_num_pages(); i++) {
         ob->set_open_page(i + 1);
         if (ob != ob->query_current_page()) {
            cost += price_object(ob->query_current_page(), 1, to_language);
         }
      }
      /* Plus cost for binding and stuff... */
      cost += BINDING_COST;
   }

   /* Ok, find the costing stuff... */
   multiplier = 200;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      if (num < discount_schedule[i][SCHEDULE_NUM]) {
         multiplier = discount_schedule[i][SCHEDULE_PERCENTAGE];
      }
   }

   return (cost * num * multiplier) / 100;
} /* price_object() */

/**
 * This method will print out the pricing schedule for the object.
 * @param ob the object to get a pricing schedule of.
 */
void print_pricing(object ob, string language) {
   int i;
   int num;
   string place;
   int cost;

   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }

   /*
    * This is the cost for one of them...  We do discounts if they
    * print a bunch.
    */
   write("The cost for the different numbers of " + ob->the_short() + " is:\n");
   write("  1 for " + (string)MONEY_HAND->money_value_string(
                    price_object(ob, 1, language), place ) +
                    " and will be ready at " +
                    amtime(time_to_collect + time_per_copy + time()) + ".\n");;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      num = discount_schedule[i][SCHEDULE_NUM];
      if (num < MAX_NUMBER) {
         write(sprintf("%3d for %s and will be ready at %s.\n", num,
                       (string)MONEY_HAND->money_value_string(
                       price_object(ob, num, language), place ),
                       amtime(time_to_collect + time_per_copy * num + time()) ));
      }
   }

   if (sizeof(translation_costs)) {
      write("You can translate a book to or from " +
            query_multiple_short(keys(translation_costs) + ({ default_language })) +
            ", the cost of doing the translation is defined in the "
            "following table.");
      if (sizeof(translation_costs) > 2) {
         write("  Translating between two of these languages "
               "is also possible, but it will cost the amount to translate "
               "from the language to " + default_language + " and back again.");
      }
      write("\n");
      foreach (language, cost in translation_costs) {
         write(sprintf("   %3d%% %s", cost, language));
      }
      write("\n");
   }
} /* print_pricing() */

/**
 * This method returns the discount schedule.  There is a default discount
 * schedule setup for printing shops.  The discount schedule tells how much
 * of a discount you get for certain numbers of a run.  It returns
 * an array of the form:
 * <pre>
 * ({ ({ numn1, dis1 }), ({ num2, dis2}), ... })
 * </pre>
 * Where each number is the discount amount for printing less than that
 * number of items.  The array must be sorted from the lowest number to
 * the highest number.
 * @return the discount schedule
 * @see set_discount_schedule()
 */
mixed *query_discount_schedule() {
   return discount_schedule;
} /* query_discount_schedule() */

/**
 * Sets the discount schedule for this object.  See the query_discount_schedule
 * help for the format of the array.
 * @param value the new discount schedule.
 * @see query_discount_schedule()
 */
void set_discount_schedule(mixed *value) {
   discount_schedule = value;
} /* set_discount_schedule() */

/**
 * This queries the cost per letter.
 * @return the cost per letter
 * @see set_letter_cost()
 * @see print_cost()
 */
int query_letter_cost() {
   return letter_cost;
} /* query_letter_cost() */

/**
 * This queries the cost per letter.
 * @param value the new cost per letter
 * @see query_letter_cost()
 * @see print_cost()
 */
void set_letter_cost(int value) {
   letter_cost = value;
} /* query_letter_cost() */

/**
 * This adds an object into the current set to be collected.  This handles
 * figuring out the nice number to use for the static and dynamic save
 * numbers.
 * @param name the name of the person adding the run
 * @param ob the object being added
 * @param cost the cost of the object
 * @param number the number to be printer
 * @see do_collect()
 * @see query_print_run()
 */
void add_print_run(string name, object ob, int number, string language) {
   mixed *arr;
   int num;

   if (!collectables[name]) {
      collectables[name] = ({ });
   }
   arr = allocate(COLLECT_ARR_SIZE);
   arr[COLLECT_TIME] = time() + time_to_collect + time_per_copy * number;
   arr[COLLECT_NUM] = number;
   arr[COLLECT_LANGUAGE] = language;
   arr[COLLECT_OB_NAME] = base_name(ob);
   num = add_auto_load_info(ob->query_static_auto_load(),
                             ob->query_dynamic_auto_load());
   arr[COLLECT_AUTO_LOAD_NUM] = num;
   collectables[name] += ({ arr });
   save_it();
} /* add_print_run() */

/**
 * This method returns the array of documents awaiting collection.  If there
 * are not documents this returns 0.
 * @param name the player to query
 * @return an array containing the player information, or 0 if none
 * @see add_print_run()
 * @see /include/print_shop.h
 */
mixed *query_print_run(string name) {
   return collectables[name];
} /* query_print_run() */

/**
 * This method will remove a players print run.
 * @param name the player whose print run is to be removed.
 * @see query_print_run()
 * @see add_print_run()
 */
void remove_print_run(string name, mixed *info) {
   int index;

   if (collectables[name]) {
      index = member_array(info, collectables[name]);
      if (index != -1) {
         /* Remove the save files... */
         remove_auto_load_info(info[COLLECT_AUTO_LOAD_NUM]);
         collectables[name] = collectables[name][0.. index - 1] +
                              collectables[name][index + 1..];
         if (!sizeof(collectables[name])) {
            map_delete(collectables, name);
         }
         save_it();
      }
   }
} /* remove_print_run() */

/**
 * This method saves the autoload information out to a file and returns
 * the number associated with the file.
 * @param static_arg the static auto load information
 * @param dynamic_arg the dynamic auto load information
 * @return the number associated with the save files
 */
protected int add_auto_load_info(string static, string dynamic) {
   int num;

   num = current_save_number;
   while (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      num++;
   }
   current_save_number = num + 1;
   unguarded( (: write_file(save_dir + "/" + $(num),
                            save_variable( ({ $(static), $(dynamic) }) ) +
                            "\n") :) );
   return num;
} /* add_auto_load_info() */

/**
 * This method removes the files associated with the auto load information.
 * @param num the auto load number
 */
private void remove_auto_load_info(int num) {
   unguarded( (: rm(save_dir + "/" + $(num) ) :) );
} /* remove_auto_load_info() */

/**
 * This method returns static the autoload information associated with the
 * file.
 * @param num the number associated with the information
 * @return the static auto load string, 0 if none
 */
string query_static_auto_load_info(int num) {
   string *arr;
   string tmp;

   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[0];
      }
   }
   return 0;
} /* query_static_auto_load_info() */

/**
 * This method returns dynamic the autoload information associated with the
 * file.
 * @param num the number associated with the information
 * @return the dynamic auto load string, 0 if none
 */
mapping query_dynamic_auto_load_info(int num) {
   mixed arr;
   string tmp;
 
   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[1];
      }
   }
   return 0;
} /* query_static_auto_load_info() */

/**
 * Sets the save file name.
 * @param name the name of the save file
 * @see query_save_dir()
 * @see load_it()
 * @see save_it()
 */
void set_save_dir(string name) {
   save_dir = name;
} /* set_save_dir() */

/** 
 * Returns the save file name
 * @return save file name
 * @see set_save_dir()
 * @see load_it()
 * @see save_it()
 */
string query_save_dir() {
   return save_dir;
} /* query_save_dir() */

/**
 * Loads the saved information off the disc.
 * @see set_save_dir()
 * @see save_it()
 */
void load_it() {
   if (save_dir) {
      unguarded((: restore_object(save_dir + "/main") :));
      if (!collectables) {
         collectables = ([ ]);
      }
   }
} /* load_it() */

/**
 * Saves the information to the disc.
 * @see set_save_dir()
 * @see load_it()
 */
void save_it() {
   if (save_dir) {
      unguarded((: save_object(save_dir + "/main") :));
   }
} /* save_it() */

/**
 * Sets the office room to which this collection room is associated.  If
 * this is set on a room, you cannot setup print jobs in the room and this
 * room specified here is queried for the information about the jobs to
 * collect.
 * @param room the new office room
 * @see query_office_room()
 * @see set_no_collection()
 */
void set_office_room(string room) {
   office_room = room;
} /* set_office_room() */

/**
 * Returns the current office room associated with this room.
 * @return the current office room
 * @see set_office_room()
 * @see query_no_collection()
 */
string query_office_room() {
   return office_room;
} /* query_office_room() */

/**
 * This sets the no collection flag.  It makes it so this room cannot be
 * used for collections.  If this is set then there should be an associated
 * collection room used to pick up the books from.  This room should
 * use the set_office_room() function to set the office room to use
 * for the collections.
 * @param collect the new value of no_collections flag
 * @see query_no_collection()
 * @see set_office_room()
 */
void set_no_collection(int collect) {
   no_collection = collect;
} /* set_no_collection() */

/**
 * This returns the no collection flag used by the room.
 * @return the no collection flag
 * @see set_no_collection()
 * @see query_office_room()
 */
int query_no_collection() {
   return no_collection;
} /* query_no_collection() */

/**
 * This method sets the function to evaluate to check to see if the shop
 * is open or not.  This should set any error messages which are needed.
 * The objects are passed in as an argument in the do_print functions
 * and nothing is passed in for the collection check.
 * @param func the open function
 * @see query_open_func()
 * @see do_print()
 * @see do_print_copies()
 * @see do_collect()
 */
void set_open_func(function func) {
   open_func = func;
} /* set_open_func() */

/**
 * This method returns the current function which is used to check for
 * the openness of the shop.
 * @see set_open_func()
 * @return the current open function
 */
function query_open_func() {
   return open_func;
} /* query_open_func() */

/**
 * This method sets the default language to use in the print shop.
 * Anything written in this language will cost nothing extra to
 * duplicate.
 * @param lang the new default language
 * @see query_default_language()
 * @see add_translation_cost()
 * @see check_for_untranslatable_language()
 */
void set_default_language(string lang) {
   default_language = lang;
} /* set_default_language() */

/**
 * This method will return the current default language for the
 * print shop.
 * @return the current default language
 * @see set_default_language()
 * @see add_translation_cost()
 * @see check_for_untranslatable_language()
 */
string query_default_language() {
   return default_language;
} /* query_default_language() */

/**
 * This method will add the cost to translate from one language to
 * another.  The default is translating to the common language and
 * this cost will be used in both directions.  ie: the cost of translating
 * from djelian to common is the same as translating from common to
 * djelian.  If translating between two languages that are not the
 * default language, say the default is common and we want to translate
 * from djelian to wombat, then the cost from djelian->common and then
 * common->wombat will be used.
 * @param lang the language to set the translation cost of
 * @param cost the cost is in percentage, 200 means twice the price
 * @see set_default_language()
 * @see remove_translation_cost()
 * @see query_all_translation_costs()
 */
void add_translation_cost(string lang, int cost) {
   translation_costs[lang] = cost;
} /* add_translation_cost() */

/**
 * This method will remove the translation cost for a specific language.
 * @param lang the language to remove the translation cost of
 * @see set_default_language()
 * @see add_translation_cost()
 * @see query_all_translation_costs()
 */
void remove_translation_cost(string lang) {
   map_delete(translation_costs, lang);
} /* remove_translation_cost() */

/**
 * This method will return a mapping of all the translation costs.
 * The keys are the languages and the values are the costs in terms
 * of percentages.
 * @return the current translation cost mapping
 * @see add_translation_cost()
 * @see remove_translation_cost()
 */
mapping query_all_translantion_costs() {
   return translation_costs;
} /* query_all_translation_costs() */

/**
 * This method sets the name of the print shop which will be used on
 * books when they are printed.  This is only needed in the collection
 * room, this is the name that is placed on the fly leaf.
 * @param name the name of the print shop
 */
void set_print_shop_name(string name) {
   print_shop_name = name;
} /* set_print_shop_name() */

/**
 * This method will return the current name of the print shop.
 * @return the name of the print shop
 */
string query_print_shop_name() {
   return print_shop_name;
} /* query_print_shop_name() */
// --- END [/mnt/home2/grok/lib/std/shops/print_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/item_shop_close.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/item_shop_close.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629675   Available: 13577029
Inodes: Total: 5242880    Free: 4960136
305 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/item_shop_close.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629675   Available: 13577029
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the general inheritable to make an item shop that will close
 * at night.
 * @author Rodion
 * Fri Oct 13 19:38:02 PDT 2000
 */
inherit "/std/shops/item_shop";
inherit "/std/shops/inherit/store_close";

/** @ignore  done to stop the thing being replaced */
void womble() {
} /* womble() */
// --- END [/mnt/home2/grok/lib/std/shops/item_shop_close.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/pub_shop_outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/pub_shop_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629675   Available: 13577029
Inodes: Total: 5242880    Free: 4960136
2016 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/pub_shop_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629675   Available: 13577029
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Based on the original "pub.c" code, this version allows you to buy an
 * actual drink (inna glass) instead of just forcefeeding you with whatever
 * you purchase.  You can also create food and serve it on plates, in boxes,
 * or whatever.
 * <p>
 * The items on sale are either cloned from the armoury, cloned from a file
 * or cloned in the "create_item()" code in the pub code itself.  Containers
 * for these items are done in the same way, using the "create_container()"
 * function.  This is the same as the "create_object()" system in
 * "item_shop.c".  You can also buy items for other people (or groups of
 * other people) in the pub.
 * <p>
 * There are several standard glasses and plates available for drinks and
 * food in the "pub_shop.h" header file, if you don't want to create the
 * glasses and plates yourself.  These plates use the "/obj/misc/plate.c"
 * inheritable file.
 * <p>
 * A "counter" will automatically be placed in the pub.  If any item cannot
 * be moved into the person who ordered it (i.e they are carrying too much )
 * it will be placed on the counter.  Empty glasses and so on will be
 * cleared from the counter after 3 seconds.  To ensure that this happens,
 * make sure that the container object you use has the property "pub item"
 * added to it.  Items will only be cleared if they are empty.
 * @author Lemming
 * @started 23/10/1999
 * @see /std/shops/inherit/pub.c
 * @see /include/shops/pub_shop.h
 * @see /include/volumes.h
 *
 * Added help file as requested by Gin on August 2001
 */

inherit "/std/room/outside";
inherit "/std/shops/inherit/pub";

/** @ignore */
void create() {
   add_help_file("pub_shop");
   do_setup++;
   outside::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   
   }

} /* create() */

/** @ignore */
void init() {
   outside::init();
   pub::init();
} /* init() */

/** @ignore */
void dest_me() {
   pub::dest_me();
   outside::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/pub_shop_outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/laundry_entry_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/laundry_entry_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629674   Available: 13577028
Inodes: Total: 5242880    Free: 4960136
4075 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/laundry_entry_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629674   Available: 13577028
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/**
 *  Inherit  : CWC Laundry Entry Inherit 
 *  Author   : Siel
 *  Date     : January 2001
 *
 */
 
#include <money.h>
#include <vault.h>

inherit "/std/room";

#define TIME_LIMIT 500
#define LO laundryowner->the_short()

string location, laundry_room;
int visit_cost;
object laundryowner;

/**
 * This function is used to set the location used for calculation of which
 * currency the laundry owner will accept.
 * @param location The name of the location.
 */
void set_location(string str) { location = str; }
/**
 * This is used to set the cost of a visit to the laundry (in monetary units)
 * @param cost The cost of a vist
 */
void set_visit_cost(int i) { visit_cost = i; }

/**
 * This is the object that is the owner of the laundry. This should be an
 * NPC.
 * @param laundryowner The owner NPC object.
 */
void set_laundryowner(object ob) { laundryowner = ob; }

/**
 * Used to set the exit from the laundry entrance room into the laundry 
 * itself.
 * The parameters are just like those of add_exit.
 * @param direction The direction of the exit.
 * @param dest The destination object. Usually the filename of the destination.
 * @param type An exit type as in add_exit.
 * @return void
 * @see add_exit
 */
void set_laundry_exit(string direc, mixed dest, string type) {
  laundry_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}

int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  
  if(!laundryowner || environment(laundryowner) != this_object())
    return notify_fail("Since the owner of this laundry is missing "
      "you think twice before entering the laundry.\n");
  
  if( !interactive(thing) )
    return 0;

  owner = (string)thing->query_name();
   
  if ( !( vroom = find_object( laundry_room ) ) )  {
      laundry_room->load_me();
      vroom = find_object( laundry_room );
  }
  if(sizeof(filter_array(all_inventory(vroom),
                         (: userp( $1 ) :)))) {
    tell_object(thing, LO + " intercepts you.\n");
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing);

    laundryowner->do_command("say No more than one person at a time in "
      "laundry room.  It can be very dangerous!");
    laundryowner->do_command("emote taps his head implying madness.");
    return notify_fail( "" );
  }
    
  if(query_property(owner)) {
    remove_property(owner);
    tell_object(thing, LO + " opens the round door of the laundry and "
      "signalls you to enter.\n" );
    tell_room(this_object(), LO + " signalls "+
              (string)thing->the_short() +" to enter the laundry through "
                "the small round door of the laundry.\n", thing );
    call_out("check_idler", TIME_LIMIT, thing);
    return 1;
  }
  
  if ( (int)thing->query_value_in( location ) +
       (int)thing->query_value_in( "default" ) < visit_cost ) {
    tell_object( thing, LO + " intercepts you.\n" );
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    
    laundryowner->do_command("say Well... I am but a poor man.  I cannot "
      "just let you use my fine, imp-powered laundry for nothing!\n" );
    laundryowner->do_command("emote sniffs.\n" );
    return notify_fail( "" );
  }
  
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay " + LO + " who signals you to go through "
    "the small, round door of the laundry.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays " + LO + " who signals to "
             + (string)thing->query_objective() + " to move through "
             "a small, round door and enters the laundry.\n", thing );
   
   return 1;
   
} /* check_customer() */

/**
 * @ignore yes
 */
void player_quitting(object who, object env) {
}
// --- END [/mnt/home2/grok/lib/std/shops/laundry_entry_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/potion_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/potion_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629673   Available: 13577027
Inodes: Total: 5242880    Free: 4960136
5564 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/potion_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629673   Available: 13577027
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: potion_shop.c,v 1.6 2000/06/23 11:44:25 terano Exp $
 *
 *
 */

/**
 * @main 
 * This room is a craft shop which handles potions and salves.
 * Do not forget important things like set_save_dir() and
 * set_theft_handler().
 * @index potion_shop
 * @started Thu Oct 29 1998
 * @author Gruper
 * @see help::craft_shop
 */


#define CONVERT "/global/events"->convert_message
#define MIN_VOLUME 1000

inherit "/std/shops/craft_shop_category";

/* Function prototypes */
void shopkeeper_say( string message );
int is_potion_or_salve( object ob );
void set_message_function( function wossname );


/* This is the function that handles messages to the player. */
private nosave function _message_function;

/* If shopkeeper is set, the messages from message_function
 * will come from the shopkeeper. */
private nosave string _shopkeeper;


/**
 * @ignore
 */
void create() {
   set_message_function( (: shopkeeper_say :) );
   ::create();
   set_allowed_to_sell( (: is_potion_or_salve :) );
}

/**
 * This method sets the message function for the shop.
 * The message function can be useful to handle messages to
 * the player via the shopkeeper. The function should be of
 * type string -> void.  If message_function is not set, we
 * default to a rather nice function.  If message_function
 * is explicitly set to 0, no message will be given apart from
 * the standard messages from craft_shop.  It is called from
 * is_potion_or_salve() and can also be used in do_buy() etc.
 * @param wossname A pointer to the function
 * @example set_message_function( (: nudity_say :) ),
 * where nudity_say looks like void nudity_say( string message ).
 * When using
 */
void set_message_function( function wossname ) {
   _message_function = wossname;
}

/**
 * @return Pointer to the message function
 */
function query_message_function() {
   return _message_function;
}


/**
 * This method sets the <b> name </b> of the shopkeeper that
 * the shop will look for when giving messages to the player.
 * @param name A name that identifies the shopkeeper to find_match
 */
void set_shopkeeper( string name ) {
   _shopkeeper = name;
}

/**
 * @return The name of the shopkeeper
 */
string query_shopkeeper() {
   return _shopkeeper;
}


/**
 * This is the default message function.
 * If the shopkeeper is in the shop, they will try to say message.
 */
void shopkeeper_say( string message ) {
   object *frog;  /* the shopkeeper */

   if( !message || message == "" )
      message = "Tuppence a bucket, well stamped down!";

   if( _shopkeeper ) {
      frog = match_objects_for_existence( _shopkeeper, this_object() );
      if( sizeof( frog ) == 1 ) {
         frog[0]->init_command( "' "+ message );
         /* Ok, we managed to give the message through the shopkeeper,
          * so we'll just bugger off. */
         return;
      }
   }

   /* We couldn't find a shopkeeper, so we just write the message.
    * Boring, if you ask me. */
   write( message );
   return;
}


/**
 * This is the default function for checking if something can
 * be sold in a potion shop.  If you override this, there is no
 * reason to inherit this file, so you can't.  It will accept any
 * object that contains something which has an eat effect or an
 * apply effect.
 * @param ob The object that someone is trying to sell to the shop
 * @return success 1 if the object can be sold, 0 if not
 */
int is_potion_or_salve( object ob ) {
   object thing, *contents;
   int found_something; // Impure stuff!
   string contents_string;

   if( !ob->query_volume() ) {
      tell_creator( this_player(), "ob has 0 volume.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "There's nothing in "+ ob->the_short() +" that "
               "can be described as either potion or salve, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   } else if( ob->query_volume() < MIN_VOLUME ||
              ob->query_volume() < ( 7 * ob->query_max_volume() / 10 ) ) {
      tell_creator( this_player(), "ob does not contain enough stuff.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "We don't deal in quantities smaller than a cup, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   }

   contents = all_inventory( ob );
   if( !sizeof( contents ) ) {
      tell_creator( this_player(), "No contents.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( ob->the_short() +" is empty, "+
               this_player()->the_short() +"!\n" ) );
      return 0;
   }

   foreach( thing in contents )
      if( !( sizeof( thing->query_apply_effects() ) +
             sizeof( thing->query_eat_effects() ) ) ) {
         found_something = 1; // Impure
      } else {
         tell_creator( this_player(), "thing %s, effect %O.\n",
                       thing->query_short(), thing->query_eat_effects()  );
      }
   
   contents_string = ( sizeof( contents ) > 1 ) ?
         query_multiple_short( contents, "the" ) +" are neither potions nor "
            "salves, or they are " :
         contents[0]->the_short() +" is neither potion nor salve, or it is ";

   // Found impure stuff
   if( found_something ) {
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "Either "+ contents_string +"impure, or so weak as "
               "to make no difference, "+ this_player()->the_short() +"." ) );
      return 0;
   }

   return 1;
}
// --- END [/mnt/home2/grok/lib/std/shops/potion_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/storeroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629671   Available: 13577025
Inodes: Total: 5242880    Free: 4960136
2120 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629671   Available: 13577025
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <config.h>
#ifndef __DISTRIBUTION_LIB__
#include <thief.h>
#endif

inherit "/std/room/basic_room";

mapping room_cont;
int max_num;
int loot;
mapping shop_type;

void create() {
  room_cont = ([ ]);
  shop_type = ([ ]);
  max_num = 8;
  ::create();
  loot = random(10);
  set_keep_room_loaded(1);
  call_out("test_cont", 1);
} /* create() */

mapping query_room_cont() {
  return room_cont;
} /* query_room_cont() */

int query_max_num() { return max_num; }
void set_max_num(int i) { max_num = i; }

void add_thing(object ob) {
  string shr;

  if (!ob || environment(ob) != this_object())
    return ;
  shr = (string)ob->query_property("shop type");
  if (!shop_type[shr])
    shop_type[shr] = ({ ob });
  else
    shop_type[shr] += ({ ob });
  shr = (string)ob->short();
  if (!room_cont[shr]) {
    room_cont[shr] = ({ ob });
    return ;
  }
  if (sizeof(room_cont[shr]) > max_num)
    call_out("do_dest", 1, ob);
  else
    room_cont[shr] += ({ ob });
  return ;
} /* add_thing() */

/* for updateing etc.... */
void test_cont() {
  int i;
  object *obs;

  obs = all_inventory();
  for (i=0;i<sizeof(obs);i++)
    add_thing(obs[i]);
} /* test_cont() */

void remove_thing(object ob) {
  mixed *arr;
  int i;
  string sh;

  if (!ob || environment(ob) == this_object())
    return ;
  sh = (string)ob->query_property("shop type");
  if (shop_type[sh])
    shop_type[sh] = (object *)shop_type[sh] - ({ ob });
  sh = (string)ob->short();
  if (!room_cont[sh])
    return ;
  arr = room_cont[sh];
  if ((i = member_array(ob, arr)) == -1)
    return ;
  if (sizeof(arr) <= 1) {
    room_cont = m_delete(room_cont, sh);
  } else
    room_cont[sh] = delete(arr, i, 1);
} /* remove_thing() */

void event_enter(object ob, string, object) {
  call_out("add_thing", 1, ob);
} /* event_enter() */

void event_exit(object ob, string mesage, object to) {
  call_out("remove_thing", 1, ob);
} /* event_exit() */

void do_dest( object thing ) {
   if ( !thing )
      return;
   thing->move( "/room/rubbish" );
} /* do_dest() */

mapping query_shop_type_mapping() { return shop_type; }

int clean_up(int) { return 0; }
// --- END [/mnt/home2/grok/lib/std/shops/storeroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/craft_shop.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629670   Available: 13577024
Inodes: Total: 5242880    Free: 4960136
688 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/craft_shop.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629670   Available: 13577024
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room will handle craft shop like things, where you sell stuff to
 * the store and it will sell it onto other players after taking
 * a margin.  This can be used for potions, pottery, swords, anything!
 * @author Pinkfish
 * @started Thu Feb  5 15:39:57 CST 1998
 */
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop";

/** @ignore yes */
void create() {
   add_help_file("craft_shop");
   basic_room::create();
   craft_shop::create();
} /* create() */

/** @ignore yes */
void init() {
   basic_room::init();
   craft_shop::init();
} /* init() */

/** @ignore yes */
void dest_me() {
   craft_shop::dest_me();
   basic_room::dest_me();
} /* dest_me() */
// --- END [/mnt/home2/grok/lib/std/shops/craft_shop.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/bank_master.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629670   Available: 13577024
Inodes: Total: 5242880    Free: 4960136
4737 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/bank_master.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629670   Available: 13577024
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the bank inheritable.  It handles all the bank transactions
 * and other such exciting stuff.
 * @author Pinkfish
 */
#include <money.h>
#include <move_failures.h>

nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_master";

private int _total_account;
private int _total_made;
private nosave string _place;

nosave string _save_file;

void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
} /* create() */

/** @ignore yes */
int query_float() {
   return 2400000;
} /* query_float() */

/** @ignore yes */
void adjust_float(int amt) {
} /* adjust_float() */

/** @ignore yes */
int is_open_for(string type, string person) {
   return 1;
} /* is_open_for() */

/**
 * This method retuns the money place for the bank.
 * @return the money place
 */
string query_money_place() { return _place; }

/**
 * This method sets the place that the money will be setup from.
 * @param word the place to set
 */
void set_place( string word ) { _place = word; }

/**
 * This method returns the save file used for the room.
 * @return the save file used
 */
string query_save_file() { return _save_file; }

/**
 * This method sets the save file for the bank.
 * @param word the save file name for the bank
 */
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
} /* set_save_file() */

/**
 * This method does the actual save.
 */
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
} /* event_save() */

mixed *stats() {
  return basic_room::stats() + 
         bank_master::stats() + ({
         ({ "save file", query_save_file() }) });
} /* stats() */

int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  //total_account -= total;
  amount = total / 3;
  //total_made += 2 * amount;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
} /* make_bank_robbers() */

void init() {
   basic_room::init();
   bank_master::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/shops/bank_master.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/bureau_de_change.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/bureau_de_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629669   Available: 13577023
Inodes: Total: 5242880    Free: 4960136
9491 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/bureau_de_change.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629669   Available: 13577023
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard money changer inheritable.
 * @author Pinkfish
 * @change Deutha
 * Extensive changes to make it work with the new currency system.
 */
#include <money.h>
#include <move_failures.h>

inherit "/std/room/basic_room";

int standard, buy_only;
string place;
mapping exchanges;

int do_buy(object *obs, string country);

int query_standard() { return standard; }

void set_standard( int number ) { standard = number; }

int query_buy_only() { return buy_only; }

void set_buy_only() { buy_only = 1; }

string query_place() { return place; }

void set_place( string word ) { place = word; }

mapping query_exchanges() { return exchanges; }

void set_exchanges( mapping map ) { exchanges = map; }

string exchanges_list() {
    int i, value, smallest;
    string list, *places;
    if ( !sizeof( exchanges ) )
         return "There are no exchanges to be made here.";
    list = "";
    places = keys( exchanges );
    for ( i = 0; i < sizeof( places ); i++ ) {
         list += places[ i ] +":\n      $I$+20,+10="+
                  (string)MONEY_HAND->money_value_string( standard, place ) +
                  " will buy: ";
         value = ( exchanges[ places[ i ] ][ 0 ] * standard ) / 100;
         smallest = MONEY_HAND->smallest_value_in( places[ i ] );
         if (value % smallest != 0)  value += smallest - (value % smallest);
         list += (string)MONEY_HAND->money_value_string( value, places[ i ] );
         if ( buy_only ) {
             list += ".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         } else {
             list += ";$I$-20,-10=\n$I$+20,+10=      for "+
                      (string)MONEY_HAND->money_value_string( standard,
                      place ) +", sell: ";
             value = ( 100 * standard ) / exchanges[ places[ i ] ][ 1 ];
             list += (string)MONEY_HAND->money_value_string( value,
                      places[ i ] ) +".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         }
    }
    return list;
} /* exchanges_list() */

void create() {
   do_setup++;
   ::create();
   do_setup--;
   standard = 100;
   place = "default";
   exchanges = ([ ]);
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
} /* create() */

void init() {
   ::init();
   add_command("buy", "[from] <string'" + implode(keys(exchanges), "|") + 
       "'> with <indirect:object:me>",  (: do_buy( $1, $4[0] ) :) );

   if ( !buy_only ){
      add_command("sell" ,"<indirect:object:me'stuff'>",
                        (:this_object()->sell($1):));
   }
   add_command("list", "", (:this_object()->list():));
} /* init() */

int do_buy(object *things, string country) {
   int     value;
   int     smallest;
   object  thing;
   object  money;
   mixed  *change;
   mixed  *monies;
   mixed  *no_value;
   string  word;
    
   // debug_printf( "%O, %O, %O\n", things, args, pattern );

   change = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money"))  {
         change = MONEY_HAND->merge_money_arrays(change,
                                                 thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }

   if (sizeof(change) == 0) {
      return notify_fail("You can only use money to buy currency here.  "
                         "Sorry.\n");
   }

   if (undefinedp(exchanges[country])) {
      foreach (word in keys(exchanges)) {
         if (lower_case(country) == lower_case(word)) {
            country = word;
            break;
         }
      }
      if (country != word) {
         add_failed_mess("You cannot exchange that currency here.  Only " + 
              query_multiple_short(keys(exchanges)) + " currency can be "
              "purchased at this shop.\n");
         this_player()->adjust_money(change);
         return 0;
      }
   }

   if (country == place) {
      this_player()->adjust_money(change);
      return notify_fail("You cannot buy currency from " + country +
            " here, since you're currently in " + country + ".\n");
   }

   monies = MONEY_HAND->filter_legal_money_to_array(change, place);
   no_value = monies[1];

   if (sizeof(monies[0]) != 0  &&  place != "default")  {
      monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
      if (sizeof(monies[0]) != 0)
         no_value = MONEY_HAND->merge_money_arrays(no_value, monies[0]);
      monies[0] = monies[1];
   }

   if (sizeof(no_value) != 0)  {
      this_player()->adjust_money(no_value);
      write("Sorry, but you cannot use " +
            MONEY_HAND->money_string(no_value) + " to buy currency here.\n");
   }

   if (sizeof(monies[0]) == 0) {
      return notify_fail("Sorry, but you didn't offer any acceptable money "
                         "to buy currency.\n");
   }

   value = (MONEY_HAND->query_total_value(monies[0], place) *
           exchanges[country][0]) / 100;
   smallest = MONEY_HAND->smallest_value_in(country);
   if (value % smallest != 0)  value += smallest - (value % smallest);
   change = MONEY_HAND->create_money_array(value, country);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(monies[0]);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(monies[0]) + " is not worth anything "
            "in " + country + ".\n");
   }
   write("OK, you bought "+ MONEY_HAND->money_string(change) + " with " +
         MONEY_HAND->money_string(monies[0]) + ".\n");

#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }

   say(this_player()->one_short() + " exchanges some currency.\n");

   return 1;
} /* do_buy() */


int sell(object *things) {
   int value;
   int test_val;
   int first;
   string *places;
   string  a_place;
   object thing;
   object money;
   mixed *monies;
   mixed *change;
   mixed *m_array_a;
   mixed *m_array_b;
   mixed *m_array_c;

   m_array_a = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money")) {
         m_array_a = MONEY_HAND->merge_money_arrays(m_array_a,
                         thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }

   if (sizeof(m_array_a) == 0) {
      return notify_fail("You can only sell currency here.  Sorry.\n");
   }

   places = m_indices(exchanges);

   m_array_b = ({ });
   m_array_c = ({ });
   first = 1;
   foreach (a_place in places)  {
      monies = MONEY_HAND->filter_legal_money_to_array(m_array_a, a_place);
      m_array_a = monies[1];

      if (sizeof(monies[0]) != 0)  {
         /*
          * OK, we need to pull off the provincial coins because they have a 
          * value of 0 in any other zone, so the player gets ripped off
          * if they do "sell coins" and they have a mixture of provincial
          * and non-provincial coinage.   Got that?
          */
         if (first  &&  a_place != "default")   {
            monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
            if (sizeof(monies[0]) != 0)
               m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
            monies[0] = monies[1];
            first = 0;
         }

         test_val = MONEY_HAND->query_total_value(monies[0], a_place) *
                    exchanges[a_place][1] / 100;
         if (test_val)   {
            value += test_val;
            m_array_b = MONEY_HAND->merge_money_arrays(m_array_b, monies[0]);
         }
         else
            m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
      }

      if (sizeof(m_array_a) == 0)
         break;
   }

   if (sizeof(m_array_c) != 0)
      m_array_a = MONEY_HAND->merge_money_arrays(m_array_a, m_array_c);

   if (sizeof(m_array_a) != 0) {
      write("Sorry, but you cannot sell " +
            MONEY_HAND->money_string(m_array_a) + " here.\n");
      this_player()->adjust_money(m_array_a);
   }

   if (sizeof(m_array_b) == 0) {
      return notify_fail( "Sorry, but you aren't offering to sell any "
            "acceptable coinage.\n");
   }
   change = MONEY_HAND->create_money_array(value, place);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(m_array_b);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(m_array_b) + " is not "
            "worth anything in " + place + ".\n");
   }

   write("OK, you sold " + MONEY_HAND->money_string(m_array_b) + " for " +
         MONEY_HAND->money_string(change) + ".\n");

#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }

   say(this_player()->one_short() + " exchanges some currency.\n");

   return 1;
} /* sell() */

int list() {
   write( exchanges_list() +"\n" );
   return 1;
} /* list() */
// --- END [/mnt/home2/grok/lib/std/shops/bureau_de_change.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/review.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/review.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629666   Available: 13577020
Inodes: Total: 5242880    Free: 4960136
15038 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/review.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629666   Available: 13577020
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains the code to deal with the maintenance reviews
 *****************************************************************************/

/**
 * @ignore yes 
 * Called once a month to conduct the shop's monthly review.
 * This method is the monthly maintenance function for the shop.  This review
 * involves paying employees direct into their nominated bank account, and
 * awarding bonuses based on the current value of the bonus fund.  If there is
 * not enough money in the profit account to pay the correct amount, the
 * employees are paid on a pro-rata basis.
 */
private void monthly_review()
{  
   int amount = calc_pay(),
       bonus_divisor = 0,
       cabinet_cost = (_num_cabinets - MIN_CABINETS) * CABINET_COST,
       pay;
   float pay_multiplier = 1.0;
   string *emps = m_indices(_employees); 

   log_file("/log/PLAYER_SHOP", "%s: %s entered monthly review (review.c)\n",
      ctime(time()), _very_short); 

   if (cabinet_cost)
   {
      adjust_profit(_proprietor, -cabinet_cost);
      shop_log(ACCOUNTS, _proprietor,
         "paid "+ MONEY_HAND->money_value_string(cabinet_cost,
         _place) + " for the rent of " + (_num_cabinets - MIN_CABINETS) +
         " cabinets", UNPAID);
   }
   if (_accounts["profit"] < 0) adjust_bonus("Shop",_accounts["profit"]);
   if (amount > _accounts["profit"])
      pay_multiplier = _accounts["profit"] / amount;

   foreach (string word in emps)
   {
      if (!_employees[word][EMP_PAY]) continue;
      pay = to_int(_employees[word][EMP_PAY] * pay_multiplier);
      if (!(_employees[word][EMP_POINTS] & NPC))
      {
         BANK_HANDLER->adjust_account(word,
            BANKS[_employees[word][EMP_BANK]][1], pay );
         PLAYER_SHOP->auto_mail(word, _proprietor, "Pay advice for "+
            _last_month, "", sprintf("For your work during %s, you have been "
            "paid a total of %s.  Keep up the good work.\n--\n%s "
            "(proprietor)\n", _last_month, MONEY_HAND->money_value_string(pay,
            _place ), _proprietor));
      }
      else _employees[word][EMP_POINTS] = EMPLOYEE + NPC;
      shop_log(ACCOUNTS, _proprietor, "paid "+ MONEY_HAND->
        money_value_string(pay, _place)+ " to "+ cap_name(word), UNPAID);
      _employees[word][EMP_PAY] = 0;
      _accounts["profit"] -= pay;
   }
   _bonus += _accounts["bonus"];
   if (_bonus < 0)
   {
      _accounts["bonus"] = _bonus;
      _bonus = 0;
   } 
   else _accounts["bonus"] = 0;

   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS]) continue;
      if (!test_prop(word, _very_short+ " handbook")) continue;

      if (_employees[word][EMP_POINTS] & MANAGER)
      {
         bonus_divisor += 4;
      }
      else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
         _eom == word)
      {
         bonus_divisor += 3;
      }
      else
      {
         bonus_divisor += 2;
      }
   }
   if (!bonus_divisor) _bonus_val = _bonus;
   else _bonus_val = (_bonus * 2) / bonus_divisor;

   _got_bonus = ({});
   _eom = sort_array(get_employees(),
      (: _employees[$2][EMP_EOM] - _employees[$1][EMP_EOM] :))[0];
   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS])
      {
         _employees[word][EMP_NOBONUS]--;
         _got_bonus += ({word});
      }
      _employees[word][EMP_EOM] = 0;
   }
   employee_log(_eom, _last_month+ "'s Employee Of The Month");
   add_board_message("Bonuses for "+ _last_month,
      sprintf("Based on the bonus fund of %s for %s, the following "
      "bonuses have been awarded:\n\n     Managers    - %s\n     Supervisors"
      " - %s\n     Employees   - %s\n\n%s's Employee Of The Month was %s.  "
      "Well done to you.\n", MONEY_HAND->money_value_string(_bonus, _place),
      _last_month, MONEY_HAND->money_value_string(_bonus_val * 2, _place),
      MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
      MONEY_HAND->money_value_string(_bonus_val, _place), _last_month,
      cap_name(_eom)));
   if (_bonus)
   {
      shop_log( ACCOUNTS, _proprietor, "paid out "+
        MONEY_HAND->money_value_string(_bonus, _place)+
        " in bonuses for "+ _last_month, UNPAID );
   }
   if (_eom == _shopkeeper->query_name())
   {
      _bonus -= to_int(_bonus_val * 1.5);
      shop_log(GENERAL, _eom, "claimed "+ 
         MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
         UNPAID);
   }
   else
   {
      _bonus -= _bonus_val;
      shop_log(GENERAL, _shopkeeper->query_name(), "claimed "+ 
         MONEY_HAND->money_value_string(_bonus_val, _place), UNPAID);
   }
   if (_bonus < 0) _bonus = 0;
   _last_month = _review_month;
   _call_review = 0;
   save_me();
   save_emps();
}
/* monthly_review() */

/**
 * @ignore yes 
 * Called once a day to conduct the shop's daily review.
 * This method is the daily maintenance function for the shop.  It checks that
 * employees are still valid players, and not creators.  It conducts automatic
 * promotions, and handles demotions for inactive employees.  It also updates
 * the lists of declined applicants and banned people and removes that status
 * if applicable.  Finally, it calls the check_hire_list function to see if 
 * we can hire any new employees.
 */
private void review_employees()
{
   int prom = FALSE,
       prom_number,
       managers,
       time = time();
   string *promos = ({}),
          promopost,
          *emps = _retired + m_indices(_employees);

   log_file("/log/PLAYER_SHOP", "%s: %s entered review_employees (review.c)\n",
      ctime(time()), _very_short); 

   /* Fire non-users, creators and demote creator alts */
   foreach (string word in emps)
   {
      if (!test_player(word))
      { 
         /* Make sure we are not firing the npc shopkeeper */
         if (_employees[word][EMP_POINTS] & NPC) continue;
         fire_them(_proprietor, word, "not existing");
      }

      else if (test_cre(word))
         fire_them(_proprietor, word, "being a creator");

      else if (test_prop(word,"no score") &&
         _employees[word][EMP_POINTS] & SUPERVISOR )
      {
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
         save_emps();
         PLAYER_SHOP->auto_mail(word, _proprietor, "Demotion", "",
         "This is to advise you that, due to you having a creator alt, "
         "you have today been demoted.\n");
         employee_log(word, "Demoted by "+ _proprietor);
         shop_log(PERSONNEL, _proprietor, "demoted "+ cap_name(word), UNPAID);
      }

      if (!test_prop(word, _very_short+ " handbook"))
      {
         _employees[word][EMP_PAY] = 0;
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
      }
   }


   /* Check for inactive managers */
   foreach (string word in get_managers())
      if ((time - _times[word]) > (60*60*24*MGR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*MGR_WARN) &&
         !_employees[word][EMP_INACTIVE] && 
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
           "", "It has come to my attention that you have now been "
           "inactive for over " + MGR_WARN+ " days.  As you are a manager, "
           "you are required to meet certain levels of attendance.  "
           "You are now in serious danger of being demoted without "
           "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
               cap_name(word) + " about inactivity", UNPAID);
      }

   /* Check supervisors for inactivity or promotion.  Sorted by points so
    * people promoted in order.
    */
   foreach(string word in sort_array(get_supervisors(), 
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
      if (time - _times[word] > (60*60*24*SPR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*SPR_WARN) &&
        !_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
            "", "It has come to my attention that you have now been "
            "inactive for over "+ SPR_WARN+ " days.  As you are a supervisor, "
            "you are required to meet certain levels of attendance.  "
            "You are now in serious danger of being demoted without "
            "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
            cap_name(word) + " about inactivity", UNPAID);
      }
      else
      {
         /* See if any managerial vacancies.  If so, and this person has
          * sufficient points & is not being ignored for promotion,
          * promote them.
          */
         prom_number = (_max_emp * PERCENT_M) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * MANAGER_POINTS) && 
           sizeof(get_managers()) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            set_employee(word, MANAGER);
            shop_log(PERSONNEL, _proprietor, "promoted "+
               cap_name(word)+ " to manager", UNPAID);
            employee_log(word, "Promoted to manager");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!", 
              "", "Congratulations!  You've been promoted to manager "
              "of "+ _shop_name+ ".  You'll find that you can now enter "
              "the managers' office.  Please remember to use the \"memo\" "
              "facility from there to discuss any major admin points with "
              "other managers.  This includes hiring, firing, and so on.\n");
            promos += ({word});
            prom = TRUE;
         }
      }

   /* Check employees for inactivity or promotion.  Sorted by points so
    * people promoted in order.
    */
   foreach(string word in sort_array(get_employees(), 
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
   {
      if (_employees[word][EMP_POINTS] & NPC) continue;
      if (time - _times[word] > (60*60*24*EMP_FIRE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         fire_them(_proprietor, word, "serious inactivity");
         continue;
      }
      if (time - _times[word] > (60*60*24*EMP_WARN))
      {
         if (!_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
         {
            PLAYER_SHOP->auto_mail(word, _proprietor, "Inactivity",
              "", "It has come to my attention that you have now been "
              "inactive for over "+ EMP_WARN+ " days.  Unless this "
              "situation is resolved, the management may have no option "
              "but to terminate your employment.\n---\n"+ _proprietor+ 
              " (proprietor)\n");
            _employees[word][EMP_INACTIVE] = TRUE;
            shop_log(PERSONNEL, _proprietor, "warned "+ 
              cap_name(word)+ " about inactivity", UNPAID);
            employee_log(word, "Warned about inactivity");
         }
      }
      else
      {
         /* See if any supervisory vacancies.  If so, and this person has
          * sufficient points & is not being ignored for promotion,
          * promote them.
          */
         prom_number = (_max_emp * PERCENT_S) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * SUPER_POINTS) &&
           sizeof( get_supervisors() ) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            if(_employees[word][EMP_POINTS] & CLOCKED_IN)
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) +
                 EMPLOYEE+ SUPERVISOR + CLOCKED_IN;
            else
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) + 
                 EMPLOYEE+ SUPERVISOR;
            shop_log(PERSONNEL, _proprietor, "promoted "+
              cap_name(word)+ " to supervisor", UNPAID);
            employee_log(word, "Promoted to supervisor");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!", "",
              "Congratulations!  You've been promoted to supervisor "
              "of "+ _shop_name+ ".  You will now be able to use your "
              "newly acquired supervisor commands.\n");
            promos += ({word});
            prom = TRUE;
         }
      }
   }

   /* Post about promotions */
   if (prom)
   {
      promopost = "The following employees have been promoted:\n\n";
      foreach (string word in promos)
         promopost += sprintf("     %s has been promoted to %s\n",
           cap_name(word), (_employees[word][EMP_POINTS] & MANAGER)?
           "manager":"supervisor");
      promopost += "\nCongratulations!\n";
      add_board_message("Promotions", promopost);
   }

   /* Check the list of banned people */
   foreach (string word in m_indices(_baddies))
      if (time - _baddies[word][BAD_TIME] > (60*60*24*BAN_LENGTH))
         remove_baddie( word );

   /* Check the list of declined applicants */
   foreach (string word in m_indices(_declined))
      if (time - _declined[word] > (60*60*24*DECLINE_LENGTH))
         remove_declined(word);

   /* See if anyone can be hired */
   remove_call_out(_call_hire_list);
   _call_hire_list = call_out((: check_hire_list() :), 5);
   save_emps();

   /* Update policies */
   managers = sizeof(get_managers()) + sizeof(get_retired());
   load_new_policies();
   if (sizeof(_new_policies))
   {
      foreach (string word in m_indices(_new_policies))
      {
         if (sizeof(_new_policies[word][POLICY_FOR]) > managers / 2)
         {
            add_policy(word);
         }
         else if (time - _new_policies[word][POLICY_TIME] > VOTE_TIMEOUT)
         {
            if (sizeof(_new_policies[word][POLICY_FOR]) >=
               sizeof(_new_policies[word][POLICY_AGAINST]))
            {
               add_policy(word);
            }
            else remove_policy(word);
         }
      }
   }

   clear_new_policies();

   /* Update the player history data */
   load_history();
   foreach (string word in m_indices(_history))
   {
      if (!test_player(word) || test_cre(word) ||
        !_times[word] || _times[word] < (time - HIST_TIMEOUT))
      {
         map_delete(_times, word);
         map_delete(_history, word);      
      }
   }
   save_hist();
   save_times();
}
/* review_employees() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/review.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/save.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629662   Available: 13577016
Inodes: Total: 5242880    Free: 4960136
3325 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629662   Available: 13577016
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains saving-related functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Save this object immediately.
 * Normal operations buffer saves to minimise disk activity.  This function is 
 * called to save immediately.
 */
private void do_save()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving shop data to %s/.\n", _savedir);
#endif
   unguarded((: save_object, _savedir+ "shop_data" :));
}
/* do_save() */

/**
 * @ignore yes 
 * Saves the applications data.
 */
private void do_save_applicants()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving applications data to %s.\n",
     _savedir+ "applications");
#endif
   unguarded((: write_file, _savedir+ "applications",
     save_variable(_applicants), 1 :));
   clear_applicants();
}
/* save_applicants() */

/**
 * @ignore yes 
 * Saves the employee data.
 */
private void do_save_emps()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving employee data to %s.\n",
     _savedir+ "employees");
#endif
   unguarded((: write_file, _savedir+ "employees",
     save_variable(_employees), 1 :));
}
/* do_save_emps() */

/**
 * @ignore yes 
 * Saves the employment history data.
 */
private void do_save_hist()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving history data to %s.\n",
     _savedir+ "history");
#endif
   unguarded((: write_file, _savedir+ "history",
     save_variable(_history), 1 :));
   clear_history();
}
/* save_hist() */

/**
 * @ignore yes 
 * Saves the new policies data.
 */
private void do_save_new_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving new policies data to %s.\n",
     _savedir+ "new_policies");
#endif
   unguarded((: write_file, _savedir+ "new_policies",
     save_variable(_new_policies), 1 :));
   _call_newpols_clear = call_out((: _new_policies= 0 :), CLEAR_DELAY);
}
/* save_new_policies() */

/**
 * @ignore yes 
 * Saves the policies data.
 */
private void do_save_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving policies data to %s.\n",
     _savedir+ "policies");
#endif
   unguarded((: write_file, _savedir+ "policies",
      save_variable(_policies), 1 :));
   clear_policies();
}
/* save_policies() */

/**
 * @ignore yes 
 * Saves the employment last-action times data.
 */
private void save_list()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving chart list data to %s.\n",
     _savedir+ "list");
#endif
   unguarded((: write_file, _savedir+ "list",
     save_variable(_list), 1 :));
}
/* do_save_list() */

/**
 * @ignore yes 
 * Saving the contents of the shop's register.
 * @param money the money array to save
 */
void save_register(mixed *money)
{
   _register = money;
   save_me();
}
/* save_register() */

/**
 * @ignore yes 
 * Saves the employment last-action times data.
 */
private void save_times()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving times data to %s.\n",
     _savedir+ "times");
#endif
   unguarded((: write_file, _savedir+ "times",
     save_variable(_times), 1 :));
}
/* save_times() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/memo.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/memo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629661   Available: 13577015
Inodes: Total: 5242880    Free: 4960136
2336 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/memo.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629661   Available: 13577015
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains memo functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Send a memo to each employee.  Only used if there is no board.
 */
private int do_memo()
{
   tell_object(this_player(), "Subject: (hit enter for general memo)\n");
   input_to((: write_memo($1) :), 0);
   add_succeeded_mess("");
   return 1;
}
/* do_memo() */


/** @ignore yes */
private void end_memo(string text, string subject)
{
   if (!text)
   {
      tell_object(this_player(), "Aborted.\n");
      return;
   }
   tell_object(this_player(), "Do you want to keep a copy of the memo? ");
   input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
/* end_memo() */


/**
 * @ignore yes 
 * Send the memo
 */
private void send_memo(string ans, string subject, string text)
{
   object tp = this_player();
   string *employees = _retired,
          tp_name = tp->query_name();

   tp = this_player();
   tp_name = tp->query_name();
   ans = lower_case(ans);
   if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
   {
      tell_object(tp,
        "Do you want to keep a copy of the memo? (Yes or No)? ");
      input_to((: send_memo($1,$(subject),$(text)) :), 0);
      return;
   }
   if (tp->query_creator() && tp_name != _creator)
      employees += ({tp_name});
   employees += ({_creator});
   foreach(string employee in m_indices(_employees))
      if (!(_employees[employee][EMP_POINTS] & NPC))
         employees += ({employee});
   if (ans[0] == 'n') employees -= ({tp_name});
   if (!sizeof(employees))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "No employees to send mail to.\n");
#endif
      tell_object(tp, "There is no-one to send a memo to!\n");
      return;
   }
#ifdef DEBUG
   tell_creator(CREATOR, "Sending employee memo to %s.\n", 
     implode(employees, "," ));
#endif
   tell_object( tp, "Sending your memo.\n" );
   if (subject && subject != "") subject = " - " + subject;
   else subject = "";
   AUTO_MAILER->auto_mail(implode(employees, ","),
     tp_name, _very_short+ " employee memo" + subject, "", text, 0, 0);
}
/* send_memo() */

/** @ignore yes */
private void write_memo(string text)
{
   this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}
/* write_memo() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/memo.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/emp_cmd.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/emp_cmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629661   Available: 13577015
Inodes: Total: 5242880    Free: 4960136
5475 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/emp_cmd.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629661   Available: 13577015
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains employee commands
 *****************************************************************************/


/**
 * @ignore yes 
 * Display or update the employee's bank details.
 */
private int do_bank(mixed *args)
{
   object tp = this_player();
   string word = tp->query_name();

   if (tp->query_creator())
   {
      tell_object(tp, "Creators don't get paid.\n");
      return 1;
   }
   add_succeeded_mess( "" );

   if ( !sizeof( args ) )
   {      
      string message = "You are currently being paid into your account at "+
        BANKS[_employees[word][EMP_BANK]][0]+ ".  To change which bank "
        "you would like your pay to be deposited at, use the command "
        "\"bank <number>\" where <number> is one of the following:\n\n";
      for (int x = 0; x < sizeof(BANKS); x++)
         message += sprintf("     %d: %s\n", x+1, BANKS[x][0]);
      tell_object(tp, message + "\n");
      return 1;
   }
   if (args[0] < 1 || args[0] > sizeof(BANKS))
   {
      tell_object(tp,  "There are "+ sizeof(BANKS)+ 
        " banks to choose from.\n");
      return 1;
   }
   _employees[word][EMP_BANK] = args[0] - 1;
   save_emps();
   tell_object(tp, "You change your bank details.\n");
   return 1;
}
/* do_bank() */


/**
 * @ignore yes 
 * Claim a badge, handbook, or bonus.
 */
private int do_claim(string item)
{
   object thing,
          tp = this_player();
   int give_bonus;
   string tp_name = tp->query_name();

   switch(item)
   {
     case "badge" :
        thing = clone_object(BADGE);
        thing->set_props(file_name(this_object()), tp->query_name());
        break;
     case "handbook" :
        thing = clone_object(STAFF_BOOK);
        thing->set_read_mess("\n   "+ _shop_name+ "\n\n"
          "   Staff Handbook\n\n   This handbook belongs to: "+
          tp->query_short()+ "\n\n", "common", 100);
        thing->set_office(file_name(this_object()));
        tp->add_property(_very_short+ " handbook",1);
        break;
     case "bonus" :
        /* Already claimed, new employee, or had bonus suspended. */
        if (member_array(tp_name, _got_bonus) != -1)
        {
           tell_object(tp, "You are not entitled to a "
             "bonus this month!\n");
           return 1;
        }

        /* Value depends on status */
        if (_employees[tp_name][EMP_POINTS] & MANAGER)
        {
           give_bonus = _bonus_val * 2;
        }
        else if (_employees[tp_name][EMP_POINTS] & SUPERVISOR ||
           _eom == tp_name)
        {
           give_bonus = to_int(_bonus_val * 1.5);
        }
        else
        {
           give_bonus = _bonus_val;
        }

        /* Nothing to give */
        if (!give_bonus)
        {
           tell_object(tp,  "There is no money in the bonus "
             "fund this month.\n");
           return 1;
        }

        /* Prevent them from claiming again this month */
        _got_bonus += ({tp_name});
        _bonus -= give_bonus;

        /* Update value of unclaimed bonus */
        if (_bonus < 0) _bonus = 0;

        thing = MONEY_HAND->make_new_amount(give_bonus, _place);
        shop_log(GENERAL, tp_name, "claimed "+ 
          MONEY_HAND->money_value_string(give_bonus, _place), UNPAID);
        if (thing->move(tp) != MOVE_OK)
        {
           thing->move(environment(tp));
           tell_object(tp, "You drop "+ thing->query_short()+
             " as you're carrying too much.\n");
        }
        save_me();
        add_succeeded_mess("$N $V "+ MONEY_HAND->
          money_value_string(give_bonus, _place )+ ".\n");
        return 1;
        break;
   }
   if (thing->move(tp) != MOVE_OK)
   {
      thing->move(this_object());
      tell_object(tp, "You drop your "+ item+
        " as you're carrying too much.\n");
   }
   add_succeeded_mess("$N $V a new "+ item+ ".\n");
   return 1;
}
/* do_claim() */

/**
 * @ignore yes 
 * This function is used by employees to clock in and out of work.
 * Clocking out may also summon the npc shopkeeper.
 */
private int do_clock(string clock)
{
   object tp = this_player();
   string word = tp->query_name();
   int pay_them = UNPAID;

   if (tp->query_creator())
   {
      tell_object(tp, "Creators don't clock in or out.\n");
      return 1;
   }

   switch(clock)
   {
     case "in" :
        if (_employees[word][EMP_POINTS] & CLOCKED_IN)
        {
           tell_object(tp, "You are already clocked in!\n");
           return 1;
        }

        /* Stop the shopkeeper appearing if on their way */
        remove_call_out(_call_summon);

        /* Is this person a cre alt? If so, prevent promotion. */
        if (tp->query_property("no score") && 
           !_employees[word][EMP_NOPROMOTE])
        {
           _employees[word][EMP_NOPROMOTE] = TRUE;
           save_emps();
        }
        pay_them = PAID;
        set_employee(word, CLOCKED_IN);
        break;
     case "out" :
        if (!(_employees[word][EMP_POINTS] & CLOCKED_IN))
        {
           tell_object(tp, "You are already clocked out!\n");
           return 1;
        }

        /* Call npc shopkeeper to work */
        remove_call_out(_call_summon);
        _call_summon = call_out((: summon_shopkeeper() :), 60);
        reset_employee(word, CLOCKED_IN);
        break;
   }
   add_succeeded_mess("$N $V "+ clock+ ".\n");
   shop_log(GENERAL, word, "clocked "+ clock, pay_them);
   return 1;
}
/* do_clock() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/emp_cmd.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/applications.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/applications.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629659   Available: 13577013
Inodes: Total: 5242880    Free: 4960136
11833 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/applications.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629659   Available: 13577013
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains application-related functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Used by the shop front to add this person to the applicants mapping.
 * @param player player to add to applicants mapping
 */
void add_applicant(string player, string message)
{
   if (previous_object() && previous_object() != find_object(_shop_front))
   {
      LOG_ERROR("office.c", "add_applicant("+player+","+message+")");
      return;
   }
   player = lower_case(player);
   if (!query_applicant(player))
   {
      load_applicants();
      if (!sizeof(_applicants)) _applicants = ([ player:APP_MAP ]);
      else _applicants += ([ player:APP_MAP ]);
      _applicants[player][APP_TIME] = time();
      _applicants[player][APP_MESSAGE] = message;
      employee_log( player, "Applied for employment" );
      save_applicants();
   }
}
/* add_applicant() */

/**
 * @ignore yes 
 * Add this person to the list of declined applicants.  Used by the shop front
 * to determine if this person can apply again yet.
 * @param applicant the declined applicant
 */
private void add_declined(string applicant)
{
   applicant = lower_case(applicant);
   if (!query_declined(applicant))
   {
      if (!sizeof(_declined)) _declined = ([applicant:0]);
      else _declined += ([applicant:0]);
      _declined[applicant] = time();
      save_me();
   }
}
/* add_declined() */

/**
 * @ignore yes 
 * Used by the managers' office whenever a manager casts a vote on an applicant
 * @param applicant the applicant to vote for
 * @param vote the vote type
 */
private void add_vote(string applicant, int vote)
{
   string voter = this_player()->query_name();
   int managers = sizeof(get_managers());

   if (!managers) managers = 1;
   load_applicants();
   if (vote == VABSTAIN) _applicants[applicant][APP_ABSTAIN] += ({voter});
   else if (vote == VFOR) _applicants[applicant][APP_FOR] += ({voter});
   else _applicants[applicant][APP_AGAINST] += ({voter});
   shop_log(GENERAL, voter, "voted on "+ cap_name(applicant), PAID);
   save_applicants();
   managers -= sizeof(_applicants[applicant][APP_ABSTAIN]);
   
   if (sizeof(_applicants[applicant][APP_FOR]) > managers / 2)
   {
     /* This applicant has the vote of over 50%
      * of managers so hire them. 
      */
      PLAYER_SHOP->auto_mail(applicant, _proprietor, _shop_name, "",
         "Congratulations!  You've been accepted to work at "+
         _shop_name+ ".  Please return to the shop within the next "
         "seven days to \"confirm\" that you wish to accept "
         "the position.\n");
      _applicants[applicant][APP_TYPE] = HIRED;
      _applicants[applicant][APP_TIME] = time();
      employee_log(applicant, "Application was accepted");
   }
   else if (sizeof(_applicants[applicant][APP_AGAINST]) >=
      managers / 2)
   {
     /* This applicant has been voted against by at least 50% of the 
      * managers so decline them. 
      */
      remove_applicant(applicant);
      PLAYER_SHOP->auto_mail(applicant, _proprietor, _shop_name, "",
         "Thank you for your recent application for employment "
         "with us.  Unfortunately, I have to inform you that you "
         "have been unsuccessful at this time.  Please feel free "
         "to re-apply again in the future, when your application "
         "will be re-considered.\n");
      employee_log(applicant, "Application was declined");
      add_declined(applicant);
   } 
}
/* add_vote() */

/**
 * @ignore yes 
 * Check to see if we should hire any more accepted applicants.
 * Called during reviews, as well as when firing/promoting employees.
 */
void check_hire_list()
{
   int count;
   string *hirees = ({});
   
   /* Applicant has not confirmed employment after being accepted 
    * so remove them. 
    */
   load_applicants();
   foreach (string word in m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == HIRED :))))
      if (time() - _applicants[word][APP_TIME] > HIRE_TIMEOUT)
      {
         PLAYER_SHOP->auto_mail(word, _proprietor,
            _shop_name, "", "Since you have not returned to confirm "
            "your employment with us, we have assumed that you are no "
            "longer interested, and removed your name from our files.  "
            "If you wish to re-apply at any time in the future, please "
            "return to the shop to do so.\n");
         employee_log(word, "Lapsed their application");
         remove_applicant(word);
      }
   
   foreach (string word in m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == APPLIED :))))
      if (sizeof(_applicants[word][APP_FOR]) >
         sizeof(get_managers()) / 2)
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
            "Congratulations!  You've been accepted to work at "+
            _shop_name+ ".  Please return to the shop within the next "
            "seven days to \"confirm\" that you wish to accept "
            "the position.\n");
         _applicants[word][APP_TYPE] = HIRED;
         _applicants[word][APP_TIME] = time();
         employee_log(word, "Application was accepted");
      }
      else if (time() - _applicants[word][APP_TIME] > VOTE_TIMEOUT)
      {
         if (sizeof(_applicants[word][APP_FOR]) <=
            sizeof(_applicants[word][APP_AGAINST]))
         {
           /* Applicant has at least as many 'no' votes than 'yes' votes
            * so decline them.
            */
            remove_applicant(word);
            PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
               "Thank you for your recent application for employment "
               "with us.  Unfortunately, I have to inform you that you "
               "have been unsuccessful at this time.  Please feel free "
               "to re-apply again in the future, when your application "
               "will be re-considered.\n");
            employee_log(word, "Application was declined");
            add_declined(word);
         }
         else
         {
           /* Applicant has more 'yes' votes as 'no' votes so accept them.
            */
            PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
               "Congratulations!  You've been accepted to work at "+
               _shop_name+ ".  Please return to the shop within the next "
               "seven days to \"confirm\" that you wish to accept "
               "the position.\n");
            _applicants[word][APP_TYPE] = HIRED;
            _applicants[word][APP_TIME] = time();
            employee_log(word, "Application was accepted");
         }
      }
   
   /* Number of places available */
   count = _max_emp - sizeof(_employees);
   
   if (count < 1) return;
   hirees = sort_array(keys(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))),
      (: _applicants[$1][APP_TIME] - _applicants[$2][APP_TIME] :));
   
   /* See if we can hire all people awaiting a vacancy */
   if (count > sizeof(hirees)) count = sizeof( hirees );
   
   /* Hire as many people as we can */
   for (int n = 0; n < count; n++) hire(hirees[n]);
   save_applicants();
}
/* check_hire_list() */

/**
 * @ignore yes 
 * Shop front.
 * Cancel application.
 */
int do_cancel()
{
   object tp = this_player();

   remove_applicant(tp->query_name());
   employee_log(tp->query_name(), "Cancelled application");
   tell_object(tp, "You cancel your application.\n");
   return 1;
}
/* do_cancel() */

/**
 * @ignore yes 
 * Shop front.
 * Confirm employment.
 */
int do_confirm()
{
   object tp = this_player();
   string applicant = lower_case(tp->query_name());
   
   if (previous_object() && previous_object() != find_object(_shop_front))
   {
      LOG_ERROR("office.c", "do_confirm()");
      return 0;
   }
   load_applicants();
   _applicants[applicant][APP_TYPE] = AWAITING;
   _applicants[applicant][APP_TIME] = time();
   tell_object(tp, "You have now been added to "
      "our waiting list.  You will be notified of your position in the "
      "list as it changes.  You may \"cancel\" your application at "
      "any time.  You are currently at position " + 
      sizeof(m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))))+ 
      " in the waiting list.\n");
   save_applicants();
   employee_log(applicant, "Confirmed employment");
   tell_object(tp, "You confirm your employment.\n");
   return 1;
}
/* do_confirm() */

/**
 * @ignore yes 
 * Managers' office.
 * Vote on an applicant.
 */
int do_vote(mixed *args, string pattern)
{
   int query_app;
   string tp = this_player()->query_name();
   
   if (pattern == VOTE_APPLICANT)
   {
      args[0] = lower_case(args[0]);
      if (!(query_app = query_applicant(args[0])))
      {
         tell_object(this_player(),cap_name(args[0])+
            " hasn't applied!\n");
         return 1;
      }
      if (query_app != APPLIED)
      {
         tell_object(this_player(), cap_name( args[0])+ 
            " has already been hired!\n");
         return 1;
      }
      load_applicants();
      if (member_array(tp, _applicants[args[0]][APP_FOR]) != -1 ||
         member_array(tp, _applicants[args[0]][APP_AGAINST]) != -1 ||
         member_array(tp, _applicants[args[0]][APP_ABSTAIN]) != -1)
      {
         tell_object(this_player(),
            "You have already voted for this person!\n");
         return 1;
      }
      switch (args[1][0])
      {
      case 'y' :
         add_vote(args[0], VFOR);
         tell_object(this_player(), "You vote for " +
            cap_name( args[0] ) + " to work for the shop.\n");
         break;
      case 'a' :
         add_vote(args[0], VABSTAIN);
         tell_object(this_player(), "You abstain on " + 
            cap_name(args[0] ) + ".\n");
         break;
      default :
         add_vote(args[0], VAGAINST);
         tell_object(this_player(), "You vote against " +
            cap_name( args[0] ) + " working for the shop.\n");
      }
      clear_applicants();
   }
   else do_policy_vote(tp, args[0], args[1]);
   return 1;
}
/* do_vote() */

/**
 * @ignore yes 
 * Send a mail to each applicant awaiting a vacancy to let them know
 * their position in the queue.
 */
private void mail_hirees()
{
   string *hirees;
   
   /* Make sure we are mailing the correct person with the correct position
    * by sorting the list by time.
    */
   load_applicants();
   hirees = sort_array(keys(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))),
      (: _applicants[$1][APP_TIME] - _applicants[$2][APP_TIME] :));
   for (int x = 0; x < sizeof(hirees); x++)
      PLAYER_SHOP->auto_mail(hirees[x], _proprietor, _shop_name, "",
         "I am writing to inform you that you have now moved to position "+
         (x + 1)+ " in the employment waiting list.  If you are not near "
         "the top of the list, please be patient.\nThank you.\n");
   clear_applicants();
}
/* mail_hirees() */

/**
 * @ignore yes 
 * Remove this person from the applicants mapping.
 * Used when an applicant is hired, declined, or cancels their application.
 * @param applicant the applicant to remove
 */
private void remove_applicant(string applicant)
{
   applicant = lower_case(applicant);
   if (query_applicant(applicant))
   {
      load_applicants();
      map_delete(_applicants, applicant);
      save_applicants();
   }
}
/* remove_applicant() */

/**
 * @ignore yes 
 * Remove this person from the list of declined applicants, allowing them to 
 * re-apply.
 * @param declined the declinee to remove
 */
private void remove_declined(string declined)
{
   declined = lower_case(declined);
   if (query_declined(declined))
   {
      map_delete(_declined, declined);
      save_me();
   }
}
/* remove_declined() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/applications.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/lists.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/lists.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629656   Available: 13577010
Inodes: Total: 5242880    Free: 4960136
9711 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/lists.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629656   Available: 13577010
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*****************************************************************************
 * This file contains some list functions
 *****************************************************************************/

/**
 * @ignore yes 
 * A nicely formatted employee list for the employee badge.
 */
string badge_list()
{
   string *results = ({}),
          *creators = ({});
 
   foreach(object ob in children(BADGE))
   {
      if (ob == find_object(BADGE)) continue;
      if (ob->query_channel() != _channel) continue;
      if (environment(ob)->query_creator())
         creators += ({ environment(ob)->query_name() });
   }
   if (member_array(CREATOR, creators) != -1)
   {
      object ob = find_player(CREATOR);
      creators -= ({CREATOR});
      if (ob && !ob->query_invis())
      {
         string temp_result = ob->query_cap_name() +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   }
   if (sizeof(creators))
      foreach(string word in sort_array(creators, 1))
      {
         string temp_result = cap_name(word) +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   foreach (string word in sort_array(_retired, 1))
   {
      object ob;

      if (ob = find_player(word))
      {
         string temp_result = "%^CYAN%^"+ ob->query_cap_name() +
            "%^RESET%^ (R)";
         int idle = 0;

         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";

         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_managers())
   {
      string temp_result = "";
      object ob;

      if (ob = find_player(word))
      {
         int idle = 0;

         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";

         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (m)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   } 
   foreach (string word in get_supervisors())
   {
      string temp_result = "";
      object ob;

      if (ob = find_player(word))
      {
         int idle = 0;

         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";

         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (s)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   } 
   foreach (string word in get_employees())
   {
      string temp_result = "";
      object ob;

      if (ob = find_player(word))
      {
         int idle = 0;

         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";

         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   if (!sizeof(results))
      /* Will only occur if no employees logged on, and CREATOR is invis.
       */
      return "\nJust you, I'm afraid.\n";
   return sprintf("\n%s\n", query_multiple_short(results));
}
/* badge_list() */

/**
 * @ignore yes 
 * The list of employees in the shop.
 * This list is displayed sorted primarily by status (Retired, manager,
 * supervisor, riff-raff) and then alphabetically within those groups.
 * It also highlights those employees currently logged on (as long as they
 * are visible).
 */
int do_list()
{
   int emps_in;
   string results = "   Employees of "+ _shop_name + "\n"
                    "     As at " + ctime(time()) + "\n\n";

   /* Retired managers */
   foreach (string word in sort_array(_retired, 1))
   {
      object ob = find_player(word);
      if (ob)
         results += "%^GREEN%^";
      results += "     "+ cap_name(word)+ 
      "%^RESET%^ (retired manager)\n";
   }

   /* Managers */
   foreach (string word in get_managers())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (manager)"+
        list_stuff(word);
   }

   /* Supervisors */
   foreach (string word in get_supervisors())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (supervisor)"+
        list_stuff(word);
   }

   /* Riff-raff */
   foreach (string word in get_employees())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in ++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^"+ list_stuff(word);
   }

   results += "\n";

   /* If viewed by manager or creator, display number of employees logged
    * on and number clocked in.
    */
   if (this_player()->query_creator() || 
     _employees[this_player()->query_name()][EMP_POINTS] & MANAGER)
   {
      results += (emps_in == 1)?"   There is one employee ":
                 "   There are "+ query_num(emps_in,0)+ " employees "; 
      results += "out of "+ query_num(sizeof(_employees) - 1)+
        " on " + mud_name() + " at the moment, with "+ query_num(num_employees_in(),
          0) + " currently clocked in.\n\n";
   }

   tell_object(this_player(), "$P$Employees$P$"+ results);
   add_succeeded_mess("");
   return 1;
}
/* do_list() */

/**
 * @ignore yes 
 * Displays the list of commands available to each employee.
 */
private int do_office()
{
   int employee;
   object tp = this_player();
   string tp_name = tp->query_name(),
          board_mess = "";

   if (!_board)
      board_mess = "   memo      - send a memo to the other employees\n";
   add_succeeded_mess("");
   tp = this_player();
   tp_name = tp->query_name();
   if (member_array(tp_name, _retired) != -1)
   {
      tell_object( tp, "As a retired manager, you can use the following "
        "commands:\n"
        "   claim     - claim a badge or handbook\n"
        "   list      - list the other employees of the shop\n"
        "   logs      - review the shop's logs\n"
        "   resign    - terminate your association with Tarnach's\n"+
        board_mess+
        "You may also enter the managers' office for more commands.\n" );
      return 1;
   }
   employee = (tp->query_creator())?SUPERVISOR + MANAGER:
              _employees[tp_name][EMP_POINTS];
   tell_object(tp, "As an employee, you can use the following commands:\n"
     "   clock     - start or finish your working day\n"+
     "   claim     - claim a badge, handbook, or this month's bonus\n"
     "   bank      - set to which bank account you are paid\n"
     "   list      - list the other employees of the shop\n"
     "   promotion - request to be ignored for promotion\n"
     "   resign    - end your employment at the shop\n"+
     board_mess );
   if (employee & SUPERVISOR)
      tell_object( tp, "\nAs a supervisor, you can also use:\n"
        "   chart   - change the information on the sales chart\n"
        "   check   - check cabinet assignments\n"
        "   logs    - review the shop's logs\n" );
   if (employee & MANAGER)
      tell_object( tp, "\nAs a manager you can enter the managers' "
        "office and use the commands listed there.\n" );
   add_succeeded_mess("");
   return 1;
}
/* do_office() */

/**
 * @ignore yes 
 */
string employees_clocked_in()
{
   object *words = ({}), ob;

   if (!num_employees_in()) words = ({"No employees"});
   if (find_object(_shopkeeper) &&
      _employees[_shopkeeper->query_name()][EMP_POINTS] & CLOCKED_IN)
      words = ({_shopkeeper->query_short()});
   foreach (string word in m_indices(_employees))
   {
      ob = find_player(word);
      if (ob && _employees[word][EMP_POINTS] & CLOCKED_IN)
            words += ({ob->query_cap_name()});
   }
   return query_multiple_short(words);
}
/* employees_clocked_in() */

/**
 * @ignore yes 
 * Displays an employee's percentage towards promotion, if applicable.
 * Displays all employees' scores to creators.
 * Displays last-action (leave) times to managers.
 */
private string list_stuff(string word)
{
   string results = "",
          tp = this_player()->query_name();

   /* Nothing to display for retired managers */
   if (member_array(word, _retired) != -1) return "\n";

   /* Npc shopkeeper */
   if (_employees[word][EMP_POINTS] & NPC) return query_worked(word) + "\n";

   /* Creator viewing - display all scores */
   if (this_player()->query_creator())
      results = " ["+ (_employees[word][EMP_POINTS] / 32) +"]";

   else if ((word == tp) && !(_employees[word][EMP_POINTS] & MANAGER))
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] /
           32 - SUPER_POINTS)) /
           (MANAGER_POINTS - SUPER_POINTS)) +"%]";
      else
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] / 32)) /
           SUPER_POINTS) +"%]";

   /* Last-action times displayed to managers & creators */
   if (this_player()->query_creator() || (_employees[tp][EMP_POINTS] & MANAGER))
      results += query_worked(word);
   return results + "\n";
}
/* list_stuff() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/lists.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/cabinets.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/cabinets.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629653   Available: 13577007
Inodes: Total: 5242880    Free: 4960136
5833 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/cabinets.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629653   Available: 13577007
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains cabinet-related functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Assign an item to use a cabinet.
 * @param word the item to be assigned
 * @param number the cabinet number to assign to
 */
private void add_chart_cabinet(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_CAB] += ({number});
   _list[word][CHART_CAB] = sort_array(_list[word][CHART_CAB], 1);
   save_list();
}
/* add_chart_cabinet() */

/**
 * @ignore yes 
 * Confirm rental/removal of cabinet
 * @param confirm player input response ( y/n )
 * @param rent whether we are adding(!=0) or removing(0) cabinet
 */
void confirm_cabinet(string confirm, int rent)
{
   if (previous_object() && previous_object() != this_object())
   {
      LOG_ERROR("office.c", "confirm_cabinet("+confirm+","+rent+")");
      return;
   }
   confirm = lower_case(confirm);
   if ( strlen(confirm) < 1 ||
     (confirm[0] != 'y' && confirm[0] != 'n'))
   {
       tell_object(this_player(), sprintf("Please enter 'yes' or 'no'.\n"
         "Are you sure you want to %s a cabinet? ", (rent)?"rent":"remove"));
       input_to("confirm_cabinet", 0, rent);
       return ;
   }
   if (confirm[0] == 'n')
   {
      tell_object(this_player(), "Ok.\n");
      return;
   }
   if (rent)
      if (_storeroom->add_cabinet())
      {
         _num_cabinets++;
         adjust_profit(this_player()->query_name(), -CABINET_COST);
         shop_log(ACCOUNTS, this_player()->query_name(),
           "rented cabinet for "+ MONEY_HAND->money_value_string(CABINET_COST,
           _place), PAID);
         save_me();
      }
   else
   {
      string cab_name;

      if ((cab_name = _storeroom->remove_cabinet()) != "")
      {
         _num_cabinets--;
         shop_log(ACCOUNTS, this_player()->query_name(), 
           "removed cabinet", PAID);
         if (file_size(_savedir+ _cab_name + ".o") > 0)
         {
            _cab_name = cab_name;
            call_out((: rm_cab() :), 5);
         }
         save_me();
      }
   }
   tell_object(this_player(), "Cabinet "+ (rent)?"rent":"remov" + "ed.\n");
}
/* confirm_cabinet() */

/**
 * @ignore yes 
 * Check cabinet assignments
 */
private int do_check()
{
   string result = "Current cabinet assignments are:\n";

   for (int x = 0; x < _num_cabinets; x++)
   {
      string *items = ({});

      result += sprintf("Cabinet %2d: ", x+1);
      foreach(string item in m_indices(_list))
         if (member_array(x+1, _list[item][CHART_CAB]) != -1)
            items += ({sprintf("%s (%d)", item, _list[item][CHART_MAX])});
      if (sizeof(items)) result += query_multiple_short( items );
      result += "\n";
   }
   result += "\n";
   tell_object(this_player(), "$P$Cabinet assignments$P$"+ result);
   return 1;
}
/* do_check() */

/**
 * @ignore yes 
 * Managers' office.
 * Removing storeroom cabinets.
 */
int do_remove()
{
   int stock;

   if (!((stock = _num_cabinets) > MIN_CABINETS))
   {
      tell_object(this_player(), "The shop already contains the "
        "minimum number of cabinets.\n");
      return 1;
   }
   if (sizeof(_storeroom->query_stock(stock)))
   {
      tell_object(this_player(), "Cabinet "+ stock+ 
        " still contains stock.\n");
      return 1;
   }
   if (query_cabinet_used(stock))
   {
      tell_object(this_player(), "Cabinet "+ stock+
        " is still assigned to hold stock.\n");
      return 1;
   }
   tell_object(this_player(), "Are you sure you wish to remove a cabinet? ");
   input_to("confirm_cabinet", 0, 0);
   return 1;
}
/* do_remove() */


/**
 * @ignore yes 
 * Managers' office.
 * Renting store cabinets.
 */
int do_rent()
{
   if (!(_num_cabinets < MAX_CABINETS))
   {
      tell_object(this_player(), "The shop already contains the "
        "maximum number of cabinets.\n");
      return 1;
   }
   if (CABINET_COST > _accounts["profit"])
   {
      tell_object(this_player(), "Cabinets currently cost "+
        MONEY_HAND->money_value_string(CABINET_COST, _place) +
        ".  There is not enough money in the profit account.\n");
      return 1;
   }
   tell_object(this_player(), "Are you sure you wish to rent a cabinet for "+
     MONEY_HAND->money_value_string( CABINET_COST, _place ) + " per month? ");
   input_to("confirm_cabinet", 0, 1);
   return 1;
}
/* do_rent() */

/**
 * @ignore yes 
 * Query which cabinets are assigned to this item.
 * @param item The item to query.
 * @return An array of cabinet numbers assigned to the item.
 */
int *query_cabinet(string item)
{
   return (!_list[item])?({}):copy(_list[item][CHART_CAB]);
}
/* query_cabinet() */

/**
 * @ignore yes 
 * Query whether this cabinet is currently assigned to any items.
 * @param cabinet The cabinet number ( between 1 and number of cabinets )
 * @return TRUE or FALSE
 */
int query_cabinet_used(int cabinet)
{
   foreach(string word in m_indices(_list))
      if ( member_array(cabinet, _list[word][CHART_CAB]) != -1)
         return TRUE;
   return FALSE;
}
/* query_cabinet_used() */

/**
 * @ignore yes 
 * Stop an item using a cabinet.
 * @param word the item to modify
 * @param number the cabinet to stop using
 */
private void remove_chart_cabinet(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_CAB] -= ({number});
   save_list();
}
/* remove_chart_cabinet() */

/**
 * @ignore yes 
 * Remove cabinet file.
 * Called via a call-out to ensure cabinet is dested before removing file.
 * @param cab_name the filename of the cabinet
 */
private void rm_cab()
{
#ifdef DEBUG
   tell_creator(CREATOR, "Removing cabinet file %s.\n", 
     _savedir+ _cab_name+ ".o");
#endif
   unguarded((: rm, _savedir+ _cab_name+ ".o" :));
   _cab_name = "";
}
/* rm_cab() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/cabinets.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/admin.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/admin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629652   Available: 13577006
Inodes: Total: 5242880    Free: 4960136
14558 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/admin.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629652   Available: 13577006
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains misc admin functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Writes a message to the shop's board if it exists.  If not, will
 * send a mail to each employee.  This message is "written" by the shop's
 * proprietor.
 * @param subject Take a guess ;-)
 * @param post See subject...
 */
private void add_board_message(string subject, string post)
{
   string *employees;

   if (_board)
   {
#ifdef DEBUG
      tell_creator(CREATOR, "Posting message %s to board %s.\n", subject,
        _channel);
#endif
      BOARD_HAND->add_message(_channel, _proprietor,
        subject, post + "--\n"+ _proprietor+ " (proprietor)");
   }
   else
   {
      employees = _retired;
      foreach(string employee in m_indices(_employees))
         if (!(_employees[employee][EMP_POINTS] & NPC))
            employees += ({ employee });
      if (!sizeof(employees))
      {
#ifdef DEBUG
         tell_creator(CREATOR, "No employees to send mail to.\n");
#endif
         return;
      }
      employees += ({CREATOR});
#ifdef DEBUG
      tell_creator(CREATOR, "Sending mail %s to all employees.\n", subject);
#endif
      AUTO_MAILER->auto_mail(implode(employees, ","), _proprietor,
           subject+ " ("+ _very_short+ ")", "", post);
   }
}
/* add_board_message() */

/**
 * @ignore yes 
 * Adjust the value of the bonus account.
 * @param emp the employee adjusting the account
 * @param amount the amount to adjust the account by
 */
private void adjust_bonus(string emp, int amount)
{
   string sign = "";

   _accounts["bonus"] += amount;
   if (amount < 0)
   {
      sign = "-";
      amount = -amount;
   }
   shop_log( ACCOUNTS, emp, sprintf( "adjusted the bonus account by %s%s",
     sign, MONEY_HAND->money_value_string( amount, _place ) ), UNPAID );
   save_me();
}
/* adjust_bonus() */

/**
 * @ignore yes 
 * Adjust the value of the profit account.
 * @param emp the employee adjusting the account
 * @param amount the amount to adjust the account by
 */
private void adjust_profit(string emp, int amount)
{
   string sign = "";

   _accounts["profit"] += amount;
   if (amount < 0)
   {
      sign = "-";
      amount = -amount;
   }
   shop_log(ACCOUNTS, emp, sprintf("adjusted the profit account by %s%s",
     sign, MONEY_HAND->money_value_string(amount, _place)), UNPAID);
   save_me();
}
/* adjust_profit() */

/**
 * @ignore yes 
 * Keep track of net change in register.
 * @param amt the amount to adjust by
 */
void adjust_takings(int amt)
{
   if (previous_object() && previous_object() != find_object(_counter))
   {
      LOG_ERROR("office.c", "adjust_bought("+amt+")");
      return;
   }
   _net_takings += amt;
   save_me();
}
/* adjust_takings() */


/**
 * @ignore yes 
 * Calculate the months' projected bonuses.
 * These values are based upon the current staff levels, as well as
 * the amount of money in the bonus account.  The result is written
 * directly to this_player(). 
 */
void calc_bonus()
{
   int bonus_val, bonus_divisor = 0;

   foreach (string str in m_indices(_employees))
   {
      if (_employees[str][EMP_NOBONUS]) continue;
      if (_employees[str][EMP_POINTS] & MANAGER)
      {
         bonus_divisor += 4;
      }
      else if (_employees[str][EMP_POINTS] & SUPERVISOR || _eom == str)
      {
         bonus_divisor += 3;
      }
      else
      {
         bonus_divisor += 2;
      }
   }
   if (!bonus_divisor) bonus_val = _accounts["bonus"];
   else bonus_val = ( _accounts["bonus"] * 2 ) / bonus_divisor;

   tell_object(this_player(), "Based on the bonus fund of "+
     MONEY_HAND->money_value_string(_accounts["bonus"], _place)+ 
     ", the following bonuses are anticipated:\n"
     "\n     Managers    - "+ 
     MONEY_HAND->money_value_string(bonus_val * 2, _place)+ 
     "\n     Supervisors - "+
     MONEY_HAND->money_value_string(to_int(bonus_val * 1.5), _place)+
     "\n     Employees   - "+
     MONEY_HAND->money_value_string(bonus_val, _place)+ "\n");
}
/* calc_bonus() */

/**
 * @ignore yes
 * Calculate total employee wage packet for this month.
 * This will calculate the wage bill for the current month, correct at the
 * time of calculation.  It is given in base units, and will need converting
 * to local currency if it is to be displayed.
 * @return the current value of the months' wages.
 */
int calc_pay()
{
   int amount = 0;

   foreach(string word in m_indices(_employees))
      amount += _employees[word][EMP_PAY];
   return amount;
}
/* calc_pay() */


/** @ignore yes */
private string cap_name(string name) 
{
   if (!name) return 0;
   if (test_player(name))
      return PLAYER_HANDLER->query_cap_name(name);
   else return capitalize(name);
}

/**
 * @ignore yes 
 * Used to check access to the managers' office.
 * Called when someone attempts to use the door modified by add_manager_exit()
 * @see add_manager_exit()
 * @param action open/close
 * @return 1 to allow access
 */
int check_manager( string action )
{
   object tp = this_player();
   string tp_name = tp->query_name();

   if (tp->query_creator() || (_employees[tp_name][EMP_POINTS] & MANAGER) ||
     (member_array(tp_name, _retired) != -1)) return 1;
   return notify_fail( "You are not a manager here!\n" );
}
/* check_manager() */

/**
 * @ignore yes 
 * Query the direction to another part of the shop.
 * This function is used by the npc shopkeeper to navigate around the shop.
 * @param place the place to get directions to
 * @return the exit from this room leading to place
 */
string directions_to( string place )
{
   if (place == _counter) return copy(_counter_dir);
   if (place == _storeroom) return copy(_store_dir);
   if (place == _shop_front) return copy(_shop_dir);
   return "here";
}
/* directions_to() */

/**
 * @ignore yes 
 * Managers' office.
 * Set maximum employees & base pay rate.
 */
int do_set(mixed *args, string pattern)
{
   int value, best;
   object money;

   switch(pattern)
   {
      case SET_EMPS :
         if (args[0] < MIN_EMP || args[0] > MAX_EMP)
         {
            tell_object(this_player(), "Must be between "+ MIN_EMP+ 
              " and "+ MAX_EMP+ ".\n");
            return 1;
         }
         shop_log(PERSONNEL, this_player()->query_name(),
           "set maximum employees to "+ args[0], PAID);
         _max_emp = args[0];
         break;
      case SET_PAY :
         money = clone_object( MONEY_OBJECT );
         money->set_money_array(MONEY_HAND->query_values_in(_place));
         if ((best = money->find_best_fit(args[1])) == -1)
         {
            tell_object(this_player(),
              "That currency is not used by the shop.\n");
            return 1;
         }
         value = args[0] * (money->query_money_array())[best + 1];
         money->dest_me();
         if (value < 1)
         {
            tell_object(this_player(),
              "You must pay your employees something.\n");
            return 1;
         }
         shop_log(PERSONNEL, this_player()->query_name(), "set pay to "+ 
           MONEY_HAND->money_value_string(value, _place), PAID);
         _pay_val = value;
         add_board_message("Pay", sprintf("The base pay rate has today "
           "been set to:\n\n   Managers: %s\n   Supervisors: %s\n   "
           "Employees: %s\n", MONEY_HAND->money_value_string(value * 2, _place), 
           MONEY_HAND->money_value_string(to_int(value * 1.5), _place),
           MONEY_HAND->money_value_string(value, _place)));
         break;
   }
   tell_object(this_player(), "Ok.\n");
   save_me();
   return 1;
}
/* do_set() */

/**
 * @ignore yes 
 * Managers' office.
 * Transfer money between accounts.
 */
int do_transfer(mixed *args)
{
   int value, best;
   object money;
   string tp;

   if (args[2] == args[3] || !args[0])
   {
      tell_object(this_player(), "The point being?\n");
      return 1;
   }
   tp = this_player()->query_name();
   money = clone_object(MONEY_OBJECT);
   money->set_money_array(MONEY_HAND->query_values_in(_place));
   if ((best = money->find_best_fit(args[1])) == -1)
   {
      tell_object(this_player(), "That currency is not used by "
        "the shop.\n");
      return 1;
   }
   value = args[0] * (money->query_money_array())[best + 1];
   money->dest_me();
   switch(args[2]) {
   case "register" :
      if (_counter->query_register() < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      _counter->adjust_register(tp, value);
      if (args[3] == "profit") adjust_profit(tp, value);
      else adjust_bonus( tp, value );
      break;
   case "bonus" :
      if (_accounts["bonus"] < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      adjust_bonus(tp, -value);
      if (args[3] == "profit") adjust_profit(tp, value);
      else
      {
         money = MONEY_HAND->make_new_amount(value, _place);
         _counter->add_money_ob(money);
         shop_log(ACCOUNTS, tp, "adjusted the register by "+
           MONEY_HAND->money_value_string(value, _place), UNPAID);
      }
      break;
   case "profit" :
      if (_accounts["profit"] < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      adjust_profit(tp, -value);
      if (args[3] == "bonus") adjust_bonus( tp, value );
      else
      {
         money = MONEY_HAND->make_new_amount(value, _place);
         _counter->add_money_ob(money);
         shop_log( ACCOUNTS, tp, "adjusted the register by "+
           MONEY_HAND->money_value_string(value, _place), UNPAID);
      }
      break;
   }
   shop_log (ACCOUNTS, tp, "transferred "+ args[0]+ " "+ args[1]+ " from "+
      args[2]+ " to "+ args[3], PAID);
   tell_object(this_player(), "Ok.\n");
   return 1;
}
/* do_transfer() */


/** @ignore yes */
private void load_applicants()
{
   if (remove_call_out(_call_apps) != -1 ||
      remove_call_out(_call_apps_clear) != -1) return;
   if (!_applicants)
      if (file_size(_savedir+ "applications") > 0)
         _applicants = restore_variable(unguarded((: read_file,
            _savedir+ "applications" :)));
      else _applicants = ([]);
}
/* load_applications() */
   

/** @ignore yes */
private void load_history()
{
   if (remove_call_out(_call_hist) != -1 ||
      remove_call_out(_call_hist_clear) != -1) return;
   if (!_history)
      if (file_size(_savedir+ "history") > 0)
         _history = restore_variable(unguarded((: read_file,
            _savedir+ "history" :)));
      else _history = ([]);
}
/* load_history() */
   

/** @ignore yes */
private void load_new_policies()
{
   if (remove_call_out(_call_newpols) != -1 ||
      remove_call_out(_call_newpols_clear) != -1) return;
   if (!_new_policies)
      if ( file_size(_savedir+ "new_policies") > 0 )
         _new_policies = restore_variable(unguarded((: read_file,
            _savedir+ "new_policies" :)));
      else _new_policies = ([]);
}
/* load_new_policies() */


/** @ignore yes */
private void load_policies()
{
   if (remove_call_out(_call_pols) != -1 ||
      remove_call_out(_call_pols_clear) != -1) return;
   if (!_policies)
      if ( file_size( _savedir+ "policies" ) > 0 )
         _policies = restore_variable( unguarded( (: read_file,
            _savedir+ "policies" :) ) );
      else _policies = ([]);
}
/* load_policies() */


/** @ignore yes */
string * query_eom() { return ({_last_month,_eom,}); }

/**
 * @ignore yes 
 * Remove this person from the employees mapping.
 * Used when an employee is fired, resigns, or retires.
 * @param employee the name of the employee to remove
 */
private void remove_employee(string employee)
{
   employee = lower_case(employee);
   if (_employees[employee])
   {
      map_delete(_employees, employee);
      save_emps();
   }
   remove_applicant(employee);
   remove_retired(employee);
   
   /* Check to see if anyone should be hired */
   remove_call_out(_call_hire_list);
   _call_hire_list = call_out((: check_hire_list() :), 5);
}
/* remove_employee() */


/**
 * @ignore yes 
 * Remove this person from the retired managers array.
 * Used when a retired manager resigns.
 * @param retired the name of the employee to remove
 */
private void remove_retired(string retired)
{
   retired = lower_case(retired);
   if (member_array(retired, _retired) == -1) return;
   _retired -= ({retired});
   save_me();
}
/* remove_retired() */


/**
 * @ignore yes 
 * Employee bits are reset on clocking out.
 * @param word the name of the employee to reset
 * @param bit the bit(s) to reset
 * @see /include/player_shop.h
 */
private void reset_employee(string word, int bit)
{
   if (!_employees[word]) return;
   if ((bit < EMPLOYEE) || (bit > CLOCKED_IN))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "Trying to reset an employee bit < %d || > %d\n",
         EMPLOYEE, CLOCKED_IN );
#endif
      return;
   }
   _employees[word][EMP_POINTS] -= _employees[word][EMP_POINTS] & bit;
   if (bit != CLOCKED_IN) save_emps();
}
/* reset_employee() */

/**
 * @ignore yes 
 * Loading the contents of the shop's register.
 * @return a mixed monetary array to place in the register
 */
mixed *restore_register() { return copy(_register + ({})); }

/**
 * @ignore yes 
 * Employee bits are set upon promotion, or when clocking in.
 * @param word the name of the employee to set
 * @param bit the bit(s) to set
 * @see /include/player_shop.h
 */
// private void set_employee(string word, int bit)
void set_employee(string word, int bit)
{
   if (!_employees[word]) return;
/*
   if ((bit < EMPLOYEE) || (bit > CLOCKED_IN))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "Trying to set an employee bit < %d || > %d\n",
         EMPLOYEE, CLOCKED_IN);
#endif
      return;
   }
*/
   _employees[word][EMP_POINTS] |= bit;
   if (bit != CLOCKED_IN) save_emps();
}
/* set_employee() */


/**
 * @ignore yes 
 * Loads the npc shopkeeper and calls him/her/it to work.  Will only reload
 * the npc once every NPC_DELAY, unless clock_out is non-zero in which case the 
 * npc will be loaded regardless - this parameter indicates that the npc is 
 * being recalled due to an employee clocking out.
 */
void summon_shopkeeper()
{
   object shopkeeper = find_object(_shopkeeper);

   /* Already loaded */
   if (shopkeeper && environment(shopkeeper)) return;

   /* Don't appear if any employees in */
   if (num_employees_in()) return;
   _shopkeeper->start_shift();
}
/* summon_shopkeeper() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/admin.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/logging.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/logging.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629648   Available: 13577002
Inodes: Total: 5242880    Free: 4960136
9201 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/logging.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629648   Available: 13577002
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains log handling functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Display the shop's logs.
 */
int do_logs(mixed *args, string pattern)
{
    string start, end, file, *files, words;

    add_succeeded_mess("");
    switch (pattern)
    {   
    case LOG_BLANK :
        /* Display available logs */
        files = get_dir(_savedir +"general.log*");
        words = "Available logs:\n\n";
        if (sizeof(files))
            words += " 1: current log\n";
        for (int i = sizeof(files); i > 1; i--)
        {
            sscanf(unguarded((: read_file, _savedir + files[i-1], 2, 1 :)),
              "%*s, %s:", start);
            sscanf(unguarded((: read_file, _savedir + files[i-1],
                  file_length(_savedir + files[i-1]), 1 :)), 
              "%*s, %s: %*s", end );
            if (start == end)
                words += sprintf("%2d: %s\n",
                  sizeof(files)-(i-2), start);
            else
                words += sprintf("%2d: %s to %s\n",
                  sizeof(files)-(i-2), start, end);
        }
        words += "\nUse \"logs <number>\" to read one of them, or \"logs ";
        if ((_employees[this_player()->query_name()] && 
            _employees[this_player()->query_name()][EMP_POINTS] & MANAGER) ||
          this_player()->query_creator())
        {
            words += "{personnel|accounts|chart}\" to view "
            "those logs.\n";
        }
        else
        {
            words += "chart\" to view that log.\n";
        }
        tell_object(this_player(),"$P$Logs$P$"+ words);
        break;
    case LOG_NUMBER :
        /* Display specific log */
        files = get_dir(_savedir +"general.log*");
        if ((args[0] < 1) || (args[0] > sizeof(files)))
        {
            tell_object(this_player(), "There are "+ sizeof(files) +
              " logs.  Use \"logs\".\n");
            return 1;
        }
        if (args[0] == 1)
            sscanf(unguarded((: read_file, _savedir +
                  files[0] :)), "%*s\n%s", words);
        else
            sscanf(unguarded((: read_file, _savedir +
                  files[sizeof(files) - (args[0]-1)] :)), "%*s\n%s", words);
        tell_object(this_player(),"$P$Log "+ args[0]+ "$P$"+ words);
        break;
    case LOG_CHART :
        /* Display chart log */
        file = _savedir + "chart.log";
        if (file_size(file) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$Chart log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The chart log is empty.\n");
            return 1;
        }
        break;
    case LOG_MGR :
        /* Display special log */
        file = _savedir + args[0] + ".log";
        if (file_size( file ) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$"+ capitalize(args[0])+
              " log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The "+ args[0]+ " log is empty.\n");
            return 1;
        }
        break;
    }
    return 1;
}
/* do_logs() */

/**
 * @ignore yes 
 * Adds an entry to the employee's history.
 * This method is intended to log relevant personnel issues such as
 * applications, hirings, promotions etc.  The normal day-to-day
 * stuff is logged in the shop's logs themselves.
 * @param employee The employee.
 * @param note The note to log.
 */
private void employee_log(string employee, string note)
{
    load_history();
    if (!sizeof(_history)) _history = ([employee:({({}),({}),})]);
    else if (!_history[employee]) _history += ([employee:({({}),({}),})]);

    _history[employee][0] += ({time()});
    _history[employee][1] += ({note});
    save_hist();

    remove_call_out(_call_times);
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([ employee:0 ]);

    _times[employee] = time();   // Update employee record
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
/* employee_log() */

/**
 * @ignore yes 
 * This function adds an entry to the logs & pays employees.
 * Logs record a full day's (3 DW days) activity, apart from the
 * chart, accounts & personnel logs which use log_file.<br>
 * @param logtype The type of log entry - see <player_shop.h>
 * @param word The employee making the entry.
 * @param words The log entry text.
 * @param paid Should the employee be paid for this entry
 */
void shop_log(int logtype, string word, string words, int paid)
{
    string date, month, colour;

    sscanf(amtime(time()), "%*s %*s %*s %s %*s", month);
    if (file_size(_savedir +"general.log") > 0)
    {
        date = ctime(time())[0 .. 9];

        /*
         * Are we on a new day yet?  If so, do the daily review.
         */
        if (date != unguarded((: read_file,
              _savedir +"general.log", 1, 1 :))[0 .. 9])
        {
            string logfile = _savedir +"general.log-"+ time(),
            summary = sprintf( "%sFor the period ending %s:%s\n",
              "%^BOLD%^", amtime(time()), "%^RESET%^" ),
            sign = "";

            _storeroom->force_load();
            call_out((: update_averages() :), 60);
            unguarded((: rename, _savedir +"general.log", logfile :));
            call_out((: review_employees() :), 5 );
            foreach (string item in m_indices(_list))
            {
                summary += sprintf(" %s - Bought %d, Sold %d\n", capitalize(item),
                  _list[item][CHART_BOUGHT], _list[item][CHART_SOLD]);
                _list[item][CHART_AVESALE] = (_list[item][CHART_AVESALE] +
                  _list[item][CHART_SOLD] + random(2)) / 2;
                _list[item][CHART_SOLD] = 0;
                _list[item][CHART_BOUGHT] = 0;
            }
            save_list();
            if (_net_takings < 0)
            {
                _net_takings = -_net_takings;
                sign = "-";
            }
            summary += sprintf("%sThe net takings of the shop were %s%s.%s\n\n",
              "%^BOLD%^", sign, MONEY_HAND->money_value_string(_net_takings,
                _place), "%^RESET%^");
            _net_takings = 0;
            save_me();
            unguarded((: write_file, _savedir +"general.log",
                date +"\n" + summary :));

            /*
             * Remove old logs.
             */
            foreach (string file in get_dir(_savedir +"general.log-*"))
            {
                sscanf(file, "%*s-%s", date);
                if (time() - to_int(date) > (60*60*24*LOG_DAYS))
                    unguarded((: rm, _savedir + "general.log-"+ date :));
            }
        }
    }

    /*
     * Are we in a new month yet?  If so do the monthly review.
     */
    if (month != _last_month && !_call_review)
    {
        if (member_array(month, ({"Offle", "February", "March",
              "April", "May", "June", "Grune", "August", "Spune",
              "Sektober", "Ember", "December", "Ick"})) != -1)
        {
            _review_month = month;
            remove_call_out(_call_review);
            _call_review = call_out((: monthly_review() :), 60);
        }
    }

    /*
     * Only pay employees if clocked in & this is a paid action
     */
    if (_employees[word])
    {
        if (!(_employees[word][EMP_POINTS] & NPC))
            _employees[word][EMP_EOM]++;
        if (paid && _employees[word][EMP_POINTS] & CLOCKED_IN)
        {
            if (_employees[word][EMP_POINTS] & MANAGER)
                _employees[word][EMP_PAY] += (_pay_val * 2);
            else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
              _eom == word)
            {
                _employees[word][EMP_PAY] += to_int(_pay_val * 1.5);
                _employees[word][EMP_POINTS] += 32;
            }
            else
            {
                _employees[word][EMP_PAY] += _pay_val;
                _employees[word][EMP_POINTS] += 32;
            }
        }
        set_emp_time(word);
        save_emps();
    }

    /*
     * Write entry to the appropriate log.
     */
    switch (logtype)
    {
    case PURCHASE :
        colour = "%^GREEN%^";
        break;
    case SALE :
        colour = "%^RED%^";
        break;
    case GENERAL :
        colour = "%^CYAN%^";
        break;
    case PERSONNEL :
        log_file(_savedir+ "personnel.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case ACCOUNTS :
        log_file(_savedir+ "accounts.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case CHARTLOG :
        log_file(_savedir+ "chart.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    default :
        colour = "%^RESET%^";
        break;
    }
    unguarded((: write_file, _savedir +"general.log", colour + amtime(time())+
        ": "+ cap_name(word) +"%^RESET%^ - "+ words +"\n" :));
}
/* shop_log() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/logging.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/policies.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/policies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629645   Available: 13576999
Inodes: Total: 5242880    Free: 4960136
4420 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/policies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629645   Available: 13576999
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains policy-related functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Update policies in force.
 * Add policy if doesn't exist, or remove it if it does.
 * @param policy the policy to update
 */
private void add_policy(string policy)
{
   load_policies();
   load_new_policies();
   if (!_policies[policy])
   {
      _policies += ([policy:({"",0})]);
      _policies[policy][0] = _new_policies[policy][POLICY_TEXT];      
      _policies[policy][1] = _new_policies[policy][POLICY_TYPE];      
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "", "Your proposition has been "
        "accepted by majority vote and is now policy.\n" );
      shop_log(GENERAL, "Shop", "accepted the "+ policy + " policy.", UNPAID);
   }
   else
   {
      map_delete(_policies, policy);
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "",
        "Your proposition to remove the above policy has been accepted "
        "by majority vote.\n");
      shop_log(GENERAL, "Shop", "removed the "+ policy + " policy.", UNPAID);
   }
   map_delete(_new_policies, policy);
   save_policies();
   save_new_policies();
}
/* add_policy() */

/**
 * @ignore yes 
 * Add a new policy suggestion.
 * @param name the name of the policy
 * @param text the body text of the policy
 * @param mgr the manager proposing the policy
 */
void add_policy_suggest(string name, string text, string mgr, int type)
{
   if (previous_object() && previous_object() != find_object(_mgr_office))
   {
      LOG_ERROR("office.c", "add_policy_suggest("+name+","+text+","+mgr+")");
      return;
   }
   load_new_policies();
   if (!sizeof(_new_policies)) _new_policies = ([ name:POLICY_MAP ]);
   else _new_policies += ([ name:POLICY_MAP ]);
   load_policies();
   if (sizeof(_policies) && _policies[name]) text = _policies[name][0];
   _new_policies[name][POLICY_TIME] = time();
   _new_policies[name][POLICY_MGR] = mgr;
   _new_policies[name][POLICY_TEXT] = text;
   _new_policies[name][POLICY_TYPE] = type;
   do_policy_vote(mgr, name, "y");
   clear_policies();
   save_new_policies();
} 
/* add_policy_suggest() */

/**
 * @ignore yes 
 * Add a vote
 * @param mgr the voting manager
 * @param policy the policy being voted upon
 */
private int do_policy_vote(string mgr, string policy, string decision)
{
   int managers;

   load_new_policies();
   if (!m_sizeof(_new_policies) || !_new_policies[policy])
   {
      tell_object(this_player(), "There is no such policy pending!\n");
      return 1;
   }
   if (member_array(mgr, _new_policies[policy][POLICY_FOR]) != -1 ||
     member_array(mgr, _new_policies[policy][POLICY_AGAINST]) != -1 )
   {
      tell_object(this_player(), "You have already voted on this policy!\n");
      return 1;
   }
   if (decision == "y")
   {
      _new_policies[policy][POLICY_FOR] += ({mgr});
      tell_object(this_player(), "You vote for the " + policy+ " policy.\n");
   }
   else
   {
      _new_policies[policy][POLICY_AGAINST] += ({mgr});
      tell_object(this_player(), "You vote against the "+
         policy+ " policy.\n");
   }
   shop_log(GENERAL, mgr, "voted on the "+ policy + " policy.", PAID);
   save_new_policies();
   managers = sizeof(get_managers()) + sizeof(get_retired());
   if (sizeof(_new_policies[policy][POLICY_FOR]) > managers / 2)
      add_policy(policy);
   else if (sizeof(_new_policies[policy][POLICY_AGAINST]) >= managers / 2)
      remove_policy(policy);
   return 1;
}
/* do_policy_vote() */

/**
 * @ignore yes
 * Query the shop's main policy - used for the notice.
 * @return the main policy of the shop
 */
string get_stock_policy() { return copy(_stock_policy); }

/**
 * @ignore yes 
 * Policy update has been unsuccessful.
 * @param the policy that was rejected
 */
private void remove_policy(string policy)
{
   load_new_policies();
   PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR],
     "Tarnach Fendertwin", "Policy proposition - "+ policy, "",
     "Your proposition has been rejected by majority vote.\n");
   shop_log(GENERAL, "Shop", "rejected the "+ policy + " policy.\n", UNPAID);
   map_delete(_new_policies, policy);
   save_new_policies();
}
/* remove_policy() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/policies.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/personnel.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/personnel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629644   Available: 13576998
Inodes: Total: 5242880    Free: 4960136
17063 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/personnel.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629644   Available: 13576998
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains the personnel related functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Adds a new employee.
 * Also prevent the employee from receiving a bonus until they have
 * worked a full month by setting EMP_NOBONUS to 1.
 * @param player the employee to add
 */
private void add_employee(string player)
{
    if (!_employees[player])
    {
        _employees += ([player:EMP_MAP]);
        _employees[player][EMP_NOBONUS] = 1;
        set_emp_time(player);
        _got_bonus += ({player});
        save_me();
        save_emps();
    }
}
/* add_employee() */

/**
 * @ignore yes 
 * Demote a manager or supervisor.
 * @param demoter the person doing the demoting
 * @param demotee the person being demoted
 */
private void demote(string demoter, string demotee)
{
    int points = _employees[demotee][EMP_POINTS] & CLOCKED_IN;
    if (_employees[demotee][EMP_POINTS] & MANAGER)
        points += (SUPER_POINTS * 32) + EMPLOYEE + SUPERVISOR;      
    else points += EMPLOYEE;
    _employees[demotee][EMP_POINTS] = points;
    save_emps();
    PLAYER_SHOP->auto_mail(demotee, _proprietor, "Demotion", "",
      "This is to advise you that you have today been demoted.\n"
      "This demotion will now stay on your employment record.\n");
    employee_log(demotee, "Demoted by "+ demoter);
    shop_log(PERSONNEL, demoter, "demoted "+ cap_name(demotee), PAID);
}
/* demote() */

/**
 * @ignore yes 
 * Managers' office.
 * Commend employees.  Adds 5% of their promotion target.
 */
int do_commend(string emp)
{
    string commender;

    if (!_employees[emp])
    {
        tell_object(this_player(), cap_name(emp)+
          " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        tell_object(this_player(), "You can't commend a manager.\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  "
          "You can't commend $C$"+ emp +".\n");
        return 1;
    }
    commender = this_player()->query_cap_name();
    AUTO_MAILER->auto_mail(emp, lower_case(commender), "Commendation",
      "", "This is to advise you that you have today received a "
      "commendation for outstanding service.\nThis will now stay on "
      "your employment record.\n");
    employee_log(emp, "Received a commendation from "+ commender);
    shop_log(PERSONNEL, commender, "commended "+ cap_name(emp), PAID);
    _employees[emp][EMP_POINTS] += (_employees[emp][EMP_POINTS] & SUPERVISOR)?
    to_int(MANAGER_POINTS * 0.05 * 32) : to_int(SUPER_POINTS * 0.05 * 32);
    save_emps();
    tell_object(this_player(), "You commend "+ cap_name(emp)+ ".\n");
    return 1;
}
/* do_commend() */

/**
 * @ignore yes 
 * Managers' office.
 * Demote supervisors or managers.
 */
int do_demote(string emp)
{
    object tp = this_player();
    emp = lower_case(emp);
    if (!_employees[emp])
    {
        tell_object(tp, cap_name(emp)+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER && !tp->query_creator())
    {
        tell_object(tp, "You don't have the authority to "
          "demote $C$"+ emp +".\n");
        return 1;
    }
    if (!( _employees[emp][EMP_POINTS] & SUPERVISOR))
    {
        tell_object(tp, "Don't be silly!  You can't demote $C$"+
          emp +".\n");
        return 1;
    }
    demote(tp->query_cap_name(), emp);
    tell_object(tp, "You demote "+ cap_name(emp)+ ".\n");
    return 1;
}
/* do_demote() */

/**
 * @ignore yes 
 * Managers' office.
 * Fire an employee.
 */
int do_fire(mixed *args)
{
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(this_player(), cap_name(args[0])+
          " doesn't work at the shop!\n");
        return 1;
    }
    if ((member_array(args[0], _retired) != -1) ||
      query_manager(args[0]) && !this_player()->query_creator())
    {
        tell_object(this_player(), "You don't have the authority "
          "to fire $C$"+ args[0] +".\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  You can't fire $C$"+
          args[0] +".\n");
        return 1;
    }
    fire_them(this_player()->query_name(), args[0], args[1]);
    tell_object(this_player(), "You fire "+ cap_name(args[0])+
      " for "+ args[1]+ ".\n" );
    return 1;
}
/* do_fire() */

/**
 * @ignore yes 
 * Managers' office.
 * Place an employee on leave.
 */
int do_leave(mixed *args)
{
    object tp = this_player();
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an employee!\n");
        return 1;
    }
    if (args[1] > MAX_LEAVE)
    {
        tell_object(tp, "You cannot place an employee on leave "
          "for more than "+ MAX_LEAVE+ " days at a time.\n");
        return 1;
    }
    _times[args[0]] = time() + (args[1] * 86400);
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
    add_succeeded_mess(cap_name(args[0])+
      " is on leave until "+ ctime(time() + (args[1] * 86400))+ ".\n");
    shop_log(PERSONNEL, tp->query_name(), "placed "+
      cap_name(args[0])+ " on leave for " + args[1]+ " days", PAID);
    employee_log(args[0], "Placed on leave by "+ tp->query_cap_name()+
      " for "+ args[1]+ " days.");
    tell_object(tp, "You place "+ cap_name(args[0])+
      " on leave for " + args[1]+ " days.\n");
    return 1;
}
/* do_leave() */

/**
 * @ignore yes 
 * This employee has requested to be passed over (or not) for promotion.
 */
private int do_promote(string on)
{
    object tp = this_player();
    add_succeeded_mess("");
    if (tp->query_creator())
    {
        tell_object(tp, "Creators don't get promoted.\n");
        return 1;
    }
    switch (on)
    {
    case "off" :
        _employees[tp->query_name()][EMP_NOPROMOTE] = TRUE;
        tell_object(tp, "You have now requested to be "
          "passed over for promotion.\n");
        break;
    case "on" :
        if (tp->query_property("no score"))
        {
            tell_object(tp, "Sorry, you cannot be promoted.\n");
            return 1;
        }
        _employees[tp->query_name()][EMP_NOPROMOTE] = FALSE;
        tell_object(tp, "You have now requested to be "
          "considered for promotion.\n");
        break;
    }
    save_emps();
    return 1;
}
/* do_promote() */

/**
 * @ignore yes 
 * Employee wishes to terminate their employment with the shop.
 */
private int do_resign()
{
    string word = this_player()->query_name();

    add_succeeded_mess("$N $V.\n");
    remove_employee(word);
    shop_log(PERSONNEL, word, "resigned", UNPAID);
    employee_log(word, "Resigned");
    return 1;
}
/* do_resign() */

/**
 * @ignore yes 
 * Managers' office.
 * Retire from management.
 */
int do_retire()
{
    string manager = this_player()->query_name();
    if (!(_employees[manager][EMP_POINTS] & MANAGER)) return 0;
    remove_employee(manager);
    _retired += ({manager});
    shop_log(PERSONNEL, manager, "retired from management", UNPAID);
    employee_log(manager, "Retired from management");
    save_me();
    add_succeeded_mess("$N retire$s.\n");
    return 1;
}
/* do_retire() */

/**
 * @ignore yes 
 * Managers' office.
 * Suspend employee's bonus for x months.
 */
int do_suspend(mixed *args)
{
    string suspender;
    object tp = this_player();

    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if ((_employees[args[0]][EMP_POINTS] & MANAGER) && 
      (!tp->query_creator()))
    {
        tell_object(tp, "You don't have the authority to "
          "suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  "
          "You can't suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    suspender = tp->query_cap_name();
    _employees[args[0]][EMP_NOBONUS] = args[1];
    save_emps();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Suspended bonus", "",
      sprintf( "This is to advise you that you have had your bonus "
        "entitlement suspended for %d month%s.\nThis suspension will "
        "now stay on your employment record.\n", args[1],
        (args[1] == 1)?"":"s"));
    employee_log(args[0], sprintf("Bonus suspended for %d month%s by %s",
        args[1], (args[1] == 1)?"":"s", suspender));
    shop_log(PERSONNEL, suspender,
      sprintf("suspended %s's bonus for %d month%s", args[0],
        args[1], (args[1] == 1)?"":"s"), PAID);
    tell_object(tp, "You suspend "+ cap_name(args[0])+
      "'s bonus for "+ args[1]+ " months.\n");
    return 1;
}
/* do_suspend() */

/**
 * @ignore yes 
 * Managers' office.
 * Warn employees.  Removes 5% of their promotion target.
 */
int do_warn(mixed *args)
{
    string warner;
    object tp = this_player();
    int points;

    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & MANAGER && !tp->query_creator() )
    {
        tell_object( tp, "You don't have the authority to "
          "warn $C$"+ args[0] +".\n" );
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  You can't warn $C$"+ args[0] +".\n");
        return 1;
    }
    warner = tp->query_cap_name();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Official warning", "",
      "This is to advise you that you have today received a formal "
      "warning for " + args[1] + ".\nThis warning will now stay on "
      "your employment record.\n");
    employee_log(args[0], "Received a warning from "+ warner+ 
      " for "+ args[1]);
    shop_log(PERSONNEL, warner, "warned "+
      cap_name( args[0] ) + " for "+ args[1], PAID);
    points = _employees[args[0]][EMP_POINTS] & CLOCKED_IN;
    if (_employees[args[0]][EMP_POINTS] & SUPERVISOR)
        _employees[args[0]][EMP_POINTS] -= to_int(MANAGER_POINTS * 0.05 * 32);
    else
    {
        _employees[args[0]][EMP_POINTS] -= to_int(SUPER_POINTS * 0.05 * 32) +
        EMPLOYEE;
        if (_employees[args[0]][EMP_POINTS] < 1)
            _employees[args[0]][EMP_POINTS] = EMPLOYEE + points;
    }
    save_emps();
    tell_object(tp, "You warn "+ cap_name(args[0])+ " for "+
      args[1]+ ".\n");
    return 1;
}
/* do_warn() */

/**
 * @ignore yes 
 * Used when employees are fired by managers, or automatically.
 * @param word the person doing the firing
 * @param them the person being fired
 * @param reason the reason for being fired
 */
private void fire_them(string word, string them, string reason)
{
    if (!_employees[them]) return;
    BANK_HANDLER->adjust_account(them, BANKS[_employees[them][EMP_BANK]][1],
      _employees[them][EMP_PAY]);
    shop_log(ACCOUNTS, _proprietor, "paid "+ 
      MONEY_HAND->money_value_string(_employees[them][EMP_PAY], _place)+
      " to "+ cap_name(them), UNPAID);
    shop_log(PERSONNEL, word, "fired "+ cap_name(them) +
      " for "+ reason, PAID);
    PLAYER_SHOP->auto_mail(them, word, _shop_name, "", 
      "Unfortunately, I have to inform you that you have today "
      "been fired for " + reason + ".  You have been paid the sum of "+
      MONEY_HAND->money_value_string( _employees[them][EMP_PAY], _place )+
      " for the work you have carried out to this date.\nIf you feel you "
      "have been unfairly dismissed, please refer to a manager.\n");
    employee_log(them, "Fired by "+ cap_name(word)+
      " for "+ reason);
    remove_employee(them);
}
/* fire_them() */

/**
 * @ignore yes 
 * Used when applicant has sufficient supporting votes to be accepted.
 * @param word the person to hire
 */
private void hire(string word)
{
    int gender;

    remove_applicant(word);

    /* Do not hire if not a user, already an employee, or banned */
    if (!test_player(word) || _employees[word] || query_baddie(word)) return;

    add_employee(word);
    employee_log(word, "Hired");
    shop_log(PERSONNEL, _proprietor, "hired "+ cap_name(word), UNPAID);
    PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "", 
      "Congratulations!  You've been hired to work at "+ _shop_name+
      ".  You'll find that you can now move through the counter "
      "to the back areas of the shop.  The first things you should "
      "do are \"claim\" a new badge and staff handbook.\n");
    gender = PLAYER_HANDLER->test_gender(word);
    add_board_message("New employee", sprintf("%s has today been employed to "
        "work for the shop.  Please make %s feel welcome, and assist %s while "
        "%s gets started in %s new position.\n", cap_name(word),
        ({"it", "him", "her"})[gender] ,({"it", "him", "her"})[gender],
        ({"it", "he", "she"})[gender], ({"its", "his", "her"})[gender]));

    /* Update the other accepted applicants */
    remove_call_out(_call_mail_hirees);
    _call_mail_hirees = call_out((: mail_hirees() :), 5);
}
/* hire() */

/**
 * @ignore yes 
 * Used by the employee list to show managers & creators the last
 * time an employee was active.  Employees will be highlighted yellow
 * if they are currently on an inactivity warning, and red if they are
 * within 7 days of being fired/demoted
 * @param emp the employee to query
 */
private string query_worked(string emp)
{
    string blurb;

    /* Clocked in */
    if (_employees[emp][EMP_POINTS] & CLOCKED_IN)
        return " is currently clocked in";

    /* NPC */
    if (_employees[emp][EMP_POINTS] & NPC)
        return " has gone home for tea";

    /* On leave */
    if (_times[emp] > time())
        return " - %^CYAN%^on leave until "+ ctime(_times[emp])+ "%^RESET%^";

    blurb = " - last action ";

    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        if ((time() - _times[emp]) > ((60*60*24*MGR_DEMOTE)-7))
            blurb += "%^RED%^"; 
        else if ((time() - _times[emp]) > (60*60*24*MGR_WARN))
            blurb += "%^RED%^"; 
    }
    else if (_employees[emp][EMP_POINTS] & SUPERVISOR)
    {
        if (( time() - _times[emp]) > ((60*60*24*SPR_DEMOTE)-7))
            blurb += "%^RED%^"; 
        else if ((time() - _times[emp]) > (60*60*24*SPR_WARN))
            blurb += "%^YELLOW%^"; 
    }
    else if (( time() - _times[emp]) > ((60*60*24*EMP_FIRE)-7))
        blurb += "%^RED%^";
    else if ((time() - _times[emp]) > (60*60*24*EMP_WARN))
        blurb += "%^YELLOW%^";
    return blurb + ctime(_times[emp])+ "%^RESET%^";
}
/* query_worked() */

/**
* @ignore yes 
* Sets the last action time of an employee.
* This time is the last time an employee did something worth
* recording and is used to determine if they are inactive.
* @param employee The employee.
*/
private void set_emp_time(string employee)
{
    if (!_employees[employee]) return;
    if (_employees[employee][EMP_INACTIVE])
    {
        _employees[employee][EMP_INACTIVE] = 0;   // Reset inactivity flag
        save_emps();
    }
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([employee:0]);
    _times[employee] = time();
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
/* set_emp_time() */

/**
 * @ignore yes 
 * View an employee's history or an applicant's application.
 * This method displays a formatted display of the employee's history
 * with a particular shop, and is viewable by managers of that shop.
 * If passed the name of an applicant, it will view the relevant application.
 * @param person The employee or applicant.
 */
void view_record(string person, string pattern)
{   
    if (pattern == VIEW_EMP)
    {
        string text = sprintf("Employment history of %s:\n\n", cap_name(person));
        load_history();
        if (!sizeof(_history) || !_history[person])
        {
            tell_object(this_player(), "There is no history for that person.\n");
            return;
        }
        for(int i = 0; i < sizeof(_history[person][0]); i++)
            text += sprintf("%s: %s\n", ctime(_history[person][0][i]),
              _history[person][1][i]); 
        tell_object(this_player(), sprintf("$P$%s's history$P$%s",
            cap_name(person), text));
        clear_history();
    }
    else
    {
        if (!query_applicant(person))
        {
            tell_object(this_player(), "That person has no application form "
              "on file.\n");
            return;
        }
        load_applicants();
        tell_object(this_player(),
          sprintf("$P$%s's history$P$Application of %s:\n\n%s", cap_name(person),
            cap_name(person), _applicants[person][APP_MESSAGE]));
        clear_applicants();
    }
}
/* view_record() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/personnel.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/baddies.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/baddies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629640   Available: 13576994
Inodes: Total: 5242880    Free: 4960136
3553 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/baddies.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629640   Available: 13576994
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains banning-related functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Ban this person from the shop.
 * This person will be banned for a specific period, and will not be allowed
 * back in the shop within this period.  People can be banned by managers, or
 * automatically for attacking employees.
 * @param word person to ban
 * @param reason reason for the ban
 * @param banner person implementing the ban
 */
private void add_baddie(string word, string reason, string banner)
{
   object ob;

   word = lower_case(word);
   if (query_baddie(word))
   {
      /*
       * Added this bit after discovering someone had been banned 75
       * times for killing Gretta @ Tarnach's- all at the same time.
       */
      if (_baddies[word][BAD_TIME] == time() ||
         reason == _baddies[word][BAD_REASON]) return;
      remove_baddie( word );
   }
   if (!sizeof(_baddies)) _baddies = ([word:BAD_MAP]);
   else _baddies += ([word:BAD_MAP]);
   _baddies[word][BAD_REASON] = reason;
   _baddies[word][BAD_BANNER] = banner;
   _baddies[word][BAD_TIME] = time();
   save_me();
   shop_log(GENERAL, banner, "banned "+ cap_name(word)+
      " for "+ reason, PAID);
   employee_log(word, sprintf("Banned by %s for %s.", cap_name(banner),
      reason));
   fire_them(_proprietor, word, reason);
   remove_applicant(word);
   if (!(ob = find_player(word))) return;

   /* If this person is in the shop front, move them outside. */
   if (environment(ob) == find_object(_shop_front))
   {
      tell_room(_shop_front, ob->query_short()+ " drifts out of the door, "
        "seemingly against "+ ob->query_possessive()+ " will.\n", ({ob}));
      tell_object(ob , "You feel yourself pushed out of the shop "
        "by a mysterious force.\n");
      tell_room(_shop_front->query_outside(), ob->query_short()+
        " drifts through the door of "+ _shop_name +
        ", seemingly against "+ ob->query_possessive()+ " will.\n", ({ob}));
      ob->move(_shop_front->query_outside());
   }
}
/* add_baddie() */

/**
 * @ignore yes 
 * Managers' office.
 * Ban a person from the shop.
 */
int do_ban(mixed *args)
{
   if (!test_player(lower_case(args[0])))
   {
      tell_object(this_player(), args[0]+ " is not a player.\n");
      return 1;
   }
   if (_employees[args[0]][EMP_POINTS] & MANAGER &&
      !this_player()->query_creator())
   {
      tell_object(this_player(), "You cannot ban "+ cap_name(args[0])+
         ".\n");
      return 1;
   }
   add_baddie(args[0], args[1], this_player()->query_name());
   tell_object(this_player(), "You ban "+ cap_name(args[0])+
     " for "+ args[1]+ ".\n");
   return 1;
}
/* do_ban() */

/**
 * @ignore yes 
 * Managers' office.
 * Remove the ban on a person.
 */
int do_unban(string person)
{
   if (!query_baddie(person))
   {
      tell_object(this_player(), person+ " is not currently banned.\n");
      return 1;
   }
   remove_baddie(person);
   shop_log(GENERAL, this_player()->query_name(),
     "removed the ban on "+ cap_name(person), PAID);
   tell_object(this_player(), "You remove the ban on "+ 
     cap_name(person)+ ".\n" );
   return 1;
}
/* do_unban() */

/**
 * @ignore yes 
 * Remove this person from the list of people banned from the shop.
 * @param word the person to unban
 */
private void remove_baddie(string word)
{
   if (!query_baddie(word)) return;
   map_delete(_baddies, word);
   save_me();
}
/* remove_baddie() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/baddies.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/masked.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/masked.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629639   Available: 13576993
Inodes: Total: 5242880    Free: 4960136
8416 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/masked.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629639   Available: 13576993
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
 * This file contains masked functions
 *****************************************************************************/

/**
 * @ignore yes 
 * Make sure all data is saved before desting this object.
 */
void dest_me()
{
   if (_very_short != UNSET_STR)
   {
      if (remove_call_out(_call_save) != -1) do_save();
      if (remove_call_out(_call_apps) != -1) do_save_applicants();
      if (remove_call_out(_call_hist) != -1) do_save_hist();
      if (remove_call_out(_call_newpols) != -1) do_save_new_policies();
      if (remove_call_out(_call_pols) != -1) do_save_policies();
      if (remove_call_out(_call_times) != -1) save_times();
      if (remove_call_out(_call_emps) != -1) do_save_emps();
   }
   if (_chart) _chart->dest_me();
   if (_board) _board->dest_me();
   if (_notice) _notice->dest_me();
   ::dest_me();
}
/* dest_me() */

/**
 * @ignore yes 
 * Someone has died.
 * This function will automatically fire an employee if they have
 * killed someone whilst on duty.  It will also make a note of anyone
 * who has killed an on-duty employee (including the npc shopkeeper).
 */
void event_death(object killed, object *others, object killer,
  string rmess, string kmess)
{
   /* Only look for players & the shopkeeper
    * We don't want to fire/ban people for killing a cabbage...
    */
   if (!killed->query_player() &&
     !(query_employee(killed->query_name()) & NPC)) return;
   if (!killer) return;

   if ((query_employee(killed->query_name()) & NPC)  || 
    (query_employee(killed->query_name())))
   {
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
      foreach(object baddie in others)
         if (baddie->query_player())
            add_baddie(baddie->query_name(),
              "the vicious assault on "+ killed->query_name(),
              _proprietor);
      return;
   }
   if (query_employee(killer->query_name()) & CLOCKED_IN)
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
   if (sizeof(others))
      foreach(object baddie in others)
      {
         if (!baddie->query_player()) continue;
         if (query_employee(baddie->query_name())& CLOCKED_IN)
            add_baddie(baddie->query_name(), "the vicious assault on "+
               killed->query_name(), _proprietor);
      }
}
/* event_death() */

/**
 * @ignore yes 
 * Someone has entered the room.
 * This function will automatically fire an employee if they have
 * teleported to this room.
 */
void event_enter(object ob, string message, object from)
{
   string room;

   if (!from || ob->query_creator() || from == find_object("/room/void") ||
     !ob->query_player()) return;
   room = file_name(from);
   if (room == _counter || room == _shop_front || room == _storeroom || 
     room == _mgr_office || from == this_object()) return;
#ifdef DEBUG
   tell_creator(CREATOR, "%s arrived from %O.\n", ob->query_name(), from);
#endif
   fire_them(_proprietor, ob->query_name(), "for teleporting into the shop");
}
/* event_enter() */

/**
 * @ignore yes 
 * init() - speaks for itself really
 */
void init()
{
   object tp = this_player();
   string word = tp->query_name();

   ::init();

   /*
    * Only employees & creators should have access to shop commands.
    */
   if (!tp->query_creator() && !_employees[word] &&
     (member_array(word, _retired) == -1)) return;
   add_command("claim", "{badge|handbook|bonus}", (: do_claim($4[0]) :));
   add_command("resign", "", (: do_resign() :));
   add_command("list", "", (: do_list() :));
   add_command("office", "", (: do_office() :));

   /*
    * If there is no board set up for this shop, all comms done by mail.
    */
   if (!_board) add_command("memo", "", (: do_memo() :));

   /*
    * Retired managers have no need for following commands.
    */
   if (member_array(word, _retired) != -1) return;
   add_command("clock", "{in|out}", (: do_clock($4[0]) :));
   add_command("bank", ({ "", "<number>" }), (: do_bank($4) :));
   if (!this_player()->query_property("no score"))
      add_command( "promotion", "{on|off}", (: do_promote($4[0]) :) );

   /*
    * Only supervisors & managers have access to following commands.
    */
   if (!tp->query_creator() &&  !(_employees[word][EMP_POINTS] & SUPERVISOR))
      return;
   add_command("chart", ({CHART_ADDITEM, CHART_REMITEM, CHART_MAXITEM,
      CHART_BUYITEM, CHART_SELLITEM, CHART_ASSIGN_ITEM, CHART_UNASSIGN_ITEM}),
     (: do_chart($4,$5) :));
   add_command("check", "cabinets", (: do_check() :));
   if (!tp->query_creator() && !(_employees[word][EMP_POINTS] & MANAGER))
      add_command( "logs", ({LOG_BLANK, LOG_NUMBER, LOG_CHART}),
      (: do_logs($4,$5) :));
   else 
      add_command("logs", ({LOG_BLANK, LOG_NUMBER,
        LOG_MGR}), (: do_logs($4,$5) :));
}
/* init() */

/**
 * @ignore yes 
 * Called when someone is refreshed or deleted
 * Will delete the employee in case of deletion or full refresh.  In case
 * of partial refresh, will reset employee to new employee status.
 */
void refresh_function(mixed employee, int flag)
{
   string emp_name;

   switch (flag)
   {
      case PLAYER_DELETED :
        emp_name = employee;
        break;
      case TOTAL_REFRESH :
      case PARTIAL_REFRESH :
        emp_name = employee->query_name();
        break;
   }

   if (query_applicant(emp_name))
   {
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your application at "+ _shop_name+ 
             " has been removed.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }   
   }

   if (member_array(emp_name, _retired) != -1)
   {     
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your employment at "+ _shop_name+ 
             " has been terminated.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }   
   }

   if (!_employees[emp_name]) return;

   switch (flag)
   {
      case PLAYER_DELETED :
        shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
        employee_log(emp_name, "Deleted character");
        remove_employee(emp_name);
        break;
      case TOTAL_REFRESH :
        tell_object(employee, "Your employment at "+ _shop_name+ 
          " has been terminated.\n");
        shop_log(PERSONNEL, emp_name, "refreshed totally", UNPAID);
        employee_log(emp_name, "Refreshed totally");
        remove_employee(emp_name);
        break;
      case PARTIAL_REFRESH :
        tell_object(employee, "Your employment level at "+ _shop_name+ 
          " has been reset.\n");
        shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
        employee_log(emp_name, "Refreshed character");
        _employees[emp_name] = EMP_MAP;
        set_emp_time(emp_name);
        _got_bonus += ({emp_name});
        save_me();
        break;
   }
}
/* refresh_function() */   

/**
 * @ignore yes 
 * Add standard stuff
 */
protected void set_long(string long_desc)
{
   string ob_file = file_name(this_object());

   /***************************
    * Add the shop's item chart
    **************************/
   _chart = clone_object(SHOP_CHART);
   _chart->set_office(ob_file);
   add_hidden_object(_chart);

   /******************************
    * Add the shop's policy notice
    *****************************/
   _notice = clone_object(SHOP_NOTICE);
   _notice->set_office(ob_file);
   add_hidden_object(_notice);
   long_desc += "Employees may \"clock\" in and out of work here "
     "and examine the items chart.  There is also a policy notice "
     "located next to the chart.\n";
   ::set_long(long_desc);
}
/* set_long() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/masked.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office_code/stock.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/stock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629636   Available: 13576990
Inodes: Total: 5242880    Free: 4960136
7340 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office_code/stock.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629636   Available: 13576990
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/******************************************************************************
* This file contains stock-related functions
*****************************************************************************/

/**
* @ignore yes 
* Keep track of items bought.
*/
void adjust_bought(string item, int amt)
{
   if (previous_object() && previous_object() != find_object(_storeroom))
   {
      LOG_ERROR("office.c", "adjust_bought("+item+","+amt+")");
      return;
   }
   _list[item][CHART_BOUGHT] += amt;
   save_list();
}
/* adjust_bought() */

/**
* @ignore yes 
* Keep track of items sold.
*/
void adjust_sold(string item, int amt)
{
   if (previous_object() && previous_object() != find_object(_storeroom))
   {
      LOG_ERROR("office.c", "adjust_sold("+item+","+amt+")");
      return;
   }
   _list[item][CHART_SOLD] += amt;
   save_list();
}
/* adjust_sold() */

/**
* @ignore yes 
* Maintain the list of stock dealt in by this shop.
*/
private int do_chart(mixed *args, string pattern)
{
   int number;
   string word = this_player()->query_name();
   
   if (sizeof(args) > 1) number = args[1];
   
   if (pattern == CHART_ADDITEM)
   {
      if(query_on_list(args[0]))
      {
         tell_object( this_player(), args[0] +
            " are already on the sales list.\n" );
         return 1;
      }
   }
   else if (!query_on_list(args[0]))
   {
      tell_object(this_player(), args[0] +" are not on the sales list.\n");
      return 1;
   }
   
   switch (pattern)
   {
   case CHART_ADDITEM :
      /* Start dealing in this item */
      add_succeeded_mess("$N put$s "+ args[0] +" on the sales list.\n");
      put_on_list(args[0]);
      shop_log(CHARTLOG, word, "put "+ args[0] +" on the sales list", PAID);
      break;
   case CHART_REMITEM :
      /* Stop dealing in this item */
      add_succeeded_mess("$N take$s "+args[0] +" off the sales list.\n");
      take_off_list( args[0] );
      shop_log(CHARTLOG, word, "took "+args[0] +" off the sales list", PAID);
      break;
   case CHART_MAXITEM :
      /* Set maximum stock */
      if (number < 1)
      {
         tell_object(this_player(), "Maximum must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the maximum stock of "+ args[0] +" to "+
         number +".\n");
      set_max(args[0], number);
      shop_log(CHARTLOG, word, "set max of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_BUYITEM :
      /* Set buy price */
      if (number < 1)
      {
         tell_object(this_player(), "Price must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the buying price of "+ args[0] +" to "+
         number +".\n");
      set_buy(args[0], number);
      shop_log(CHARTLOG, word, "set buy of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_SELLITEM :
      /* Set sell price */
      if (number < 1)
      {
         tell_object(this_player(), "Price must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the selling price of "+ args[0] +" to "+
         number +".\n");
      set_sell(args[0], number);
      shop_log(CHARTLOG, word, "set sell of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_ASSIGN_ITEM :
      /* Assign item to cabinets */
      if (member_array( number, _list[args[0]][CHART_CAB] ) != -1)
      {
         tell_object(this_player(), args[0]+ 
            " are already assigned to cabinet "+ number+ ".\n");
         return 1;
      }
      if (number < 1 || number > _num_cabinets)
      {
         tell_object(this_player(), "That cabinet does not exist.\n");
         return 1;
      }
      add_chart_cabinet(args[0], number);
      add_succeeded_mess("$N assign$s "+ args[0] +" to use cabinet "+
         number +".\n");
      shop_log(CHARTLOG, word, "assigned "+ args[0] +
         " to cabinet "+ number, PAID);
      break;
   case CHART_UNASSIGN_ITEM :
      /* Stop item using cabinets */
      if (member_array( number, _list[args[0]][CHART_CAB] ) == -1)
      {
         tell_object(this_player(), args[0]+ 
            " are not assigned to cabinet "+ number+ ".\n");
         return 1;
      } 
      remove_chart_cabinet(args[0], number);
      add_succeeded_mess("$N stop$s "+ args[0] +" using cabinet "+
         number +".\n");
      shop_log(CHARTLOG, word, "unassigned "+ args[0] +
         " from cabinet "+ number, PAID);
      break;
   }
   return 1;
}
/* do_chart() */

/**
* @ignore yes 
* Add an item for the shop to deal in.
*/
private void put_on_list(string word)
{
   if (!_list[word])
   {
      _list[word] = ({5, 0, 20, 25, ({}), 0, 0, 0});
      save_list();
   }
}
/* put_on_list() */

/**
* @ignore yes 
* Query the average number of this item in stock.
* @param item The item to query.
* @return The average stock.
*/
int query_ave(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_AVE]);
}
/* query_ave() */

/**
* @ignore yes 
* Query the buying price of this item.
* This is the actual value, in the smallest unit of local currency
* (eg. pence, farthings etc), rather than the absolute value. 
* @param item The item to query.
* @return The buy price.
*/
int query_buy(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_BUY]);
}
/* query_buy() */

/**
* @ignore yes 
* Query the maximum number of this item allowed in stock.
* @param item The item to query.
* @return The maximum stock.
*/
int query_max(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_MAX]);
}
/* query_max() */

/**
* @ignore yes 
* Query if the shop sells this item.
* @param item The item to query.
* @return TRUE or FALSE
*/
int query_on_list(string item) { return (!_list[item])?FALSE:TRUE; }

/**
* @ignore yes 
* Query the sell price of this item.
* This is the actual value, in the smallest unit of local currency
* (eg. pence, farthings etc), rather than the absolute value. 
* @param item The item to query.
* @return The sell price.
*/
int query_sell(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_SELL]);
}
/* query_sell() */

/**
* @ignore yes 
* Set the buy price of this item.
*/
private void set_buy(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_BUY] = number;
   save_list();
}
/* set_buy() */

/**
* @ignore yes 
* Set the maximum number of this item allowed in stock.
*/
private void set_max(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_MAX] = number;
   save_list();
}
/* set_max() */

/**
* @ignore yes 
* Set the sell price of this item.
*/
private void set_sell(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_SELL] = number;
   save_list();
}
/* set_sell() */

/**
* @ignore yes 
* Stop the shop dealing in this item.
*/
private void take_off_list(string word)
{
   if (!_list[word]) return;
   map_delete(_list, word);
   save_list();
}
/* take_off_list() */

/**
* @ignore yes 
* Updates the chart with the average stock of an item.
*/
private void update_averages()
{
   log_file("/log/PLAYER_SHOP", "%s: %s entered update_averages (stock.c)\n",
      ctime(time()), _very_short); 
   foreach (string words in m_indices(_list))
   {
      _list[words][CHART_AVE] = (_list[words][CHART_AVE] +
         query_stock(words) + random(2)) / 2;
   }
   save_list();
}
/* update_averages() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office_code/stock.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/counter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/counter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629634   Available: 13576988
Inodes: Total: 5242880    Free: 4960136
12285 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/counter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629634   Available: 13576988
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The standard inheritable object for player-run shop counters.
 *
 * <p><b>Description</b></p>
 * The area behind the counter is the location of the sales log and the
 * cash register. It is also fitted as standard with a basic calculator
 * for those mathematically-challenged employees. 
 * </p>
 * <p>The register holds the shop's float. Employees can put money in,
 * or get money from the register as with any other container, and all
 * additions and removals are logged.
 * </p>
 * <p>The shop's log allows employees to log a sale or purchase to verify
 * the actions they have taken. This allows managers and supervisors to
 * confirm that employees are not taking advantage of the shop as all stock
 * movements, register adjustments and log entries should match up.
 * </p>
 *
 * @example
 * #include "path.h"
 * 
 * inherit "/std/shops/player_shop/counter";
 * 
 * void setup()
 * {
 *    set_light(60);
 *    set_office( PATH+ "office" );
 *    set_directions( "west", "south", "east" );
 * 
 *    set_short( "behind the counter of Tarnach's shop" );
 *    set_long( "This is the area behind the counter of the Creel Springs "
 *       "branch of Tarnach Fendertwin's Quality Consumables.\n" );
 *    add_exit( "south", PATH + "storeroom", "door" );
 *    add_exit( "east", PATH + "front", "path" );
 *    add_exit( "west", PATH + "office", "door" );
 * }
 *
 * @see /include/player_shop.h
 * @see /std/shops/player_shop/office.c
 * @see /std/shops/player_shop/mgr_office.c
 * @see /std/shops/player_shop/storeroom.c
 * @see /std/shops/player_shop/shop_front.c
 * @see /std/shops/player_shop/shopkeeper.c
 * @author Ringo
 * @started 1st August 1999
 */
inherit "/std/room/basic_room";

#include <player_shop.h>
#include <money.h>

private nosave mixed *_money;

private nosave object _register = 0;

private nosave string _save_file = "",
                      _place = UNSET_STR,
                      _office = "",
                      _storeroom = "",
                      _mgr_office = "",
                      _shop_front = "",
                      _store_dir = "",
                      _office_dir = "",
                      _shop_dir = "";

private nosave int _call_save = 0;

int action(string);
void add_money_ob(object);
int adjust_register(string, int);
string directions_to(string);
private int do_calc(int,string,int);
private int do_correction(mixed);
private int do_log(mixed *);
int query_register();
private void save_me(string);
void save_register(int);
protected void set_office(string);
protected void set_directions(string, string, string);


/**
 * @ignore yes
 */
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   add_property("no burial", 1);
   add_property("determinate", "");
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   add_item("calculator", "A standard shop's calculator used to total "
     "up all those difficult prices.  To use, see \"syntax calc\".");
   add_help_file("player_shop_counter");
}
/* create() */


/**
 * @ignore yes
 */
void init()
{
   ::init();
   if (!_office || _office == "") return;
   this_player()->command_override((: action :));   
   add_command("calc", "<number> {+|-|*|/} <number>",
     (: do_calc($4[0],$4[1],$4[2]) :));
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
   {
      add_command("log",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_log($4) :));
      add_command("correction",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_correction($4) :));
   }
}
/* init() */

/**
 * @ignore yes
 * Disallow non-employees access to the register
 * @param str the action to intercept
 */
int action(string str)
{
   string st1;
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
     return 0;
   sscanf(str,"%s %s",str,st1);
   if(str == "get" || str == "take")
      if (strsrch(st1, "register") != -1)
      {
         tell_object(this_player(), "You are not an active employee here!\n");
         return 1;
      }
   return 0;
}
/* action() */

/**
 * @ignore yes
 * Put some money back into the register
 * @param money the money object to add
 */
void add_money_ob(object money)
{
   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "add_money_ob()");
      return;
   }
   if (!money) return;
   money->move( _register ); 
   save_register(TRUE);
}
/* add_money_ob() */

/**
 * @ignore yes
 * Take some money from the register.
 * Used for transferring to bonus/profit accounts.
 * @param player the player adjusting the register
 * @param amount the amount to adjust by
 * @return the actual amount adjusted by
 */
int adjust_register(string player, int amount)
{
   int value;
   object cash, change;

   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "adjust_register(" + player+","+amount+")");
      return 0;
   }
   if (amount < 0) return 0;
   cash = present(MONEY_ALIAS, _register);
   if ( !cash ) return 0;
   _money = cash->query_money_array() + ({});
   value = MONEY_HAND->query_total_value(_money, _place);
   if (value < amount) amount = value;
   change = MONEY_HAND->pay_amount_from( amount, cash, _place );
   if (change) change->move( _register );
   _office->shop_log(ACCOUNTS, player, "adjusted the register by "+
     MONEY_HAND->money_value_string(amount, _place), UNPAID);
   save_register(TRUE);
   return amount;
}
/* adjust_register() */

/**
 * @ignore yes
 * Query the direction to another part of the shop.
 * This function is used by the npc shopkeeper to navigate around the shop.
 * @param place The full path to the destination.
 * @return The direction, or "here" if already there.
 */
string directions_to(string place)
{
   if (place == _storeroom) return _store_dir;
   if (place == _office) return _office_dir;
   if (place == _shop_front) return _shop_dir;
   return "here";
}
/* directions_to() */

/**
 * @ignore yes
 * Calculator
 */
private int do_calc(int a, string sign, int b)
{
   int c = 0;
   string result = a+ " "+ sign+ " "+ b+ " = ",
          temp;

   switch (sign)
   {
     case "+" :
        result += sprintf("%d\n", a+b);
        break;
     case "-" :
        result += sprintf("%d\n", a-b);
        break;
     case "*" :
        result += sprintf("%d\n", a*b);
        break;
     case "/" :
        if (!b)
        {
           tell_object( this_player(), 
             "Trying to divide by zero?  Whatever next?\n");
           return 1;
        } 
        if (a % b) c = ((a%b) * 100)/b;
        temp = sprintf("%02d",c);
        result += sprintf("%d.%s\n", a/b, temp[0..1]);
        break;
   }
   tell_object(this_player(), result);
   add_succeeded_mess("$N use$s the calculator.\n");
   return 1;
}
/* do_calc() */

/**
 * @ignore yes
 * Correct the shop's log
 */
private int do_correction(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     "ERROR IN LOG - correct entry follows:", UNPAID);
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], UNPAID);
   add_succeeded_mess("$N make$s a correction in the transaction log book.\n");
   return 1;
}
/* do_correction() */

/**
 * @ignore yes
 * Shop's log
 */
private int do_log(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(), 
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], PAID);
   add_succeeded_mess("$N make$s an entry in the transaction log book.\n");
   return 1;
}
/* do_log() */

/**
 * @ignore yes
 * Someone has died.
 * This function will automatically fire an employee if they have
 * killed someone whilst on duty.  It will also make a note of anyone
 * who has killed an on-duty employee (including the npc shopkeeper).
 */
void event_death(object k, object *o, object k2, string r, string k3)
{
   _office->event_death(k, o, k2, r, k3);
}
/* event_death() */

/**
 * @ignore yes
 * Someone has entered the room.
 * This function will automatically fire an employee if they have
 * teleported to this room.
 */
void event_enter(object ob, string message, object from)
{
   _office->event_enter(ob, message, from);
}
/* event_enter() */

/**
 * Query the value of the register's contents.
 * @return the current value of the register's contents
 */
int query_register()
{
   object cash = present(MONEY_ALIAS, _register);

   if (!cash) return 0;
   _money = cash->query_money_array() + ({});
   return MONEY_HAND->query_total_value(_money, _place);
}
/* query_register() */

/**
 * @ignore yes
 * Saves the contents of the register whenever they change.
 * @param old the money array to save
 * @param word the object changing the register (player or "shop")
 */
private void save_me(string name)
{
   int difference;
   object cash;
   mixed *old = _money + ({});

   if (!_register) return;
   cash = present(MONEY_ALIAS, _register);
   if (!cash) _money = ({});
   else _money = (mixed *)cash->query_money_array() + ({});
#ifdef DEBUG
   tell_creator(CREATOR, "Register contains: %O.\n", _money);
#endif
   _office->save_register(_money);
   difference = MONEY_HAND->query_total_value(_money, _place) -
     MONEY_HAND->query_total_value(old, _place);
   if (!difference) return;
   _office->adjust_takings(difference);
   if (!name || name == "") return;
   if (difference < 0)
      _office->shop_log(PURCHASE, name, "removed "+
        MONEY_HAND->money_value_string(-difference, _place)+ 
        " from register", UNPAID);
   else
      _office->shop_log(SALE, name, "added "+
        MONEY_HAND->money_value_string(difference, _place)+
        " to register", UNPAID);
}
/* save_me() */

/**
 * @ignore yes
 * Save the register
 * @param no_player 0 if a player caused the register to save
 */
void save_register(int no_player)
{
   remove_call_out(_call_save);
   _call_save = call_out((: save_me($((!no_player)?
      this_player()->query_name():"shop")) :), 1);
}
/* save_register() */

/**
 * Set the directions to other parts of the shop.
 * This function is used by the npc shopkeeper to navigate around the shop,
 * using the exits at the given directions. These directions should be the
 * standard "north", "southeast" etc.
 * @param office The direction to the office.
 * @param storeroom The direction to the store room.
 * @param shop The direction to the shop front.
 * @example set_directions( "west", "south", "east" );
 * 
 */
protected void set_directions(string office, string storeroom, string shop)
{
   _office_dir = office;
   _store_dir = storeroom;
   _shop_dir = shop;
}
/* set_directions() */

/**
 * @ignore yes
 * Adding a bit of standard stuff to the set_long()
 * @param long_desc the long description
 */
protected void set_long(string long_desc)
{
   long_desc += "Employees of the shop can \"log\" transactions or "
     "\"correction\"s here.  The shop's cash register is under the "
     "counter and there is a calculator next to that.\n";
   ::set_long(long_desc);
}
/* set_long() */

/**
 * Set the path of the main office.
 * Also sets up the and restores the register.
 * @example set_office( PATH + "tarnach's_office" );
 * @param path The full path & filename to the office.
 */
protected void set_office(string path)
{
   object cash;

   _office = path;
   _storeroom = _office->query_storeroom();
   _mgr_office = _office->query_mgr_office();
   _shop_front = _office->query_shop_front();
   _place = _office->query_place();
   if (_register) return;
   _register = clone_object("/obj/misc/cash_register");
   _register->set_name("register");
   _register->set_short("cash register");
   _register->add_adjective("cash");
   _register->set_long("The cash register is really just an iron drawer "
     "mounted underneath the counter.  In a certain light, it almost "
     "seems tongue-shaped.\n");
   _register->set_shop(this_object());
   add_hidden_object(_register);
   _register->reset_get();
   _money = _office->restore_register();
   if (!_money || !sizeof(_money)) return;
   cash = clone_object(MONEY_OBJECT);
   cash->set_money_array(_money);
   cash->move(_register);
}
/* set_office() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/counter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/mgr_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/mgr_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629631   Available: 13576985
Inodes: Total: 5242880    Free: 4960136
23711 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/mgr_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629631   Available: 13576985
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The standard inheritable object for player-run shop manager offices.
 *
 * <p><b>Description</b></p>
 * <p>The managers' office provides a front-end to the manager commands,
 * although these are mainly handled by the _office_. It also provides a
 * place of refuge for managers since only they have access to this room,
 * as well as allowing them to send and read their mail. Finally, it allows
 * them to claim a manager's handbook. 
 * </p>
 * <p>From here, managers can vote on employment applications and policy
 * suggestions. They can make personnel decisions such as commendations,
 * warnings, bonus suspensions, firing and demoting employees. They can
 * place employees on leave for a certain period if they know that employee
 * is away. They can view the ordinary, accounts, personnel and chart logs.
 * They can rent or remove additional stock cabinets. They can ban or unban
 * people from the shop. They can transfer monies between the profit account,
 * bonus account and cash register (see below). Finally, they can retire and
 * stay on as a retired manager, taking no further active role in the shop
 * other than voting on policy suggestions. 
 * </p>
 * 
 * <p><b>Accounts</b></p>
 * <p>There are three accounts in the shop, the first of which is the
 * register. This contains the 'float' - the money used for buying and
 * selling stock. The register is located behind the counter and is
 * accessible to every employee. 
 * </p>
 * <p>The profit account contains the funds used to pay operating expenses
 * such as cabinet rentals and employee pay. 
 * </p>
 * <p>The bonus account holds the funds used to pay the monthly bonus. 
 * </p>
 * <p>Monies can be transferred between all three accounts at any time, as
 * long as none would go negative as a result. 
 * </p>
 * 
 * @example
 * #include "path.h"
 * 
 * inherit "/std/shops/player_shop/mgr_office";
 * 
 * void setup()
 * {
 *    set_light(60);
 *    set_office( PATH+ "office" );
 * 
 *    set_short( "Tarnach Fendertwin's office" );
 *    set_long( "This room is the office of Tarnach Fendertwin himself.  "
 *     "Since he rarely visits this branch of the chain, it is more "
 *      "commonly used by the shop's managers.\n" );
 *    add_exit( "north", PATH +"office", "door" );
 * }
 * 
 * @see /include/player_shop.h
 * @see /std/shops/player_shop/office.c
 * @see /std/shops/player_shop/counter.c
 * @see /std/shops/player_shop/storeroom.c
 * @see /std/shops/player_shop/shop_front.c
 * @see /std/shops/player_shop/shopkeeper.c
 * @author Ringo
 * @started 1st August 1999
 */
inherit "/std/room/basic_room";

#include <player_shop.h>
#include <mail.h>
#include <move_failures.h>
#include <money.h>
#include "patterns.h"

private nosave string _office = "", 
_place = "", 
_shop_front = "", 
_counter = "",
_storeroom = "";

private nosave object _notice = 0;

private string cap_name(string);
private int do_accounts();
private int do_ban(mixed *);
private int do_check();
private int do_claim();
private int do_commend(string);
private int do_demote(string);
private int do_fire(mixed *);
private int do_leave(mixed *);
private int do_list(mixed *);
private int do_logs(mixed *, string);
private int do_mail(string);
private int do_memo();
private int do_office();
private int do_policies();
private int do_policy(mixed *,string);
private int do_project(string);
private int do_query(string);
private int do_remove();
private int do_rent();
private int do_retire();
private int do_set(mixed *, string);
private int do_suspend(mixed *);
private int do_transfer(mixed *);
private int do_unban(string);
private int do_view(string,string);
private int do_vote(mixed *, string);
private int do_warn(mixed *);
private void end_memo(string,string);
private void end_policy_suggest(string,string,int);
private void send_memo(string, string, string);
protected void set_office(string);
private void write_memo(string);

/** @ignore yes */
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("determinate", "");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_mgr_office");
}
/* create() */


/** @ignore yes */
void init()
{
    ::init();
    if (!_office || _office == "") return;
    if ( !_office->query_manager(this_player()->query_name()) &&
      !_office->query_retired(this_player()->query_name()) &&
      !this_player()->query_creator()) return;
    add_command("list", ({LIST_BLANK, LIST_CHOICE}),
      (: do_list($4) :));
    add_command("memo", "", (: do_memo() :));
    add_command("office", "", (: do_office() :));
    add_command("claim", "", (: do_claim() :));
    add_command("accounts", "", (: do_accounts() :));
    add_command("logs", ({LOG_BLANK, LOG_NUMBER, LOG_MGR}),
      (: do_logs($4,$5) :));
    add_command("mail", ({"", "<string>"}), (: do_mail($4) :));
    add_command("query", "{pay|employees}", (: do_query($4[0]) :));
    add_command("view", ({VIEW_EMP, VIEW_APP}), (: do_view($4[0],$5) :));
    add_command("project", "{pay|bonus}", (: do_project($4[0]) :));
    add_command("vote", VOTE_POLICY, (: do_vote($4,$5) :));
    add_command("policy", ({POLICY_SUGGEST, POLICY_REMOVE}),
      (: do_policy($4,$5) :));
    add_command("policies", "", (: do_policies() :));

    if (_office->query_retired(this_player()->query_name())) return;
    add_command("rent", "cabinet", (: do_rent() :));
    add_command("remove", "cabinet", (: do_remove() :));
    add_command("retire", "", (: do_retire() :));
    add_command("vote", VOTE_APPLICANT, (: do_vote($4,$5) :));
    add_command("check", "votes", (: do_check() :));
    add_command("commend", "<word'employee'>", (: do_commend($4[0]) :));
    add_command("fire", "<word'employee'> [for] <string'reason'>",
      (: do_fire($4) :));
    add_command("warn", "<word'employee'> [for] <string'reason'>",
      (: do_warn($4) :));
    add_command("demote", "<word'employee'>", (: do_demote($4[0]) :));
    add_command("suspend", "<word'employee'> [for] <number> [months]",
      (: do_suspend($4) :));
    add_command("leave", "<word'employee'> [for] <number> [days]",
      (: do_leave($4) :));
    add_command("ban", "<word'person'> [for] <string'reason'>",
      (: do_ban($4) :));
    add_command("unban", "<word'person'>", (: do_unban($4[0]) :));
    add_command("set", ({SET_EMPS, SET_PAY}), (: do_set($4,$5) :));
    add_command("transfer", "<number'amount'> <string'type'> [from] "
      "{register|bonus|profit} [to] {register|bonus|profit}",
      (: do_transfer($4) :));
}
/* init() */


/** @ignore yes */
private string cap_name(string name) 
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}

/** @ignore yes */
void dest_me()
{
    if (_notice) _notice->dest_me();
    ::dest_me();
}
/* dest_me() */


/** @ignore yes */
private int do_accounts()
{
    tell_object(this_player(), "The shop's accounts are as follows:\n"+
      sprintf("   Cash   : %s\n   Bonus  : %s\n   Profit : %s\n",
        MONEY_HAND->money_value_string(_counter->query_register(), _place),
        MONEY_HAND->money_value_string(_office->query_bonus(), _place),
        MONEY_HAND->money_value_string(_office->query_profit(), _place)));
    return 1;
}
/* do_accounts() */


/** @ignore yes */
private int do_ban(mixed *args) { return _office->do_ban(args); }


/** @ignore yes */
private int do_check()
{
    string results,
    name = this_player()->query_name();
    mapping applicants;

    add_succeeded_mess("");
    applicants = _office->get_applicants();
    applicants = filter(applicants, (: $(applicants)[$1][APP_TYPE] == 1 :));
    if (this_player()->query_creator())
    {
        results = "The following votes have been cast:\n\n";
        foreach (string word in sort_array(keys(applicants), 1))
        {
            results += cap_name(word)+ " - applied " +
            ctime(applicants[word][APP_TIME] )+ "\n   Votes for:     ";
            foreach (string vote in applicants[word][APP_FOR])
            results += cap_name(vote) + "  ";
            results += "\n   Votes against: ";
            foreach (string vote in applicants[word][APP_AGAINST])
            results += cap_name(vote) + "  ";
            results += "\n   Abstentions:   ";
            foreach (string vote in applicants[word][APP_ABSTAIN])
            results += cap_name(vote) + "  ";
            results += "\n\n";
        }
        tell_object(this_player(), "$P$Votes cast$P$"+ results);
        return 1;
    }
    results = "You have cast the following votes:\n\nFor: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_FOR]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAgainst: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_AGAINST]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAbstentions: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_ABSTAIN]) != -1)
        results += cap_name(vote)+ "  ";
    tell_object(this_player(), results + "\n");
    return 1;
}
/* do_check() */


/** @ignore yes */
private int do_claim()
{
    object thing;

    if (!_office || _office == "") return 0;
    thing = clone_object(MGR_BOOK);
    thing->set_read_mess("\n   "+ _office->query_shop_name()+ "\n\n"
      "   Manager's Handbook\n\n   This handbook belongs to: "+
      this_player()->query_short()+ "\n\n", "common", 100);
    thing->set_office(_office);
    if (thing->move(this_player()) != MOVE_OK)
    {
        thing->move(this_object());
        tell_object(this_player(),
          "You drop your handbook as you're carrying too much.\n");
    }
    add_succeeded_mess("$N $V a new handbook.\n");
    return 1;
}
/* do_claim() */


/** @ignore yes */
private int do_commend(string emp) { return _office->do_commend(emp); }


/** @ignore yes */
private int do_demote(string emp) { return _office->do_demote(emp); }


/** @ignore yes */
private int do_fire(mixed *args) { return _office->do_fire(args); }


/** @ignore yes */
private int do_leave(mixed *args) { return _office->do_leave(args); }


/** @ignore yes */
private int do_list(mixed *args)
{
    string results, word;
    mapping baddies, applicants;
    string *applied, *hired, *awaiting;

    if (!sizeof(args)) args = ({"employees"});
    add_succeeded_mess("");
    switch (args[0])
    {
    case "applicants" : 
        results = "      Applications for employment as at " +
        ctime(time()) + "\n\n";
        applicants = _office->get_applicants();
        if (!applicants || applicants == ([]))
        {
            tell_object(this_player(), results+
              "No applications outstanding.\n");
            return 1;
        }
        applied = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == APPLIED :))), 
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        hired = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == HIRED :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        awaiting = sort_array(keys(filter(applicants, 
              (: $(applicants)[$1][APP_TYPE] == AWAITING :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        if ( sizeof(awaiting))
        {
            results += "Applicants awaiting vacancies:\n";
            foreach (word in awaiting)
            results += "     "+ cap_name(word)+
            " - confirmed employment " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(hired))
        {
            results += "Applicants yet to confirm their employment:\n";
            foreach (word in hired)
            results += "     "+ cap_name(word)+ " - voted in " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(applied))
        {
            results += "Applicants yet to be hired or rejected.  Vote now!\n";
            foreach (word in applied)
            {
                results += "     "+ cap_name(word)+ " - applied " +
                ctime(applicants[word][1])+ "\n";
                results += sprintf("     %-12s%-5d%-16s%-5d%-13s%-5d\n",
                  "Votes for:", sizeof(applicants[word][APP_FOR]),
                  "Votes against:", sizeof(applicants[word][APP_AGAINST]),
                  "Abstentions:", sizeof(applicants[word][APP_ABSTAIN]));
            }
        }
        tell_object(this_player(), "$P$Applications list$P$"+ results);
        break;
    case "baddies" :
        if (!m_sizeof(baddies = _office->get_baddies()))
        {
            tell_object(this_player(),
              "There are no people on the list at the moment.\n");
            return 1;
        }
        results = "This is a list of people banned from the shop:\n\n";
        foreach (word in sort_array(keys(baddies), 1))
        {
            results += cap_name(word)+ " banned by "+ 
            baddies[word][BAD_BANNER]+ " on "+
            ctime(baddies[word][BAD_TIME] )+ ".\n   Banned for "+
            baddies[word][BAD_REASON]+ ".\n\n";
        }
        tell_object(this_player(), "$P$Baddies$P$\n"+ results);
        break;
    default :
        return _office->do_list();
    }
    return 1;
}
/* do_list() */


/** @ignore yes */
private int do_logs(mixed *args, string pattern)
{
    return _office->do_logs(args, pattern);
}
/* do_logs() */


/** @ignore yes */
private int do_mail(string words) { return MAIL_TRACK->mail(words); }


/** @ignore yes */
private int do_memo()
{
    tell_object(this_player(), "Subject: (hit enter for general memo)\n");
    input_to((: write_memo($1) :), 0);
    add_succeeded_mess("");
    return 1;
}
/* do_memo() */


/** @ignore yes */
private int do_office()
{
    int retired = _office->query_retired(this_player()->query_name());
    string result = (retired)?
    "As a retired manager, you can use the following commands:\n":
    "As a manager, you can use the following commands:\n";

    result +=
    "   accounts  - view register, bonus & profit accounts\n"
    "   claim     - claim a manager's handbook\n"
    "   list      - list employees, applicants or banned people\n"
    "   logs      - review the shop's logs\n"
    "   mail      - read / send mail\n"
    "   memo      - send a message to the other managers\n"
    "   policy    - suggest a new (or remove an old) policy for the shop\n"
    "   policies  - check on the proposed policies\n"
    "   project   - view anticipated paypacket & bonus values\n"
    "   query     - query pay amount or number of employees\n"
    "   view      - view a person's history with this shop\n"
    "               or an applicant's application form\n"
    "   vote      - vote for a policy to be implemented into the shop\n";
    if (!retired)
        result +=
        "               or for an applicant to work for the shop\n"
        "   (un)ban   - (un)ban a person from the shop for "+
        BAN_LENGTH+ " days\n"
        "   rent      - rent storeroom cabinets\n"
        "   remove    - remove storeroom cabinets\n"
        "   check     - check votes you have made on applications\n"
        "   commend   - reward an outstanding employee\n"
        "   demote    - demote an employee\n"
        "   fire      - end someone's employment\n"
        "   leave     - place an employee on leave for up to "+
        MAX_LEAVE+ " days\n"
        "   retire    - end your active employment at the shop\n"
        "   set       - set number of employees, and pay amount\n"
        "   suspend   - suspend an employee's bonus entitlement\n"
        "   transfer  - transfer money between register, bonus & profit\n"
        "   warn      - issue a formal warning to an employee\n";
    tell_object(this_player(), result+ "\n");
    add_succeeded_mess("");
    return 1;
}
/* do_office() */


/** @ignore yes */
private int do_policies()
{
    mapping policies = _office->get_new_policies();
    if (!m_sizeof(policies))
        tell_object(this_player(), "There are no policies awaiting sanction.\n");
    else
    {
        int i = 1;

        tell_object(this_player(), "The following policies have been suggested."
          "  Policies in existence are proposed to be overturned.\n");
        foreach(string policy in m_indices(policies))
        tell_object(this_player(), sprintf("%d. %s - %s [%s]. %s\n", i++,
            (policies[policy][POLICY_TYPE])?"MGR":"EMP", policy,
            policies[policy][POLICY_MGR], policies[policy][POLICY_TEXT]));
    }
    return 1;
}
/* do_policies() */


/** @ignore yes */
private int do_policy(mixed *args, string pattern)
{
    string *managers, mgr;

    if (pattern == POLICY_SUGGEST)
    {
        if (_office->query_policy(args[1]))
        {
            tell_object(this_player(), "This name is already in use.\n");
            return 1;
        }
        this_player()->do_edit(0, (: end_policy_suggest($1,
              $(lower_case(args[1])),$((args[0] == "manager")?1:0)) :));
        add_succeeded_mess("");
        return 1;
    }
    if (_office->query_policy(args[0]) < 2)
    {
        tell_object(this_player(), "This policy does not exist.\n");
        return 1;
    }
    args[0] = lower_case(args[0]);
    tell_object(this_player(), "You suggest that the "+ args[0]+
      " policy should be removed.\n");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({mgr});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, "TFQC policy suggestion",
      "", "Please note that I would like you to vote on removing the "+
      args[0]+ " policy.\n", 0, 0);
    _office->add_policy_suggest(args[0], "", mgr);
    return 1;
}   
/* do_policy() */


/** @ignore yes */
private int do_project(string projection)
{
    add_succeeded_mess("");
    switch (projection)
    {
    case "bonus" :
        _office->calc_bonus();
        break;
    case "pay" :
        tell_object(this_player(),
          "For the month to date, the staff wages total "+
          MONEY_HAND->money_value_string( _office->calc_pay(), 
            _place)+ ".\n");
        break;
    }
    return 1;
}
/* do_project() */


/** @ignore yes */
private int do_query(string query)
{
    add_succeeded_mess("");
    switch(query)
    {
    case "pay" :
        tell_object(this_player(), "The pay is currently set at "+
          MONEY_HAND->money_value_string(_office->query_pay(),
            _place)+ ".\n");
        break;
    case "employees" :
        tell_object(this_player(),
          "The maximum number of employees is currently "+ 
          _office->query_maxemp()+ ".\n");
        break;
    default :
    }
    return 1;
}
/* do_query() */


/** @ignore yes */
private int do_remove() { return _office->do_remove(); }


/** @ignore yes */
private int do_rent() { return _office->do_rent(); }


/** @ignore yes */
private int do_retire() { return _office->do_retire(); }


/** @ignore yes */
private int do_set(mixed *args, string pattern)
{ 
    return _office->do_set(args, pattern);
}
/* do_set() */


/** @ignore yes */
private int do_suspend(mixed *args) { return _office->do_suspend(args); }


/** @ignore yes */
private int do_transfer(mixed *args) { return _office->do_transfer(args); }


/** @ignore yes */
private int do_unban( string person ) { return _office->do_unban(person); }


/** @ignore yes */
private int do_view(string person, string pattern)
{
    _office->view_record(person, pattern);
    return 1;
}
/* do_view() */


/** @ignore yes */
private int do_vote(mixed *args, string pattern)
{
    return _office->do_vote(args, pattern);
}
/* do_vote() */


/** @ignore yes */
private int do_warn(mixed *args) { return _office->do_warn(args); }


/** @ignore yes */
private void end_memo(string text, string subject)
{
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    tell_object(this_player(), 
      "Do you want to keep a copy of the memo? ");
    input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
/* end_memo() */


/** @ignore yes */
private void end_policy_suggest(string text, string name, int type)
{
    string mgr, *managers;

    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    /* Remove newlines */
    text = replace_string(text, "\n", " ");
    text = replace_string(text, "  ", " ");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({lower_case(mgr)});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, _office->shop_very_short()+ " policy suggestion",
      "", "Please note that there is a new policy, "+ name+ 
      ", on which I would like you to vote.\n", 0, 0);
    _office->add_policy_suggest(name, text, mgr, type);
}
/* end_policy_suggest() */


/** @ignore yes */
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k, o, k2, r, k3);
}
/* event_death() */


/** @ignore yes */
void event_enter(object ob, string message, object from)
{
    _office->event_enter(ob, message, from);
}
/* event_enter() */


/** @ignore yes */
private void send_memo(string ans, string subject, string text)
{
    string *managers;

    ans = lower_case(ans);
    if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
    {
        tell_object(this_player(),
          "Do you want to keep a copy of the memo? (Yes or No)? ");
        input_to((: send_memo($1,$(subject),$(text)) :), 0);
        return;
    }
    managers = _office->get_managers();
    managers += _office->get_retired();
    if ( this_player()->query_creator() &&
      this_player()->query_name() != _office->query_creator())
        managers += ({lower_case(this_player()->query_name())});
    managers += ({_office->query_creator()});
    if ( ans[0] == 'n' ) 
        managers -= ({lower_case(this_player()->query_name())});
    if (!sizeof(managers))
    {
        tell_object(this_player(), "\nNo recipients!\n");
        return;
    }
    tell_object(this_player(), "\nSending your memo.\n");
    subject = (subject && subject != "")?" - "+ subject:"";
    AUTO_MAILER->auto_mail(implode(managers, ","),
      this_player()->query_name(), _office->shop_very_short()+
      " manager memo" + subject, "", text, 0, 0);
}
/* send_memo() */


/** @ignore yes */
protected void set_long(string long_desc)
{
    long_desc += "Managers can use their own \"office\" commands "
    "from in here.  There is a management policy notice on the wall.\n";
    ::set_long( long_desc );
}
/* set_long() */

/**
 * Set the path of the main office.
 * @example set_office( PATH+ "office" );
 * @param path The full path & filename.
 */
protected void set_office(string path)
{
    _office = path;
    _place = _office->query_place();
    _shop_front = _office->query_shop_front();
    _counter = _office->query_counter();
    _storeroom = _office->query_storeroom();

    /******************************
     * Add the shop's policy notice
     *****************************/
    _notice = clone_object(SHOP_NOTICE);
    _notice->set_office(_office);
    _notice->set_type(1);
    add_hidden_object(_notice);
}
/* set_office() */

/** @ignore yes */
private void write_memo(string text)
{
    this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}
/* write_memo() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/mgr_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/office.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629622   Available: 13576976
Inodes: Total: 5242880    Free: 4960136
28807 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629622   Available: 13576976
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The standard inheritable object for player-run shop offices.
 * 
 * <p><b>Description</b></p>
 * <p>This office is the nerve centre of the shop. Most of the data
 * structures are defined and maintained from here, and virtually all
 * of the managerial functions are forwarded here. It is this object
 * that passes the common variables across to other files as they call
 * for them. This minimises the complexity of setting up each object - as
 * long as they point to this object, and this object is correctly set up,
 * the objects will know which shop they belong to, who the employees are,
 * who the proprietor is etc. 
 * </p>
 * <p>Before the shop will function correctly, it must be registered with
 * the handler - see set_very_short()
 * </p>
 * <p>Most of the functions defined in the office are not needed by
 * creators. Those that are needed are shown in the examples. Other
 * functions are not necessary, but may be useful. 
 * </p>
 * <p>The source to this object is split into 15 different files. The
 * main file, office.c includes the other files under the office_code
 * directory. This is intended to ease code maintenance as the total
 * size of the office code (as of December 2000) is around 165k. 
 * </p>
 * <p>In general, the functions contained in office.c are those intended
 * to be used directly by creators. The other functions are called
 * internally by the shop. 
 * </p>
 * <p>The data itself is also saved into several files. The data is
 * arranged into these files to minimise the amount of disk activity
 * when changes are made. For example, employee data changes every time an
 * employee does something. The list of applicants, however, changes only
 * when an application status changes. They are, therefore, saved into
 * seperate files. Also, each save call is subject to a callout, and will
 * limit the amount of disk writing actually done. The only data not stored
 * by this file is the stock data, which is saved by each cabinet
 * individually. All data and logs are saved into several files within
 * a directory "/d/(domain)/save/player_shops/(shop_very_short)/".
 * In addition, some data are cleared if it hasn't been used for a while.
 * This will typically save up to 100k of memory for a store the size of
 * Tarnach's.
 * </p>
 * <p>The shop supports notice boards, posting all hirings, promotions,
 * bonus amounts in addition to any posts requested in the inheriting
 * object. In the absence of a board, all posts are mailed to each employee
 * and each employee will have access to an additional "memo" command in
 * the office. 
 * </p>
 * <p>Applications are handled automatically, with managers voting whether
 * to accept or reject an application. On gaining positive votes from at
 * least 50% of the managers, an applicant is hired. If they receive more
 * than 50% negative votes, they are rejected. If there are insufficient
 * votes to settle the decision, an applicant will be hired if more managers
 * have voted for than against. Policy suggestions are handled in a similar
 * way. 
 * </p>
 * <p>The shop's two main administration routines are run on a regular
 * basis. The first of these is run every day and is responsible for
 * checking that employees are still valid players (not deleted chars or
 * creators). It conducts automatic promotions, and handles demotions for
 * inactive employees. It also updates the lists of declined applicants
 * and banned people and removes that status if applicable. Finally, it
 * calls the check_hire_list() function to see if we can hire any new
 * employees. 
 * </p>
 * <p>The second is run every Discworld month. This review involves paying
 * employees directly into their nominated bank account, and awarding
 * bonuses based on the current value of the bonus fund. 
 * </p>
 * 
 * @example
 * #include "path.h"
 * 
 * inherit "/std/shops/player_shop/office";
 *  
 * void setup()
 * {
 *    set_light(60);
 *    set_place("Lancre");
 *    set_proprietor("Tarnach Fendertwin");
 *    set_shop_name("Tarnach Fendertwin's Quality Consumables (Creel Springs)");
 *    set_very_short("TFQC-CS");
 *    set_channel("tarnachcs", 0);
 *    set_shopkeeper(PATH + "shopkeeper");
 *    set_stock_policy("magical spell components");
 * 
 *    set_shop_front(PATH+ "front");
 *    set_counter(PATH+ "counter");
 *    set_storeroom(PATH+ "storeroom");
 *    set_directions("east", "east", "east");
 * 
 *    set_short("office of Tarnach's shop");
 *    set_long("This room is the office of the Creel Springs branch of "
 *      "Tarnach Fendertwin's Quality Consumables.  There is a door to the "
 *      "managers' office in the south wall.\n");
 *    add_sign("The sign is a small piece of paper stuck to the wall.\n",
 *      "This seems to be a handwritten note from Tarnach himself.  "
 *      "The handwriting, not to mention the spelling and the grammar, "
 *      "is appalling, so it's difficult to make out much.  All you "
 *      "can understand is something about what the \"office\" is for.",
 *      "sign", "sign" )->add_property( "there", "on one wall");
 *    add_exit("east", PATH+ "counter", "door");
 *    add_manager_exit("south", PATH + "mgr_office");
 * }
 * 
 * @see /include/player_shop.h
 * @see /std/shops/player_shop/mgr_office.c
 * @see /std/shops/player_shop/counter.c
 * @see /std/shops/player_shop/storeroom.c
 * @see /std/shops/player_shop/shop_front.c
 * @see /std/shops/player_shop/shopkeeper.c
 * @author Ringo
 * @started 1st August 1999
 */
inherit "/std/room/basic_room";

#include <player_shop.h>
#include <mail.h>
#include <board.h>
#include <money.h>
#include <move_failures.h>
#include <refresh.h>
#include "office.h"


/*
 * Globals
 */
private nosave string _proprietor = UNSET_STR,
                      _shop_name = UNSET_STR,
                      _very_short = UNSET_STR, 
                      _place = UNSET_STR, 
                      _channel = UNSET_STR,
                      _storeroom = "",
                      _shop_front = "",
                      _counter = "",
                      _mgr_office = "",
                      _store_dir = "",
                      _counter_dir = "",
                      _shop_dir = "",
                      _shopkeeper = "",
                      _stock_policy = "",
                      _cab_name = "",
                      _review_month = "",
                      _savedir = "",
                      _creator = CREATOR;

private nosave object _chart = 0,
                      _board = 0,
                      _notice = 0;

private nosave mapping _history = 0,
                       _applicants = 0,
                       _policies = 0,
                       _new_policies = 0,
                       _list = ([]),
                       _times = ([]),
                       _employees = ([]);

/** Used to keep track of (and remove) call_outs */
private nosave int _call_save = 0,
                   _call_hist = 0,
                   _call_hist_clear = 0,
                   _call_times = 0,
                   _call_hire_list = 0,
                   _call_mail_hirees = 0,
                   _call_summon = 0,
                   _call_emps = 0,
                   _call_review = 0,
                   _call_apps = 0,
                   _call_apps_clear = 0,
                   _call_pols = 0,
                   _call_pols_clear = 0,
                   _call_newpols = 0,
                   _call_newpols_clear = 0;

private string *_retired = ({}),
               *_got_bonus = ({}),
               _last_month = "last month",
               _eom = CREATOR;

private mapping _baddies = ([]),
                _declined = ([]),
                _accounts = (["profit":0,"bonus":0]);

private int _max_emp = MAX_EMP,
            _bonus_val = 0, 
            _bonus = 0, 
            _pay_val = 4,
            _num_cabinets = MIN_CABINETS,
            _net_takings = 0;

private mixed *_register = ({});

/**
 * @ignore yes
 */
void create()
{  
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   seteuid("Room");
   add_property("determinate", "");
   add_help_file("player_shop_office");
} /* create() */

/**
 * @ignore yes
 * Include rest of source - this is split up to keep filesizes within a
 * practical size limit.  This should make maintaining the source less of a
 * nightmare.  Only public functions will be found in this file.
 */
#include "office_code/admin.c"         // misc admin functions
#include "office_code/applications.c"  // application-related functions
#include "office_code/baddies.c"       // banning-related functions
#include "office_code/cabinets.c"      // cabinet-related functions
#include "office_code/emp_cmd.c"       // employee commands
#include "office_code/lists.c"         // listing functions
#include "office_code/logging.c"       // log-related functions
#include "office_code/masked.c"        // masked functions
#include "office_code/memo.c"          // memo functions
#include "office_code/personnel.c"     // personnel-related functions
#include "office_code/policies.c"      // policy-related functions
#include "office_code/review.c"        // daily & monthly review functions
#include "office_code/save.c"          // saving-related functions
#include "office_code/stock.c"         // stock-related functions

/******************************************************************************
 ******************************************************************************
 *                       START OF PUBLIC FUNCTIONS                            *
 ******************************************************************************
 ******************************************************************************/

/**
 * Set the exit to the managers' office.
 * This method also modifies the exit to allow only managers to enter the
 * managers' office.
 * @example add_manager_exit( "east", PATH + "tarnach's_man_office" );
 * @param dir the direction of the exit.
 * @param path the full path and filename to the managers' office of the shop.
 */
protected void add_manager_exit(string dir, string path)
{
   add_exit(dir, path, "door");
   modify_exit(dir, ({"function", ({this_object(),
     "check_manager"}), "door short", "office door", "door long",
     "There is a sign on the door which reads: \""+ _proprietor+ 
     "- Private\".\n"}));
   _mgr_office = path;
}
/* set_mgr_office() */


/**
 * Query the list of applicants.
 * This method returns the list of applicants as a mapping formatted
 * as follows:<br>
 * ([ "name": type, time, ({ for }), ({ against }), ({ abstain }), ])
 * @return the applicants mapping formatted as above.
 */
mapping get_applicants()
{
   load_applicants();
   clear_applicants();
   return copy(_applicants + ([]));
}

/**
 * Query the people banned from the shop.
 * This method returns a mapping of the people banned from this shop, along
 * with the time that they were banned, the person banning them, and the 
 * reason they were banned.  The format for this mapping is:<br>
 * ([ person:({ reason, banner, time }) ])
 * @return the mapping, formatted as above.
 */
mapping get_baddies() { return copy(_baddies + ([])); }

/**
 * Query the list of employees.
 * This method returns the list of employees, sorted alphabetically.
 * @see get_supervisors()
 * @see get_managers()
 * @see get_retired()
 * @return the sorted array of employees.
 */
string *get_employees()
{
   string *employees = m_indices(_employees);

   /* Don't include people with the supervisor bit set */
   foreach (string word in employees)
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         employees -= ({word});
   return copy(sort_array(employees, 1));
}
/* get_employees() */

/**
 * Query the list of managers.
 * This method returns the list of managers, sorted alphabetically.
 * @see get_employees()
 * @see get_supervisors()
 * @see get_retired()
 * @return the sorted array of managers.
 */
string *get_managers()
{
   return copy(sort_array(keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & MANAGER :))), 1));
}
/* get_managers() */

/**
 * Query the policy suggestions.
 * These are the policies that have been proposed but not yet implemented.
 * @see get_policies()
 * @see query_policy()
 * @return a mapping of the suggested shop policies.
 */
mapping get_new_policies()
{ 
   load_new_policies();
   clear_new_policies();
   return copy(_new_policies);
}

/**
 * Query the policies.
 * These are the policies currently in effect.
 * @see get_new_policies()
 * @see query_policy()
 * @return a mapping of the shop policies.
 */
mapping get_policies(int type)
{
   load_policies();
   clear_policies();
   if (type)
      return copy(filter(_policies, (: _policies[$1][1] :)));
   else
      return copy(filter(_policies, (: !_policies[$1][1] :)));
}
/* get_policies() */

/**
 * Query the list of retired managers.
 * This method returns the list of retired managers, sorted alphabetically.
 * @see get_employees()
 * @see get_supervisors()
 * @see get_managers()
 * @return the sorted array of retired managers.
 */
string *get_retired() { return copy(sort_array(_retired, 1)); }

/**
 * Query the list of supervisors.
 * This method returns the list of supervisors, sorted alphabetically.
 * @see get_employees()
 * @see get_managers()
 * @see get_retired()
 * @return the sorted array of supervisors.
 */
string *get_supervisors()
{
   string *supervisors = keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & SUPERVISOR :)));

   /* Managers also have the supervisor bit set, so don't
    * include them in this list.
    */
   foreach (string word in supervisors)
      if (_employees[word][EMP_POINTS] & MANAGER)
         supervisors -= ({word});
   return copy(sort_array(supervisors, 1));
}
/* get_supervisors() */

/**
 * Query the number of employees currently clocked in.
 * This function will also clock out any employees that are no longer on DW.
 * @return the number of employees clocked in. 
 */
int num_employees_in()
{
   int any = 0;

   foreach (string word in m_indices(_employees))
      if (_employees[word][EMP_POINTS] & CLOCKED_IN)
      {
         if (_employees[word][EMP_POINTS] & NPC) continue;
         if (!find_player(word) || !interactive(find_player(word)))
         {
            reset_employee(word, CLOCKED_IN);
            shop_log(GENERAL, word, "was clocked out", UNPAID);
         }
         else any++;
      }
   return any;
}
/* num_employees_in() */

/**
 * Determine if this person has applied for a job.
 * @param player the player to query.
 * @return APPLIED if applied, HIRED if voted in, AWAITING if awaiting 
 * a vacancy.  Otherwise, will return FALSE.
 */
int query_applicant(string player)
{
   load_applicants();
   clear_applicants();
   if (!sizeof(_applicants)) return FALSE;
   if (_applicants[player]) return copy(_applicants[player][APP_TYPE]);
   return FALSE;
}
/* query_applicant() */

/**
 * Determine if this person is banned from the shop.
 * @param player the player to query.
 * @return the time of the ban if banned, FALSE if not banned.
 */
int query_baddie(string player)
{
   if (!m_sizeof(_baddies)) return FALSE;
   if (_baddies[player]) return copy(_baddies[player][BAD_TIME]);
   return FALSE;
}
/* query_baddie() */

/**
 * Query the value of the bonus account.
 * This is the current value of the bonus account.  Will need converting to 
 * local currency if it is to be displayed.
 * @see query_profit()
 * @return the value of the bonus account.
 */
int query_bonus() { return copy(_accounts["bonus"]); }

/**
 * Query the channel used by the shop.
 * @see set_channel()
 * @return the channel in use by this shop
 */
string query_channel() { return copy(_channel); }

/**
 * Query the path to the shop counter.
 * @see set_counter()
 * @return the path to the counter.
 */
string query_counter() { return copy(_counter); }

/**
 * Query the maintainer of this shop's files.
 * @see set_creator()
 * @return the person responsible for this shop.
 */
void query_creator(string creator) { return copy(_creator); }

/**
 * Determine if a player was declined for a job.
 * This method is used to determine if there is a declined application
 * registered for a player.
 * @param player the player to query.
 * @return FALSE, or the time at which the applicant was declined. 
 */
int query_declined(string player)
{
   if (!sizeof(_declined)) return FALSE;
   if (_declined[player]) return copy(_declined[player]);
   return FALSE;
}
/* query_declined() */


/**
 * Determine if this person is an employee of the shop.
 * @see query_supervisor()
 * @see query_manager()
 * @see query_retired()
 * @param player the player to query.
 * @return the employee's points, or FALSE if not an employee.
 */
int query_employee(string player)
{
   if (_employees[player]) return copy(_employees[player][EMP_POINTS]);
   return FALSE;
}
/* query_employee() */

/**
 * Return the employee data.
 * This includes only active employees - retired managers are not included.
 * The data is formatted as:<br>
 * ([ employee:({ points, time, bank, pay, inactive, nobonus, nopromote }) ])<br>
 * @return the employee mapping, formatted as above.
 */
mapping query_employees() { return copy(_employees + ([])); }

/**
 * Query the list of items sold by the shop.
 * Generates an array of the keys to the list mapping.
 * @see query_list_mapping()
 * @see query_list_string()
 * @return the list of items in array form.
 */
string *query_list_array() { return copy(m_indices(_list) + ({})); }

/**
 * Query the list of items sold by the shop.
 * @see query_list_array()
 * @see query_list_string()
 * @return the list of items in mapping form.
 */
mapping query_list_mapping() { return copy(_list) + ([]); }

/**
 * Query the list of items sold by the shop.
 * Generates a list of all items bought & sold by this shop, and outputs a
 * multiple short string for use in displays.
 * @see query_list_array()
 * @see query_list_mapping()
 * @return the list of items.
 */
string query_list_string()
{
   if (!m_sizeof(_list)) return "absolutely nothing at the moment";
   return query_multiple_short(m_indices(_list));
}
/* query_list_string() */

/**
 * Determine if this person is a manager of this shop.
 * @see query_employee()
 * @see query_supervisor()
 * @see query_retired()
 * @param player the player to query.
 * @return TRUE or FALSE
 */
int query_manager(string player)
{
   if (_employees[player]) return (_employees[player][EMP_POINTS] & MANAGER);
   return FALSE;
}
/* query_manager() */

/**
 * Query the maximum number of employees.
 * @return the maximum number of employees allowed at this shop.
 */
int query_maxemp() { return copy(_max_emp); }

/**
 * Query the path to the managers' office.
 * @return the path to the managers' office.
 */
string query_mgr_office() { return copy(_mgr_office); }

/**
 * Query the number of storeroom cabinets.
 * @return the number of cabinets in the storeroom.
 */
int query_num_cabinets() { return copy(_num_cabinets); }

/**
 * Query the base pay rate.
 * This is the base pay rate set by the managers; the amount each employee
 * will receive for a single transaction.
 * @return the value of the base pay rate
 */
int query_pay() { return copy(_pay_val); }

/**
 * Query the location of this shop.
 * @see set_place()
 * @return the location of the shop
 */
string query_place() { return copy(_place); }

/**
 * Determine if a shop policy exists.
 * @see get_policies()
 * @see get_new_policies()
 * @param policy The name of the policy to query.
 * @return 2 if it is already policy, 1 if it is a proposal, else 0
 */
int query_policy(string policy)
{
   load_policies();
   clear_policies();
   if (m_sizeof(_policies) && _policies[policy]) return 2;
   load_new_policies();
   clear_new_policies();
   if (m_sizeof(_new_policies) && _new_policies[policy]) return 1;
   return 0;
}
/* query_policy() */

/**
 * Query the value of the profit account.
 * This is the current value of the profit account.  Will need converting to 
 * local currency if it is to be displayed.
 * @see query_bonus()
 * @return the value of the profit account
 */
int query_profit() { return copy(_accounts["profit"]); }

/**
 * Query the name of the proprietor.
 * @see set_proprietor()
 * @return the name of the proprietor
 */
string query_proprietor() { return copy(_proprietor); }

/**
 * Determine if this person is a retired manager of this shop.
 * @see query_employee()
 * @see query_supervisor()
 * @see query_manager()
 * @param player The player to query.
 * @return TRUE or FALSE
 */
int query_retired(string player)
{
   return (member_array(player, _retired) == -1)?FALSE:TRUE;
}
/* query_retired() */

/** @ignore yes */
string query_savedir() { return copy(_savedir); }

/**
 * Query the path to the shop front.
 * @see set_shop_front()
 * @return the path to the shop front
 */
string query_shop_front() { return copy(_shop_front); }

/**
 * Query the full name of the shop.
 * @see set_shop_name()
 * @return the full name of the shop
 */
string query_shop_name() { return copy(_shop_name); }

/**
 * Query the shopkeeper name.
 * @see set_shopkeeper()
 * @return the name of the shopkeeper
 */
string query_shopkeeper() { return copy(_shopkeeper); }


/**
 * Query number of items in stock.
 * Determines the number of a specific item currently held by this shop.
 * @param items the item to query
 * @return the number of 'items' in stock
 */
int query_stock(string items) { return _storeroom->query_num_items(items, 0); }

/**
 * Query the path to the storeroom.
 * @see set_storeroom()
 * @return the path to the storeroom
 */
string query_storeroom() { return copy(_storeroom); }

/**
 * Determine if this person is a supervisor of this shop.
 * @see query_employee()
 * @see query_manager()
 * @see query_retired()
 * @param player The player to query.
 * @return TRUE or FALSE
 */
int query_supervisor(string player)
{ 
   if (_employees[player])
      return (_employees[player][EMP_POINTS] & SUPERVISOR);
   return FALSE;
}
/* query_supervisor() */

/**
 * Save the employee data file.
 * This method uses a call_out to help minimise the amount of disk activity
 * during normal operations of the shop.  The very short name of the shop
 * must have been set previously.
 * @see save_me()
 * @see set_very_short()
 */
protected void save_emps()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_emps);
   _call_emps = call_out((: do_save_emps() :), SAVE_DELAY);
}
/* save_emps() */

/**
 * Save the shop data file.
 * This method uses a call_out to help minimise the amount of disk activity
 * during normal operations of the shop.  The very short name of the shop
 * must have been set previously.
 * @see save_emps()
 * @see set_very_short()
 */
protected void save_me()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_save);
   _call_save = call_out((: do_save() :), SAVE_DELAY);
}
/* save_me() */

/**
 * Set the channel used by the shop.
 * This sets the channel used by the employees' badges, and also the
 * name of the board.  If a board has been set-up for this shop, this
 * function will also add the board into the room.
 * @example set_channel( "tarnachcs", 0 );
 * @see query_channel()
 * @param name the name of the channel.
 * @param board non-zero if a board exists for this shop.
 */
protected void set_channel(string name, int board)
{
   _channel = lower_case(name);
   if (board)
   {
      _board = clone_object("/obj/misc/board");
      _board->set_datafile(name);
      _board->move(this_object());
   }
}
/* set_channel() */

/**
 * Set the path to the counter.
 * This is the full path and filename of the counter object to be used by this
 * shop.
 * @example set_counter( PATH + "counter" );
 * @see query_counter()
 * @param path The full path and filename to the shop's counter.
 */
protected void set_counter(string path) { _counter = path; }

/**
 * Set the creator of this shop.
 * This person will receive all applications, complaints, suggestions
 * etc in the absence of any managers.  Default is set by CREATOR in
 * <player_shop.h>
 * @example set_creator( "ringo" );
 * @see query_creator()
 * @param creator The person responsible for this shop.
 */
protected void set_creator(string creator) { _creator = creator; }

/**
 * Set the directions to other parts of the shop.
 * This function is used by the npc shopkeeper to navigate around the shop, 
 * using the exits at the given directions.  These directions should be the 
 * standard "north", "south", "up" etc.
 * @example set_directions( "southeast", "southeast", "southeast" );
 * @param store the direction to the storeroom.
 * @param counter the direction to the counter.
 * @param shop the direction to the shop front.
 */
protected void set_directions(string store, string counter, string shop)
{
   _store_dir = store;
   _counter_dir = counter;
   _shop_dir = shop;
}
/* set_directions() */

/**
 * Set the location of the shop.
 * This is used by the money handling functions to determine which 
 * currency to use and therefore should be one of the locations returned
 * by the query_all_places() function in /obj/handlers/money_handler
 * @example set_place( "Lancre" );
 * @see query_location()
 * @param place the location of this shop.
 */
protected void set_place(string place) { _place = place; }

/**
 * Set the name of the proprietor.
 * A fictional name; the owner of this establishment.  All administration
 * board posts & mudmails will be sent by this name.
 * @example set_proprietor( "Tarnach Fendertwin" );
 * @see query_proprietor()
 * @param name the name of the proprietor.
 */
protected void set_proprietor(string name) { _proprietor = name; }

/**
 * Set the path to the customer area.
 * @example set_shop_front( PATH + "shopfront" );
 * @see query_shop_front()
 * @param path the full path and filename to the customer area of the shop.
 */
protected void set_shop_front(string path) { _shop_front = path; }

/**
 * Set the full name of the shop.
 * This is used throughout the shop, and passed to the shop front as the
 * short description for the shop.
 * @example set_shop_name( "Tarnach Fendertwin's Quality Consumables (Creel Springs)" );
 * @see query_shop_name()
 * @param name the name of the shop.
 */
protected void set_shop_name(string name) { _shop_name = name; }

/**
 * Set the npc shopkeeper object.
 * @example set_shopkeeper( PATH + "shopkeeper" );
 * @see /std/shops/player_shop/shopkeeper.c
 * @param path the full path to the shopkeeper.
 */
protected void set_shopkeeper(string path)
{ 
   _shopkeeper = path;
   path=_shopkeeper->query_name();
   if (!_employees || !_employees[path])
   {
      _employees += ([path:EMP_MAP]);
      _employees[path][EMP_POINTS] = EMPLOYEE + NPC; 
   }
}

/**
 * Set the path to the storeroom.
 * @example set_storeroom( PATH + "storeroom" );
 * @see query_storeroom()
 * @param path the full path and filename to the storeroom of the shop.
 */
protected void set_storeroom(string path) { _storeroom = path; }

/**
 * Set the stock's main policy.
 * This is a general description of the items that this store deals in.
 * @example set_stock_policy( "magical spell components" );
 * @param desc the main stock description.
 */
protected void set_stock_policy(string desc) { _stock_policy = desc; }

/**
 * Set the very short name of the shop.
 * This is used in many places including save-file names, setting up 
 * player-titles, and mail headers.  It should be no more than around
 * 4 or 5 chars in length.  This function also restores all saved data.
 * You must register this name by calling add_shop() in the handler.
 * @example set_very_short( "TFQC-CS" );
 * @see shop_very_short()
 * @see /obj/handlers/player_shop
 * @param name the very short name.
 */
protected void set_very_short(string name)
{
   if (PLAYER_SHOP->query_shop(name) != file_name(this_object()))
      return;
   _very_short = name;
   _savedir = sprintf("/save/player_housing/%s/player_shops/%s/",
      lower_case(geteuid(this_object())), name);
   if (file_size(_savedir+ "shop_data.o") > 0)
      unguarded((: restore_object, _savedir+ "shop_data" :));
   if (file_size(_savedir+ "employees") > 0)
      _employees = restore_variable(unguarded((: read_file,
        _savedir+ "employees" :)));
   if (file_size(_savedir+ "times") > 0)
      _times = restore_variable(unguarded((: read_file,
      _savedir+ "times" :)));
   if (file_size(_savedir+ "list") > 0)
      _list = restore_variable(unguarded((: read_file, _savedir+ "list" :)));
}
/* set_very_short() */

/**
 * Query the very short name of the shop.
 * @see set_very_short()
 * @return the very short name of the shop.
 */
string shop_very_short() { return copy(_very_short); }
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/shop_front.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/shop_front.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629615   Available: 13576969
Inodes: Total: 5242880    Free: 4960136
20026 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/shop_front.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629615   Available: 13576969
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The standard inheritable object for player-run shop fronts.
 *
 * <p><b>Description</b></p>
 * <p>As far as the customer is concerned, the shop front is the shop.
 * They will have no access to the other areas of the shop. In this room,
 * they can apply for a position, make a complaint or suggestion, as well
 * as buy and sell items. The main entrance is linked to a bell which will
 * 'tinkle' throughout the shop. In the event that the npc shopkeeper is
 * not currently working, and no employees are currently in the shop, a
 * push-bell is provided to alert any employees who may be logged on. 
 * </p>
 * <p>Applicants who have had their application accepted can confirm their
 * employment here. Any applicant may also cancel their application.
 * </p>
 * <p>All suggestions and complaints are mailed to managers. All
 * applications are saved and managers are notified by e-mail.
 * </p>
 * <p>Note that the outside entrance to this room should be modified to
 * call the tinkle_bell() function. This will ensure that the shop's bell
 * alerts any employees within the shop whenever the door is opened/closed.
 * In the <i>setup()</i> function, the relevant exit should be modified
 * along these lines: 
 * </p>
 * <pre>
 * modify_exit( DIRECTION, ({ "open/close func", ({ this_object(),
 *    "shop_bell" }), "door short", "shop door", "door long",
 *    "This is a functional, if not terribly exciting door.  "
 *    "There is a sign hanging above it.\n" }) );
 * </pre>
 * <p>And the function shop_bell() which looks like this:</p> 
 * <pre>
 * int shop_bell(int opening)
 * {
 *     ( PATH_TO_SHOP_FRONT )->tinkle_bell(opening);
 *     return 1;
 * }
 * </pre>
 * 
 * @example
 * #include "path.h"
 * 
 * inherit "/std/shops/player_shop/shop_front";
 * 
 * void setup()
 * {
 *    set_light(60);
 *    set_office( PATH+ "office" );
 * 
 *    set_long( "This is the Creel Springs branch of Tarnach Fendertwin's "
 *       "Quality Consumables, a shop that acts as a trading post for magic "
 *       "spell components.  There is a small card and a push-bell on the "
 *       "counter to the east and a sign hanging from the front of it.  The "
 *       "door to the east leads out to the village lane.\n" );
 *    add_sign( "The sign is a piece of white card that hangs from the front "
 *      "of the counter.\n", "Welcomme to Tarnach's!  Pleese ask aboute "
 *      "our pryces for buying and selling: "+ query_office()->
 *      query_list_string() +".  Employement enquyries wellcome!" );
 *    set_exit_counter( "west" );
 *    set_exit_out( "east", "/d/ram/Lancre_Kingdom/Creel_Springs_pt/creel_springs02" );
 * }
 * 
 * @see /include/player_shop.h
 * @see /std/shops/player_shop/office.c
 * @see /std/shops/player_shop/mgr_office.c
 * @see /std/shops/player_shop/counter.c
 * @see /std/shops/player_shop/storeroom.c
 * @see /std/shops/player_shop/shopkeeper.c
 * @author Ringo
 * @started 1st August 1999
 */
inherit "/std/room/basic_room";

#include <player_shop.h>
#include <mail.h>

private nosave class applying_player
{
    int step;
    string *answers;
}

private nosave string _inside = "",
_outside = "",
_office = "",
_counter = "",
_storeroom = "",
_mgr_office = "",
_channel;

private void abort_app(class applying_player);
private void apply(class applying_player);
private string cap_name(string);
int check_employee(string, object, string);
private void confirm_abort(string, class applying_player);
private void confirm_apply(string, string, class applying_player);
private void continue_loop(class applying_player);
string directions_to(string);
private int do_apply();
private int do_cancel();
private int do_complain();
private int do_confirm();
private int do_push();
private int do_suggestion();
private void end_app(class applying_player);
private void end_complaint(string);
private void end_suggestion(string);
private void finish_edit(string, class applying_player);
string query_office();
string query_outside();
protected void set_exit_counter(string);
protected void set_exit_out(string, string);
protected void set_office(string);
string sign_text();
int tinkle_bell(string);


/** @ignore yes */
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("no burial", 1);
    add_property("los", "closed");
    add_property("determinate", "");
    add_item("counter", "The counter divides this room of the shop in two.  "
      "You get the feeling that only employees can pass it.  There's a "
      "%^BOLD%^card%^RESET%^ on the counter that catches your attention, "
      "next to which is a small %^BOLD%^bell%^RESET%^.");
    add_item("card", "The card seems to be a simple form.  One section "
      "seems to allow you to \"apply\" for a job here, whilst the "
      "bottom section could be filled out to make a \"suggestion\".\n"
      "If you wish to \"complain\" about an employee, you may do so here.  "
      "If you have been accepted for employment, you can also \"confirm\" "
      "you accept, or you can \"cancel\" your application at any time.");
    add_item("doorbell", "The bell above the door is positioned so that as the "
      "door passes underneath it, it will ring.");
    add_item(({"bell", "push-bell"}),
      ({"long", "This is a small push-bell for summoning the employees.",
        "push", (: do_push() :)}));
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_shopfront");
}
/* create() */


/** @ignore yes */
void init()
{
    string tp;

    ::init();
    if (!_office || _office == "") return;
    tp = this_player()->query_name();
    _office->summon_shopkeeper();
    add_command("complain", "", (: do_complain() :));
    add_command("suggestion", "", (: do_suggestion() :));
    if (!check_employee("void", this_player(), "void"))
        add_command("apply", "", (: do_apply() :));
    if ( _office->query_applicant(tp) == HIRED)
        add_command("confirm", "employment", (: do_confirm() :));
    if (_office->query_applicant(tp))
        add_command( "cancel", "application", (: do_cancel() :) );
}
/* init() */


/** @ignore yes */
private void abort_app(class applying_player player_info)
{
    tell_object(this_player(),
      "Are you sure you want to ABORT the application? ");
    input_to((: confirm_abort($1,$(player_info)) :), 0);
} 
/* abort_app() */


/** @ignore yes */
private void apply(class applying_player player_info)
{
    object tp = this_player();
    tell_object(tp, "\n\n");
    tell_object(tp, "%^BOLD%^Application for employment with "+
      _office->query_shop_name()+ "%^RESET%^\n\n"
      "Please note that a blank entry will abort your application.\n");
    tell_object(tp, "There are " + query_num(sizeof(APP_QUESTIONS))+
      " questions on this application form.  Please answer them all.  "
      "You will get an opportunity at the end to let us know anything "
      "else about you that seems relevant.\n\n" );
    continue_loop(player_info);
}
/* apply() */


/** @ignore yes */
private string cap_name(string name) 
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}

/** @ignore yes */
int check_employee(string verb, object thing, string special)
{
    if (thing->query_creator() || 
      _office->query_retired(thing->query_name())) return 1;
    return _office->query_employee(thing->query_name());
}
/* check_employee() */


/** @ignore yes */
private void confirm_abort(string confirm, class applying_player player_info)
{
    confirm = lower_case(confirm);
    if (strlen(confirm) < 1 || (confirm[0] != 'y' && confirm[0] != 'n'))
    {
        tell_object(this_player(), "Please enter 'yes' or 'no'.\n"
          "Are you sure you want to ABORT the application? ");
        input_to((: confirm_abort($1,$(player_info)) :), 0);
        return ;
    }
    if (confirm[0..0] != "y")
    {
        continue_loop(player_info);
        return ;
    }
    tell_object(this_player(), "Application aborted.\n");
    return;
}
/* confirm_abort() */


/** @ignore yes */
private void confirm_apply(string str, string message,
  class applying_player player_info)
{
    string from, *managers;

    str = lower_case( str );
    if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'n'))
    {
        tell_object(this_player(), "Are you sure you want to send "
          "the application (Yes or No)? ");
        input_to((: confirm_apply($1,$(message),$(player_info)) :), 0);
        return;
    }
    if(str[0] == 'n')
    {
        confirm_abort("y", player_info);
        return;
    }
    from = (string)this_player()->query_name();
    managers = _office->get_managers();
    if (!sizeof(managers)) managers = ({ _office->query_creator() });
    AUTO_MAILER->auto_mail(implode(managers, ","),
      _office->query_proprietor(), "Application for employment with "+
      _office->shop_very_short(), "", "There is a new application to be "
      "viewed.\nPlease vote on "+ cap_name( from )+ "'s application as "
      "soon as possible.\n", 0, 0);
    _office->add_applicant(from, message);
    tell_object(this_player(), "\nYour application has now been sent "
      "to the managers.  You will hear from us as soon as they have "
      "made a decision.  Thank you for your application, and good luck.\n");
}
/* confirm_apply() */


/**
 * @ignore yes
 * The application form for the shop.  Viciously ripped out of the
 * Patricican's Application room for Creators.
 */
private void continue_loop(class applying_player player_info)
{
    string q_str = "Question #"+(player_info->step+1)+": ";
    tell_object(this_player(), "\n%^CYAN%^" + sprintf("%s%-=*s\n",
        q_str, this_player()->query_cols() - strlen(q_str),
        APP_QUESTIONS[player_info->step]) + "%^RESET%^");
    this_player()->do_edit("", (: finish_edit($1,$(player_info)) :), 0);
} 
/* continue_loop() */


/** @ignore yes */
string directions_to(string place)
{
    if (place == _counter || place == _office || place == _storeroom)
        return copy(_inside);
    return "here";
}
/* directions_to() */


/**
 * @ignore yes
 * Application for employment.
 * This function is the start of the application process.  The
 * applicant is asked the questions defined in APP_QUESTIONS in 
 * player_shop.h, and the answers are forwarded to each manager, or
 * CREATOR if there are currently no managers of the shop.
 */
private int do_apply()
{
    int awaiting_vacancies = 0;
    mapping applicants;
    string tp = this_player()->query_name();
    class applying_player player_info;

    if (_office->query_applicant(tp))
    {
        tell_object(this_player(), "You've already applied here!\n");
        return 1;
    }
    if (_office->query_declined(tp))
    {
        tell_object(this_player(), "I'm sorry, but you cannot make another "
          "application just yet.\n");
        return 1;
    }
    applicants = _office->get_applicants();
    foreach (string applicant in m_indices(applicants))
    if (applicants[applicant][APP_TYPE] == AWAITING)
        awaiting_vacancies++;
    if ((awaiting_vacancies > (_office->query_maxemp() / 10)))
    {
        tell_object(this_player(), "I'm sorry, but we do not have any "
          "vacancies at the moment.  Please try again at a later date.\n");
        return 1;
    }
    player_info = new(class applying_player);
    player_info->step = 0;
    player_info->answers = ({});
    call_out((: apply($(player_info)) :), 0);
    add_succeeded_mess("");
    return 1;
}
/* do_apply() */


/** @ignore yes */
private int do_cancel() { return _office->do_cancel(); }


/**
 * @ignore yes
 * Complaint about the shop's employees.
 * The complaint is forwarded to each manager, or CREATOR if there 
 * are currently no managers of the shop.
 */
private int do_complain()
{
    tell_object(this_player(), COMPLAINT_TEXT + 
      "  This complaint will then be sent to the managers of the shop.  "
      "If you would rather remain anonymous to the managers, please "
      "contact a liaison, or send a mail with all the above details to "+
      cap_name(_office->query_creator())+ ".\n");
    this_player()->do_edit("%^CYAN%^"+ COMPLAINT_TEXT + "%^RESET%^\n\n",
      (: end_complaint($1) :));
    add_succeeded_mess("");
    return 1;
}
/* do_complain() */


/** @ignore yes */
private int do_confirm() { return _office->do_confirm(); }


/** @ignore yes */
private int do_push()
{
    if (this_player()->query_property("shop bell pressed"))
        return notify_fail( "Calm down!  You've only just pushed it.  Try "
          "in a minute or so if there's still no reply.\n" );
    if (check_employee("void", this_player(), "void"))
        return notify_fail("There's already an employee here: You!\n");
    if (!_channel || _channel == "")
        return notify_fail( "You push the bell, but no-one can hear you.\n" );
    this_player()->add_property("shop bell pressed", 1, BELL_TIMEOUT);
    HISTORY_HANDLER->add_chat_history(_channel, "Shop: ", this_player()->
      query_short() + " called for assistance.");
    children(BADGE)->receive(_channel, "Shop", this_player()->query_short()+
      " is calling for assistance.");
    add_succeeded_mess("$N $V the bell.\n");
    return 1;
}
/* do_push() */


/**
 * @ignore yes
 * Suggestion for the shop.
 * The complaint is forwarded to each manager, or s if there 
 * are currently no managers of the shop.
 */
private int do_suggestion()
{
    tell_object(this_player(), SUGGEST_TEXT+ "\n");
    this_player()->do_edit("%^CYAN%^"+ SUGGEST_TEXT+ "%^RESET%^\n",
      (: end_suggestion($1) :));
    add_succeeded_mess("");
    return 1;
}
/* do_suggestion() */


/** @ignore yes */
private void end_app(class applying_player player_info)
{
    string message = "";

    for (int i = 0; i < sizeof(APP_QUESTIONS); i++)
    {
        message += "%^CYAN%^" + sprintf("%2d) %-=*s\n", (i+1), 70, 
          APP_QUESTIONS[i]) + "%^RESET%^" +
        sprintf("      %-=*s\n\n", 72, player_info->answers[i]);
    }
    tell_object(this_player(), "We have your application as:\n" + message+
      "\nDo you wish to send it? ");
    input_to((: confirm_apply($1,$(message),$(player_info)) :), 0);
}
/* end_app() */


/** @ignore yes */
private void end_complaint(string text)
{
    string *managers;

    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    if (!sizeof(managers = _office->get_managers()))
        managers = ({_office->query_creator()});
    AUTO_MAILER->auto_mail(implode(managers, ","), 
      this_player()->query_name(), _office->shop_very_short()+ " complaint",
      "", text, 0, 0);
    tell_object(this_player(), "Your complaint has now been sent to the "
      "managers, and will be dealt with as soon as possible.\n");
}
/* end_complaint() */  


/** @ignore yes */
private void end_suggestion(string text)
{
    string *managers;

    if (!text)
    {
        tell_object( this_player(), "Aborted.\n" );
        return;
    }
    if (!sizeof(managers = _office->get_managers()))
        managers = ({_office->query_creator()});
    AUTO_MAILER->auto_mail( implode( managers, "," ),
      this_player()->query_name(), _office->shop_very_short()+ " suggestion",
      "", text, 0, 0 );
    tell_object(this_player(), "Your suggestion has been sent to the "
      "managers, and will be dealt with as soon as possible.\n");
}
/* end_suggestion() */  


/** @ignore yes */
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k,o,k2,r,k3);
}
/* event_death() */


/** @ignore yes */
void event_enter(object ob, string message, object from)
{
    mapping baddies;
    int days;
    string name = ob->query_name();

    if (_office->query_baddie(name))
    {
        baddies = _office->get_baddies();
        days = (((BAN_LENGTH*60*60*24) -
            (time() - baddies[name][2])) / (60*60*24)) + 1;
        tell_room(this_object(), ob->query_short()+
          " drifts out of the door, seemingly against "+
          ob->query_possessive()+ " will.\n", ({ob}));
        tell_object(ob, "You feel yourself pushed out of the shop by "
          "a mysterious force.\nYou have been banned from this shop for "+
          baddies[name][0]+ " and will not be re-admitted for a maximum of "+ 
          query_num(days)+ " days.\n");
        ob->move(_outside);
    }
}
/* event_enter() */


/** @ignore yes */
string long(string word, int dark)
{
    int emps_in = 0;

    if (find_object(_office->query_shopkeeper()) &&
      _office->query_employee(_office->query_shopkeeper()->
        query_name()) & CLOCKED_IN)
    {
        emps_in = 1;
    }
    emps_in += _office->num_employees_in();
    return sprintf("%s%s %s currently clocked in.\n",
      ::long(word,dark), _office->employees_clocked_in(),
      (emps_in == 1)? "is" : "are");
}
/* long() */


/** @ignore yes */
private void finish_edit(string message, class applying_player player_info)
{
    if (!message || message == "")
    {
        abort_app(player_info);
        return;
    }
    player_info->answers += ({message});
    player_info->step++;
    if (player_info->step == sizeof(APP_QUESTIONS)) end_app(player_info);
    else continue_loop(player_info);
}
/* finish_edit() */


/**
 * Query the path to the office.
 * @return The path to the office.
 */
string query_office() { return copy(_office); }


/**
 * Query the path to the room outside the shop.
 * @return The full path set by set_exit_out()
 */
string query_outside() { return copy(_outside); }


/**
 * Add the exit to the counter.
 * Creates a hidden exit to the shop which will only allow employees to
 * pass.  This function must be called after the set_office function.
 * @example set_exit_counter( "west" );
 * @param direction The direction to the counter.
 */
protected void set_exit_counter(string direction)
{
    _inside = direction;
    add_exit(direction, _counter, "hidden");
    modify_exit(direction, ({"function", "check_employee"}));
}
/* set_exit_out() */


/**
 * Add the exit to outside the shop.
 * This exit will notify employees anywhere in the shop when
 * someone walks through it.  This function must be called after
 * the set_office function.
 * @example set_exit_out( "east", "/d/ram/Lancre_Kingdom/Creel_Springs_pt/creel_springs02" );
 * @param direction The direction to outside the shop.
 * @param path The path to outside the shop.
 */
protected void set_exit_out(string direction, string path)
{
    _outside = path;
    add_exit(direction, path, "door");
    modify_exit(direction, ({"open/close func", ({this_object(),
          "tinkle_bell"})}));
}
/* set_exit_out() */


/**
 * Set the path of the main office.
 * @example set_office( PATH + "office" );
 * @param path The full path & filename.
 */
protected void set_office(string path)
{
    _office = path;
    _counter = path->query_counter();
    _mgr_office = path->query_mgr_office();
    _storeroom = path->query_storeroom();
    _channel = path->query_channel();
    set_short( path->query_shop_name() );
    add_sign("A small golden plaque with engraved text.\n",
      (: sign_text :), "small plaque", "plaque",
      "common")->add_property("there", "on one wall");
}
/* set_office() */

/** @ignore yes */
string sign_text()
{
    string *eom = _office->query_eom();
    return sprintf("\n%%^YELLOW%%^  Employee Of The Month for %s : %s%%^RESET%%^\n\n",
       eom[0], cap_name(eom[1]));
}
/* sign_text() */


/** @ignore yes */
int tinkle_bell(string action)
{
    tell_room(this_object(), "The bell tinkles as the door "+
      action+ "s.\n");
    tell_room(find_object(_counter), "The bell over the shop door "
      "tinkles.\n");
    tell_room(find_object(_office), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    tell_room(find_object(_storeroom), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    tell_room(find_object(_mgr_office), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    return 1;
}
/* tinkle_bell() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/shop_front.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/storeroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629610   Available: 13576964
Inodes: Total: 5242880    Free: 4960136
27023 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/storeroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629610   Available: 13576964
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
* The standard inheritable object for player-run shop storerooms.
* 
* <p><b>Description</b></p>
* <p>The storeroom does not directly contain any stock, rather it acts
* as an interface between the employees and the stock cabinets. A shop
* may contain a varying number of cabinets between a specified minimum
* and maximum level. Any cabinets above the minimum are rented for a set
* fee. 
* </p>
* <p>This room contains functions to add items to and remove items from
* the cabinets, which are assigned a particular item to store. Each
* cabinet will hold a maximum number of items and the code, therefore,
* has been designed to be quite flexible.
* </p>
* <p>In order to accommodate the _npc shopkeeper_, as well as the
* newer/lazier employees, the storeroom can automatically assign items to
* or retrieve items from a cabinet depending on the settings specified by
* the managers. However, employees can also specify a particular cabinet
* when adding/removing items or listing the stock. The actions will then
* take place on that cabinet, as long as it is assigned that item. All
* additions and removals to the stock are logged. 
* </p>
* <p>Specific products can be stored in more than one cabinet, and more
* than one type of product can be stored in a single cabinet. This ensures
* maximum flexibility within the stockroom.
* </p>
* <p>Bearing in mind that in the old model, the average size of a medium
* stock file was 650k, the major benefits of multiple stock cabinets are:
* <ul>
* <li>Greater efficiency - A maximum of 50 objects are saved at a time,
* instead of potentially several thousand.</li>
* <li>Reduction in risk - Less chance that a crash will result in
* catastrophic loss of stock due to data loss whilst writing.</li>
* </ul></p>
* <p>The cabinets are loaded only when needed, and then unloaded a set
* time later.  If they are needed again during this time, the time to
* unload is reset.  This means that the disk access is kept to a minumum,
* whilst also conserving memory (remember, each cabinet - when full - can
* take up around 50kb).
* </p>
* <p>Finally, on a more cosmetic note, a shopping bag dispenser is fitted
* as standard. Pulling the roll dispenses a bag complete with message. 
* </p>
* 
* @example
* #include "path.h"
* 
* inherit "/std/shops/player_shop/storeroom";
* 
* void setup() {
*    set_light(60);
*    set_directions( "north", "north", "north" );
*    set_office( PATH+ "office" );
* 
*    set_short( "storeroom of Tarnach's shop" );
*    set_long( "This is the storeroom of the Creel Springs branch of "
*        "Tarnach Fendertwin's Quality Consumables.\n" );
*    add_exit( "north", PATH+ "counter", "door");
* }
* 
* @see /include/player_shop.h
* @see /std/shops/player_shop/office.c
* @see /std/shops/player_shop/mgr_office.c
* @see /std/shops/player_shop/counter.c
* @see /std/shops/player_shop/shop_front.c
* @see /std/shops/player_shop/shopkeeper.c
* @author Ringo
* @started 1st August 1999
*/

//#define DEBUG

inherit "/std/room/basic_room";

#include <player_shop.h>
#include <move_failures.h>
#include "patterns.h"

private nosave string _office = "", 
_counter = "",
_mgr_office = "",
_shop_front = "",
_office_dir = "", 
_counter_dir = "",
_shop_dir = "";

private nosave object *_cabinets = 0;

private nosave int _num_cabinets, _call_cabs_clear;

private nosave mapping _cache = ([]);

int add_cabinet();
private void clear_cabinets();
string directions_to(string);
private int do_add(object *, mixed *);
private int do_list(mixed *, string);
private int do_remove(mixed *);
private void init_cabinets();
private int pull_roll();
int query_content(int);
int query_num_items(string, int);
string query_office();
int query_stock(string);
string remove_cabinet();
protected void set_directions(string, string, string);
protected void set_office(string);

/** @ignore yes */
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("no burial", 1);
    add_property("determinate", "");
    add_item("cabinet", "There are several cabinets in the room, holding "
      "the entire stock of the shop.  If you are authorised to do so, you "
      "may \"list\" the stock, as well as \"add\" and \"remove\" "
      "items from the cabinets.");
    add_item(({"roll", "bag"}), "You could probably \"pull\" a bag off "
      "the roll and give it to a customer with their purchase.\n"
      "Bags should only be handed out with purchases of 10 or more items.");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_storeroom");
}
/* create() */


/** @ignore yes */
void init()
{
    ::init();
    if (!_office || _office == "") return;
    add_command("add", ({"<indirect:object:me'item(s)'>", 
        "<indirect:object:me'item(s)'> to cabinet <number'cabinet'>"}),
      (: do_add($1,$4) :));
    add_command("pull", "roll", (: pull_roll() :));
    if (_office->query_employee(this_player()->query_name()) ||
      this_player()->query_creator())
    {
        add_command("list", ({LIST_BLANK, LIST_CABINET,
            LIST_ITEM, LIST_ITEM_CABINET}),
          (: do_list($4,$5) :));
        add_command("remove", ({"<number> <string'item(s)'>", 
            "<number> <string'item(s)'> from cabinet <number'cabinet'>"}),
          (: do_remove($4) :));
    }
    else if (_office->query_retired(this_player()->query_name()))
        add_command("list", ({LIST_BLANK, LIST_CABINET,
            LIST_ITEM, LIST_ITEM_CABINET}), (: do_list($4,$5) :));
}
/* init() */


/** @ignore yes */
int add_cabinet()
{
    object cabinet;
    string cab_name;

    if (previous_object() && previous_object() != find_object(_office))
    {
        LOG_ERROR("storeroom.c", "add_cabinet()");
        return 0;
    }
    if ((_num_cabinets) == MAX_CABINETS) return 0;
    init_cabinets();
    cab_name = "cabinet"+ _num_cabinets++;
    cabinet = clone_object(CABINET);
    cabinet->set_name(cab_name);
    cabinet->set_save_file(_office->query_savedir()+ cab_name);
    _cabinets += ({cabinet});
    return 1;
}
/* add_cabinet() */


/** @ignore yes */
private void clear_cabinets()
{
    if (!_cabinets) return;
#ifdef DEBUG
    tell_creator(CREATOR, "Clearing cabinets.\n");
#endif
    foreach (object cabinet in _cabinets) cabinet->dest_me();
    _cabinets = 0;
}
/* clear_cabinets() */


/** @ignore yes */
void dest_me()
{
    remove_call_out(_call_cabs_clear);
    clear_cabinets();
    ::dest_me();
}
/* dest_me() */


/** @ignore yes */
string directions_to(string place)
{
    if (place == _counter) return copy(_counter_dir);
    if (place == _office) return copy(_office_dir);
    if (place == _shop_front) return copy(_shop_dir);
    return "here";
}
/* directions_to() */


/** @ignore yes */
private int do_add(object *items, mixed *args)
{
    int cab_no = 0;
    object *okay = ({}),
    *failed = ({});

    add_succeeded_mess("");
    if (sizeof(args) > 1)
    {
        cab_no = args[1];
        if (cab_no < 1 || cab_no > _num_cabinets)
        {
            tell_object(this_player(), "That cabinet does not exist!\n");
            return 1;
        }
    }
    init_cabinets();
    foreach (string plural in _office->query_list_array())
    {
        int tot_i, number, temp_num;
        mixed *test;

        parse_command(plural, items, "%i", test);
        if (!test || !sizeof(test)) continue;
        if (!sizeof(_office->query_cabinet(plural)))
        {
            tell_object(this_player(), "There are no cabinets assigned to "+
              plural+ "!\n");
            return 1;
        }
        if ((tot_i = _office->query_max(plural) - query_stock(plural)) < 1)
        {
            tell_object(this_player(),
              "The shop is already fully stocked on "+ plural +".\n");
            test = ({});
            continue;
        }
        test = test[1..];
        if (test[0]->query_collective())
        {
            number = test[0]->query_amount();
        }
        else
        {
            number = sizeof(test);
        }
        if (cab_no)
        {
            int cab_i = 0;

            foreach (object ob in all_inventory(_cabinets[cab_no-1]))
            {
                if (ob->query_collective())
                {
                    cab_i += ob->query_amount();
                }
                else
                {
                    cab_i += 1;
                }
            }

            cab_i = STOCK_PER_CABINET - cab_i;

            if (cab_i < 1)
            {
                tell_object(this_player(), "That cabinet is already full.\n");
                return 1;
            }
            if (member_array(cab_no, _office->query_cabinet(plural)) == -1)
            {
                tell_object(this_player(), plural +
                  " do not belong in that cabinet.\n");
                return 1;
            }
            if (number > cab_i)
            {
                tell_object(this_player(), "You cannot add all of the "+ plural +
                  " to cabinet "+ cab_no+ " without exceeding the maximum.\n");
                if (test[0]->query_collective())
                {
                    object temp = test[0]->make_medium_clone(cab_i);
                    test[0]->adjust_amount(-cab_i);
                    test = ({temp});
                    test->move(this_player());
                }
                else
                {
                    test = test[0 .. (cab_i - 1)];
                }
            }
        }
        else if (number > tot_i)
        {
            tell_object(this_player(), "You cannot add all of the "+ plural +
              " to the stock without exceeding the maximum.\n");
            if (test[0]->query_collective())
            {
                object temp = test[0]->make_medium_clone(tot_i);
                test[0]->adjust_amount(-tot_i);
                test = ({temp});
                test->move(this_player());
            }
            else
            {
                test = test[0 .. (tot_i - 1)];
            }
            number = tot_i;
        }
        temp_num = number;
        if (cab_no)
        {
            object *temp_fail;
            okay += test;
            temp_fail = _cabinets[cab_no - 1]->
            add_items(test, this_player());
            failed += temp_fail;
            if (sizeof(temp_fail))
            {
                temp_num -= temp_fail[0]->query_amount();
            }
            else
            {
                temp_num -= sizeof(temp_fail);
            }
        }
        else
        {
            int cab_i = 0;

            foreach(cab_no in _office->query_cabinet(plural))
            {
                object *temp_fail;

                if (!number) break;

                foreach (object ob in all_inventory(_cabinets[cab_no-1]))
                {
                    if (ob->query_collective())
                    {
                        cab_i += ob->query_amount();
                    }
                    else
                    {
                        cab_i += 1;
                    }
                }

                cab_i = STOCK_PER_CABINET - cab_i;

                if (cab_i < 1) continue;

                if (cab_i > number)
                {
                    cab_i = number;
                }

                if (test[0]->query_collective())
                {
                    object temp = test[0]->make_medium_clone(cab_i);
                    test[0]->adjust_amount(-cab_i);
                    okay += ({temp});
                    temp_fail = _cabinets[cab_no - 1]->
                    add_items(({temp}), this_player());
                }
                else
                {
                    okay += test[0..(cab_i-1)];
                    temp_fail = _cabinets[cab_no - 1]->
                    add_items(test[0 .. (cab_i - 1)], this_player());
                    test -= test[0 .. (cab_i - 1)];
                }
                number -= cab_i;
                failed += temp_fail;
                if (sizeof(temp_fail))
                {
                    if (temp_fail[0]->query_collective())
                    {
                        temp_num -= temp_fail[0]->query_amount();
                    }
                    else
                    {
                        temp_num -= sizeof(temp_fail);
                    }
                }
            }

            if (sizeof(test) && test[0]->query_amount())
            {
                tell_object(this_player(), "There is not enough room in the "
                  "assigned cabinets for "+ query_multiple_short(test)+ ".\n");
                if (test[0]->query_collective())
                {
                    temp_num -= test[0]->query_amount();
                }
                else
                {
                    temp_num -= sizeof(test);
                }
            }
            cab_no = 0;
        }
        test = ({});
        _office->adjust_bought(plural, temp_num);
        if (!_cache[plural])
        {
#ifdef DEBUG
            tell_creator(CREATOR,"Creating %s cache entry.\n", plural);
#endif
            _cache += ([plural:({1,0})]);
        }
        else
        {
            _cache[plural][0] = 1;
        }
    }
    okay -= failed;
    if (sizeof(failed))
    {
        string short = query_multiple_short(failed);
        tell_room(environment(this_player()), this_player()->query_short()+
          " accidentally drops "+ short+
          " on the floor.\n", ({this_player()}));
        tell_object(this_player() , "You accidentally drop "+
          short+ " on the floor.\n");
    }
    if (sizeof(okay))
    {
        string short = query_multiple_short(okay);
        _office->shop_log(PURCHASE, this_player()->query_name(),
          this_player()->convert_message(short)+
          " added to stock", UNPAID);
        add_succeeded_mess("$N $V "+ short+ 
          " to the stock.\n");
    }
    return 1;
}
/* do_add() */


/** @ignore yes */
private int do_list(mixed *args, string pattern)
{
    object *found_items = ({});
    int i = 0;

    add_succeeded_mess("");
    init_cabinets();
    foreach (object cabinet in _cabinets)
    i += sizeof(all_inventory(cabinet));
    if (!i)
    {
        tell_object(this_player(), 
          "There is nothing in stock at the moment.\n");
        return 1;
    }

    /* Plain old full stock list */
    if (pattern == LIST_BLANK)
    {
        string result = sprintf("     Stock of %s\n     As at %s\n\n",
          _office->query_shop_name(), ctime(time()));
        foreach(string key in _office->query_list_array())
        {
            found_items = ({});
            //reset_eval_cost(MAX_STOCK);
            found_items += ((class obj_match)match_objects_in_environments(key, _cabinets))->objects;
            if (sizeof(found_items))
                result += query_multiple_short( found_items )+ "\n";
        }
        tell_object(this_player(), "$P$Stock list$P$"+ result);
        return 1;
    }

    /* List of stock in specified cabinet */
    if (pattern == LIST_CABINET)
    {
        string result;

        if (args[0] < 1 || args[0] > _num_cabinets)
        {
            tell_object(this_player(), "That cabinet does not exist!\n");
            return 1;
        }
        if (!sizeof(all_inventory(_cabinets[args[0] - 1])))
        {
            result = "There is nothing in that cabinet at the moment.\n";
        }
        else
        {
            result = sprintf("     Stock of cabinet %d\n     As at %s\n\n",
              args[0], ctime(time()));
            foreach(string key in _office->query_list_array())
            {
                if (sizeof(found_items = ((class obj_match)match_objects_in_environments(key,
                        _cabinets[args[0]-1]))->objects ))
                {
                    result += query_multiple_short(found_items)+ "\n";
                }
            }
        }
        tell_object(this_player(), "$P$Cabinet "+ args[0]+ 
          " stock list$P$"+ result);
        return 1;
    }

    /* Plain old item search */
    if (pattern == LIST_ITEM)
    {
        string result;

        found_items += ((class obj_match)match_objects_in_environments(args[0], _cabinets))->objects;
        if (!sizeof(found_items))
        {
            tell_object(this_player(),  "There are no "+ args[0]+
              " in stock.\n");
            return 1;
        }
        result = sprintf("     List of %s\n     As at %s\n\n%s", args[0],
          ctime(time()), query_multiple_short(found_items));
        tell_object(this_player(), "$P$List of " + args[0]+ "$P$"+ result);
        return 1;
    }

    /* List of specific items in specified cabinet */
    if (args[1] < 1 || args[1] > _num_cabinets)
    {
        tell_object(this_player(), "That cabinet does not exist!\n");
        return 1;
    }
    if (!sizeof(all_inventory(_cabinets[args[1] - 1])))
    {
        tell_object(this_player(), "There is nothing in that cabinet at "
          "the moment.\n");
        return 1;
    }
    found_items = ((class obj_match)match_objects_in_environments(args[0],
        _cabinets[args[1]-1]))->objects;
    if (!sizeof(found_items))
    {
        tell_object(this_player(), "There are no "+ args[0]+ " in stock.\n");
        return 1;
    }
    tell_object(this_player(), "$P$List of "+ args[0]+ " in cabinet "+
      args[1]+ "$P$"+ sprintf("     List of %s in cabinet %d\n     "
        "As at %s\n\n%s", args[0], args[1], ctime(time()),
        query_multiple_short(found_items)));
    return 1;
}
/* do_list() */


/** @ignore yes */
private int do_remove(mixed *args)
{
    int cab_no = 0;
    object *items = ({}), *failed;

    failed = ({});
    add_succeeded_mess("");
    if (sizeof(args) > 2) cab_no = args[2];
    if (query_num_items(args[1], cab_no) < args[0])
    {
        tell_object(this_player(), "The stock does not contain "+ 
          args[0] + " "+ args[1]+ " to remove.\n");
        return 1;
    }
    init_cabinets();
    if (!cab_no)
    {
        int number = args[0];

        for(int i = sizeof(_cabinets); i > 0; i--)
        {
            object *stock = ((class obj_match)match_objects_in_environments(args[1],
                _cabinets[i-1]))->objects;
            if (sizeof(stock))
            {
                if (stock[0]->query_collective())
                {
                    if (stock[0]->query_amount() > number)
                    {
                        object ob = stock[0]->make_medium_clone(number);
                        items += ({ ob });
                        stock[0]->adjust_amount(-number);
                        if (ob->move(this_player()) != MOVE_OK)
                        {
                            ob->move(environment(this_player()));
                            failed += ({ ob });
                        }
                    }
                    else
                    {
                        number -= stock[0]->query_amount();
                        items += stock;
                        failed += _cabinets[i-1]->remove_items(stock, this_player());
                    }
                }
                else
                {
                    if (sizeof(stock) > number) stock = stock[ 0 .. (number-1) ];
                    items += stock;
                    failed += _cabinets[i-1]->remove_items(stock, this_player());
                    number -= sizeof(stock);
                }
            }
            if (!number) break;
        }
    }
    else
    {
        items = ((class obj_match)match_objects_in_environments(args[1],
            _cabinets[cab_no-1]))->objects[0 .. (args[0] - 1)];
        failed = _cabinets[cab_no - 1]->remove_items(items, this_player());
    }
    foreach (string vest in _office->query_list_array())
    {
        if (pluralize(args[1]) == vest)
        {
            args[1] = pluralize(args[1]);
            break;
        }
    }
    if (!_cache[args[1]])
    {
#ifdef DEBUG
        tell_creator(CREATOR,"Creating %s cache entry.\n", args[1]);
#endif
        _cache += ([args[1]:({1,0})]);
    }
    else
    {
        _cache[args[1]][0] = 1;
    }
    items -= failed;
    if (sizeof(failed))
    {
        tell_room(environment(this_player() ), this_player()->query_short()+
          " accidentally drops "+ query_multiple_short(failed)+
          " on the floor.\n", ({this_player()}));
        tell_object(this_player() , "You accidentally drop "+
          query_multiple_short(failed)+ " on the floor.\n");
    }
    if (find_object(_office->query_shopkeeper()) &&
      this_player() == find_object(_office->query_shopkeeper()))
        _office->query_shopkeeper()->set_failed(sizeof(failed));
    if (sizeof(items))
    {
        _office->shop_log(SALE, this_player()->query_name(),
          this_player()->convert_message(query_multiple_short(items))+
          " removed from stock", UNPAID);
        foreach (string plural in _office->query_list_array())
        {
            object *test = ({});
            parse_command(plural, items, "%i", test);
            if (!test || !sizeof(test)) continue;
            _office->adjust_sold(plural, sizeof(test) - 1);
        } 
        add_succeeded_mess("$N $V "+ query_multiple_short(items)+
          " from the stock.\n");
    }
    return 1;
}
/* do_remove() */


/** @ignore yes */
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k,o,k2,r,k3);
}
/* event_death() */


/** @ignore yes */
void event_enter(object ob, string message, object from)
{
    _office->event_enter(ob, message, from);
}
/* event_enter() */


/** @ignore yes */
string long(string word, int dark)
{
    return sprintf("%sThere are currently %d store cabinets "
      "in the room.\n", ::long(word,dark), _num_cabinets); 
}
/* long() */


/** @ignore yes */
private void init_cabinets()
{
    if (remove_call_out(_call_cabs_clear) == -1 && !_cabinets)
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Initialising cabinets.\n");
#endif
        _cabinets = ({});
        for (int i = 0; i < _num_cabinets; i++)
        {
            string cab_name = "cabinet"+ i;
            object cabinet = clone_object(CABINET);
            cabinet->set_name(cab_name);
            cabinet->set_save_file(_office->query_savedir()+ cab_name);
            _cabinets += ({cabinet});
        }
    }
    _call_cabs_clear = call_out((: clear_cabinets() :), CLEAR_DELAY);
}
/* init_cabinets() */


/** @ignore yes */
private int pull_roll()
{
    object bag;
    string message, day, day2, month;

    bag = clone_object(SHOP_BAG);
    sscanf(amtime(time()), "%*s %s %s %s", day, day2, month);
    if (member_array( month, ({"Offle", "February", "March",
          "April", "May", "June", "Grune", "August", "Spune", "Sektober",
          "Ember", "December", "Ick"}) ) == -1)
        message = sprintf("A very happy %s %s %s\n\nfrom everyone at\n\n%s, %s",
          day, day2, month, _office->query_shop_name(),
          _office->query_place());
    else message = sprintf("With the compliments of\n\n%s, %s.",
          _office->query_shop_name(), _office->query_place());
    bag->set_read_mess(message);
    bag->set_max_cond(400);
    bag->set_cond(400);
    if ((int)bag->move(this_player()) != MOVE_OK)
    {
        bag->move(this_object());
        tell_object(this_player(), 
          "You drop the bag as you're carrying too much.\n");
    }
    add_succeeded_mess("$N $V the roll and $I comes off in $p hand.\n",
      ({bag}) );
    return 1;
}
/* pull_roll() */

/**
* Query the current number of items in stock.
* @param item The item to query.
* @param cabinet The cabinet to look in (0 to look at all stock).
* @return The number of that item in stock.
*/
int query_num_items(string item, int cabinet)
{
    object *obs;
    init_cabinets();
    if (cabinet)
    {
        obs = ((class obj_match)match_objects_in_environments(item,
            _cabinets[cabinet-1]))->objects;
        if (!sizeof(obs))
        {
            return 0;
        }
        else if (obs[0]->query_collective())
        {
            return obs[0]->query_amount();
        }
        else
        {
            return sizeof(obs);
        }
    }
    else
    {
        return query_stock(item);
    }
}
/* query_num_items() */


/**
* Query the path to the office.
* @return The path to the office.
*/
string query_office() { return copy(_office); }


/**
* Query the current stock.
* @param item The item to query.
* @return The amount of stock.
*/
int query_stock(string item)
{
    object *obs;
    init_cabinets();

    if (!_cache[item])
    {
#ifdef DEBUG
        tell_creator(CREATOR,"Creating %s cache entry.\n", item);
#endif
        _cache += ([item:({1,0})]);
    }
    if (_cache[item][0])
    {
#ifdef DEBUG
        tell_creator("ringo","Updating %s in cache.\n", item);
#endif
        //reset_eval_cost(MAX_STOCK);
        obs = ((class obj_match)match_objects_in_environments(item, _cabinets))->objects;
        if (!sizeof(obs)) 
        {
            _cache[item][1] = 0;
        }
        else if (obs[0]->query_collective())
        {
            _cache[item][1] = obs[0]->query_amount();
        }
        else
        {
            _cache[item][1] = sizeof(obs);
        }
        _cache[item][0] = 0;
    }
    return _cache[item][1];
}
/* query_stock() */


/** @ignore yes */
string remove_cabinet()
{
    object cabinet;

    if (previous_object() && previous_object() != find_object(_office))
    {
        LOG_ERROR("storeroom.c", "remove_cabinet()");
        return "";
    }
    if ((_num_cabinets) == MIN_CABINETS) return "";
    init_cabinets();
    _num_cabinets--;
    cabinet = _cabinets[_num_cabinets];
    _cabinets -= ({cabinet});
    cabinet->move("/room/rubbish");
    return cabinet->query_name();
}
/* remove_cabinet() */


/**
* Set the directions to other parts of the shop.
* This function is used by the npc shopkeeper to navigate
* around the shop, using the exits at the given directions.
* These directions should be the standard "north", "southeast" etc.
* @param office The direction to the office.
* @param counter The direction to the counter.
* @param shop The direction to the shop front.
*/
protected void set_directions(string office, string counter, string shop)
{
    _office_dir = office;
    _counter_dir = counter;
    _shop_dir = shop;
}
/* set_directions() */


/** @ignore yes */
protected void set_long(string long_desc)
{
    long_desc += "Employees can \"add\" something to, \"remove\" "
    "something from and \"list\" the stock.\nThere is a roll of "
    "shopping bags conveniently located on one wall.\n";
    ::set_long(long_desc);
}
/* set_long() */


/**
* Set the path of the main office.
* @param path The full path & filename.
*/
protected void set_office(string path)
{
    _office = path;
    _counter = _office->query_counter();
    _mgr_office = _office->query_mgr_office();
    _shop_front = _office->query_shop_front();
    _num_cabinets = _office->query_num_cabinets();
}
/* set_office() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/storeroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/player_shop/shopkeeper.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/player_shop/shopkeeper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629603   Available: 13576957
Inodes: Total: 5242880    Free: 4960136
35437 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/player_shop/shopkeeper.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629603   Available: 13576957
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The standard inheritable object for player-run shop npc shopkeepers.
 * 
 * <p><b>Description</b></p>
 * <p>With the exception of the office, the shopkeeper contains the most
 * complex code. This npc is intended to mimic a player as closely as
 * possible. It adds and removes stock, and uses the cash register in the
 * same way as a player. It moves through the shop to the correct area to
 * perform its tasks. It logs sales and purchases in the same way as an
 * employee. The exceptions, as far as a customer is concerned, are that
 * money and items are implicitly given to the npc when a transaction is 
 * initiated.
 * </p>
 * <p>Probably the most 'intelligent' functions of the npc are to do with
 * money. Historically, the npc was limited to the lowest denomination and
 * was therefore limited by the amount of this coin in the customer's
 * possession, or the contents of the register. It also meant that a large
 * transaction could result in several hundred coins being exchanged.
 * </p>
 * <p>The npc now has the ability to take the appropriate coins from a
 * player during a sale, and to get the correct amount of money from the
 * register depending upon its contents. It will start with the highest
 * value coins and work downwards until it has the correct amount of money
 * to pay for the goods received. Unfortunately, the npc cannot yet handle
 * change, and will therefore return the goods to the customer if unable to
 * get the correct money from the register. 
 * </p>
 * <p>The npc will work between the hours specified by the creator, and can
 * also be sent home by an employee. The npc will also return home if
 * attacked. In this instance, the attacker will be banned from the shop
 * automatically, and fired if they are an employee. 
 * </p>
 * <p>The npc will conduct some standard tests on items before they are
 * bought from a customer. These are mainly basic stuff like checking the
 * item is stocked by the shop. Any custom rules (such as not buying
 * unpickled bits, uncharged magic wands, certain types of 'things') can
 * be specified by the creator. Obviously, this may have an impact on
 * code-maintenance if players change the list of stocked items regularly.
 * However, I haven't had to change these rules significantly in the last
 * year or so at Tarnach's. 
 * </p>
 * 
 * @example
 * #include "path.h"
 * 
 * inherit "/std/shops/player_shop/shopkeeper";
 * 
 * void setup()
 * {
 *    set_name( "betty" );
 *    set_short( "Miss Betty Scuttle" );
 *    basic_setup( "human" , "fighter" , 15 );
 *    set_gender( "female" );
 *    add_alias( ({ "scuttle", "betty scuttle", "miss betty scuttle" }) );
 *    set_long( "This is Miss Scuttle, an amiable middle-aged lady who "
 *      "helps out in the shop from time to time.\n" );
 *    set_office( PATH + "office" );
 *    set_dearie( ({ "love", "my dear", "dear", "honey" }) );
 *    set_work_hours( ({0,0,23,59,}) );
 * }
 * 
 * object *item_test( mixed * items )
 * {
 *    object *give_back_wand= ({}),
 *           *give_back_unpickled = ({});
 * 
 *    foreach( object ob in items )
 *    {
 *       if ( ob->query_magic_wand() && !ob->query_charges() )
 *       {
 *          give_back_wand += ({ ob });
 *       }
 *    }
 * 
 *    if ( sizeof( give_back_wand ) )
 *    {
 *       do_command( "'I'm sorry, we don't buy uncharged magic wands." );
 *    }
 * 
 *    foreach( object ob in items )
 *    {
 *       if ( ( ob->query_property( "corpse bit" )  &&  !ob->no_decay()  &&
 *          !ob->query_cured() ) || ob->query_decay_speed() )
 *       {
 *          give_back_unpickled += ({ ob });
 *       }
 *    }
 *    if ( sizeof( give_back_unpickled ) )
 *    {
 *       do_command( "'We can't accept unpickled items." );
 *    }
 *    return ( give_back_wand + give_back_unpickled );
 * }
 * 
 * @see /include/player_shop.h
 * @see /std/shops/player_shop/office.c
 * @see /std/shops/player_shop/mgr_office.c
 * @see /std/shops/player_shop/storeroom.c
 * @see /std/shops/player_shop/shop_front.c
 * @see /std/shops/player_shop/shopkeeper.c
 * @author Ringo
 * @started 1st August 1999
 */
inherit "/obj/monster";

#include <player_shop.h>
#include <money.h>
#include <living.h>
#include <move_failures.h>

#define set_busy(O) (_busy = O)
#define reset_busy() (_busy = 0)

#define NOT_EIGHT (({ "between seven and nine", \
                     "just over seven", \
                     "just under nine", \
                     "seven plus one", \
                     "nine minus one", \
                     "two times four", \
                  })[random(5)])

#define num_str(i) ((i == 8)?NOT_EIGHT:query_num(i))

#define DEARIE (", "+ _dearie[random(sizeof(_dearie)-1)])

private nosave object _busy = 0;

private nosave mixed _info = 0;

private nosave string _office = "",
_storeroom = "", 
_shop_front = "",
_counter = "",
_place = "",
_smallest_in,
_smallest_plural_in,
*_dearie = ({""});

private nosave int * _work_hrs = ({9,0,17,30,}),
_smallest_value_in,
_failed = 0;

private nosave mapping _values_sing = ([]),
_values_plural = ([]);

private void announce_number();
private void announce_price();
private void buy_something(object *);
private void check_money(mixed);
private void deposit_money();
int do_buy(string);
int do_browse(string);
int do_list(mixed  *);
int do_sell(object *);
private void end_shift();
private void get_from_store();
private void get_money();
private void get_more_stuff();
private void give_stuff();
private void how_many(string);
private void how_much(string);
private void look_chart();
private void look_how_much();
private void no_coins();
private int outside_hours(int);
private void put_in_store();
private int query_busy();
string query_office();
private void say_to_room(object, string, string);
private void sell_something(string);
protected object * item_test(object *);
protected void set_dearie(string *);
void set_failed(int);
protected void set_office(string);
protected void set_work_hours(int *);
void shuffle_to(string,function);
private int sort_keys(string, string, int);
void start_shift();
private void taken_over();
private void what_items();

/** @ignore yes */
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("determinate", "");
    add_property("unique", 1);
    add_property("run away", -1);
    add_alias("shopkeeper");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
}
/* create() */

/** @ignore yes */
private void announce_number()
{
    if (stringp(_info))
    {
        int number = _storeroom->query_num_items(_info);  

        if (!number) do_command("'I'm afraid we don't have any "+ _info +
              " in stock"+ DEARIE+ ".");
        else do_command("'You're in luck"+ DEARIE+ ".  We have "+
              num_str(number) + " in stock.");
    }
    reset_busy();
    _info = 0;
}
/* announce_number() */


/** @ignore yes */
private void announce_price()
{
    if (stringp(_info))
        do_command("'We sell "+ _info + " for "+
          num_str(_office->query_sell(_info))+ " "+ _smallest_plural_in+
          " each, and buy them for "+ num_str(_office->query_buy(_info))+
          " "+ _smallest_plural_in + " each.");
    reset_busy();
    _info = 0;
}
/* announce_price() */


/** @ignore yes */
void attack_by(object baddie)
{
    if (_office == "") return;
    this_object()->stop_fight(baddie);
    baddie->stop_fight(this_object());
    do_command("'Why are you attacking me, "+ baddie->query_cap_name()+ "?");
    do_command("'I'm not staying here for this!");
    do_command(_office->query_channel()+ "@ is being attacked by "+ 
      baddie->query_cap_name()+ ".");
    call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
    _office->event_death(this_object(), 0, baddie, 0, 0);
#ifdef DEBUG
    tell_creator(CREATOR,  "Attacked by %s.\n", baddie->query_short());
#endif
}
/* attack_by() */


/** @ignore yes */
private void buy_something(object *obs)
{
    int spare, number, amount = 0;
    object *give_back, cont = clone_object("/std/container");

    obs->move(cont);
    _info = ({});
    foreach(string item in _office->query_list_array())
    _info += ((class obj_match)match_objects_in_environments(item, cont))->objects;
    give_back = obs - _info;
    if (sizeof(give_back))
    {
        give_back->move(_busy);
        do_command("'I'm afraid I can't buy "+
          query_multiple_short(give_back)+ " from you"+ DEARIE+ ".");
    }
    if (number = sizeof(_info))
    {
        if (_info[0]->query_collective())
            number = _info[0]->query_amount();
    }
    if (number > (MAX_INVEN + query_dex()))
    {
        _info->move(_busy);
        do_command("'I'm sorry"+ DEARIE+ ", but I can only carry "+
          num_str(MAX_INVEN+ query_dex())+ " items.");
        cont->dest_me();
        reset_busy();
        return;
    }
    give_back = ({});
    give_back = filter(_info, (: ($1)->query_continuous() :));
    if (sizeof(give_back))
    {
        _info -= give_back;
        do_command("'I have nothing to carry "+
          query_multiple_short(give_back)+ " in.");
        give_back->move(_busy);
    }

    give_back = item_test(_info);
    if (sizeof(give_back))
    {
        give_back->move(_busy);
        _info -= give_back;
    }
    if (!(number = sizeof(_info)))
    {
        do_command("'You don't have anything to sell"+ DEARIE+ ".");
        cont->dest_me();
        reset_busy();
        return;
    }
    if (_info[0]->query_collective())
        number = _info[0]->query_amount();
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking stock.\n");
#endif
    spare = _office->query_max(pluralize(_info[0]->query_name())) -
    _office->query_stock(pluralize(_info[0]->query_name()));
    if (spare < 1)
        foreach(string alias in _info[0]->query_alias())
    {
        int check_spare;

        if((check_spare = _office->query_max(pluralize(alias)) -
            _office->query_stock(pluralize(alias))) > 0)
            spare = check_spare;
    }   
    if (spare < 1)
        spare = _office->query_max(pluralize(_info[0]->query_short())) -
        _office->query_stock(pluralize(_info[0]->query_short()));
    if (spare < 1)
    {
        do_command("'I'm afraid we don't need any of those"+ DEARIE+ ".");
        _info->move(_busy);
        cont->dest_me();
        reset_busy();
        return;
    }
    if (number > spare)
    {
        do_command("'I'm afraid we don't need that many"+ DEARIE+ 
          ", but I could take "+ num_str(spare)+ " from you.");
        _info->move(_busy);
        cont->dest_me();
        reset_busy();
        return;
    }

    /* Let's check if we can afford to buy this stuff... */
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking money.\n");
#endif
    foreach(string item in _office->query_list_array())
    {
obs = ((class obj_match)match_objects_in_environments(item, this_object()))->objects;
        if (number = sizeof(obs))
        {
            if (obs[0]->query_collective())
                number = obs[0]->query_amount();
            amount += _office->query_buy(item) * number;
        }
        if (_counter->query_register() < amount * _smallest_value_in)
        {
            do_command("'I'm afraid we don't have enough money to buy "+
              query_multiple_short(_info) + " from you" + DEARIE+ ".");
            _info->move(_busy);
            cont->dest_me();
            reset_busy();
            return;
        }
    }

    give_back = ({});
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking we can carry it.\n");
#endif
    if (sizeof(_info))
    {
        obs = _info;
        foreach(object thing in obs)
        if ((int)thing->move(this_object()) != MOVE_OK)
        {
#ifdef DEBUG
            tell_creator(CREATOR,  "Can't carry %O.\n", thing);
#endif            _info -= ({ thing });
            give_back += ({ thing });
        }
        tell_room(environment(this_object()), query_short()+
          " takes "+ query_multiple_short(_info) +".\n");
    }
    obs = all_inventory(cont) - give_back;
    if (sizeof(give_back))
    {
        do_command("'I cannot carry "+ query_multiple_short(give_back, "the")
          +DEARIE+".");
        give_back->move(_busy);
    }
    if (sizeof(obs))
    {
        do_command("'I'm afraid we can't buy "+
          query_multiple_short(obs, "the") +" from you"+ DEARIE+ ".");
        obs->move(_busy);
    }
    obs = all_inventory(cont);
    if (sizeof(obs)) obs->move(environment(_busy),
          "$N manage$s to get knocked onto the floor.");
    if (sizeof(_info))
    {
#ifdef DEBUG
        tell_creator(CREATOR,  "Buying: %O\n", _info);
#endif
        do_command("'I'll be right back.");
        call_out("shuffle_to", NPC_DELAY, _counter, (: get_money() :));
    }
    else reset_busy();
    cont->dest_me();
}
/* buy_something() */


/* Check have correct change */
private void check_money(mixed monies)
{
#ifdef DEBUG
    tell_creator(CREATOR, "Buying %d %s for %d each - total %d.\n", monies[1],
      monies[2], monies[3], monies[0] );
#endif
    if (monies[0] > query_value_in(_place))
    {
#ifdef DEBUG
        tell_creator(CREATOR, "No correct change (%d).\n", query_value_in(_place));
#endif  
        do_command("put coins in register");
        call_out("shuffle_to", NPC_DELAY, _shop_front, (: no_coins() :));
        return;
    }
    do_command("log shop bought "+ monies[1] +" "+ monies[2] +
      " for "+ (monies[3] * monies[1]));
#ifdef DEBUG
    tell_creator(CREATOR, "Total: %d   My value: %d\n", monies[0],
      query_value_in( _place ) );
#endif
    call_out("shuffle_to", NPC_DELAY, _storeroom, (: put_in_store() :));
}
/* check_money() */


/** @ignore yes */
private void deposit_money()
{
    if (pointerp(_info))
    {
        do_command("log shop sold "+ _info[1]+ " "+ _info[0]+ " for "+
          _info[2]);
        do_command("put coins in register");
    }
    call_out("shuffle_to", NPC_DELAY, _storeroom, (: get_from_store() :));
}
/* deposit_money() */


/** @ignore yes */
int do_buy(string stuff)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_buy()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "say", "I would like to buy "+ stuff + 
      ", please.\n%^RESET%^");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: sell_something($(stuff)) :), NPC_DELAY);
    }
    return 1;
}
/* do_buy() */


/** @ignore yes */
int do_browse(string item)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_browse()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "ask", "How much do "+ item +" cost?\n");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: how_much($(item)) :), NPC_DELAY);
    }
    return 1;
}
/* do_browse() */


/** @ignore yes */
int do_list(mixed *args)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_list()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    if (!sizeof(args) || !args[0] || args[0] == "")
    {
        say_to_room( this_player(), "ask", "What items do you buy and sell?\n");
        if (query_busy())
            init_command(":seems busy at the moment.", NPC_DELAY);
        else
        {
            set_busy(this_player());
            call_out((: what_items() :), NPC_DELAY);
        }
        return 1;
    }
    say_to_room(this_player(), "ask", "How many "+ args[0]+ " do you have?\n");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: how_many($(args[0])) :), NPC_DELAY);
    }
    return 1;
}
/* do_list() */


/** @ignore yes */
int do_sell(object *obs)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_sell()\n" );
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "say", "I would like to sell " +
      query_multiple_short(obs, "the")+ ", please.\n%^RESET%^");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: buy_something($(obs)) :), NPC_DELAY);
    }
    return 1;
}
/* do_sell() */


/** @ignore yes */
private void end_shift()
{
    if (environment() != find_object("/room/rubbish"))
        do_command(_office->query_channel()+ "@ is clocking out.");
    do_command("clock out");
    move("/room/rubbish", "$N make$s some tea.", "$N go$s home for tea.");
}
/* end_shift() */


/** @ignore yes */
void event_person_say(object thing, string start, string mess, string lang)
{
    string words;

#ifdef DEBUG
    tell_creator(CREATOR,  "In event_person_say()\n" );
#endif
    if (outside_hours(TRUE)) return;
    if (!mess || (mess == "")) return;
    mess = lower_case(mess);
    if (query_busy()) return;
    set_busy(thing);
    if (sscanf(mess, "%*s buy %s, please.", words) == 2)
    {
        call_out((: sell_something($(words)) :), NPC_DELAY);
        return;
    }
    if (sscanf(mess, "%*show many %s", words) == 2)
    {
        call_out((: how_many($(words)) :), NPC_DELAY);
        return;
    }
    if (sscanf(mess, "%*show much %s", words) == 2)
    {
        call_out((: how_much($(words)) :), NPC_DELAY);
        return;
    }
    if (( sscanf( mess, "%*s take over%*s") == 2) &&
      (_office->query_employee(thing->query_name()) ||
        thing->query_name() == CREATOR))
    {
        call_out((: taken_over() :), NPC_DELAY);
        return;
    }
    reset_busy();
    ::event_person_say(thing, start, mess, lang);
}
/* event_person_say() */


/** @ignore yes */
private void get_from_store()
{
    if (pointerp(_info))
    {
        int number, bag_item_weight, info1 = to_int(_info[1]);
        object *inven;

        _failed = 0;
        if (info1 > (MAX_INVEN + query_dex())) number = MAX_INVEN + query_dex();
        else number = info1;
#ifdef DEBUG
        tell_creator(CREATOR, "Removing %d %s\n", number, _info[0]);
#endif
        inven = all_inventory();
        do_command("remove " + number+ " "+ _info[0]);
        if (_failed)
        {
            do_command("add "+ _failed+ " "+ _info[0]);
            do_command("get "+ _info[0]);
        }
        inven = all_inventory() - inven;
        number -= _failed;
        info1 -= number;

        foreach(object thing in inven)
        if (thing->query_weight() < MAX_BAG_WEIGHT/5)
            bag_item_weight += thing->query_weight();
        bag_item_weight = (MAX_BAG_WEIGHT+bag_item_weight-1)/MAX_BAG_WEIGHT;
        if ( number > 9 )
        {
            number = (((number+9)/10) > bag_item_weight)?
            (number+9)/10:bag_item_weight;
            for(int i=0; i < number; i++) do_command("pull roll");
            for(int i=0; i < number; i++)
                do_command("put "+ _info[0]+ " in bag "+ (i+1));
        }

        if (info1)
        {
            _info[1] = sprintf("%d",info1);
            call_out("shuffle_to", NPC_DELAY, _shop_front,
              (: get_more_stuff() :));
            return;
        }
    }
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: give_stuff() :));
}
/* get_from_store() */


/** @ignore yes */
private void get_money()
{   
    if (pointerp(_info))
    {
        int total;
        mixed monies = ({0,0,0,0,});
        string *sort_keys_sing = sort_array(keys(_values_sing),
          (: sort_keys($1,$2,1) :));
        string *sort_keys_plural = sort_array(keys(_values_plural),
          (: sort_keys($1,$2,0) :));

#ifdef DEBUG
        tell_creator(CREATOR, "Singular: %O\n", sort_keys_sing);
        tell_creator(CREATOR, "Plural: %O\n", sort_keys_plural);
#endif
        foreach(string item in _office->query_list_array())
        {
            object *things = ((class obj_match)match_objects_in_environments(item,
              this_object()))->objects;
#ifdef DEBUG
            tell_creator(CREATOR, "We have %d %s\n", sizeof(things), item);
#endif
            if (monies[1] = sizeof(things))
            {
                if (things[0]->query_collective())
                    monies[1] = things[0]->query_amount();
                monies[3] = _office->query_buy(item);
                do_command( "'"+ capitalize(item) +" are worth "+
                  num_str(monies[3]) +" "+ _smallest_plural_in +
                  " each, and I have "+ num_str(monies[1]) + ".");
                monies[0] += monies[3] * monies[1];
                monies[2] = item;
                break;
            }
        }
        monies[0] *= _smallest_value_in;
        total = monies[0];

        for (int i=0; i < sizeof(sort_keys_sing); i++)
        {
            if (total < _values_sing[sort_keys_sing[i]]) continue;
            for (int c = total / _values_sing[sort_keys_sing[i]]; c > 0; c--)
            {
                string coins = sprintf("%d %s", c,
                  (c == 1)?sort_keys_sing[i]:sort_keys_plural[i]);
#ifdef DEBUG
                tell_creator(CREATOR, "Trying to get %s\n", coins);
#endif
                do_command("get "+ coins+ " from register");
                if (sizeof(match_objects_for_existence(coins, this_object())))
                {
                    total -= (c * _values_sing[sort_keys_sing[i]]);
#ifdef DEBUG
                    tell_creator(CREATOR, "New total: %d\n", total);
#endif
                    break;
                }
            }
        }
#ifdef DEBUG
        tell_creator(CREATOR, "Buying %d %s for %d each.\n", monies[1],
          monies[2], monies[3]);
#endif
        call_out((: check_money($(monies)) :), 1);
    }
    else
        call_out("shuffle_to", NPC_DELAY, _storeroom, (: put_in_store() :));
}
/* get_money() */


/** @ignore yes */
private void get_more_stuff()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("drop all");
        do_command("'I still need to get you "+ num_str(to_int(_info[1]))+ " "+
          _info[0]+ DEARIE+ ".  I won't be long.");
        call_out( "shuffle_to", NPC_DELAY, _storeroom,
          (: get_from_store() :) );
        return;
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
/* get_more_stuff() */


/** @ignore yes */
private void give_stuff()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("'Thank you for your custom" + DEARIE+ ".");
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
/* give_stuff() */


/** @ignore yes */
private void how_many(string item)
{   
    _info = 0;
    foreach (string thing in _office->query_list_array())
    if (sscanf(item, "%*s"+ thing +"%*s") == 2) _info = item;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those" + DEARIE+ ".");
        reset_busy();
        return;
    }
    do_command("'"+ capitalize( _info ) +"?  I'll just go and see.");
    call_out("shuffle_to", NPC_DELAY, _office, (: look_chart() :));
}
/* how_many() */


/** @ignore yes */
private void how_much(string item)
{   
    _info = 0;
    foreach (string thing in _office->query_list_array())
    if (sscanf(item, "%*s"+ thing +"%*s") == 2) _info = thing;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those"+ DEARIE+ ".");
        reset_busy();
        return;
    }
    do_command("'"+ capitalize( _info ) +"?  I'll just go and see.");
    call_out("shuffle_to", NPC_DELAY, _office, (: look_how_much() :));
}
/* how_much() */


/** @ignore yes */
void init()
{
    object tp = this_player();

#ifdef DEBUG
    tell_creator(CREATOR,  "In init()\n" );
#endif
    if (environment(this_object()) == find_object("/room/rubbish")) return;
#ifdef DEBUG
    tell_creator(CREATOR,  "Not in /room/rubbish\n");
#endif
    ::init();
    tp->add_command("buy", this_object(), "<string'item(s)'>",
      (: do_buy($4[0]) :));
    tp->add_command("sell", this_object(), "<indirect:object:me>",
      (: do_sell($1) :));
    tp->add_command("list", this_object(), ({"", "<string'item(s)'>"}),
      (: do_list($4) :));
    tp->add_command("browse", this_object(), "<string'item(s)'>",
      (: do_browse($4[0]) :));
    outside_hours(TRUE);
}
/* init() */


/** @ignore yes */
private void look_chart()
{
    if (stringp(_info)) do_command("'Now, let me see, "+ _info +"...");
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: announce_number() :));
}
/* look_chart() */


/** @ignore yes */
private void look_how_much()
{
    if (stringp(_info)) do_command("'Now, let me see, "+ _info +"...");
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: announce_price() :));
}
/* look_how_much() */


/** @ignore yes */
private void no_coins()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("'I'm sorry" + DEARIE+ ".  I don't have the correct "
          "change to give you.  Please call again later.");
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
/* no_coins() */


/** @ignore yes */
private int outside_hours(int working)
{
    int hrs, mins;
    string am_pm;

    if (query_busy()) 
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Outside working hours but already busy.  "
          "Continuing.\n");
#endif
        return FALSE;
    }
    if (sscanf(amtime(time()), "%d:%d%s,%*s", hrs, mins, am_pm) == 4)
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Time is %02d:%02d%s.\n", hrs, mins, am_pm);
#endif
        if (am_pm == "am")
        {
            if (hrs == 12) hrs = 0;
        }
        else
        if (hrs != 12) hrs += 12;
#ifdef DEBUG
        tell_creator(CREATOR, "Which is %02d:%02d.\n", hrs, mins);
#endif
        if ((hrs < _work_hrs[0] ||
            (hrs == _work_hrs[0] && mins < _work_hrs[1])) ||
          (hrs > _work_hrs[2] ||
            (hrs == _work_hrs[2] && mins > _work_hrs[3])))
        {
            if (!working)
            {
#ifdef DEBUG
                tell_creator(CREATOR, "Outside working hours & not "
                  "working.  Sending to /room/rubbish.\n");
#endif
                move("/room/rubbish");
                return TRUE;
            }
#ifdef DEBUG
            tell_creator(CREATOR, "Outside working hours & working.  "
              "Sending home now.\n");
#endif
            call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
            return TRUE;
        }
    }
    return FALSE;
}
/* outside_hours() */


/** @ignore yes */
private void put_in_store()
{
    if (pointerp(_info)) do_command("add all");
    do_command("drop all");
    foreach (string value in keys(_values_sing))
    do_command("get every "+ value);
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: give_stuff() :));
}
/* put_in_store() */


/** @ignore yes */
private int query_busy()
{
    if (!objectp(_busy) || !interactive(_busy) || _busy->query_invis())
        return 0;
    if (environment(_busy) != find_object(_shop_front)) return 0;
    return (_busy != 0);
}
/* query_busy() */


/**
 * Query the path to the office.
 * @return The path to the office.
 */
string query_office() { return copy(_office); }


/** @ignore yes */
private void say_to_room(object me, string t, string message)
{
    tell_object(me, "You "+ t+ ": "+ message);
    foreach(object player in all_inventory(environment(this_object())))
    if (interactive(player) && player != me)
        tell_object(player, player->colour_event("say", "%^CYAN%^")+
          me->query_short()+ " "+ t + "s: "+ message);
}
/* say_to_room() */


/** @ignore yes */
private void sell_something(string items)
{
    int each, number, in_stock;
    mixed *money_array;

    _info = 0;
    foreach (string item in _office->query_list_array())
    if (sscanf(items, "%*s"+ item +"%*s") == 2) _info = item;
    else if (sscanf(pluralize(items), "%*s"+ item +"%*s") == 2)
        _info = item;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those"+ DEARIE+ ".");
        reset_busy();
        return;
    }
    if (sscanf(items, "%*s%d "+ _info +"%*s", number) != 3) number = 1;
#ifdef DEBUG
    tell_creator(CREATOR, "Customer asked for %d %s.\n", number, _info);
#endif
    if (number > (in_stock = _storeroom->query_num_items(_info)))
    {
        if (!in_stock)
        {
            do_command("'I'm afraid we don't have any "+ _info+ " in stock"+
              DEARIE+ ".");
            reset_busy();
            return;
        }
        do_command("'I'm afraid we don't have that many "+ _info +
          " in stock, but I can sell you "+ num_str(in_stock)+ ".");
        reset_busy();
        return;
    }

    if (number < 1)
    {
        do_command("'My, my.  You are amusing aren't you" + DEARIE+ "?");
        do_command("peer "+ _busy->query_name());
        reset_busy();
        return;
    }
    each = _office->query_sell(_info);
    do_command( "'"+ capitalize(_info) +" are worth "+
      num_str(each) +" "+ _smallest_plural_in + " each, and you want "+ 
      num_str(number) + ".");
    each *= number;
    if (_busy->query_value_in(_place) < (each * _smallest_value_in))
    {
        do_command("'I'm afraid you don't have enough money" + DEARIE+ ".");
        reset_busy();
        return;
    }
    money_array = MONEY_HAND->create_money_array(each * _smallest_value_in,
      _place);
    _busy->pay_money(money_array, _place);
    adjust_money(money_array);
#ifdef DEBUG
    tell_creator(CREATOR, "Monies adjusted by %O.\n", money_array);
#endif
    tell_room( environment( this_object() ), query_short()+ 
      " takes the money.\n" );
    do_command("'I'll be right back"+ DEARIE+ ".");
    _info = ({ _info, sprintf("%d", number), sprintf("%d", each) });
#ifdef DEBUG
    tell_creator(CREATOR,  "Selling: %O\n", _info);
#endif
    call_out("shuffle_to", NPC_DELAY, _counter, (: deposit_money() :));
}
/* sell_something() */


/**
 * Test items before buying.
 * This function adds more shop-specific checks to see if we should buy
 * something not covered by the standard checks.
 * The function should take a parameter of an mixed array, being the objects
 * the customer is trying to sell.  It should return an array of the objects
 * we are not buying.  Any response by the npc should be handled within the
 * function.  All other processing will be handled by the inheritable.
 * If you need such processing, create this function within your own
 * object.
 * 
 * @example object *item_test( mixed * items )
 * {
 *    object *give_back = ({});
 * 
 *    foreach( object ob in items )
 *    {
 *       if ( ( ob->query_property( "corpse bit" )  &&  !ob->no_decay()  &&
 *         !ob->query_cured() ) || ob->query_decay_speed() )
 *       {
 *          give_back += ({ ob });
 *       }
 *    }
 *    if ( sizeof( give_back ) )
 *    {
 *       do_command( "'We can't accept unpickled items, my dear." );
 *    }
 * 
 *    return ( give_back );
 * }
 *
 * @param items The objects to test
 * @return object The objects to give back to the customer
 */
protected object * item_test(mixed * items) { return ({}); }


/**
 * Set the pleasantries to be used by this npc, i.e.
 * @example set_dearie( ({ "dearie", "my dear", ... }) );
 * @param dearie An array of strings to be used
 */
protected void set_dearie(string *dearie) { _dearie = dearie; }

/** @ignore yes */
void set_failed(int failed) { _failed = failed; }


/**
 * Set the path of the main office.
 * @param path The full path & filename.
 */
protected void set_office(string path)
{
    mapping values;
    string new_key;

    _office = path;
    _place = _office->query_place();
    _smallest_in = MONEY_HAND->smallest_in( _place );
    _smallest_value_in = MONEY_HAND->smallest_value_in(_place);
    _smallest_plural_in = MONEY_HAND->query_plural_for(_smallest_in);
    values = MONEY_HAND->query_mapped_values_in(_place);
    foreach(string key in keys(values))
    {
        new_key = MONEY_HAND->query_aliases_for(key)[0];
        _values_sing += ([new_key:values[key]]);
    new_key = MONEY_HAND->query_details_for(key)[5];
    _values_plural += ([new_key:values[key]]);
}
#ifdef DEBUG
tell_creator(CREATOR, "Singular values: %O.\n", _values_sing);
tell_creator(CREATOR, "Plural values: %O.\n", _values_plural);
#endif
_storeroom = _office->query_storeroom();
_counter = _office->query_counter();
_shop_front = _office->query_shop_front();
add_respond_to_with(({ "@say", "hello" }), "'Hello, $hcname$.  What can I do for you?");
add_respond_to_with(({ "@smile", query_name() }), "smile at $hname$");
}
/* set_office() */


/**
* Set the working hours for this shopkeeper.
* Will set the hours that this shopkeeper will work.  This is an array
* of the format ({start_hour,start_min,end_hour,end_min})
* @param hours an array as above
*/
protected void set_work_hours(int *hours) { _work_hrs = hours; }


/** @ignore yes */
void shuffle_to(string location, function next_action)
{
    string direc = environment()->directions_to(location);

    if (!direc)
    {
        if (environment() == find_object("/room/rubbish")) return;
        if (environment() == _shop_front->query_outside())
        {
            move(_shop_front, "$N enter$s the shop.",
              "$N enter$s _shop_front->query_short().");
        }
        else
        {
            do_command("'I seem to be lost...");
            do_command("sob");
            move(_office, "$N runs in, sobbing.", "$N leave$s, sobbing.");
            end_shift();
            return;
        }
        call_out("shuffle_to", NPC_DELAY, location, next_action);
        return;
    }
    if (direc == "here")
    {
        do_command("smile brightly");
        do_command("'Here we are.");
        if (next_action) call_out(next_action, NPC_DELAY);
        else reset_busy();
        return;
    }
    do_command(direc);
    call_out("shuffle_to", NPC_DELAY, location, next_action);
}
/* shuffle_to() */


/** @ignore yes */
private int sort_keys(string s1, string s2, int sing)
{
    if (sing) return (_values_sing[s1] < _values_sing[s2])?1:-1;
    else return (_values_plural[s1] < _values_plural[s2])?1:-1;
}
/* sort_keys() */


/** @ignore yes */
void start_shift()
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In start_shift()\n" );
#endif
    if (outside_hours(FALSE)) return;
    set_busy(this_object());
    move(_office, "$N arrive$s for " + query_possessive()+ " shift.");
    if (_office->query_employee(query_name()) & CLOCKED_IN)
        do_command("clock out");
    do_command("claim badge");
    do_command("wear badge");
    do_command("clock in");
    do_command(_office->query_channel()+ "@ is clocking in.");
    call_out("shuffle_to", NPC_DELAY, _shop_front, 0);
}
/* start_shift() */


/** @ignore yes */
private void taken_over()
{
    do_command("'Okay then" + DEARIE+ ".  See you later.");
    set_busy(this_object());
    call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
}
/* taken_over() */


/** @ignore yes */
private void what_items()
{
    do_command("'Well" + DEARIE+ ", we trade in "+
      _office->query_list_string()+ ".");
    reset_busy();
}
/* what_items() */
// --- END [/mnt/home2/grok/lib/std/shops/player_shop/shopkeeper.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/shops/engrave_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/shops/engrave_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629594   Available: 13576948
Inodes: Total: 5242880    Free: 4960136
6751 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/shops/engrave_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629594   Available: 13576948
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a small inheritable to allow places to do engraving.  POut a
 * piece of code inthe init function which calls the engrave_init()
 * function.
 * @example
 * inherit "/std/room/basic_room";
 * inherit "/std/shops/engrave";
 *
 * void init() {
 *    basic_room::init();
 *    engrave_init();
 * } /\* init() *\/
 * @author Macchirton
 * @change 17th of May 1998 Pinkfish
 * Turned into an inheritable mbase and reworked to make work with add_command
 * correctly.
 *
 * Added set_engrave_language(string str) to solve the problem with 
 * "common" engravings  
 * - Danbala, Sept 2002
 */

#include <money.h>
#include <shops/engrave.h>

void set_engrave_language(string str);
protected int do_engrave( object *things, string message);
mixed query_property(string name);

private string _lingo = "general";

//private object shop_keeper;
//private int check_shop_keeper;

void create() {
   this_object()->add_help_file("engrave");
} /* create() */

/**
 * Sets the shop keeper for the engraving shop.  If the shop keeper is
 * not set then it will not be checked for.  If it is checked it will be
 * checked for the existance of.
 * @param ob the shop keeper to test for
 * @see query_engrave_shopkeeper()
 */
//void set_engrave_shopkeeper(object ob) {
//   check_shop_keeper = 1;
//   shop_keeper = ob;
//} /* set_engrave_shopkeeper() */

/**
 * This method returns the currently ste shop keeper for the engraving shop.
 * @return the shop keeper
 * @see set_engrave_shopkeeper()
 */
//object query_engrave_shopkeeper() {
//   return shop_keeper;
//} /*  query_engrave_shopkeeper() */

/**
 * This method should be called in the inheriting room's init function.  IUt
 * will setup the commands to allow the object to be engraved.
 * @see do_engrave()
 */
void engrave_init() {
   add_command( "engrave", "<string> on <indirect:object>",
                (: do_engrave($1, $4[0]) :));
} /* init() */

/**
 * This method is called when a living object is attempted to be engraved.
 * This should be overridden in the inheritable to print out the
 * message you wish to say.  If this function returns 1 then the
 * default failed message is not used.
 * @param liv the living objects
 * @return 0 use default fail mesasage, 1 override default fail message
 * @see do_engrave()
 */
protected int engrave_living(object *obs) {
   return 0;
} /* engrave_living() */

/**
 * This method is called if the objects in question are unable to be
 * engraved.
 * This should be overridden in the inheritable to print out the
 * message you wish to say.  If this function returns 1 then the
 * default failed message is not used.
 * @param obs the objects which could not be engraved.
 * @return 0 use default fail mesasage, 1 override default fail message
 * @see do_engrave()
 */
protected int engrave_wrong_items(object *obs) {
   return 0;
} /* engrave_wrong_items() */

/**
 * This method is called if the player does not have enough money to
 * complete the engraving.
 * This should be overridden in the inheritable to print out the
 * message you wish to say.  If this function returns 1 then the
 * default failed message is not used.
 * @param obs the objects which were unable to be engraved
 * @param cost the cost of the objects to be engraved
 * @return 0 use default fail mesasage, 1 override default fail message
 * @see do_engrave()
 */
protected int engrave_no_money(object *obs, int cost) {
   return 0;
} /* engrave_no_money() */

/**
 * This method is called when the engrave is successful.
 * This should be overridden in the inheritable to print out the
 * message you wish to say.  If this function returns 1 then the
 * default failed message is not used.
 * @see do_engrave()
 */
int engrave_objects(object *obs, int cost) {
   return 0;
} /* engrave_objects() */

/**
 * This method does the actual engraving.
 * @param things the things to get engraved.
 * @param message the message to engarve on the objects
 * @see engrave_init()
 */
protected int do_engrave( object *things, string message) {
   int cost;
   string coststring;
   string place;
   object *liv;
   object *engravable;

//   if ( check_shop_keeper && !shop_keeper){
//      add_failed_mess("There is noone here to engrave $I for you.\n", things);
//      return 0;
//   }

   liv = filter(things, (: living($1) :));
   if (sizeof(liv) && !engrave_living(liv)) {
      add_failed_mess("Cannot engrave messages on $I, they are living things.\n", liv);
   }
   things -= liv;
   if (!sizeof(things)) {
      return 0;
   }

   // Holy blade of soyin does weird things.
   engravable = filter(things,
                       (: ($1->query_property( "shop type" ) == "jewellers" ||
                         $1->query_property( ENGRAVE_PROP ) == 1 ||
                           $1->query_property( "shop type" ) == "armoury") &&
                          $1->query_short() != "holy blade of Soyin" :) );
   if (!sizeof(engravable)) {
      if (!engrave_wrong_items(things - engravable)) {
         add_failed_mess("Cannot engrave messages on $I.\n",
                         things - engravable);
      }
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   coststring = replace_string(message, " ", "");
   cost = (strlen(coststring) * 80) * sizeof(engravable);
   /*a dollar for 5 letters */
   if ( (int) this_player()->query_value_in( place ) < cost ) {
      if (!engrave_no_money(engravable, cost)) {
         add_failed_mess("Not enough money to engrave $I, you need " +
                         MONEY_HAND->money_value_string(cost, place) + ".\n",
                         engravable);
      }
      return 0;
   }
   if ( engrave_objects( engravable, cost ) ) {
      this_player()->pay_money( ( mixed *)MONEY_HAND->create_money_array( cost, 
                                place ), place );

      add_succeeded_mess( ({ "You have the message \"" + message + 
                            "\" engraved into $I for " +
                            MONEY_HAND->money_value_string(cost, place)
                            + ".\n", "$N gets $I engraved with a message.\n" }),
                            engravable);
      engravable->add_read_mess( message,
                 "neatly engraved letters", _lingo, 1);   
      return 1;
   }
   else return 0;

} /* do_engrave() */
/**
 * Init
 * Made compatable with the axiom Arghrgh is Arghrgh.
 * Also made OO complient.
 * Terano.
 */
void init() {
  engrave_init();
}

/**
 * This method sets which language (for example, "agatean", or
 * "morporkian") to be used when engraving.  It defaults to "general",
 * which is not to be recommended. 
 * @see do_engrave()
 */
void set_engrave_language(string lang) {
  _lingo = lang;
} /* set_language() */
// --- END [/mnt/home2/grok/lib/std/shops/engrave_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/linker.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/linker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629592   Available: 13576946
Inodes: Total: 5242880    Free: 4960136
6440 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/linker.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629592   Available: 13576946
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: linker.c,v 1.3 2003/01/30 06:15:10 pinkfish Exp $
 *
 *
 */

#include <room.h>

nosave int av_flag, ad_flag, rm_flag;

string d_prep, s_prep, r_name, *rooms;

object room;

void setup_shadow(object thing, string *words, string word1, 
  string word2, string word3) {
  shadow(thing, 1);
  room = thing;
  rooms = words;
  if(!word1) {
    d_prep = "into";
  } else {
    d_prep = word1;
  }
  if(!word2) {
    s_prep = "in";
  } else {
    s_prep = word2;
  }
  r_name = word3;
} /* setup_shadow() */

void destruct_shadow(object thing) {
  if(thing == this_object()) {
    destruct(this_object());
  } else {
    thing->destruct_shadow(thing);
  }
} /* destruct_shadow() */

string *query_rooms() {
  return rooms;
} /* query_rooms() */

string query_dynamic_preposition() {
  return d_prep;
} /* query_dynamic_preposition() */

string query_static_preposition() {
  return s_prep;
} /* query_static_preposition() */

string query_room_name() {
  return r_name;
} /* query_room_name() */

string area_name() {
  string *bits;
  if(r_name) {
    return r_name;
  }
  bits = explode((string)room->query_short(), " of ");
  if(sizeof(bits) > 1) {
    return bits[ sizeof( bits ) - 1];
  }
  return "the area";
} /* area_name() */

string compose_start() {
  if(s_prep == "") {
    return capitalize((string)room->the_short());
  }
  return capitalize(s_prep)+" "+(string)room->the_short();
} /* compose_start() */

void event_person_say( object person, string start, string rest,
      string language, string accent ) {
   int i;
   if ( start[ 0 .. 3 ] == "the " )
      start = explode( (string)person->a_short(), " " )[ 0 ] +
            start[ 3 .. strlen( start ) - 1 ];
   for ( i = 0; i < sizeof( rooms ); i++ )
      if ( find_object( rooms[ i ] ) )
         all_inventory( find_object( rooms[ i ] ) )->event_person_say( person,
                compose_start() +", "+ start, rest, language, accent );
    room->event_person_say( person, start, rest, language, accent );
} /* event_person_say() */

private string conjugate_verbs(string mess) {
  string *words, verb, part;
  int i;
  
  if(strsrch(mess, "$s") == -1)
    return mess;
  
  words = explode( mess, " " );
  for ( i = sizeof( words ) - 1; i > -1; i-- ) {
    /*
     * If $s ends a word, it represents verb conjugation.
     * The test of the following letter is to check that it does end the
     * word.
     */
    if ( ( sscanf( words[ i ], "%s$s%s", verb, part ) == 2 ) &&
         ( ( part[ 0 ] < 97 ) || ( part[ 0 ] > 122 ) ) ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
    /*
     * If we have %<verb>%, it represents verb conjugation.
     * This is unlikely to get confused with anything else...
     */
    if ( sscanf( words[ i ], "%%%s%%%s", verb, part ) == 3 ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
  }
  return implode( words, " " );
}

void event_exit(object person, string message, object to) {
  int ad_flag, rm_flag, i;
  string arrive, direc, *exits, link_mess, *link_array;
  
  room->event_exit(person, message, to);
  if(!message) {
    return;
  }
  arrive = "";
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(to == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(arrayp(room->query_dest_other())) {
    if(member_array(direc, room->query_dest_other()) != -1) {
      i = member_array(direc, room->query_dest_other());
      link_array = room->query_dest_other()[i + 1][11];
    }
  }
  if(arrayp(link_array)) {
    link_mess = link_array[0];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));

    link_mess = conjugate_verbs(link_mess);
  }
    
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      if(to != find_object(rooms[i])) {
        tell_room(find_object(rooms[i]), link_mess);
      }
    }
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to == find_object(rooms[i])) {
      arrive = (string)to->query_dynamic_preposition()+" "+
        (string)to->the_short();
      rm_flag = 1;
    }
  }
  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ "+direc;
    message += " "+arrive;
    if(rm_flag) {
      message += ".\n";
    } else {
      message += "and $V$0=leaves,leave$V$ "+ area_name() +".\n";
    }
  } else {
    message = (string)person->a_short() +" $V$0=teleports,teleport$V$";
    if(rm_flag) {
      message += " "+ arrive +".\n";
    } else {
      message += " out of "+area_name()+".\n";
    }
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to != find_object(rooms[i])) {
      tell_room(find_object(rooms[i]), message);
    }
  }
} /* event_exit() */

void event_enter( object person, string message, object from ) {
  int ad_flag, rm_flag, i;
  string direc, *exits, link_mess, *link_array;
  room->event_enter(person, message, from);
  if(!message || !from) {
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(from == find_object(rooms[i])) {
      rm_flag = 1;
    }
  }
  if(rm_flag) {
    return;
  }
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(from == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(member_array(direc, room->query_dest_other()) != -1) {
    i = member_array(direc, room->query_dest_other());
    link_array = room->query_dest_other()[i + 1][11];
  }
  if(arrayp(link_array)) {
    link_mess = link_array[1];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));
    link_mess = conjugate_verbs(link_mess);
  }
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      tell_room(find_object(rooms[i]), link_mess);
    }
    return;
  }

  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ into "+
      area_name()+" from the "+direc+".\n";
  } else {
    message = (string)person->a_short()+
      " $V$0=teleports,teleport$V$ into "+area_name() +".\n";
  }
  for(i = 0; i < sizeof(rooms); i++) {
    tell_room(find_object(rooms[i] ), message);
  }
} /* event_enter() */

int query_linked() { return 1; }


// --- END [/mnt/home2/grok/lib/std/room/basic/linker.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/topography/fixed_shadow.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/topography/fixed_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629591   Available: 13576945
Inodes: Total: 5242880    Free: 4960136
5764 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/topography/fixed_shadow.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629591   Available: 13576945
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: fixed_shadow.c,v 1.2 2002/12/17 05:03:28 rhinehold Exp $
 *
 *
 */

/*
** fixed_shadow.c - shadow for fixed rooms in topographies, so the rooms
**                  can find area rooms and such.
**/
/**
 * This is a shadow that gets attached to "normal" (ie, fixed) rooms that
 * used in a region controlled by a topography handler.  It masks
 * query_dest_other() so that exits from the room get handled correctly.
 * It also adds certain other functions used by the topography system.
 * This allows a fixed room to be converted for use in a topography with
 * minimal changes.
 * @author Jeremy
 * @see topography
 */

#include <dirs.h>
#include <room.h>

string topo_handler;
object fixed_room;
mapping topo_barriers = ([ ]);

mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);

/**
 * This method is deprecated.  Use set_topo_handler().
 */
void set_area_handler(string s) { topo_handler = s; }

/**
 * This method sets the topography handler for this fixed room.
 * @param s pathname of topography handler
 * @see topography
 * @see query_topo_handler()
 */
void set_topo_handler(string s) { topo_handler = s; }

/**
 * @ignore
 */
string query_area_handler() { return topo_handler; }

/**
 * This method returns the topography handler set for this fixed room.
 * @return the topography handler
 * @see set_topo_handler()
 */
string query_topo_handler() { return topo_handler; }

/**
 * This method adds directions from which the room cannot be reached.
 * The parameter is a mapping, giving the direction as the key and a
 * message to be printed upon failure as the value.<p>
 * NOTE: the direction is the direction the person is going (ie, the
 * command given); e.g., to block access from the west, use "east" as the
 * key.
 * @param m a mapping representing the direction(s) from which to block
 * access (the key) and a message to be printed (the value).
 * @see query_topo_barriers()
 * @see query_topo_barrier()
 */
void add_topo_barriers(mapping m) { topo_barriers += m; }

/**
 * This method returns the current mapping of barriers.
 * @return the current mapping of barred directions and messages.
 * @see add_topo_barriers()
 * @see query_topo_barrier()
 */
mapping query_topo_barriers() { return topo_barriers; }

/**
 * This method returns the message associated with the given barred
 * direction.
 * @param direc the direction to be queried
 * @return the failure message associated with the given direction
 * @see add_topo_barriers()
 * @see query_topo_barriers()
 */
mixed query_topo_barrier(string direc) { return topo_barriers[direc]; }

/**
 * This method can be used to determine if this is a fixed room.
 * @return 1
 */
int query_fixed_room() { return 1; }

/**
 * This method masks the standard query_dest_other() function.  It calls
 * the topology handler to find the connecting room (which is usually
 * cloned on-the-fly).
 * @param direc room exit name
 * @return structure describing the exit
 * @see /std/room
 */
// This gives us time to clone the connecting room before the player
// moves into it.
varargs mixed *query_dest_other( string direc ) {
  object room;
  mixed ret;

  //tell_creator("jeremy", "%O:query_dest_other(%s)\n", this_object(), direc);
  if (!stringp(direc)) {
    return fixed_room->query_dest_other(direc);
  }
  ret = fixed_room->query_dest_other(direc);
  if (!sizeof(ret)) {
    return 0;
  }
  if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
  (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
    room = (topo_handler)->find_room_at_exit(this_object(),
                           dirs[direc], direc);
    if (!objectp(room)) {
      return 0;
    }
    ret[ROOM_DEST] = file_name(room);
  }
  return ret;
} /* query_dest_other() */

/**
 * @ignore
 */
void attach(object ob) {
  shadow(ob);
  fixed_room = ob;
} /* attach() */


/**
 * This method adds exits for the room if they don't already exist.
 * "compass4" and "compass8" can be specified as exit names to add
 * exits for all of the normal 4 or 8 compass directions, respectively.
 * @param e array of exit names
 * @param type type of exit ("path", "road", etc)
 */
// A dummy exit name of "/topography" is used to avoid null strings.
void add_topo_exits(string *other_exits, string other_types) {
  string s;

  foreach (s in other_exits) {
    if ((s == "compass4") || (s == "compass8")) {
      if (!this_object()->query_exit("north"))
        this_object()->add_exit("north", "/topography", other_types);
      if (!this_object()->query_exit("south"))
        this_object()->add_exit("south", "/topography", other_types);
      if (!this_object()->query_exit("east"))
        this_object()->add_exit("east", "/topography", other_types);
      if (!this_object()->query_exit("west"))
        this_object()->add_exit("west", "/topography", other_types);
      if (s == "compass8") {
        if (!this_object()->query_exit("northeast"))
          this_object()->add_exit("northeast", "/topography", other_types);
        if (!this_object()->query_exit("northwest"))
          this_object()->add_exit("northwest", "/topography", other_types);
        if (!this_object()->query_exit("southeast"))
          this_object()->add_exit("southeast", "/topography", other_types);
        if (!this_object()->query_exit("southwest"))
          this_object()->add_exit("southwest", "/topography", other_types);
      }
    } else {
      this_object()->add_exit(s, "/topography", other_types);
    }
  }
} /* add_topo_exits() */
// --- END [/mnt/home2/grok/lib/std/room/basic/topography/fixed_shadow.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/chatter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/chatter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629589   Available: 13576943
Inodes: Total: 5242880    Free: 4960136
4295 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/chatter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629589   Available: 13576943
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: chatter.c,v 1.10 2003/07/14 19:41:13 ceres Exp $
 *
 */

/**
 * The standard chatter inheritable for room chats.  
 * @author Pinkfish
 * @see /std/room.c
 * @see room_chat
 */
#include <room.h>

nosave int _off;
nosave object _room;
nosave mixed *_chats;

/**
 * Allows the chat interval to be changed.
 * @param min minimum interval between chats (seconds)
 * @param max maximum interval between chats (seconds)
 */
void set_chat_min_max( int min,int  max ) {
  if (_chats) {
    _chats[0]=min;
    _chats[1]=max;
  }
} /* set_chat_min_max() */

/**
 * Gives the chatter a room to chat at and the chat args.
 * @param my_room room object
 * @param chat_args chat data: ({ min, max, chats array })
 * @see room_chat
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void setup_chatter( object my_room,  mixed *chat_args ) {
   _off = 1;
   _room = my_room;
   
   if( !arrayp( chat_args ) ) {
      chat_args = ({ chat_args });
   }
   
   _chats = chat_args + ({ 0 });
} /* setup_chatter() */

/** @ignore yes */
void dest_me() {
  destruct( this_object() );
} /* dest_me() */

/** @ignore yes */
void make_chat() {
   int saying;
   mixed stuff;

   if(!_room) {
     dest_me();
     return; 
   }
   
   if ( !_chats || sizeof(_chats) < 3 || !sizeof(_chats[2]) ||
        !sizeof( filter( all_inventory( _room ), (: interactive($1) :),
         this_object() ) ) ) {
      _off = 1;
      return;
   }
   saying = random( sizeof( _chats[ 2 ] ) );
   if ( saying == _chats[ 3 ] ) {
     saying = ( saying + 1 ) % sizeof( _chats[ 2 ] );
   }
   _chats[ 3 ] = saying;
   stuff = _chats[ 2 ][ saying ];
   if (stringp(stuff)) {
      if ( stuff[ 0 ] == '#' ) {
         call_other( _room, stuff[ 1 .. 99 ] );
      } else {
         tell_room( _room, _chats[ 2 ][ saying ] +"\n" );
      }
   }
   if ( intp( stuff ) ) {
      map( filter( all_inventory( _room ), (: $1 && living( $1 ) 
         && $1->query_creator() :) ), (: tell_creator( $1, "Warning: "
         "room_chat array contains integer argument. Did you mix up "
         "the syntax with load_chat()'s?\n" ) :) );
   }
   ROOM_HANDLER->add_chatter( this_object(), _chats[ 0 ] +
         random( _chats[ 1 ] - _chats[ 0 ] + 1 ) );
} /* make_chat() */

/**
 * Checks that the chatter is on and being activated
 * properly from the room_handler. 
 * @see /std/room/basic/chatter
 * @see /obj/handlers/room_handler
 */
void check_chat() {
   if ( !_off || !pointerp( _chats ) ) {
      return;
   }
   _off = 0;
   ROOM_HANDLER->add_chatter( this_object(), ( _chats[ 0 ] +
         random( _chats[ 1 ] - _chats[ 0 ] + 1 ) ) / 2 );
} /* check_chat() */

/**
 * Adds more chats to the existing set of room chats
 * managed by this chatter object.
 * @param new_chats an array of new chat strings
 * @see remove_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void add_room_chats( string *new_chats ) {
   if (sizeof(new_chats)) { 
     if (sizeof(_chats[2])) {
        _chats[2] = _chats[2] + new_chats;
     } else {
        _chats[2]= new_chats;
     }
   }
} /* add_room_chats() */

/**
 * Removes chats from the set of room chats
 * managed by this chatter object.  If there are no chats
 * left the chatter is destructed.
 * @param dead_chats an array of chat strings to remove
 * @see add_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void remove_room_chats( string *dead_chats ) {
   if (sizeof(_chats[2])) {
      _chats[2] = _chats[2] - dead_chats;
   }
   if (!sizeof(_chats[2])) {
      destruct(this_object());
   }
} /* remove_room_chats() */

/**
 * Returns the the set of room chats
 * managed by this chatter object.  
 * @return pointer to the mixed array of chat args
 * @example
 *  ({ 120, 240, ({ "A frog gimbles the curtains.",
 *                  "A truly revolting smell drifts insidiously "
 *                  "from the rug." }) })
 * @see add_room_chats
 * @see remove_room_chats
 * @see room_chat
 * @see /std/room/basic/chatter
 */
mixed *query_room_chats() { return _chats; }

/** @ignore yes */
int clean_up( int parent ) {
  /* Clones of this object are pointless without a room to chat to. */
  if (parent)
    return 0;
  if (!_room || _room->query_chatter() != this_object())
    dest_me();
}
// --- END [/mnt/home2/grok/lib/std/room/basic/chatter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/multichatter.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/multichatter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629588   Available: 13576942
Inodes: Total: 5242880    Free: 4960136
5195 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/multichatter.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629588   Available: 13576942
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: multichatter.c,v 1.1 1999/09/21 02:44:39 pinkfish Exp $
 *
 */

/**
 * The multiple rates chatter inheritable for room chats.  
 * This chatter handles multiple calls to room_chat
 * by adding the chats independently with their own 
 * chat interval.
 * @author Shaggy
 * @see /std/room.c
 * @see room_chat
 */
#include <room.h>

nosave int off;
nosave object room;
nosave mixed *chats;

/**
 * Allows the chat interval to be changed.
 * @param min minimum interval between chats (seconds)
 * @param max maximum interval between chats (seconds)
 */
void set_chat_min_max( int min,int  max ) {
  if (chats) {
    chats[0]=min;
    chats[1]=max;
  }
}

/**
 * Gives the chatter a room to chat at and the chat args.
 * If you call it again it you can give the room an
 * additional set of chats without destroying the
 * first, with the new set operating independently at
 * the new rate.  You can call this function as many
 * times as you like.
 * @param my_room room object
 * @param chat_args chat data: ({ min, max, chats array })
 * @see room_chat
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void setup_chatter( object my_room,  mixed *chat_args ) {
   off = 1;
   room = my_room;
   if (sizeof(chats)) chats += chat_args + ({0,0});
   else chats = chat_args + ({0,0});
} /* setup_chatter() */

void dest_me() {
  destruct( this_object() );
}

int query_multichatter() { return 1; }

int check_interactive( object thing ) { return interactive( thing ); }

void make_chat() {
  int saying;
  string stuff;
  int set,nextt,t;

  if (!sizeof( filter_array( all_inventory( room ), "check_interactive",
        this_object() ) ) ) {
    off = 1;
    return;
  }
  nextt=2147483647; // largest possible int, roughly the year 2030 :)
  t=time();
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) {
      if (t>=chats[set+4]) {
        saying = random( sizeof( chats[ set+2 ] ) );
        if ( saying == chats[ set+3 ] )
        saying = ( saying + 1 ) % sizeof( chats[ set+2 ] );
        chats[ set+3 ] = saying;
        stuff = chats[ set+2 ][ saying ];
        if ( stuff[ 0 ] == '#' )
          call_other( room, stuff[ 1 .. 99 ] );
        else
          tell_room( room, chats[ set+2 ][ saying ] +"\n" );
        chats[ set+4 ]=time()+chats[ set ] 
            +random(chats[ set+1 ] - chats[ set ] + 1)-4;
// The -4 is to do with the fact that chats only occur at most
// every 4 seconds (see the room_handler)
      }
      if (chats[ set+4 ]<nextt) nextt=chats[ set+4 ];
    }
  }
  if (nextt!=2147483647) {
    if ((nextt+=4-t)<5) nextt=5; 
    ROOM_HANDLER->add_chatter( this_object(), nextt );
  }
} /* make_chat() */

/**
 * Checks that the chatter is on and being activated
 * properly from the room_handler. 
 * @see /std/room/basic/chatter
 * @see /obj/handlers/room_handler
 */
void check_chat() {
  int set,t,nextt;

  if ( !off || !pointerp( chats ) )
      return;
  off = 0;

  t=time();
  nextt=2147483647;
  for (set=0; set<sizeof(chats); set+=5) {
    if (t>=chats[set+4]+chats[set]) chats[set+4]=t+random(chats[set+1]);
    if (chats[set+4]<nextt) nextt=chats[set+4];
  }
  if ((nextt+=4-t)<5) nextt=5;
  ROOM_HANDLER->add_chatter( this_object(), nextt );
} /* check_chat() */

/**
 * Adds more chats to the existing set of room chats
 * managed by this chatter object.  This function
 * always adds to the first set of chats even if
 * multiple sets exist on the chatter.
 * @param new_chats an array of new chat strings
 * @see remove_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void add_room_chats( string *new_chats ) {
   if (sizeof(new_chats)) { 
     if (sizeof(chats[2])) chats[2] = chats[2] + new_chats;
     else chats[2]= new_chats;
   }
} /* add_room_chats() */

/**
 * Removes chats from the set of room chats
 * managed by this chatter object.  If there are no chats
 * left the chatter is destructed.  This function
 * removes chats from any set by identifying all
 * copies in each set and removing them.
 * @param dead_chats an array of chat strings to remove
 * @see add_room_chats
 * @see query_room_chats
 * @see /std/room/basic/chatter
 */
void remove_room_chats( string *dead_chats ) {
  int set;
  mixed *new_chats;

  new_chats=({ });
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) chats[set+2] = chats[set+2] - dead_chats;
    if (set==0 || sizeof(chats[set+2])) 
       new_chats=new_chats+chats[(set)..(set+4)];
  }
  chats=new_chats;
} /* remove_room_chats() */

/**
 * Returns the the set of room chats
 * managed by this chatter object.  
 * @return pointer to the mixed array of chat args
 * @example
 *  ({ 120, 240, ({ "A frog gimbles the curtains.",
 *                  "A truly revolting smell drifts insidiously "
 *                  "from the rug." }) })
 * @see add_room_chats
 * @see remove_room_chats
 * @see room_chat
 * @see /std/room/basic/chatter
 */
mixed *query_room_chats() { return chats; }

/** @ignore yes */
int clean_up( int parent ) {
/* Clones of this object are pointless without a room to chat to. */
  if (parent) {
    return 0;
  }
  if (!room) dest_me();
} /* clean_up() */





// --- END [/mnt/home2/grok/lib/std/room/basic/multichatter.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/graffbase.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/graffbase.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629586   Available: 13576940
Inodes: Total: 5242880    Free: 4960136
4999 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/graffbase.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629586   Available: 13576940
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * $Locker:  $
 * $Id: graffbase.c,v 1.2 2001/07/25 00:39:17 olorin Exp $
 *
 * This is the temporary and hacked version of Taniwha's graffiti base code.
 * The original files can be found in /w/hobbes/misc/graffiti/
 * Based on /obj/misc/quill
 * Taniwha, 1997
 *
 * $Log: graffbase.c,v $
 * Revision 1.2  2001/07/25 00:39:17  olorin
 * Removed a spurious definition of the type var, which conflicted
 * with a global var, and wasn't used anyway.
 * Fixed a silly sentence construct in a fail message as well.
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
 */

#include <language.h>
// Property to add to an object to allow scrawling

#define GRAFFITI "graffiti"

#define ETP environment(this_player())
#define TO this_object()


object writing_on;
 /* string type; */
object old;
string olds;

/* Functions to override in inheriting objects */
string query_drawingwith(); // name of thing doing the drawing
int do_check();  // do we have the "pen and paper"
int done_check(); // Clean uo routine, break chalk etc

string query_drawingwith() { return "something"; }
int do_check() { return 0; } // fail
int done_check() { return 0; }


void init() {
 this_player()->add_command( "scrawl", this_object(), "with charcoal on wall");
 this_player()->add_command( "scrawl", this_object(), "on wall with charcoal");
} /* init() */

int do_scrawl( object *things ) {
    string language;
   /* if(!this_object()->do_check() ) return 0;*/
    if ( !ETP->query_property( GRAFFITI) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "+
          "this wall.\n");
        return 0;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "
           "a wall when you're not using a language that can be used for "
          "scrawling on a wall with.\n",({writing_on}));
        return 0;
    }

    if(( old = present("graffiti",ETP)) && !interactive(old))
    {
        olds = old->query_property("graffiti");
    }
    if ( writing_on ) {
        this_player()->add_failed_mess( this_object(), "The writing "+
          "spot seems to be busy at the moment.\n",
          ({writing_on}));
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(), ({"You start scrawling "+
      "on a wall with some charcoal.\n", "$N starts scrawling on a wall with "
      "some charcoal.\n"}) );
    writing_on = ETP;
    call_out( "begin_writing", 0, this_player() );
    return 1;
} /* do_write() */

void begin_writing( object writer ) {
    if ( !writer ) {
        writing_on = 0;
        return;
    }
    writer->do_edit( 0, "end_writing" );
} /* begin_writing() */

void end_writing( string words ) {
    string language;
    string extra;
    if ( !words || ( words == "" ) ) {
        write( "You don't scrawl anything on "+
         "the wall.\n");
        say( (string)this_player()->the_short() +" doesn't "+
          "scrawl anything after all.\n" );
        writing_on = 0;
        return;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        write( "You seem to have changed to using a non-written language.\n" );
        say( (string)this_player()->the_short() +" seems "+
          "linguistically-challenged.\n" );
        writing_on = 0;
        return;
    }
    if ( !writing_on ) {
        write( "You seem to have lost what you were scrawling on.\n" );
        say( (string)this_player()->the_short() +" looks around "+
          "in puzzlement.\n" );
        return;
    }
    if (  writing_on != ETP ) {
        write("The wall seems to have run away from you.\n" );
        say( (string)this_player()->the_short() +" looks like "+
          (string)this_player()->query_pronoun() +"'s lost something.\n" );
        writing_on = 0;
        return;
    }
    /*   
       writing_on->add_read_mess( words, type, language, 0 );
    */
    if(!stringp(olds)) olds = "";
    words = olds +"\n"+"%^MAGENTA%^Scrawled with rough charcoal, you "
             "read the words:%^RESET%^\n\n"+
    words;
    if(old) old->move("/room/rubbish");
    extra = TO->extra_stuff();
    if(!strlen(extra))extra = "Some disreputable character has scrawled "
        "graffiti over this wall.  You may be able to \"read\" it.\n";
    ETP->add_sign(
      extra,
      words,	
      "graffiti",
      ({"graffiti","scrawl"}),
      language
    );
    old = present("graffiti",ETP);
    old->add_property("determinate","some ");
    old->add_property("there","on the wall");
    if(old) old->add_property("graffiti",words);

    write( "As you finish scrawling on the wall, the piece of charcoal "
           "breaks.\n" );
    say( (string)this_player()->the_short() +" finishes scrawling "+
      "on the wall.\n" );
    this_object()->done_check();
    writing_on = 0;
} /* end_writing() */
// --- END [/mnt/home2/grok/lib/std/room/basic/graffbase.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/npcroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/npcroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629585   Available: 13576939
Inodes: Total: 5242880    Free: 4960136
4286 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/npcroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629585   Available: 13576939
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: npcroom.c,v 1.1 1998/11/01 12:02:03 terano Exp $
 *
 *
 */

/*
 * $Locker:  $
 * $Id: npcroom.c,v 1.1 1998/11/01 12:02:03 terano Exp $
 *
 * $Log: npcroom.c,v $
 * Revision 1.1  1998/11/01 12:02:03  terano
 * Initial revision
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: npcroom.c,v 1.1 1998/11/01 12:02:03 terano Exp $
 *
 * $Log: npcroom.c,v $
 * Revision 1.1  1998/11/01 12:02:03  terano
 * Initial revision
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: npcroom.c,v 1.1 1998/11/01 12:02:03 terano Exp $
 *
 * $Log: npcroom.c,v $
 * Revision 1.1  1998/11/01 12:02:03  terano
 * Initial revision
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/* Inheritable object to make the functions to handles the creation of objects
 * and npc's in a room.
 * reset_objects is an array of the objects 
 * reset_definitions is an array of the definitions of how these objects
 * should be cloned
 * the value of a reset definition is an array containig the following:
 *   ({ flag, delay, clone_info, entry_mess })
 * flag can be REMOVABLE, FIXED or UNIQUE defining whether a new item
 *   should be cloned if this one is removed from the room, only cloned if
 *   this one is destructed, or as fixed, but it's the master objects that's
 *   put here(mainly for unique npc's with their own file).
 * delay is the delay in seconds between reset being called and the cloning  
 * clone_info can be a string, in which case it's considered to be the
 *   filename of the thing to put here, or a function pointer meaning
 *   it's a function returning the thing.
 * entry_mess is the parameter given to move when moving the item to this 
 *   room.
 */

#define FLAG 0
#define DELAY 1
#define CLONE 2
#define MESS 3
#define REMOVABLE 0
#define FIXED 1
#define UNIQUE 2

nosave mixed  *reset_definitions;
nosave object *reset_objects;

void add_cloned_object( int flag, int delay, mixed clone_info, 
                       string entry_mess ) {
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
} /* add_cloned_object() */

mixed *query_cloned_objects() {
   return reset_objects + ({ });
} /* query_cloned_objects() */

mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
} /* query_cloned_definitions() */

private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
} /* make_clone() */

private void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
} /* make_object() */

void reset() {
   int i;
   
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] || 
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
      }
   }
} /* reset() */
// --- END [/mnt/home2/grok/lib/std/room/basic/npcroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/multiroom_situation_changer.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/multiroom_situation_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629584   Available: 13576938
Inodes: Total: 5242880    Free: 4960136
14261 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/multiroom_situation_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629584   Available: 13576938
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <am_time.h>
#include <situations.h>

#define RANDOM(a,b) ("/obj/handlers/random_num.c"->random(a,b))
#define MIN_DURATION  1
/* seconds between checks for situation changes */
#define SECTOCHECK    15
/* maximum random install delay (seconds) */
#define INSTALLDELAY  15
#define MAXROOMS      30

/* Room info
 * (roominfo[i])[0]=currentsits [1]=offset [2]=els [3]=sittiming 
 *              [4]=chatmin [5]=chatmax [6]=awake
 * int *currentsits;
 * string *els;
 * int offset;
 * mixed *sittiming;
 * int chatmin, chatmax;
 * int awake;  0 off 1 on 
 */
nosave mapping roominfo;
nosave mixed *rooms;

/* global situation info */
nosave mapping sitdata;

/**
 * situation changer object associated with multiple room objects.
 * It keeps a list of rooms and checks them all in turn. It 
 * behaves similarly to the room_handler.  It's main purpose is
 * to avoid duplicating a large chat database for many rooms
 * that all use it. 
 */

/** 
 * returns status of situation manager.  
 * If it is sleeping it will turn on again if a
 * player enters the room.
 * @return status 0 off 1 on 2 sleeping
 */
int query_status() { return 1; }

/** 
 * returns situations currently turned on.
 * @return int array of situation labels
 */
int *query_current_situations(object room) 
{ 
  if (!roominfo[file_name(room)]) return 0;
  return (roominfo[file_name(room)])[0]; 
}

void dest_me() {
  destruct(this_object());
} /* dest_me() */

/**
 * Adds a situation for the rooms.  These situations can be
 * invoked manually with start_situation or automatically via
 * automate_situations.
 * @param num number labelling the situation
 * @param func function to be called at start of situation 
 *             that might be used to load NPC's.  If it is
 *             a set of two function pointers ({ f1, f2 })
 *             the second function is called when the
 *             situation is ended.  The start function is 
 *             passed the num label of the room and a
 *             do_start_mess flag.  If the flag is one
 *             the situation is starting rather than
 *             being reloaded.  The end function is only
 *             passed the num label.
 * @param startmess message told to the room at start of situation
 * @param endmess message told to the room at end of situation
 * @param extralooksting extra look string appended to rooms long 
 * description during the situation
 * @param chats an array of chat strings to be active 
 * during the situation 
 * @param add_items a mixed array of ({ item, item description }) 
 * pairs to be active during the situation
 * @see start_situation
 * @see automate_situations
 * @see add_item
 * @see room_chat
 * @see add_extra_look
 * @example
 *  add_situation( 0, 0, "Water seeps out of the ground to form puddles.", 
 *     "",  "There are large puddles on the ground here.",
 *     ({"A hidden frog croaks quietly.",
 *       "There is a blooping sound." }),
 *     ({ ({"puddle", "The puddles are dark and murky.  " 
 *                    "They will probably dry up given time." }) }) );
 */
void add_situation(int num, function *func, string startmess, string endmess, 
                   string extralookstring, string *chats, mixed *add_items ) {
  if (!sizeof(sitdata))
    sitdata= ([ num : 
              ({ startmess, endmess, extralookstring, chats, add_items, func }) ]);
  else
    sitdata+= ([ num : 
               ({ startmess, endmess, extralookstring, chats, add_items, func }) ]);
}

/**
 * Starts a situation previously added for the room
 * that is managed by this object.
 * These situations can be invoked manually with 
 * start_situation or automatically via
 * automate_situations. 
 * @param num number labelling the situation
 * @param do_start_mess 0 to supress the start_mess string
 *        This is to fake it that a situation has been 
 *        going for a while when really you just loaded it.
 * @param room room to add situation to
 * @see add_situation
 * @see end_situation
 * @see automate_situations
 */
void start_situation(int num, int do_start_mess, object room) {
  mixed *sdata;
  string *chats;
  mixed item,*items;
  int *currentsits;
  string *els;
  object chatter;

  if (!(sdata=sitdata[num]) || !room) return;
  if (!roominfo[file_name(room)]) roominfo[file_name(room)]=
                 ({ 0,0,0,0,60,120,1 });
  currentsits=(roominfo[file_name(room)])[0];
  els=(roominfo[file_name(room)])[1];
  if (!currentsits) currentsits=({ num });
  else currentsits=currentsits+({ num });

  if (sizeof(sdata[2])) {
    if (els && sizeof(els)) els+=({ sdata[2] });
    else { 
      els=({ sdata[2] });   
      room->add_extra_look(this_object()); 
    }
  }
  if (do_start_mess && sizeof(sdata[0])) 
    tell_room(room, sdata[0]+"\n");
  chats=sdata[3];
  if (chats && sizeof(chats)) {
    //    tell_creator("shaggy","Adding: %O\n",chats);
    if (!(chatter=room->query_chatter())) {
      room->room_chat( ({ (roominfo[file_name(room)])[4],(roominfo[file_name(room)])[5], chats }) );
      chatter=room->query_chatter();
      chatter->check_chat();
    }
    else chatter->add_room_chats(chats);
  }
  items=sdata[4];
  if (sizeof(items)) {
    foreach(item in items) room->add_item(item[0],item[1]);
  }
  if (sdata[5]) { /* functionp */
    if (functionp(sdata[5])) (*(sdata[5]))(num,do_start_mess);
    else if (arrayp(sdata[5]) && functionp((sdata[5])[0])) 
      (*((sdata[5])[0]))(num,do_start_mess);
  }
  (roominfo[file_name(room)])[0]=currentsits;
  (roominfo[file_name(room)])[1]=els;
} /* start_situation() */

/**
 * Ends a situation previously added and started on the room
 * that is managed by this object.
 * These situations can be invoked manually with start_situation 
 * or automatically via automate_situations. 
 * @param num number labelling the situation
 * @param room room to end situation on
 * @see add_situation
 * @see start_situation
 * @see automate_situations
 */
void end_situation(int num, object room) {
  mixed *sdata;
  string *chats;
  mixed item,*items;
  int *currentsits;
  string *els;
  object chatter;
  
  if (!(sdata=sitdata[num]) || !room) return;
  if (!roominfo[file_name(room)]) return;
  currentsits=(roominfo[file_name(room)])[0];
  els=(roominfo[file_name(room)])[1];
  if (currentsits) currentsits=currentsits-({ num });
  if (els && sizeof(sdata[2])) { 
    els-=({ sdata[2] });
    if (!sizeof(els)) room->remove_extra_look(this_object());
  }

  chats=sdata[3];
  if (chats && sizeof(chats) && (chatter=room->query_chatter())) {
    //    tell_creator("shaggy","Removing: %O\n",chats);
    chatter->remove_room_chats(chats);
  }
  items=sdata[4];
  if (sizeof(items)) {
    foreach(item in items) room->remove_item(item[0],item[1]);
  }
  if (sizeof(sdata[1])) 
    tell_room(room,sdata[1]+"\n");
  if (sdata[5]) { /* functionp */
    if (arrayp(sdata[5]) && functionp((sdata[5])[1])) 
      (*((sdata[5])[1]))(num);
  }
  (roominfo[file_name(room)])[0]=currentsits;
  (roominfo[file_name(room)])[1]=els;
} /* end_situation() */

/**
 * Starts and ends situations according to the information
 * in the sittiming mapping.  It is called continuously 
 * automatically while there are interactives in the room.
 */
void manage_situations(object room) {
  mixed *sit;
  int num,t,it,cnt,possible;
  int *currentsits,*newsits,*changes;
  int ttmp,tstep,offset,awake;
  mixed data;

//  tell_creator("shaggy","Managing %O %O %O \n",room,roominfo[file_name(room)],
//    filter_array( all_inventory( room ),(: interactive($1) :)));
  if (!room || !(data=roominfo[file_name(room)])) return;
  if (!sizeof(filter_array( all_inventory( room ),(: interactive($1) :)))) {
    (roominfo[file_name(room)])[6]=0;  
    return;
  }
//  tell_creator("shaggy","No abort \n");

  currentsits=data[0];
  offset=data[2];
  awake=data[6];
  t=time()+offset;
  newsits=({});
  tstep=2147483647;
  
  cnt=0;
  foreach(sit in data[3]) {
    cnt++;
    ttmp=sit[1];
    it=t/ttmp;
    possible=0;
    if (sit[2]) {
      if (functionp(sit[2])) possible=(*(sit[2]))();
      else possible=sit[2];
      possible=
	(possible&(1<<((AM_TIME_HANDLER)->query_am_hour(it*ttmp-offset))))
	&&
	(RANDOM(1000,it*1147483647+cnt*2047483243) < sit[3]);
    }
    if (possible) {
      if (arrayp(sit[0])) {
	num=(sit[0]) [((t % ttmp)*sizeof(sit[0]))/ttmp];
	ttmp=ttmp/sizeof(sit[0]);
      }
      else num=sit[0];
      if (member_array(num,newsits)==-1) newsits=newsits+({ num });
    }
    if (ttmp<tstep) tstep=ttmp;
  }
  if (currentsits && sizeof(currentsits)) {
    changes=currentsits-newsits;
    if (sizeof(changes)) foreach(num in changes) {
      if (awake) call_out("end_situation",random(INSTALLDELAY),
        num,room);
      else end_situation(num,room);
    }
    changes=newsits-currentsits;
    }
  else changes=newsits;
  if (sizeof(changes)) foreach(num in changes) {
    if (awake) call_out("start_situation",random(INSTALLDELAY),
       num,awake,room);
    else start_situation(num,awake,room);
  }
  if ((tstep/=SECTOCHECK)>=MAXROOMS) tstep=MAXROOMS-1; 
  if (!rooms[tstep]) rooms[tstep]=({ room });
  else rooms[tstep]=rooms[tstep]+({ room });

  (roominfo[file_name(room)])[6]=1;  
} /* manage_situations() */

/**
 * Starts and ends situations according to the information
 * in the sittiming mapping for each room in the rooms array.  
 * It is called continuously 
 * automatically while there are interactives in the room.
 */
void manage_rooms_situations() {
  object room,*current_rooms;

  current_rooms = rooms[ 0 ];
  rooms[ 0 .. <2 ] = rooms[ 1 .. <1 ];
  rooms[ <1 ] = 0;
  call_out("manage_rooms_situations",SECTOCHECK);
  if ( !pointerp( current_rooms ) ) return;
  foreach ( room in current_rooms ) manage_situations(room);
} /* manage_room_situations() */

/**
 * Tests for enabling situation managing.
 * If situation managing is already active or turned off
 * it does nothing.
 * @param room the room
 * @see automate_situations
 */
void check_situations(object room) {
  if (room && roominfo[file_name(room)] 
    && !((roominfo[file_name(room)])[6])
    && interactive(this_player())) manage_situations(room); 
}
/**
 * Awakes starting and ending of situations.
 * These situations can be invoked manually with start_situation.
 * The awaked starting and ending is unaffected by the room 
 * unloading.  When the room reloads the situation will be 
 * restarted unless its duration is up.
 * @param chatargs same as arguments to room chat:
 *    ({ min, max, ({ chat1, chat2, ... }) })
 *    if you want no non-situational chats just put ({ min, max, ({ }) })
 *    min, max are always needed being the minimum/maximum time
 *    between all chats.  chat1 is a string containing a chat.
 * @param xval First random seed number (eg. x coordinate)
 * @param yval Second random seed number (eg. y coordinate)
 * @param sittiming A mixed array containing the information 
 *    about when the situations added by add_situation are 
 *    automatically started and ended:
 *
 *    ({ info1, info2, info3, ... })
 *
 *  Each info is a mixed array as follows:
 *
 *    ({ number, duration, when, chance })
 *               -- or --
 *    ({ ({ num0, num1, num2, ..., numN }) , when, duration, percent })
 *
 * number     (int) label of the situation to start 
 *            up if number is an array then a set of
 *            situations are started one at a time.
 *            The total duration is divided evenly 
 *            between the situations labelled by the 
 *            numbers in the array which are started 
 *            and ended in the order given.  The 
 *            entire set always gets used.
 *
 * duration   (int) time (minutes) situation should last for
 *
 * when       (int) a nighttime/daytime mask
 *            This determines when during the day in
 *            Ankh-Morpork time the situation may occur.  
 *            The masks are defined in evolvingtime.h
 *            It can be a function pointer in which case it is 
 *            expected to return a mask value.
 *
 * chance     (int) 1/1000 chance per period of duration minutes 
 *            of getting into the situation
 * @see add_situation
 * @see start_situation
 * @see end_situation
 * @see evolvingroom.h
 * @example
 *  automate_situations( room, ({ 50,70, ({""}) }), 
 *     170,  220,
 *     ({ ({           0, 5, WHEN_ANY_TIME, 200 }),
 *        ({ ({ 1,2,3 }), 6, (WHEN_NIGHT|WHEN_EVENING), 500 }) }) );
 */
void automate_situations(mixed *chatargs, int xval, int yval, mixed *edata,
  object room) {
  mixed sit;
  mixed *sittiming;
  int offset;

  offset=xval*38547+yval*1232444311;

  if ( pointerp(chatargs[2]) && sizeof(chatargs[2])) {
    room->room_chat( chatargs );
  }

  if (sizeof(edata)) {
    foreach(sit in edata) {
      if (sit[1]<MIN_DURATION) {
        write("Invalid situation duration: "+sit[1]+"\n");
        return;
      }
      sit[1]*=60; /* minutes to seconds */
      if (!sittiming) sittiming=({ sit });
      else sittiming=sittiming+({ sit });
      /* may add extra info to sittiming later */
    }
  }
  roominfo[file_name(room)]=({  0,0, offset, sittiming, 
       chatargs[0], chatargs[1], 0 });
  manage_situations(room);
} /* automate_situations() */

/**
 * Shuts down all current and pending situations.  It also turns off the
 * awaked situation manager so no more are added.  It does not
 * destruct this object so all the add_situations are still loaded
 * and make be recommenced with automate_situations.  dest_me is
 * the appropriate call to permanently remove all situations.
 * @param room room to shutdown situations on
 * @see automate_situations
 */
void shutdown_situations(object room) {
  int num, *currentsits;

  currentsits=(roominfo[file_name(room)])[0];
  if (currentsits && sizeof(currentsits)) {
    foreach(num in currentsits) end_situation(num, room);
  }
} /* shutdown_situations() */

string extra_look(object room) {
  string *els;

  if (!roominfo[file_name(room)]) return "";
  els=(roominfo[file_name(room)])[1];
  if (!els || !sizeof(els)) {
    return "";
  }
  return implode(els,"  ")+"\n";
} /* add_extra_look() */

void create() {
   rooms = allocate( MAXROOMS );
   manage_rooms_situations();
   roominfo= ([ ]);
} /* create() */

object *query_rooms() { return rooms; }









// --- END [/mnt/home2/grok/lib/std/room/basic/multiroom_situation_changer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/door.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/door.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629580   Available: 13576934
Inodes: Total: 5242880    Free: 4960136
17559 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/door.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629580   Available: 13576934
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: door.c,v 1.28 2003/05/22 17:57:31 ceres Exp $
 *
 * Basic door object used by rooms. Typically there is no need to use any of
 * the methods in this object since they are accessible through modify_exit.
 *
 * @author pinkfish
 *
 */
#include <door.h>
#include <room.h>
#include <parse_command.h>
#include <dirs.h>

#define BEVERB ({ " is ", " are " })
#define PRONOUN ({ "it", "them" })
#define CLOSED        2
#define CLOSED_LOCKED 3

inherit "/std/basic/enchant";
inherit "/std/basic/hide_invis";
inherit "/std/basic/property";
inherit "/std/basic/close_lock";
inherit "/std/basic/trap";
inherit "/std/basic/id_match";

private int how_many;
private int one_way;
// pk only pick, no one can pick.
private string _lock_owner;
private string shrt;
private string lng;
private string my_id;
private string other_id;
private string *name;
private string *adjs;
private string *plu;
private string dest;
private string _door_name;
private object key;
private object my_room;

/** 
 * @ignore yes
 */
void create() {
   hide_invis::create();
   property::create();
   close_lock::create();
   name = ({ "door" });
   lng = "It's just a door.\n";
   shrt = "door";
   adjs = ({ });
   plu = ({ });
   add_property( "determinate", "the " );
   set_unlocked();
} /* create() */ 

/**
 * This method returns how many doors are stored in this particular
 * door object.  This is used for double doors and things like that
 * to make the plurals work correctly.
 * @return an integer value representing the number of doors.
 * @see set_how_many() 
 */
int query_how_many() { 
    return how_many; 
} /* query_how_many() */ 

/** 
 * This method sets how many doors there are so that plurals
 * and everything are set correctly.  It also flags the door
 * with the "group object" property.
 * @param number the number of doors this door should represent.
 * @see query_how_many()
 */
void set_how_many( int number ) {
  // make the doors act as plural if there's more than one of them
  if(number)
    add_property("group object", 1);
  else
    remove_property("group object");
  how_many = number;
} /* set_how_many() */ 

/**
 * This method is used to determine if a door has been flagged as being
 * 'one way' or not. 
 * @return an integer value which returns 1 if the door is one way,
 * 0 if it is not. 
 * @see set_one_way()
 */
int query_one_way() { 
    return one_way; 
} /* query_one_way() */ 

/**
 * This method is used to set whether or not the door is one way.
 * A one way door won't trigger a "broken door" message when there's
 * no exit leading back.
 * @param number pass 1 if the door is one way, or 0 if it isn't.
 */ 
void set_one_way( int number ) { 
    one_way = number; 
} /* set_one_way() */ 

/**
 * This method returns the short of the door.  This is normally a string
 * like "east door".
 * @return a string containing the short for the door.
 * @see set_short() 
 */ 
string query_short() {  
    return shrt; 
} /* query_short() */

/** 
 * This method sets the short for the door.  As well as setting the short,
 * it calculates the name, adjectives and plurals for the door.  
 * @param words the short to set for the door object. 
 * @see query_short() 
 */ 
void set_short( string words ) {
   string *bits;
   shrt = words;
   bits = explode( words, " " );

   // Now split apart any hyphenated words. 
   // And add them to the original. 

   bits += implode( map( bits, (: explode( $1, "-" ) :) ), (: $1 + $2 :) );
   bits = uniq_array( bits );

   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs += bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
} /* set_short() */

/** 
 * This returns the name of the door.  Note that this is different to the
 * actual 'name' of the door.  It is normally an exciting and original
 * value of 'door'. 
 * @return a string representing the door name.  
 */ 
string query_door_name() { 
    return _door_name; 
} /* query_door_name() */ 

/** 
 * This method sets the name of the door.  Note that this is different
 * to the actual visible name or short of the door.
 * @param word the new door name
 * @see query_door_name()
 * @see set_short()
 */ 
void set_door_name( string word ) { 
    _door_name = word; 
} /* set_door_name() */ 

/** 
 * This method sets the owner of the lock.   This value is used in
 * pick_lock() to determine whether or not various PK checks etc
 * are passed.
 * @param owner the name of the player who owns the lock.
 */ 
void set_lock_owner(string owner) { 
    _lock_owner = owner; 
} /* set_lock_owner() */ 

/** 
 * This method is used to determine which player owns the lock
 * on this door.
 * @return a string containing the name of the player who owns the
 * lock.
 * @see set_lock_owner() 
 */ 
mixed query_lock_owner() { 
    return _lock_owner; 
} /* query_lock_owner() */ 

string query_long() { return lng; }
void set_long( string word ) {lng = word;}

string query_my_id() { return my_id; }
void set_my_id( string word ) { my_id = word; }

string query_other_id() { return other_id; }
void set_other_id( string word ) { other_id = word; }

string *query_name() { return name; }
string *query_adjs() { return adjs; }
string *query_plu() { return plu; }

string query_dest() { return dest; }
void set_dest( string word ) { dest = word; }

object query_my_room() { return my_room; }

/** 
 * @ignore yes
 */ 
void init() {
   add_command( "knock", "on <direct:object>" );
   close_lock::init();
} /* init() */ 

string query_determinate() { return "the "; }
string short() { return query_short(); }
string a_short() { return "$a_short:"+ file_name( this_object() ) +"$"; }
string one_short() { return "$one_short:"+ file_name( this_object() ) +"$"; }
string poss_short() { return "$poss_short:"+ file_name( this_object() ) +"$"; }
string the_short() { return "$the_short:"+ file_name( this_object() ) +"$"; }
string pretty_short() { return query_short(); }
string query_plural() { return pluralize( query_short() ); }
string pretty_plural() { return pluralize( query_short() ); }

string long() {
  return lng + ( ( this_player()->query_see_octarine() ) ? enchant_string() :
                 "" ) + long_status();
}

int drop() { return 1; }
int get() { return 1; }

/** 
 * This method is called by /std/room/basic_room.c in query_door()
 * to create the door. 
 * @param word the name of the door being created
 * @param mine the object that owns the door
 * @param his the destination for the door
 * @param args dest_other information from door.  This is mainly
 * the modify_exit() parameters.
 * @param type the type of the door, eg, door, window, etc. 
 */ 
void setup_door( string word, object mine, string his, mixed *args,
                 string type) {
   string *bits;

   my_id = word;
   my_room = mine;
   dest = his;

   switch(type) {
   case "window":
     if(word != "window")
       shrt = word + " window";
     else
       shrt = word;
     
     lng = "It's just the " + shrt + ".\n";
     name = ({ shrt, "window" });
     plu = ({ "windows" });
     break;
     
   default:
     if ( word[ 0 .. 5 ] == "enter " ) {
       if(SHORTEN[word[6..100]])
         name += ({ SHORTEN[word[6..100]] });
       shrt = word[ 6 .. 100 ] +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     } else {
       if(SHORTEN[word])
         name += ({ SHORTEN[word] });
       shrt = word +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     }
     break;
   }

   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits;
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });

   (!args[ D_CLOSED ]) ? set_closed() : set_open();
   (args[ D_LOCKED ]) ? set_locked() : set_unlocked();

   set_key(args[ D_KEY ] );
   set_difficulty(args[ D_DIFFICULTY ] );
   if ( args[ D_SECRET ] )
      add_hide_invis( "secret", 0, 200, 0 );

   if(sizeof(args) >= D_TRANSPARENT && args[D_TRANSPARENT])
     set_transparent();

   set_door_name(args[D_NAME]);
}

void add_alias( string word ) {
   string *bits;

   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
} /* add_alias() */

/** @ignore yes
 * I believe this function is used to forcibly load & setup the other side
 * of a door. I'm not entirely sure if all of this is needed but debugging
 * it is tricky. -- Ceres
 */
int force_other() {
  string door_name, direc;
  
  if(!find_object(dest)) {
    if(!load_object(dest))
      return 0;
    dest->query_door( my_room, _door_name );
  }

  // No ID then we need to find our ID
  if(!other_id) {
    door_name = my_room->call_door(my_id, "query_door_name");
    direc = dest->query_door(my_room, door_name);
    my_room->modify_exit( my_id, ({ "other", direc }) );
  }
  
  // Still no id? Then we're in trouble.
  if(!other_id)
    return 0;
  
  return 1;
}

int do_open() {
  if(!::do_open())
    return 0;

  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }

  /*
   * If the door is now open, it's outdoors and this is not a move (i.e. the
   * room handler is not involved), the wind could blow it shut.
   */
  if(((string)my_room->query_property( "location" ) == "outside") &&
     (member_array(find_object(ROOM_HANDLER), previous_object(-1)) == -1))
    ROOM_HANDLER->add_door( this_object() );
  
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    if(this_player())
      dest->tell_door(other_id, (string)this_player()->a_short() +
                      " opens the $D.\n", 0);
    else
      dest->tell_door(other_id, "Someone opens the $D.\n", 0);
  }
  
  return 1;
}

int do_close() {
  if(!::do_close())
    return 0;

  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }

  if(!one_way && find_object(dest)) {
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D which "
                       "lock$s as $p close$s.\n", 0 );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D.\n", 0 );
    }
  }
  return 1;
}

int do_lock(object *obs) {
  if(!::do_lock(obs))
    return 0;

  if(!force_other() && !one_way) {
    set_unlocked();
    return 0;
  }

  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 1 }));
    dest->tell_door(other_id, "Someone locks the $D.\n", 0);
  }
  
  return 1;
}

int do_unlock(object *obs) {
  if(!::do_unlock(obs))
    return 0;

  if(!force_other() && !one_way) {
    set_locked();
    return 0;
  }

  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 0 }));
    dest->tell_door(other_id, "Someone unlocks the $D.\n", 0);
  }
  
  return 1;
}

int do_knock() {
  if(this_player()->query_property("dead"))
    return 0;
  
  if ( !other_id && !one_way ) {
    ROOM_HANDLER->check_door( ({ my_room, my_id }) );
    if ( !other_id )
      return 0;
  }
  if ( one_way )
    return 1;

  if(query_transparent())
    dest->tell_door(other_id, this_player()->a_short() +
                    " knocks on the $D.\n", 0);
  else
    dest->tell_door( other_id, "Someone knocks on the $D.\n", 0 );
  event(find_object(dest), "door_knock", this_player(), other_id);
  return 1;
}

int pick_unlock(object thing) {
  if (stringp(_lock_owner)) {
     // Check and see if they are pk, get the owner from our room
     // or the other room.
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }

  if(!::pick_unlock(thing)) {
    return 0;
  }

  if(!force_other() && !one_way ) {
    set_locked();
    return 0;
  }

  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 0 }) );
    dest->tell_door( other_id, "Someone unlocks the $D.\n", 0 );
  }
  return 1;
}

int pick_lock( object thing ) {
  if (stringp(_lock_owner)) {
     // Check and see if they are pk, get the owner from our room
     // or the other room.
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }

  if(!::pick_lock(thing))
    return 0;
  
  if(!force_other() && !one_way ) {
    set_unlocked();
    return 0;
  }
  
  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 1 }) );
    dest->tell_door( other_id, "Someone locks the $D.\n", 0 );
  }
  return 1;
}

string *parse_command_id_list() {
  return (this_player() ? name + ({ this_player()->find_rel(my_id) }) : name);
}

string *parse_command_adjectiv_id_list() { return adjs; }
string *parse_command_plural_id_list() { return plu; }

object query_parse_id( mixed *arr ) {
   if (arr[P_THING] == 0) {
      return this_object();
   }
   if (arr[P_THING] < 0) { /* specific object case */
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return this_object();
   }
   arr[P_THING]--; /* lots of objects case */
   if (arr[P_THING] != 0) {
      return this_object();
   }
   arr[P_THING] = -10101;
   return this_object();
}

mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   if (input[<1] == "all") {
      return 0;
   }
   return ::parse_match_object(input, viewer, context);
} /* parse_match_object() */

void dest_me() {
  //  tell_creator("ceres", "Door being destructed: %O %O %O\n",
  //my_room, call_stack(1), call_stack(2));
  destruct( this_object() );
}
void dwep() { destruct( this_object() ); }
void go_away() { call_out("dest_me", 0); }
int move() { return 1; }

int moving_open( object thing ) {
  if(!::do_open())
    return 0;

  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }
  
  // This is now handled in the sneaking shadow.
  //thing->remove_hide_invis("sneaking");
  
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    dest->tell_door(other_id, (string)thing->a_short() + " opens the $D.\n", 0);
  }

  tell_object( thing, "You open the "+ shrt +".\n" );
  tell_room( my_room, (string)thing->the_short() +
             " opens the "+ shrt +".\n", thing );
  return 1;
}

int moving_close( object thing ) {
  if(!::do_close())
    return 0;
  
  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }

  if(!one_way && find_object(dest))
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door(other_id, (string)thing->the_short() +
                      " closes the $D which lock$s as $p close$s.\n", thing );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      if ( thing->short() )
        dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                         " closes the $D.\n", thing );
    }

  if(query_autolock()) {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +
                 " which locks as it closes.\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +" which locks as it closes.\n", thing );
  } else {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +".\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +".\n", thing );
  }

  return 1;
}

int moving_unlock(object thing) {
  if(!::do_unlock(all_inventory(thing)))
    return 0;

  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 0 }));

  tell_object(thing, "You unlock the "+ shrt +".\n");
  if (thing->short())
    tell_room( my_room, capitalize( (string)thing->the_short() ) +
               " unlocks the "+ shrt +".\n", thing );
  return 1;
}

int moving_lock(object thing) {
  if(!::do_lock(all_inventory(thing)))
    return 0;

  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 1 }));
  
  tell_object( thing, "You lock the "+
               (string)dest->call_door( other_id, "query_short" ) +".\n" );
  if (thing->short())
    dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                     " locks the $D.\n", thing );
  return 1;
}

void tell_door(string words, object thing) {
  tell_room(my_room, replace( words, ({
    "$D", shrt, "$p", PRONOUN[how_many], "$s", ({ "s", "" })[how_many] })),
            ({ thing }));
}

/** @ignore yes */ 
mixed *stats() {
  return property::stats() + close_lock::stats() +
         ({ ({ "lock owner", _lock_owner }),
            ({ "other id", other_id }),
            ({ "dest", dest }) });
} /* stats() */ 

// Mask long status from close_lock to accurated describe double doors.
string long_status() {
   string str;
   // If it is stuck in one state don't bother telling us the state.
   if (!query_stuck()) {
      if(query_how_many() > 0)
      {
        str = "They are";
      } 
      else 
      {
        str = "It is";
      }
      switch (query_closed_locked_status()) {
         case CLOSED_LOCKED :
            return str + " closed and locked.\n";
         case CLOSED :
            return str + " closed.\n";
         default :
            return str + " open.\n";
      }
   } else {
      return "";
   }
}
// --- END [/mnt/home2/grok/lib/std/room/basic/door.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/item.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/item.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629575   Available: 13576929
Inodes: Total: 5242880    Free: 4960136
25696 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/item.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629575   Available: 13576929
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: item.c,v 1.18 2001/05/30 01:27:24 presto Exp $
 *
 *
 */
#define DEBUG 1;
#include <parse_command.h>
#include <obj_parser.h>

#define POSITION_SIZE 2
#define POSITION_DESC 0
#define POSITION_MULT 1

private mixed *_lng;
private string *_shrt;
private string *_adjs;
private string *_plu;
private string *_name;
#ifdef DEBUG
private string _creator_room;
#endif
private mapping _verb;
private mapping _plural;
private mapping _other_things;
private mapping _pattern;
private int *_cur_desc;
private mapping _gather;
private mapping _position_stuff;
private mapping _count;

/** @ignore yes */
void init() {
    string name;
    mixed rest;

    foreach (name, rest in _other_things) {
//        if (name != "get") {
            this_player()->add_command(name, this_object(), _pattern[name]);
//        }
    }
} /* init() */

#ifdef DEBUG
string query_creator_room() { return _creator_room; }

void print_stuff() {
    // Debugging function
    printf("lng = %O\nshrt = %O\nadjs = %O\nplu = %O\nname = %O\n" +
      "verb = %O\nplural = %O\nother_things = %O\npattern = %O\n" +
      "cur_desc = %O\ngather = %O\n", _lng, _shrt, _adjs, _plu, _name, _verb,
      _plural, _other_things, _pattern, _cur_desc, _gather);
}
#endif

void create() {
#ifdef DEBUG
    _creator_room = file_name(previous_object());
#endif
    _adjs = ({ });
    _lng = ({ "" });
    _shrt = ({ "" });
    _gather = ([ ]);
    _plu = ({ });
    _name = ({ });
    _verb = ([ ]);
    _plural = ([ ]);
    _pattern = ([ ]);
    _cur_desc = ({ });
    _count = ([ ]);
    _other_things = ([ "smell" : 0, "taste" : 0, "read" : 0 ]);
} /* create() */

/** @ignore yes */
int query_visible( object thing ) { return 1; }

/** @ignore yes */
string hide_invis_string() { return ""; }

/**
 * This method returns the base array of shorts to be processed in the
 * other short methods.  This is the short without the leading
 * 'the', 'a' whatever...
 * @return the array of shorts
 */
string *query_short_array() {
    string *ret;
    int i;

    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ _shrt[i] });
    }
    return ret;
} /* query_short_array() */

/** @ignore yes */
string short() {
    return query_multiple_short(query_short_array());
} /* short() */

/** @ignore yes */
string pretty_short() {
    string *ret;

    ret = query_short_array();
    if (sizeof(ret)) {
        //return ret[ 0 ];
        return query_multiple_short(ret);
    } else {
        return "something";
    }
} /* pretty_short() */

/** @ignore yes */
string a_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:" + add_a( $1 ) + "$" :)), "");
} /* a_short() */

/** @ignore yes */
string the_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " +  $1 + "$" :)), "");
} /* the_short() */

/** @ignore yes */
string one_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
} /* one_short() */

/** @ignore yes */
string poss_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
} /* poss_short() */

/**
 * @ignore 
 * This is used to make the reads of the items not fail.
 */
string query_read_short() {
    return "$name$";
} /* query_read_short() */

/** @ignore yes */
string query_plural() {
    string *ret;
    int i;

    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ pluralize(_shrt[i]) });
    }
    return query_multiple_short(ret);
} /* query_plural() */

/** @ignore yes */
string pretty_plural() {
    int i;

    foreach (i in _cur_desc) {
        return pluralize(_shrt[i]);
    }
    return 0;
} /* query_plural() */

/** @ignore yes */
string long( string name, int dark ) {
    int i;
    string *ret;

    ret = ({ });
    foreach (i in _cur_desc) {
        if ( !_lng[ i ] ) {
            continue;
        }
        if (functionp(_lng[ i ])) {
            ret += ({ evaluate(_lng[ i ]) });
        } else {
            ret += ({ _lng[ i ] });
        }
    }
    if ( !sizeof( ret ) ) {
        return "You don't think that the "+name+" is here.\n";
    }
    return implode( evaluate(ret), "\n")+"\n";
} /* long() */

/*
void set_long(string s) { _lng[_cur_desc] = s; }
string query_long() { return _lng[_cur_desc]; }
 */
/**
 * This returns the currently matching indexes for the item object.
 * @return the array of currently matchig indexes
 */
int *query_cur_desc() { return _cur_desc; }
/**
 * This method returns the verbs mapping used in the item object.
 * @return the verbs in the item object
 */
mapping query_verbs() { return _verb; }
/**
 * This method returns the plurals mapping used in the item object.
 * @return the plurals in the item object
 */
mapping query_plurals() { return _plural; }

/**
 * This method returns all the long descriptions for the item object.  The
 * positions in the array correspond to the index used to reference the
 * items.
 * @return the array of long descriptions
 */
string *query_lng() { return _lng; }
/**
 * This method returns all the short descriptions for the item object.  The
 * positions in the array correspond to the index used to reference the
 * items.
 * @return the array of long descriptions
 */
string *query_shrt() { return _shrt; }

/**
 * This method figures out what gatherables are available for the
 * current description set.  The array contains the values passed
 * into the add_item stuff with the "gather" index.
 * @return the current gatherables
 */
mixed *query_gather() {
    mixed *g = ({ });
    int i;

    foreach (i in _cur_desc) {
        if (_gather[i]) {
            g += ({ _gather[i] });
        }
    }
    return g;
} /* query_gather() */

/** @ignore yes */
int drop() { return 1; }
/** @ignore yes */
int get() { return 1; }

/** @ignore yes */
int query_item(string str) { return _verb[str]; }

/**
 * This method setups all the internal stuff, including the long
 * description.
 * @param bits the bits to look through
 * @param index the index which refers to the item in question
 */
private void setup_bits_for_item(int index, mixed bits) {
    int i;
    string str;
    mixed pat;

    if (!pointerp(bits)) {
        _lng[index] = bits;
        return ;
    }

    _lng[index] = "You see nothing special.\n";
    for (i = 0; i < sizeof(bits); i += 2) {
        /*
         * Figure out what the pattern should be.  We should have apattern
         * specified if the second element of the array is a function
         * pointer, or the array is three long.
         */
        if ((arrayp( bits[i + 1] ) && sizeof( bits[i + 1] ) == 3) ||
          (sizeof( bits[i + 1] ) == 2 && functionp( bits[i + 1][0] ))) {

            pat = bits[i + 1][<1];

            if (!arrayp(pat)) {
                pat = ({ pat });
            }        
        }    
        else {
            pat = ({ "<direct:object>" });
        }

        /* Ok.   Now check the other bits. */
        if (!pointerp(bits[i])) {
            bits[i] = ({ bits[i] });
        }

        /* Go through and add all the relevant data for the bit in. */
        foreach (str in bits[i]) {
            /* The real long description. */
            if (str == "long") {
                _lng[index] = bits[i+1];
            } else if (str == "gather") {
                // I'm not completely certain this is right; I don't
                // quite understand where we are here...
                _gather[index] = bits[i+1];
            } else if (str == "item_count")  {
               if (!_count[index])  _count[index] = bits[i + 1];
            } else if (str == "position" ||
              str == "position multiple") {
                if (!_position_stuff)
                    _position_stuff = ([ ]);
                if (!_position_stuff[index]) {
                    _position_stuff[index] = allocate(POSITION_SIZE);
                }
                if (str == "position") {
                    _position_stuff[index][POSITION_DESC] = bits[i + 1];
                } else {
                    _position_stuff[index][POSITION_MULT] = bits[i + 1];
                }
            } else if (!_other_things[str]) {
                /* A command, hide it away... */
                _pattern[str] = pat;
                _other_things[str] = ([ index : bits[i+1] ]);
            } else {
                if (member_array(pat, _pattern[str]) == -1) {
                    _pattern[str] += pat - (string *)_pattern[str];
                }
                _other_things[str][index]   = bits[i+1];
            }
        }
    }
} /* setup_bits_for_item() */

/**
* This is a helper function for the delete function, it removes everything
* not in the standard static arrays.
* @param index the index to remove
*/
private void remove_bits_for_item(int index) {
    string str;
    string adj;
    mixed value;
    int frog;
    int bing;
    int i;
    int j;

    /* Fix up the gather mapping */
    map_delete(_gather, index);
    foreach (frog, bing in _gather) {
        if (frog > index) {
            map_delete(_gather, frog);
            _gather[frog - 1] = bing;
        }
    }

    /* Fix up the position mapping */
    if (_position_stuff) {
        map_delete(_position_stuff, index);
        foreach (frog, bing in _position_stuff) {
            if (frog > index) {
                map_delete(_position_stuff, frog);
                _position_stuff[frog - 1] = bing;
            }
        }
    }

    /* Fix up the parse_command mapping. */
    foreach (str, value in _other_things) {
        if (value) {
            map_delete(value, index);
            if (!sizeof(value)) {
                map_delete(_other_things, str);
                map_delete(_pattern, str);
            } else {
                foreach (frog, bing in value) {
                    if (frog > index) {
                        map_delete(value, frog);
                        value[frog - 1] = bing;
                    }
                }
            }
        }
    }

    /* Fix up the verbs array */
    foreach (str, value in _verb) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                foreach (adj in value[i]) {
                    j = member_array(adj, _adjs);
                    if (j != -1) {
                        _adjs = _adjs[0..i - 1] + _adjs[i + 1..];
                    }
                }
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
                j = member_array(str, _name);
                if (j != -1) {
                    _name = _name[0..j - 1] + _name[j + 1..];
                }
            }
        }
        _verb[str] = value;
    }

    /* Fix up the plural array */
    foreach (str, value in _plural) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
            }
        }
        _plural[str] = value;
    }
} /* remove_bits_for_item() */

/**
 * This method sets up all the parse command handling stuff that is needed
 * for the given name.
 * @param index the index to associate it with
 * @param name the name to add in 
 * @param no_plural do not add in any plurals
 */
private void add_name_reference(int index, string name, int no_plural) {
    string *bits;
    string plural;
    string s;

    bits = explode(name, " ");
    s = bits[<1];
    if (member_array(s, _name) == -1) {
        _name += ({ s });
    }

    /* First setup the name. */
    if (!_verb[s]) {
        _verb[s] = ({ bits[0..<2], index });
    } else {
        _verb[s] += ({ bits[0..<2], index });
    }

    /* Now setup the plural */
    if (!no_plural) {
        plural = pluralize(s);
        if (member_array(plural, _plu) == -1) {
            _plu += ({ plural });
        }
        if (!_plural[plural]) {
            _plural[plural] = ({ bits[0..<2], index });
        } else {
            _plural[plural] += ({ bits[0..<2], index });
        }
    }

    /* The adjective. */
    _adjs += bits[0..<2];
} /* add_name_reference() */

/**
 * This method setups the item initially.   This is called by the
 * add_item method in the room itself.
 * @param nam the name(s) to add the item for
 * @param long the long description of the item
 * @param no_plural do not add a plural flag
 * @return the index associated with the item
 */
int setup_item(mixed nam, mixed long, int no_plural) {
    int index;
    string str;

    index = sizeof(_lng);
    if (pointerp(nam)) {
        if (sizeof(nam) > 0) {
            _shrt += ({ nam[0] });
            if (no_plural) {
                _plu += ({ "no plural" });
            } else {
                _plu += ({ pluralize(nam[0]) });
            }
        }
        foreach (str in nam) {
            add_name_reference(index, str, no_plural);
        }
    } else {
        _shrt += ({ nam });
        if (no_plural) {
            _plu += ({ "no plural" });
        } else {
            _plu += ({ pluralize(nam) });
        }
        add_name_reference(index, nam, no_plural);
    }

    _lng += ({ 0 });
    setup_bits_for_item(index, long);
    return index;
} /* setup_item() */

/**
 * This method non-destructively modifies the items values.  It will not
 * remove the value for this item, remember this!  If you add again
 * and again you will end up with multiple of the same object.
 * @see /std/room->modify_item_by_name()
 * @param str the name to reference the object by
 * @param long the long bits to change on the item
 * @return 1 on success, 0 on failure
 */
int modify_item_by_index(int index, mixed long) {
    if (index >= sizeof(_lng)) {
        return 0;
    }

    /* Got a match... */
    setup_bits_for_item(index, long);
    return 1;
} /* modify_item_by_index() */

/**
 * This method non-destructively modifies the items values.  It will not
 * remove the value for this item, remember this!  If you add again
 * and again you will end up with multiple of the same object.
 * @see /std/room->modify_item_by_name()
 * @param str the name to reference the object by
 * @param long the long bits to change on the item
 * @return 1 on success, 0 on failure
 */
int modify_item_by_name(string str, mixed long) {
    int index;

    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }

    return modify_item_by_index(index, long);
} /* modify_item_by_name() */

/** @ignore yes */
int modify_item(mixed str, mixed long) {
    if (stringp(str)) {
        return modify_item_by_name(str, long);
    }
    if (intp(str)) {
        return modify_item_by_index(str, long);
    }
    return 0;
} /* modify_item() */

/**
 * This method removes an item by the returned index number from the
 * add_item method.
 * @param index the index number to remove
 * @return 1 on success, 0 on failure
 * @example
 * int _item_number;
 *
 * void bing {
 *    _item_numer = add_item("frog", "It wombles!");
 * } /\* bing() *\/
 * 
 * void remove_bing() {
 *    remove_item(_item_number);
 * } /\* remove_bing() *\/
 */
int remove_item_by_index(int index) {
    if (index >= sizeof(_lng)) {
        return 0;
    }

    _shrt = _shrt[0..index - 1] + _shrt[index + 1..];
    _adjs = _adjs[0..index - 1] + _adjs[index + 1..];
    _lng = _lng[0..index - 1] + _lng[index + 1..];
    _plu = _plu[0..index - 1] + _plu[index + 1..];

    remove_bits_for_item(index);
} /* remove_item_by_index() */

/**
 * This method removes an item by the short description.
 * @param index the index number to remove
 * @return 1 on success, 0 on failure
 */
int remove_item_by_name(string str) {
    int index;

    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }

    return remove_item_by_index(index);
} /* remove_item_by_name() */

/** @ignore yes */
int remove_item(mixed str) {
    if (stringp(str)) {
        return remove_item_by_name(str);
    }
    if (intp(str)) {
        return remove_item_by_index(str);
    }
    return 0;
} /* remove_item() */

/** @ignore yes */
string *parse_command_id_list() { return _name; }
/** @ignore yes */
string *parse_command_plural_id_list() { return _plu; }
/** @ignore yes */
string *parse_command_adjectiv_id_list() { return _adjs; }

// Okay... Sibbis fixed all sorts of small bugs in this... 02/18/1995
//      (BTW: THIS IS UGLY!!!!)
/** @ignore yes */
object query_parse_id(mixed *arr)
{
    string *bits;
    mixed stuff;
    int i, j, match, all_match;

    bits = explode(arr[P_STR], " ");
    bits -= ({ "a", "an", "the" });
    /* all case */
    if (arr[P_THING] == 0)
    {
        stuff = _plural[bits[<1]];
        if (!stuff) {
            stuff = _verb[bits[<1]];
            if (!stuff) {
                return 0;
            }
        }
        _cur_desc = ({ });
        all_match = 0;
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (match) {
                all_match = 1;
                if (member_array(stuff[j+1], _cur_desc) == -1) {
                    _cur_desc += ({ stuff[j+1] });
                }
            }
        }
        if (all_match) {
            return this_object();
        } else {
            return 0;
        }
    }

    /* specific object case */
    if (arr[P_THING] < 0) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }

            if (++arr[P_THING] != 0) {
                continue;
            }

            /* Get the current thingy out of the list */
            if (match) {
                _cur_desc = ({ stuff[j+1] });
                arr[P_THING] = -10321;
                return this_object();
            }
        }
        return 0;
    }

    /* Lots of objects case.   The objects are specified though. */
    stuff = _plural[bits[<1]];
    if (!stuff) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
    }

    _cur_desc = ({ });
    for (j = 0; j < sizeof(stuff); j += 2) {
        match = 1;
        for (i=0;i<sizeof(bits)-1;i++) {
            /*
             * Modified by Deutha to allow reference to "a thing", "an object", etc.
             */
            if ( member_array( bits[ i ], stuff[ j ] ) == -1 ) {
                match = 0;
                break;
            }
        }
        if (match) {
            if (member_array(stuff[j+1], _cur_desc) == -1) {
                _cur_desc += ({ stuff[j+1] });
            }
            arr[P_THING]--;
            if (arr[P_THING] <= 0) {
                arr[P_THING] = -10786;
                return this_object();
            }
        }
    }

    // return this_object();
    return 0;
} /* query_parse_id() */

/** @ignore yes */
mixed* parse_match_object(string* input,
                          object player,
                          class obj_match_context context) {
   int *stuff;
   mixed *plural;
   mixed *sing;
   string *its, *thems;
   string item;
   int i;
   int j;
   int match;
   int ret;

   // debug_printf( "Input: %O\nPlayer: %O\nContext: %O\n", input, player, context );

   if (input[<1] == "here" && sizeof(input) > 1) {
      input = input[0..<2];
   }

   /* context */
   if ( this_object() == context->it &&
        input[<1] == "it" ) {

      sing = ({ });

      its = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));

      foreach( item in its ) {
          if ( arrayp( _verb[ item ] ) ) {
             sing += ({ ({ item }), _verb[ item ][ 1 ] });   
          }
      }

      plural = ({ });
   } else if( input[<1] == "them" &&
              context->plural &&
              member_array( this_object(), context->plural ) != -1) {

      plural = ({ });

      thems = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));

      foreach( item in thems ) {
          if ( arrayp( _verb[ item ] ) ) {
             plural += ({ ({ item }), _verb[ item ][ 1 ] });   
          }
      }

      sing = ({ });
   } else {
      plural = _plural[input[<1]];
      sing = _verb[input[<1]];
   }

   if (!sizeof(plural) && !sizeof(sing)) {
      return 0;
   }

   stuff = ({ });
   //
   // Check sinular matches.
   //
   for (i = 0; i < sizeof(sing); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], sing[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         // debug_printf( "Singular: %O\nStuff: %O\nContext: %O\n", sing, stuff, context );

         if (member_array(sing[i+1], stuff) == -1) {
            stuff += ({ sing[i+1] });
            ret |= OBJ_PARSER_MATCH_SINGULAR;
         }
      }
   }
   //
   // Check plural matches.
   //
   for (i = 0; i < sizeof(plural); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], plural[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(plural[i+1], stuff) == -1) {
            stuff += ({ plural[i+1] });
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }


   if (sizeof(stuff)) {
       //
       // We matched, so see if we should have.
       //
       if (context->ordinal) {
          if (context->ordinal > sizeof(stuff)) {
             context->ordinal -= sizeof(stuff);
             return 0;
          }
          context->ignore_rest = 1;
          context->ordinal--;

          _cur_desc = stuff[context->ordinal..context->ordinal];
       } else if (context->number_included) {
          _cur_desc = stuff[0..context->number_included];
          context->number_included -= sizeof(stuff);
          if (context->number_included <= 0) {
             context->ignore_rest = 1;
          }
       } else if (ret & OBJ_PARSER_MATCH_PLURAL) {
          _cur_desc = stuff;
       } else {
          _cur_desc = stuff[0..0];
       }

       return ({ ret, ({ this_object() }) });
   } else {
      return 0;
   }
} /* parse_match_object() */

/** @ignore yes */
void dest_me() {
    destruct(this_object());
    return ;
} /* dest_me() */

/** @ignore yes */
void dwep() {
    destruct(this_object());
    return ;
} /* dwep() */

/** @ignore yes */
int move() { return 1; }

/** @ignore yes */
int command_control(string command, object *indir, string id_arg,
  string ii_arg, string *args, string pattern) {

    int desc, size, num;
    mixed temp;

    if (!_other_things[command]) {
        return 0;
    }

    size = sizeof(_cur_desc);

    foreach (desc in _cur_desc) {
        temp = _other_things[command][desc];

        if (arrayp(temp)) {
            if (sizeof(temp) == 3 || (sizeof(temp) == 2 && !functionp(temp[0]))) {
                num += call_other(temp[0], temp[1], command, indir, id_arg, 
                  ii_arg, args, pattern);                
            }
            else { 
                if (sizeof(temp) == 2 && functionp(temp[0])) {
                        num += evaluate(temp[0], command, indir, id_arg, ii_arg, 
                            args, pattern);                                
                }    
            }
        }        
        else {
            if (functionp(temp)) {
//                num += evaluate(temp, command, indir, id_arg, ii_arg, args, 
//                    pattern);
                temp = evaluate(temp, command, indir, id_arg, ii_arg, args, 
                    pattern);
            }            
//            else {
            // If we have a string, then we're going to display it to the
            // player. 
            if (stringp(temp)) {
                write(temp);
                num++;
                add_succeeded_mess(({ "", "$N $V $D.\n" }));
            }
            else { 
                // If we got an integer instead, we have to return
                // num. 

                if ( intp( temp ) ) {
                    num += temp;
                }
            }
//            }

        }
    }    

    return num;
} /* command_control() */

/** @ignore yes */
mapping query_other_things() { return _other_things; }

/** @ignore yes */
mapping query_pattern() { return _pattern; }

/** @ignore yes */
string query_position_string(string pos) {
    int i;

    if (!_position_stuff) {
        return 0;
    }

    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_DESC];
        }
    }
    return 0;
} /* query_position_string() */

/** @ignore yes */
int query_position_multiple(string pos) {
    int i;

    if (!_position_stuff) {
        return 0;
    }

    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_MULT];
        }
    }
    return 0;
} /* query_position_multiple() */

/** @ignore yes */
mapping query_position_stuff() { return _position_stuff; }

int query_count()  {
   int i;
   int ret = 0;

   foreach (i in _cur_desc)  {
      ret += evaluate(_count[i]);
   }
   return ret;
}
// --- END [/mnt/home2/grok/lib/std/room/basic/item.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/twilight.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/twilight.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629569   Available: 13576923
Inodes: Total: 5242880    Free: 4960136
7649 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/twilight.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629569   Available: 13576923
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: twilight.c,v 1.2 2000/04/11 19:58:57 drakkos Exp $
 *
 *
 */

/*
 * $Locker:  $
 * $Id: twilight.c,v 1.2 2000/04/11 19:58:57 drakkos Exp $
 *
 * $Log: twilight.c,v $
 * Revision 1.2  2000/04/11 19:58:57  drakkos
 * Fixed an ugly typo.
 *
 * Revision 1.1  1998/11/01 12:02:03  terano
 * Initial revision
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: twilight.c,v 1.2 2000/04/11 19:58:57 drakkos Exp $
 *
 * $Log: twilight.c,v $
 * Revision 1.2  2000/04/11 19:58:57  drakkos
 * Fixed an ugly typo.
 *
 * Revision 1.1  1998/11/01 12:02:03  terano
 * Initial revision
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: twilight.c,v 1.2 2000/04/11 19:58:57 drakkos Exp $
 *
 * $Log: twilight.c,v $
 * Revision 1.2  2000/04/11 19:58:57  drakkos
 * Fixed an ugly typo.
 *
 * Revision 1.1  1998/11/01 12:02:03  terano
 * Initial revision
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
/*
 * $Locker:  $
 * $Id: twilight.c,v 1.2 2000/04/11 19:58:57 drakkos Exp $
 *
 * $Log: twilight.c,v $
 * Revision 1.2  2000/04/11 19:58:57  drakkos
 * Fixed an ugly typo.
 *
 * Revision 1.1  1998/11/01 12:02:03  terano
 * Initial revision
 *
 * Revision 1.1  1998/01/15 01:37:46  ceres
 * Initial revision
 *
*/
// This (hopefully) will cause the long of the room to work (correctly and
// constantly), along with appropriate add_items.
//
// Functions:
//   int add_day_item( mixed shorts, mixed desc, mixed no_plural ) 
//      These items are visible only by day.
//   int add_night_item( same as above )
//      These items are visible only by night.
//   void set_day_long( string long )
//      The long of the room during day.
//   void set_night_long( string long )
//      The long of the room during the night, and when the player has light
//      to see by.
//   void room_day_chat( mixed *chats ), room_night_chat( mixed *chats )
//      The chat that pops up during the day and night, respectively.
//      Either use these or use room_chat( mixed *chats ), BUT NOT BOTH!
//      IE:  No room_day_chat( chats ) and room_chat( chats ).  Bad stuff
//      happens.  (Well, not bad, but just not what you want.)
//   int query_time()
//      Returns last_updated.  0 = NIGHT, 1 = DAY.
//
// Functions to define in your room: (Optional)
//   void changing_to_day( int just_cloned ) {...}
//   void changing_to_night( int just_cloned ) {...}
//      These functions are called whenever day turns to night or night turns
//      to day.  Just_cloned is an integer which is always either 0 or 1.  
//      The only time that it's 1 is when the room is just cloned.  This helps
//      avoid silly messages: IE: If you have a room that has an NPC which is
//      to be in the room only during the day, you don't want a "The NPC 
//      leaves the room." message if the room is cloned during the night and
//      the changing_to_night() function is called.  Unfortunately, it takes
//      a second or two for this function to be called after the room is
//      created. 
//
// This function is handled by /std/outside.c and others...
//   add_item( string|string* item, string|string* desc, int noplural )
//      Works as normal.  These items will appear day or night.
//   set_dark_mess( string long )
//      The long of the room if it's too dark.
//   set_bright_mess( string long )
//      The long of the room if it's too bright.

#include <twilight.h>
#include <climate.h>

int last_updated;
mixed roomitems;
string *roomlong;
mixed roomchats;
object shadowed_obj;

void set_current_long();
string return_long( mixed desc );
void do_change();
void change( int time_now );

void create() {
  seteuid( (string)"/secure/master"->creator_file( file_name(
    this_object() ) ) );
}

void destruct_shadow( object thing ) {
  if( thing == this_object() )
    destruct( thing );
  else
    thing->destruct_shadow( thing );
}

void setup_shadow( object this_room ) {
  shadow( this_room, 1 );

  shadowed_obj = this_room;
  
  if( WEATHER_HANDLER->query_day() ) {
    call_out( "changing_to_day", 0, 1 );
    last_updated = DAY;
  } else {
    call_out( "changing_to_night", 0, 1 );
    last_updated = NIGHT;
  }
  roomitems = ({ ({ }), ({ }) });
  roomlong = allocate( 2 );
  roomlong = ({ 0, 0 });
  roomchats = allocate( 2 );
  // Tell the WEATHER_HANDLER that this room wants to be notified.
  WEATHER_HANDLER->weather_notify( this_room, NOTIFY_DAY );
}

// This is a possibly temporary thing to periodically look at the time.
void event_weather(int whats_changed) {
  if (WEATHER_HANDLER->query_day()) {
    if (last_updated == NIGHT) 
      change( DAY );
  } else if (last_updated == DAY)
    change( NIGHT );

  shadowed_obj->event_weather( whats_changed );
}

void change( int time_now ) {
  int i;
  
  /* Time to update the room. */
  last_updated = time_now;
  set_current_long();
  
  /* Turn on/off items */
  /* Changed by Presto 12/20/97 */
  for ( i = 0; i < sizeof( roomitems[ last_updated ] ); i += 2 )  {
    shadowed_obj->modify_item( roomitems[ last_updated ][ i ],
                               roomitems[ last_updated ][ i + 1 ] );
  }
  for ( i = 0; i < sizeof( roomitems[ 1 - last_updated ] ); i += 2 )  {
    if ( member_array( roomitems[ 1 - last_updated ][ i ],
                       roomitems[ last_updated ] ) == -1 )  {
      shadowed_obj->modify_item( roomitems[ 1 - last_updated ][ i ],
                                 "You can't see that now.\n" );
    }
  }
  
  /* New room chats */
  /* Changed by Presto 12/20/97 */
  shadowed_obj->stop_room_chats();
  if( sizeof(roomchats[last_updated]) )
    shadowed_obj->room_chat( roomchats[last_updated] );
  
  /* Tell the room that the time has changed. */
  if( last_updated == DAY )
    shadowed_obj->changing_to_day( 0 );
  else
    shadowed_obj->changing_to_night( 0 );
}

void set_day_long( string str ) {
  roomlong[DAY] = str;
  set_current_long();
}

void set_night_long( string str ) {
  roomlong[NIGHT] = str;
  set_current_long();
}

void set_current_long() {
  if (roomlong[last_updated] != 0 && roomlong[last_updated] != "")
    shadowed_obj->set_long( roomlong[last_updated] );
}

varargs int add_day_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;

  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;

  roomitems[DAY] += ({ the_item, return_long( desc ) });

  if( last_updated == DAY ) 
    return this_object()->add_item( shorts, desc, no_plural );
  
  return 1;
}

varargs int add_night_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;
  
  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;

  roomitems[NIGHT] += ({ the_item, return_long( desc ) });
    
  if( last_updated == NIGHT ) 
    return shadowed_obj->add_item( shorts, desc, no_plural );
  return 1;
}

void room_day_chat( mixed *args ) {
  roomchats[DAY] = args;
  if( last_updated == DAY )
    shadowed_obj->room_chat( args );
}

void room_night_chat( mixed *args ) {
  roomchats[NIGHT] = args;
  if( last_updated == NIGHT )
    shadowed_obj->room_chat( args );
}

/* Returns the long part of the description. */
string return_long( mixed desc ) {
  int ma;

  if( !pointerp( desc ) )
    return (string)desc;

  ma = member_array( "long", desc );
  if( ma < 0 )
    return "Error: No long found.";
  
  return (string)desc[ma+1];
}

int query_time() { return last_updated; }
mixed query_roomitems() { return roomitems; }
string *query_roomlong() { return roomlong; }
mixed query_roomchats() { return roomchats; }
// --- END [/mnt/home2/grok/lib/std/room/basic/twilight.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/situation_changer.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/situation_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629567   Available: 13576921
Inodes: Total: 5242880    Free: 4960136
27923 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/situation_changer.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629567   Available: 13576921
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <am_time.h>
#include <situations.h>

#define RANDOM(a,b) ("/obj/handlers/random_num.c"->random(a,b))
/**
 * situation changer object associated with a room object.
 */

class situation_timing { 
  mixed label;
  mixed duration;
  mixed when;
  int chance;
  int *endat;
  mixed background;
  mixed category;
  int it;
  mapping it_data;  
}

nosave int offset;
nosave string *els;
nosave mixed *currentsits,*autosits;
nosave mapping sitdata;
nosave mapping sitwords;
nosave class situation_timing *sittiming;
/* By default chat fairly frequently (1-2 minutes) because
 * these situations will not necessarily be around that long */
nosave int chatmin=60,chatmax=120;
nosave object ownerroom;
nosave int automate=0; /* 0=no, 1=yes, 2=sleeping */
nosave mixed cco; /* cco[0] = last handle, cco[i] = call_outs for handle i>0 */

varargs mixed change_situation( mixed label, mixed duration,  
  mixed words, mixed handle );

object set_room(object room_o) { 
  //  tell_creator("shaggy","Room set: %O %O %O\n",room_o,this_object(),previous_object()); 
  ownerroom=room_o;
  return this_object();
}

object query_room() { return ownerroom; }
/** 
 * This function selects word replacements for #n in the text.
 * @param label Situation label to choose for
 * @param choice A random seed (integer) or
 *               a set of pairs exactly the same as the second
 *               argument to replace.
 * @see replace
 * @example
 *      choose_words( "frog", ({ "#1", "tadpole", "#2", "pond" }));
 */
void choose_words( mixed label, mixed choice )
{
  int i;
  class situation sit;
  string *wc;

  sit = sitdata[ label ];
  if (sizeof(sit->random_words)) {
    if (!sitwords) sitwords= ([ ]);

    if (intp(choice)) {
      wc=({ });
      for (i=0;i<sizeof(sit->random_words);i++) {
        wc+=({ "#"+(i+1),
          ((sit->random_words)[i])[
          RANDOM(sizeof((sit->random_words)[i]),choice+i*3347483647)] });
      }
      sitwords[label] = wc;
    }
    else 
      sitwords[label] = choice;
  }
}

/** 
 * Replaces #1 in text with the one of the first array of words in wordlist
 * and #2 with one of the second array of words and so on...
 * Each string in the string array is changed.
 */
string *insert_words_chats(class situation sit, string *words) {
  string *outarray=({ });
  string s1;

  if (!sizeof(sit->chats)) return ({ });
  foreach (s1 in sit->chats) outarray+= ({ replace(s1,words) });
  return outarray;
}

/** 
 * Replaces #1 in text with the one of the first array of words in wordlist
 * and #2 with one of the second array of words and so on...
 * For items only the item text is changed, not the key words.
 */
mixed *insert_words_items(class situation sit, string *words) {
  mixed *outarray=({ });
  mixed ai,e0,e1;

  if (!sizeof(sit->add_items)) return ({ });
  foreach (ai in sit->add_items) {
    if (sizeof(ai)>=2) {
      e0=ai[0];
      if (arrayp(e0)) e0=explode(lower_case(replace(implode(e0,"|"),words)),"|");
      else e0=lower_case(replace(e0,words));
      e1=ai[1];
      if (arrayp(e1)) e1=explode(replace(implode(e1,"|"),words),"|");
      else e1=replace(e1,words);
      ai = ({ e0,e1 })+ai[2..];
    }
    outarray+= ({ ai });
  }
  return outarray;
}

/** 
 * returns status of situation manager.  
 * If it is sleeping it will turn on again if a
 * player enters the room.
 * @return status 0 off 1 on 2 sleeping
 */
int query_status() { return automate; }

/** 
 * returns situations currently turned on.
 * @return int array of situation labels
 */
int *query_current_situations() { return ({ currentsits, autosits }); }

/** 
 * returns sittiming class with info about automated situations 
 * @return class sittiming
 */
mixed *query_sittiming() { return sittiming; }

/** 
 * returns mapping of situations. 
 * @return mapping of situations
 */
mapping query_situations() { return sitdata; }

void dest_me() {
  destruct(this_object());
} /* dest_me() */

/** @ignore yes */
int clean_up( int parent ) {
/* Clones of this object are pointless without a room to manage. */
  if (parent) {
    return 0;
  }
  return 1;
} /* clean_up() */

/**
 * Adds a situation to the room.  These situations can be
 * invoked manually with start_situation or automatically via
 * automate_situation.
 * @param label string or number labelling the situation
 * @param sit a structure (class) containing all the bits
 * of the situation you want to add.
 * eg. 
 * start_func function to be called at start of situation 
 *             that might be used to load NPC's or anything
 *             beyond a message.
 * 
 *             The start function is passed the label, 
 *             a do_start_mess flag and the room object.  
 *             If the flag is 1 the situation is starting 
 *             rather than being reloaded.  Thus if 
 *             do_start_mess is 0 then you should avoid
 *             any obvious start messages and make it look
 *             like the situation is already underway.
 *
 * end_func function to be called an the end of a situation.  
 *             The end function is only
 *             passed the label and the room object.
 *
 * start_mess message told to the room at start of situation
 *
 * end_mess message told to the room at end of situation
 *
 * extra_look extra look string appended to rooms long 
 *             during the situation
 *
 * chats an array of chat strings to be active 
 *             during the situation 
 *
 * add_items a mixed array of ({ item, item description }) 
 *             pairs to be active during the situation
 *
 * random_words sets of words of the form ({ ({ "option1","option2" }),
 *             ({ "adjective1","adjective2" }), ... }).  One of the
 *             the first set replaces #1 in any text above and one of
 *             the second set replaces #2 in any text above and so on.
 *             The random choice is fixed for the duration of any one
 *             situation.
 *
 * @see start_situation
 * @see automate_situation
 * @see add_item
 * @see room_chat
 * @see add_extra_look
 * @example
 * #include <situations.h>
 *
 * class situation frogs;
 * frogs = new(class situation, 
 *     start_mess: "Water seeps out of the ground to form puddles.",
 *     extra_look: "There are large puddles on the ground here.",
 *     chats: ({"A hidden frog croaks quietly.",
 *              "There is a blooping sound." }),
 *     add_items:({ ({"puddle", "The puddles are dark and murky.  " 
 *                    "They will probably dry up given time." }) }) );
 * add_situation( "frogs", frogs );
 * @example
 * add_situation( "frogs", new(class situation, 
 *      start_mess: "Water seeps out of the ground to form puddles.",
 *      extra_look: "There are large puddles on the ground here.",
 *      chats: ({"A hidden frog croaks quietly.",
 *               "There is a blooping sound." }),
 *      add_items: ({ ({"puddle", "The puddles are dark and murky.  " 
 *                      "They will probably dry up given time." }) }) ));
 */
void add_situation( mixed label, class situation sit ) {
  if (!sizeof(sitdata)) {
    sitdata= ([ label : sit ]);
    sitwords= ([ ]);
  }
  else {
    sitdata+= ([ label : sit ]);
  }
}

/**
 * Starts a situation previously added to the room
 * that is managed by this object.
 * These situations can be invoked manually with 
 * start_situation or automatically via
 * automate_situation. 
 * @param label string or number labelling the situation
 * @param do_start_mess 0 to supress the start_mess string
 *        This is to fake it that a situation has been 
 *        going for a while when really you just loaded it.
 * @see add_situation
 * @see end_situation
 * @see automate_situation
 */
void start_situation(mixed label, int do_start_mess) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;
  
  sdata=sitdata[ label ];
  words=sitwords[ label ];
  //  tell_creator("shaggy","label starting: %O\n",label);
  
  if (!currentsits) currentsits=({ label });
  else currentsits=currentsits+({ label });

  //  tell_creator("shaggy","Start seed: %O\n",seed);

  if (sizeof(sdata->extra_look)) {
    if (els && sizeof(els)) 
      els+=({ replace(sdata->extra_look,words) });
    else { 
      els=({ replace(sdata->extra_look,words) });   
      ownerroom->add_extra_look(this_object()); 
    }
  }
  if (do_start_mess && sizeof(sdata->start_mess)) 
    tell_room(ownerroom, replace(sdata->start_mess,words)+"\n");
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats)) {
    //    tell_creator("shaggy","Adding: %O %O %O\n",sdata->chat_rate,chats,ownerroom->query_chatter());
/* Note we use the old chatter because it is more efficient unless
   we know for certain that we need chats with different rates 
   in which case we use the multichatter 
*/
    if (!(chatter=ownerroom->query_chatter())) {
      if (sdata->chat_rate) {
        ownerroom->room_chat( ({ chatmin,chatmax, ({ }) }),
                      clone_object("/std/room/basic/multichatter")  );  
        chatter=ownerroom->query_chatter();
        chatter->setup_chatter( ownerroom,
        ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
      } else {
        ownerroom->room_chat( ({ chatmin,chatmax, chats }) );
        chatter=ownerroom->query_chatter();
      }
      chatter->check_chat();
    } else {
      if (sdata->chat_rate) {
        if (!(chatter->query_multichatter())) {
          mixed *args;
          args=(chatter->query_room_chats())[0..2];
          chatter->dest_me();
          ownerroom->room_chat( args,
                        clone_object("/std/room/basic/multichatter")  );  
          chatter = ownerroom->query_chatter();
        }
        chatter->setup_chatter( ownerroom,
          ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
        chatter->check_chat();
      }
      else chatter->add_room_chats(chats); 
    } 
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) { 
      ownerroom->add_item(item[0],item[1]);
      //      tell_creator("shaggy","Adding item: %O:%O\n",item[0],item[1]);
    }
  }
  if (sdata->start_func) { /* functionp */
    (*(sdata->start_func))(label,do_start_mess,ownerroom);
  }
} /* start_situation() */

/**
 * Ends a situation previously added and started on the room
 * that is managed by this object.
 * These situations can be invoked manually with start_situation 
 * or automatically via automate_situation. 
 * @param label string or number labelling the situation
 * @see add_situation
 * @see start_situation
 * @see automate_situation
 */
void end_situation(mixed label) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;

  sdata=sitdata[ label ];
  words=sitwords[ label ];
//  tell_creator("shaggy","label ending: %O\n",label);

  if (currentsits) currentsits=currentsits-({ label });
  if (els && sizeof(sdata->extra_look)) { 
    els-=({ replace(sdata->extra_look,words) });
    if (!sizeof(els)) ownerroom->remove_extra_look(this_object());
  }
  
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats) && (chatter=ownerroom->query_chatter())) {
    //tell_creator("shaggy","Removing: %O\n",chats);
    chatter->remove_room_chats(chats);
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) {
      if (arrayp(item[0])) 
        ownerroom->remove_item((item[0])[0]);
      else 
        ownerroom->remove_item(item[0]);
      //        tell_creator("shaggy","Removing item: %O:%O\n",item[0],item[1]);
    }
  }
  if (sizeof(sdata->end_mess)) 
    tell_room(ownerroom,replace(sdata->end_mess,words)+"\n");
  if (sdata->end_func) { /* functionp */
    (*(sdata->end_func))(label,ownerroom);
  }
} /* end_situation() */
  
/**
 * Starts one or more situations that will end after a
 * specified duration.  You can use an array and make
 * further situations commence when others end.
 * @param label (mixed) label of the situation to start 
 *  up.  If you pass an array such as ({ "frog1", "frog2" }) for the 
 * label then that set of situations are started one at
 * a time and the total duration is split evenly between them.
 * Label is usually an integer or a string or an array of
 * integers and/or strings.
 * If the string is a list of labels
 * separated by , then multiple situations
 * are started using those labels.
 * @param duration (int) total time (seconds) the overall situation 
 * should last.  You can put an array of durations -- one for each
 * situation if the label lists more than one situation and then
 * the overall time is the sum of the numbers.
 * -1 means indefinite so having any situations after
 * something with -1 duration is pointless.
 * @param handle is an internal thing that should only be called with 0
 * unless you really know what you are doing.
 * @param words is a list of replacements for #n in the text OR
 *        a random number seed, it is
 *        passed to choose_words.
 *        eg. ({ "#1", "frog", "#2", "honey" }) or 22
 * @return call_out that is propogating the changes
 * This is useful if you want to be able to kill the whole
 * set without disturbing other situations.
 * @see start_situation
 * @see end_situation
 * @see add_situation
 * @see choose_words
 */
varargs mixed change_situation( mixed label, mixed duration, 
     mixed words, mixed handle  ) {
  mixed frog,bing;
  mixed ending;

//  tell_creator("shaggy","CHANGE: %O %O\n",label,duration);

  if (!cco) cco=({ 1, 0 });
  if (!handle) {
    handle=member_array(0,cco[1..<1])+1;
    if (!handle) { 
      cco+=({ 0 });
      handle=sizeof(cco)-1;
    }
  }
  cco[0]=handle;

  if (!duration) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    foreach(bing in frog) end_situation(bing);
    cco[handle]=0;
    return 0;
  }
  if (!arrayp(duration)) {
    if (arrayp(label)) {
      bing=duration/sizeof(label);
      duration=({ });
      foreach (frog in label) duration+=({ bing });
    }
    else duration=({ duration });  
  }  

  if (arrayp(label) && sizeof(label)>1 && sizeof(label)>sizeof(duration)) {
    frog=label[0];
    if (stringp(frog)) ending=explode(frog,",");
    else ending=({ frog });
    label=label[1..<1];
  } 

  if (sizeof(duration)==1) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    if (ending) {  
      ending-=frog;
      foreach(bing in ending) end_situation(bing);
    }
    if (currentsits) frog=frog-currentsits;
    foreach(bing in frog) {
      if (!sizeof(words)) choose_words( bing, time()*335423611 );
      else choose_words( bing, words );
      start_situation(bing,1);
    }
    if (duration[0]!=-1) 
      cco[handle]=call_out("change_situation",duration[0],
                           label,0,words,handle);

    return handle;
  }
  if (arrayp(label)) frog=label[0];
  else frog=label;
  if (stringp(frog)) frog=explode(frog,",");
  else frog=({ frog });
  if (ending) {  
    ending-=frog;
    foreach(bing in ending) end_situation(bing);
  }
  if (currentsits) frog=frog-currentsits;
  foreach(bing in frog) start_situation(bing,1);
  if (duration[0]!=-1) 
    cco[handle]=
    call_out("change_situation",duration[0],
             label,duration[1..<1],words,handle);

  return handle;
} /* change_situation */

int query_possible(class situation_timing sit, int it, int tod, int cnt) 
{
  int possible;
  class situation_timing sit2;
  int cnt2,it2,tod2,possible2;

  if (functionp(sit->when)) possible=(*(sit->when))(tod);
  else possible=sit->when;

  possible=
    (possible&(1<<((AM_TIME_HANDLER)->query_am_hour(tod))))
    &&
    (RANDOM(1000,it*1147483647+cnt*2047483243) < sit->chance);
  //  tell_creator("shaggy","trying %O (%O %O %O %O %O %O)\n",sit->label,possible,sit->when,(1<<((AM_TIME_HANDLER)->query_am_hour(tod))),RANDOM(1000,it*1147483647+cnt*2047483243),tod,it);
  //    tell_creator("shaggy","trying %O %O %O %O %O %O\n",time(),t,offset,ttmp,tod,it);
  if (possible && sit->category) {
    /* If it is a member of a category we must check that there
       are no others of the category going first */
    cnt2=0;
    foreach (sit2 in sittiming) {
      cnt2++;
      if (cnt2!=cnt && sit2->category == sit->category) {
	it2=(tod+offset+(cnt2*234231))/sit2->duration;
	tod2=it2*sit2->duration-offset-(cnt2*234231);
	if (functionp(sit2->when)) possible2=(*(sit2->when))(tod2);
	else possible2=sit2->when;
	possible2=
	  (possible2&(1<<((AM_TIME_HANDLER)->query_am_hour(tod2))))
	  &&
	  (RANDOM(1000,it2*1147483647+cnt2*2047483243) < sit2->chance);
	//	tell_creator("shaggy","Comparing %O (%O %O %O %O %O %O)\n",sit2->label,possible2,sit2->when,(1<<((AM_TIME_HANDLER)->query_am_hour(tod2))),RANDOM(1000,it2*1147483647+cnt2*2047483243),tod2,it2);
	if (possible2 && (tod2<tod || (tod==tod2 && cnt2<cnt))) {
	  possible=0;
	  break;
	}
      }
    }
  }

  return possible;

} /* query_possible() */

/**
 * Starts and ends situations according to the information
 * in the sittiming array.  It is called continuously 
 * automatically while there are interactives in the room.
 */
void manage_situations() {
  class situation_timing sit;
  int t,t0,it,tod,cnt,possible,dt,tc,i;
  mixed label,lb;
  mixed *newsits;
  mixed *changes;
  mixed *background_on,*background_off; /* background situations */
  int ttmp,tstep;

//  tell_creator("shaggy","Managing: %s %O\n",ownerroom->query_short(),sittiming);

  if (!automate) return;
  if (!sizeof(filter_array( all_inventory( ownerroom ),(: interactive($1) :)))) {
    automate=2;
    return;
  }
  //  tell_creator("shaggy","Time %O\n",time());
  t0=time()+offset;
  newsits=({});
  tstep=2147483648;
  background_on=({ });
  background_off=({ });

  cnt=0;
  foreach (sit in sittiming) {
    cnt++;
    t=t0+(cnt*234231);
    ttmp=sit->duration;
    it=t/ttmp;
    /* time of day it started */
    tod=it*ttmp-offset-(cnt*234231);

    /* possible values cached in it_data mapping */
    possible=sit->it_data[ it ];

    /* If it's not in cache -- work it out */
    if (undefinedp(possible)) {
      possible=query_possible(sit, it, tod, cnt);
      sit->it_data[ it ]=possible;
      if (!undefinedp(sit->it_data[ it-1 ])) 
	map_delete(sit->it_data,it-1);
    } else {
      //      tell_creator("shaggy","Test for %O cached %O\n",sit->label,possible);
    }

    if (possible) {
      if (sit->background) background_off+=explode(sit->background,",");
      if (arrayp(sit->label)) {
	//      label=(sit->label) [((t % ttmp)*sizeof(sit->label))/tmp];
	dt=(t % ttmp); 
	i=0;
	foreach (tc in sit->endat) {
	  if (tc>dt) break;
	  i++; 
	} 
	label=(sit->label)[i];
	ttmp=tc-dt;
      }
      else label=sit->label;
      
      if (stringp(label)) {
	label=explode(label,",");
	newsits=newsits+label;
	foreach(lb in label) choose_words(lb,it*1147483647+cnt*2047555777);
      }
      else { 
	newsits=newsits+({ label });
	choose_words(label,it*1147483647+cnt*2047555777);
      }
    }
    else {
      if (sit->background) background_on+=explode(sit->background,",");
      /* pretest next possible time to avoid retesting every situation,
	 every time one of them might start */
      /* possible values cached in it_data mapping */
      possible=sit->it_data[ it+1 ];
      /* If it's not in cache -- work it out */
      if (undefinedp(possible)) {
	possible=query_possible(sit, it+1, tod+sit->duration, cnt);
	sit->it_data[ it+1 ]=possible;
	if (!undefinedp(sit->it_data[ it-1 ]))
	  map_delete(sit->it_data,it-1);
      }
      if (possible) 
	ttmp=ttmp-(t % ttmp); 
      else 
	ttmp=2*ttmp-(t % ttmp);
    }

    if (ttmp<tstep) tstep=ttmp;
  }
   
  //  tell_creator("shaggy","newsits: %O tstep: %O t: %O/%O \n",newsits,tstep,dt,tc);

  call_out("manage_situations",tstep+1);

  newsits = newsits+(background_on-background_off);

  if (autosits && sizeof(autosits)) {
    changes=autosits-newsits;
    if (sizeof(changes)) { 
      foreach(label in changes) end_situation(label);
      autosits=autosits-changes;
    }
    changes=newsits-autosits;
  }
  else changes=newsits;
  if (sizeof(changes)) {
    foreach(label in changes) start_situation(label,2-automate);
    if (autosits) autosits=autosits+changes; 
    else autosits=changes;
  }

  automate=1;
} /* manage_situations() */

/**
 * Tests for enabling situation managing.
 * If situation managing is already active or turned off
 * it does nothing.
 * @see automate_situation
 */
void check_situations() {
  if (automate==2 && interactive(this_player())) manage_situations();
}

/**
 * Makes a seed value for the random part of when 
 * situations turn on and off.  The two ints must be 
 * constant for a given room -- like the coordinates.
 * @param xval integer to use to make a seed (eg. x coordinate)
 * @param yval integer to use to make a seed (eg. y coordinate)
 */
void make_seed(int xval, int yval) {
  /* The >>2 makes time() + offset always positive */
  offset=(xval*38547+yval*1232444311)>>2;
} /* set_seed() */

/**
 * Automate starting and ending of a situations.
 * These situations can be invoked manually with start_situation.
 * The automated starting and ending is unaffected by the room 
 * unloading.  When the room reloads the situation will be 
 * restarted unless its duration is up.
 * You must include the file situations.h for the definitions
 * of the when masks.
 * @param label (mixed) label of the situation to start 
 *  up.  If you pass an array such as ({ "frog1", "frog2" }) for the 
 * label then that set of situations are started one at
 * a time and the total duration is split evenly between them.
 * Label is usually an integer or a string or an array of
 * integers and/or strings.
 * If the string is a list of labels
 * separated by , then multiple situations
 * are started using those labels.
 * @param duration (int) total time (seconds) the overall situation 
 * should last.  If an array is specified for duration each
 * situation gets it's own little one.  If -1 is specified as
 * a duration for one part that situation is background complimentary
 * situation to the rest that is on when the rest are off.
 * @param when (int) a time of the day mask.  This limits when
 * the situation is allowed to occur.  The mask is composed of
 * the allowed hours in AM time ( 24 hours clock, (1<<hour) and 
 * combined with | (OR) ).   You can just use these
 * predefined masks and ingore how it works:
 *  WHEN_WEE_HOURS, WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_AFTERNOON
 *  WHEN_EVENING, WHEN_LATENIGHT, WHEN_MIDDAY, WHEN_MORNING, 
 *  WHEN_EARLY_MORNING, WHEN_LATE_MORNING, WHEN_NIGHT, WHEN_DAY
 *  WHEN_ANY_TIME    
 * The masks are defined in /include/situations.h.
 * @param chance  (int) chance in 1000 of starting the situation
 *  This is tested every duration seconds.
 * @see add_situation
 * @see start_situation
 * @see end_situation
 * @see evolvingroom.h
 * @example
 * #include <situations.h>
 *
 *  automate_situation( "frog", 300, WHEN_ANY_TIME, 200 );
 *
 * This will automatically start the situation labelled "frog" 
 * at a random time that is any time of the day with a 200/1000
 * chance of it starting per 300 seconds.  It will last for
 * 300 seconds (5 minutes).  
 * @example
 *  automate_situation( ({"frog1","frog2"}), 240, WHEN_EVENING|WHEN_NIGHT,
 * , 300 );
 *
 * This will automatically start a situation that is a combination 
 * of "frog1" followed by "frog2" at a random time but only in the
 * evening or at night.  There will be a 300/1000 chance of it 
 * starting per 240 seconds.  Both the "frog1" and "frog2" 
 * situations will get half the total time (as there are two),  
 * 120 seconds each, for a total duration of 240 seconds (4 minutes).
 */
void automate_situation( mixed label, mixed duration, mixed when, mixed chance,
     mixed category ) {
  mixed chatargs,endat,background,labels;
  int i,d;
  string ook;

//  tell_creator("shaggy","Automating %O\n",label);

  if (!offset) {
    //    tell_creator("shaggy","automate_sit: %O %O %O\n",ownerroom,this_object(),previous_object()); 
    ook=file_name(ownerroom);
    if (!ook || ook=="") {
      write( "Bad file name" );
      return;
    }
    /* generate a seed value that is all the characters in the
       filename multiplied together:  not wonderful but you
       can specify your own with situation_changer_seed */
    offset=1;
    foreach (i in ook) offset*=i;
    /* The >>2 makes time() + offset always positive */
    offset=(offset>>2)+1;
    
  }    
  if (ownerroom->query_chatter()) {
    chatargs=(ownerroom->query_chatter())->query_room_chats();
    if (sizeof(chatargs)==3) {
      chatmin=chatargs[0];
      chatmax=chatargs[1];
    }
  }

  endat=({ });
  if (arrayp(duration)) {
    if (!arrayp(label) || sizeof(duration)!=sizeof(label)) {
      write("Duration must be an array of the same length as label");
      return;
    }
    d=0;
    labels=({ });
    for (i=0;i<sizeof(duration);i++) {
      if (duration[i]!=-1) { 
	d+=duration[i]; /* -1 means infinite duration background situation */
        endat+=({ d });
	labels=labels+({ label[i] });
      }
      else {
	if (background) background=implode(explode(background,",")+({ label[i] }),",");
        else background=label[i];
      }
    }
  } else {
    labels=label;
    d=duration;
    if (arrayp(label)) {
      for (i=0;i<sizeof(label);i++) {
        endat+=({ ((i+1)*duration)/sizeof(label) });
      }
    } else {
      endat=({ duration });
    }
  }
  //  tell_creator("shaggy","%O endat %O\n",label,endat);

  if (!sittiming) 
    sittiming=
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  else 
    sittiming=sittiming+
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  automate=2; /* start sleeping */
} /* automate_situation() */

/**
 * Shuts down all current and pending situations.  It also turns off the
 * automated situation manager so no more are added.  It does not
 * destruct this object so all the add_situations are still loaded
 * and may be recommenced with automate_situation or change_situation.  
 * dest_me is the appropriate call to permanently remove all situations.
 * @see automate_situation
 * @see change_situation
 */
void shutdown_all_situations() {
  int label;
  mixed h;

  if (sizeof(cco)>1) {
    foreach (h in cco[1..<1]) {
       if (h) remove_call_out(h);
    }
  }
  cco=({ 0 });
  if (currentsits && sizeof(currentsits)) {
    foreach(label in currentsits) end_situation(label);
  }
  autosits=0;
  automate=0;
} /* shutdown_all_situations() */

/**
 * Shuts down a change_situation based on the call_out handle
 * returned by the call to change_situation.
 * @param handle call_out handle.  If 0 then the last
 * known handle is used.
 * @param label label or array of labels of situations to clean 
 * up with end_situation
 * @param the_room the room
 * @see automate_situation
 * @see change_situation
 */
void shutdown_situation(int handle, mixed label) {
  mixed frog,bing;

  if (sizeof(cco)) {
    if (!handle) handle=cco[0];
    if (handle && cco[handle]) remove_call_out(cco[handle]);
    cco[handle]=0;
  }

  if (arrayp(label)) { 
    frog=({ });
    foreach(bing in label) {
      if (stringp(bing)) frog+=explode(bing,",");
      else frog+=({ bing });
    }
  }
  else if (stringp(label)) label=explode(label,",");
  else label=({ label });

} /* shutdown_sit uation() */

string extra_look() {
  if (!els || !sizeof(els)) {
    return "";
  }
  return implode(els,"  ")+"\n";
} /* add_extra_look() */
// --- END [/mnt/home2/grok/lib/std/room/basic/situation_changer.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/situation_changer_handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/situation_changer_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629560   Available: 13576914
Inodes: Total: 5242880    Free: 4960136
1813 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/situation_changer_handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629560   Available: 13576914
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <situations.h>

/* This is a changer and handler rolled into one.  The base
   object stores all the situations and the clones of it
   point its sitdata for theirs. 

   The situations for the base object may be setup
   using the setup_situations function which is only
   called on the base, not the clones.  Otherwise
   you can call add_situations as usual but you its good
   to check that the room's changer is not a clone first.
    */ 

inherit "/std/room/basic/situation_changer";

void add_situation( mixed label, class situation sit ) {
  if (!clonep()) ::add_situation( label, sit );
  else write("You can't add situations to a clone of this object.");
}

/* The base object will be used to manage a room */
object set_room(object room_o) { 
  //  tell_creator("shaggy","set room on %O\n",this_object());

  if (clonep() ) {
    object base;

    base = find_object(base_name(this_object()));
    if (!base) {
      (base_name(this_object()))->parp();
      base = find_object(base_name(this_object()));
    }
    //    if (!base) tell_creator("shaggy","%O just wouldn't load!\n",base_name(this_object()));
    
    if (!(base->query_room())) {
      //      tell_creator("shaggy","Using %O instead of %O\n",base,this_object());
      call_out( "dest_me", 2 );
      return room_o->set_situation_changer( base );
    }
    sitdata = base->query_situations();
  }      

  return ::set_room( room_o );
}

void dest_me() {
  //  tell_creator("shaggy","Test Desting %O %O\n,",this_object(),
  //	       sizeof(children(base_name(this_object()))));

  if (clonep()) ::dest_me();
  else if (sizeof(children(base_name(this_object())))==1) ::dest_me();
  return;
}

void create() {
//  tell_creator("shaggy","create on %O\n",this_object());
  
  if (!clonep()) this_object()->setup_situations();
}
// --- END [/mnt/home2/grok/lib/std/room/basic/situation_changer_handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/water.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/water.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629559   Available: 13576913
Inodes: Total: 5242880    Free: 4960136
48727 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/water.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629559   Available: 13576913
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the co-inheritable for rooms containing water.  It handles adding
 * the appropriate effects to objects entering the water, skillchecks to see
 * if they can move around, making their positions appropriate and things like
 * that.  It also takes care of some miscellaneous stuff like salinity,
 * turbidity, currents etc.  Rather than using this co-inheritable directly, it
 * is recommended that you inherit either /std/room/water_inside.c or
 * /std/room/water_outside.c.
 * When using this file, remember the following: if you mask event_enter you
 * should call the inherited function, and unforeseen consequences may result
 * from using modify_exit with the "function", "exit mess" or "enter mess"
 * options.  Using "exit mess" or "enter mess" will only disrupt the tailored
 * swimming/drifting/floating/sinking exit and entry messages, but changing the
 * exit function will allow people through exits without passing the
 * appropriate swimming skillcheck.  For this reason, it is recommended to mask
 * swim_exit instead, and check that the inherited function returns 1 before
 * allowing them to pass.
 * @author Bakhtosh
 * @see /std/room/water_inside
 * @see /std/room/water_outside
 * @see /std/effects/other/immersed
 */

#include <armoury.h>
#include <position.h>
#include <room.h>
#include <tasks.h>

#define ANCHOR_PROP "anchor"
#define GILLS_PROP "gills"
#define FLOATING_PROP "floating"
#define LIVES_IN_WATER_PROP "lives in water"
#define SWIMMING_SKILL "other.movement.swimming"
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define LIVING_WET_EFFECT "/std/effects/other/wetness"
#define SWIM_EFFECT "/std/effects/other/water_effect"

mixed query_property(string);
varargs mixed *query_dest_other(string);
varargs int add_property(string, mixed, int);
int modify_exit(mixed, mixed*);
string query_destination(string);
string *query_exits();
int set_water_light(int);
int query_my_light();
varargs string *query_dest_dir(object);
int lives_in_water( object ob );

varargs void soak(object, int);
object get_water();
int water_override(string);
int do_float();
int do_drift();
int do_swim();
int get_swim_enum(object);
int query_bottom();
int query_surface();
string get_exit_mess(object, string);
string get_enter_mess(object, string);
object query_above_room();
void update_water_light();

private string on_bottom = "lying on the bottom",
        non_float = "drifting nearby",
        floating = "floating nearby",
        sinking = "sinking nearby",
        s_in_mess = "$N sink$s $down$ from $F.",
        s_out_mess = "$N sink$s $down$.",
        f_in_mess = "$N float$s $up$ from $F.",
        f_out_mess = "$N float$s $up$.",
        c_in_mess = "$N $V$0=is,are$V$ swept in from $F by the current.",
        c_out_mess = "$N $V$0=is,are$V$ swept $T by the current.",
        up_dir = "up", down_dir = "down";
        
private int bottom = -1, surface = -1, clarity = 90, salinity = 0,
        turbulence = 100, update_light = 1, light_first_queried = 0,
        last_speech_volume = 0;
        
private mapping flows = ([ ]), exit_messes = ([ ]), enter_messes = ([ ]),
        origins = ([ ]);

/**
 * This sets up different search returns for the default 'not there'
 * search result.
 */
string* query_default_search_description() {
   return ({
       "Funnily enough there is nothing interesting in the water.\n",
       "You search around and discover a whole bunch of water.\n",
       "You look up and down, left and right, then up and down again but "
       "all you can find is water.\n"
           });
}

/**
 * @ignore yes
 */
mixed *query_default_position(object ob) {
  return ({SWIMMING, "%^BOLD%^You start to swim.%^RESET%^\n",
           "$C$"+ob->one_short()+" "
           "$V$0=starts,start$V$ to swim.\n"});
} /* query_default_position() */

/**
 * @ignore yes
 */
int is_allowed_position(string poss) {
  if (poss == SWIMMING) {
    return 1;
  }
  return 0;
} /* is_allowed_position() */

/**
 * This function sets the position that non-living items will have when they
 * are lying on the bottom in this room.  The default is "lying on the bottom".
 * @param mess the new position for items lying on the bottom
 * @see query_bottom_mess
 * @example
 *   set_bottom_mess("lying in the seaweed");
 */
void set_bottom_mess(string mess) {
  on_bottom = mess;
}

/**
 * This function returns the position that non-living items will have when they
 * are lying on the bottom in this room.
 * @returns the current position for items lying on the bottom
 * @see set_bottom_mess
 */
string query_bottom_mess() {
  return on_bottom;
}

/**
 * This function sets the position that non-living items will have when they
 * are neither sinking nor floating in this room.  The default is "drifting
 * nearby".
 * @param mess the new position for drifting items
 * @see query_nonfloat_mess
 * @example
 *   set_nonfloat_mess("drifting amid the seaweed");
 */
void set_nonfloat_mess(string mess) {
   non_float = mess;
}

/**
 * This function returns the position that non-living items will have when they
 * are neither sinking nor floating in this room.
 * @return the current position for drifting items
 * @see set_nonfloat_mess
 */
string query_nonfloat_mess() {
  return non_float;
}

/**
 * This function sets the position that non-living items will have when they
 * are floating in this room.  The default is "floating nearby".
 * @param mess the new position for floating items
 * @see query_float_mess
 * @example
 *   set_float_mess("floating above the seaweed");
 */
void set_float_mess(string mess) {
  floating = mess;
}

/**
 * This function returns the position that non-living items will have when they
 * are floating in this room.
 * @return the current position for floating items
 * @see set_float_mess
 */
string query_float_mess() {
  return floating;
}

/**
 * This function sets the position that non-living items will have when they
 * are sinking in this room.  The default is "sinking nearby".
 * @param mess the new position for sinking items
 * @see query_sinking_mess
 * @example
 *   set_sinking_mess("sinking into the seaweed");
 */
void set_sinking_mess(string mess) {
  sinking = mess;
}

/**
 * This function returns the position that non-living items will have when they
 * are sinking in this room.
 * @return the current position for sinking items
 * @see set_sinking_mess
 */
string query_sinking_mess() {
  return sinking;
}

/**
 * This function sets the message that will be displayed when an object sinks
 * into this room.  The string "$down$" will be replaced by the current down
 * direction for this room (as set by set_down_dir), and the usual other
 * $-expansion for messages will occur, including the replacement of "$F" by
 * the direction from which they are arriving.  The default is "$N sink$s
 * $down$ from $F.".
 * @param mess the new entry message for sinking objects
 * @see query_sink_in_mess
 * @see set_down_dir
 * @see query_down_dir
 * @example
 *   set_sink_in_mess("$N sink$s into the cavern from $F.");
 */
void set_sink_in_mess(string mess) {
  s_in_mess = mess;
}

/**
 * This function returns the message that will be displayed when an object
 * sinks into this room, with the usual $-expansion not done.
 * @return the current entry message for sinking objects
 * @see set_sink_in_mess
 */
string query_sink_in_mess() {
  return replace(s_in_mess, ({"$down$", down_dir}));
}

/**
 * This function sets the message that will be displayed when an object sinks
 * out of this room.  The string "$down$" will be replaced by the current down
 * direction for this room (as set by set_down_dir), and the usual other
 * $-expansion for messages will occur.  The default is "$N sink$s $down$.".
 * @param mess the new exit message for sinking objects
 * @see query_sink_out_mess
 * @see set_down_dir
 * @see query_down_dir
 * @example
 *   set_sink_out_mess("$N sink$s $down$ out of the cavern.");
 */
void set_sink_out_mess(string mess) {
  s_out_mess = mess;
}

/**
 * This function returns the message that will be displayed when an object
 * sinks out of this room, with the usual $-expansion not done.
 * @return the current exit message for sinking objects
 * @see set_sink_out_mess
 */
string query_sink_out_mess() {
  return replace(s_out_mess, ({"$down$", down_dir}));;
}

/**
 * This function sets the message that will be displayed when an object floats
 * into this room.  The string "$up$" will be replaced by the current up
 * direction for this room (as set by set_up_dir), and the usual other
 * $-expansion for messages will occur, including the replacement of "$F" by
 * the direction from which they are arriving.  The default is "$N float$s $up$
 * from $F.".
 * @param mess the new entry message for floating objects
 * @see query_float_in_mess
 * @see set_up_dir
 * @see query_up_dir
 * @example
 *   set_float_in_mess("$N float$s into the cavern from $F.");
 */
void set_float_in_mess(string mess) {
  f_in_mess = mess;
}

/**
 * This function returns the message that will be displayed when an object
 * floats into this room, with the usual $-expansion not done.
 * @return the current entry message for floating objects
 * @see set_float_in_mess
 */
string query_float_in_mess() {
  return replace(f_in_mess, ({"$up$", up_dir}));
}

/**
 * This function sets the message that will be displayed when an object floats
 * out of this room.  The string "$up$" will be replaced by the current up
 * direction for this room (as set by set_up_dir), and the usual other
 * $-expansion for messages will occur.  The default is "$N float$s $up$.".
 * @param mess the new exit message for floating objects
 * @see query_float_out_mess
 * @see set_up_dir
 * @see query_up_dir
 * @example
 *   set_float_out_mess("$N float$s $up$ out of the cavern.");
 */
void set_float_out_mess(string mess) {
  f_out_mess = mess;
}

/**
 * This function returns the message that will be displayed when an object
 * floats out of this room, with the usual $-expansion not done.
 * @return the current entry message for floating objects
 * @see set_float_out_mess
 */
string query_float_out_mess() {
  return replace(f_out_mess, ({"$up$", up_dir}));
}

/**
 * This function sets the message that will be displayed when an object is
 * swept into this room by a current.  The usual $-expansion for messages
 * will occur.  The default is "$N $V$0=is,are$V$ swept in from $F by the
 * current.".
 * @param mess the new entry message for objects swept by a current
 * @see query_sweep_in_mess
 * @example
 *   set_sweep_in_mess("$N $V$0=is,are$V$ washed in from $F by the raging "
 *              "torrent.");
 */
void set_sweep_in_mess(string mess) {
  c_in_mess = mess;
}

/**
 * This function returns the message that will be displayed when an object
 * is swept into this room by a current, with the $-expansion not done.
 * @return the current entry message for objects swept by a current
 * @see set_sweep_in_mess
 */
string query_sweep_in_mess() {
  return c_in_mess;
}

/**
 * This function sets the message that will be displayed when an object is
 * swept out of this room by a current.  The usual $-expansion for messages
 * will occur, including the replacement of "$T" by the direction in which they
 * are moving.  The default is "$N $V$0=is,are$V$ swept $T by the current.".
 * @param mess the new exit message for objects swept by a current
 * @see query_sweep_out_mess
 * @example
 *   set_sweep_out_mess("$N $V$0=is,are$V$ washed away $T by the raging "
 *              "torrent.");
 */
void set_sweep_out_mess(string mess) {
  c_out_mess = mess;
}

/**
 * This function returns the message that will be displayed when an object
 * is swept out of this room by a current, with the $-expansion not done.
 * @return the current exit message for objects swept by a current
 * @see set_sweep_in_mess
 */
string query_sweep_out_mess() {
  return c_out_mess;
}

/**
 * This function sets the direction that is considered to be up by this room.
 * This is used by several exit messages, and by the water effect to decide
 * which way a panicking player will flee to try to reach the surface.  For
 * this reason, it should be set to the name of an exit which leads towards a
 * surface room.  Also, buoyant objects will be inclined to move in this
 * direction.  The default, of course, is "up".
 * @param mess the new direction to be considered to be up
 * @see query_up_dir
 * @see set_float_in_mess
 * @see set_float_out_mess
 * @see flee_drowning
 * @example
 *   set_up_dir("upwest");
 */
void set_up_dir(string dir) {
  up_dir = dir;
}

/**
 * This function returns the direction that is currently considered to be up in
 * this room.
 * @return the current direction considered to be up
 * @see set_up_dir
 */
string query_up_dir() {
  return up_dir;
}

/**
 * This function sets the direction that is considered to be down by this room.
 * This is used by several exit messages.  Also, dense objects will be inclined
 * to move in this direction.  The default, of course, is "down".
 * @param mes the new direction to be considered to be down
 * @see query_down_dir
 * @see set_sink_in_mess
 * @see set_sink_out_mess
 * @example
 *   set_down_dir("downeast");
 */
void set_down_dir(string dir) {
  down_dir = dir;
}

/**
 * This function returns the direction that is currently considered to be down
 * in this room.
 * @return the current direction considered to be down
 * @see set_down_dir
 */
string query_down_dir() {
  return down_dir;
}

/**
 * This function sets whether or not this room has a solid surface or bottom in
 * it.  If it does, then items may appear as being on the bottom, and living
 * objects are more able to resist currents (as they have something to hold on
 * to).  The parameter of this function can be 1 to make this room have a
 * bottom, 0 to make it have no bottom, or -1 (the default) to make it decide
 * whether or not it has a bottom by checking to see if it has any exits in the
 * current down direction (as set by set_down_dir).
 * @param val whether or not the room has a bottom
 * @see query_bottom
 * @see set_bottom_mess
 * @see set_down_dir
 */
void set_bottom(int val) {
  bottom = val;
  if (bottom > 1 || bottom < -1) {
    bottom = 1;
  }
}

/**
 * This function sets whether or not this room has an interface with air or
 * surface in it.  If it does, then living objects may breathe here, and
 * turbidity does not effect visibility.  The parameter of this function can be
 * 1 to make this room have a surface, 0 to make it have no surface, or -1 (the
 * default) to make it decide whether or not it has a surface by checking to
 * see if it has any exits in the current up direction (as set by set_up_dir).
 * @param val whether or not the room has a surface
 * @see query_surface
 * @see set_clarity
 * @see set_turbidity
 * @see set_up_dir
 */
void set_surface(int val) {
  surface = val;
  if (surface > 1 || surface < -1) {
    surface = 1;
  }
} /* set_surface() */


/**
 * This function sets the clarity of the water as an integer variable between 1
 * and 100.  The main effect of this is to reduce the light levels of the room
 * to simulate the obscuring effect of turbid water.  The default clarity is
 * 90.
 * @param how_clear the new clarity of the water
 * @see query_clarity
 * @see set_turbidity
 */
void set_clarity(int how_clear) {
  clarity = how_clear;
  if (clarity > 100) {
    clarity = 100;
  }
  else if (clarity < 0) {
    clarity = 0;
  }
  if (!query_property("dark mess")) {
    if (clarity < 20) {
      add_property("dark mess", "The water here is very murky.");
    }
    else if (clarity < 50) {
      add_property("dark mess", "The water here is quite murky.");
    }
    else if (clarity < 80) {
      add_property("dark mess", "The water here is slightly murky.");
    }
  }
}

/**
 * This function returns the current clarity of the water, which is an integer
 * variable between 1 and 100.
 * @return the current clarity of the water
 * @see set_clarity
 * @see query_turbidity
 */
int query_clarity() {
  return clarity;
}

/**
 * This function is an alternative method of setting the clarity of the water.
 * The turbidity is defined as 100 minus the clarity of the water.  The default
 * turbidity is 10.
 * @param how_murky the new turbidity of the water
 * @see set_clarity
 * @see query_turbidity
 */
void set_turbidity(int how_murky) {
  set_clarity(100 - how_murky);
}

/**
 * This function returns the current turbidity of the water, which is an
 * integer variable between 1 and 100.  It will be equal to 100 minus the
 * current clarity of the water.
 * @return the current turbidity of the water
 * @see set_turbidity
 * @see query_clarity
 */
int query_turbidity() {
  return 100 - query_clarity();
}

/**
 * This function sets the salinity of the water as an integer variable between
 * 0 and 100.  Higher salinity will have a small positive effect on the
 * buoyancy of objects in the room.  The default salinity is 0.
 * @param how_salty the new salinity of the water
 * @see query_salinity
 * @see calc_buoyancy
 */
void set_salinity(int how_salty) {
  salinity = how_salty;
  if (salinity > 100) {
    salinity = 100;
  }
  else if (salinity < 0) {
    salinity = 0;
  }
}

/**
 * This function returns the current salinity of the water, which is an integer
 * variable between 0 and 100.
 * @return the current salinity of the water
 * @see set_salinity
 */
int query_salinity() {
  return salinity;
}

/**
 * This function sets the turbulence of the water as a non-negative integer
 * variable.  A random number up to the turbulence is added to the difficulty
 * of all skillchecks to leave the room via a water exit with swim_exit as the
 * exit function, except when the exiting object is not moving of its own
 * accord (such as when it is being swept along by a current).  The default
 * turbulence is 100.
 * @param how_turbulent the new turbulence of the water
 * @see query_turbulence
 * @see swim_exit
 */
void set_turbulence(int how_turbulent) {
  turbulence = how_turbulent;
  if (turbulence < 0) {
    turbulence = 0;
  }
}

/**
 * This function returns the current turbulence of the water, which is a
 * non-negative integer.
 * @return the current turbulence of the water
 * @see set_turbulence
 */
int query_turbulence() {
  return turbulence;
}

/**
 * This function sets whether the room will use the light levels of the
 * surface to determine its own.  If the function is called with a non-zero
 * value, the the current light level in the room will be overridden by a new
 * value based on the light of the room found by query_above_room.  If the room
 * above is an outside room, with light levels that depend on the time of day,
 * then the light in this room will be updated every time it is queried.  A
 * water room will default to using this option, but it will be overridden by
 * any calls to adjust_light (including calls to set_light).  It is possible to
 * call set_water_light to avoid this, but it should not be necessary.  If a
 * series of rooms with vertical exits between them are all set to use surface
 * light, then the effect will be for the light of the room at the top of the
 * stack to filter down through the rest, appropriately attenuated by
 * turbidity.
 * @param val whether the room should use light from the surface
 * @see query_above_room
 * @see query_water_surface_light
 * @see update_water_light
 * @see set_water_light
 * @see set_turbidity
 * @see set_clarity
 */
void set_use_surface_light(int val) {
  int surface_light;
  object above;
  update_light = 0;
  if (!val) {
    return;
  }
  above = query_above_room();
  if (!above) {
    set_water_light(0);
    return;
  }
  if (function_exists("query_day_light", above) ||
           above->water_surface_light_varies()) {
    update_light = 1;
    return;
  }
  if (function_exists("query_water_surface_light", above)) {
    surface_light = above->query_water_surface_light();
  }
  else {
    surface_light = above->query_my_light();
  }
  set_water_light(surface_light);
}


/**
 * This function returns the amount of light that will filter down to rooms
 * below this one that have had set_use_surface_light called in them.  Its
 * default is to return a value based on the light in this room and the clarity
 * of the water.
 * @return the amount of light that filters down to rooms below this one
 * @see set_use_surface_light
 * @see set_turbidity
 * @see set_clarity
 */
int query_water_surface_light() {
  update_water_light();
  return query_my_light()*query_clarity()/100;
}

/**
 * This function returns the amount of light that will filter down to this
 * room from those above it if set_use_surface_light has been called.  It is
 * intended to be used only by the update_water_light function, but has been
 * separated out to allow it to be masked.
 * @return the amount of light that filters down from rooms above this one
 * @see update_water_light
 * @see query_above_room
 * @see query_water_surface_light
 */
int get_water_surface_light() {
  object above = query_above_room();
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    return above->query_water_surface_light();
  }
  return above->query_my_light();
}

/**
 * This function updates the amount of light filtering down to this room from
 * the rooms above it, if it is necessary to do so.  It is called by
 * query_light in /std/room/water_inside and /std/room/water_outside.
 * @see set_use_surface_light
 * @see set_light
 * @see query_water_surface_light
 * @see get_water_surface_light
 */
void update_water_light() {
  if (!update_light) {
    return;
  }
  if (!light_first_queried) {
    set_use_surface_light(1);
    light_first_queried = 1;
    update_water_light();
    return;
  }
  set_water_light(get_water_surface_light());
}

/**
 * This function adds a water current flowing through a particular exit, which
 * may sweep objects through it or make it harder for them to swim through.
 * The second argument is the rate of flow.  If this is positive, then water
 * will be flowing from this room into the next one.  If it is positive, then
 * water will be flowing from the next room into this one.  It is up to the
 * coder of the specific rooms to ensure that the currents in different rooms
 * match one another.
 * @param dir the exit through which the current is flowing
 * @param rate the strength of the current
 * @see delete_flow
 * @see query_flow
 * @see query_flows
 * @see drift
 * @see swim_exit
 * @example
 *   // There is a current flowing south.
 *   add_flow("north", -80);
 *   add_flow("south", 80);
 */
void add_flow(string dir, int rate) {
  flows[dir] = rate;
}

/**
 * This function removes a water current through a particular exit.
 * @param dir the exit for which any water current should be removed
 * @see add_flow
 * @see query_flow
 * @see query_flows
 */
void delete_flow(string dir) {
  map_delete(flows, dir);
}

/**
 * This function returns a mapping of all the current flows through exits in
 * this room.  The keys of the mapping are the exits through which the currents
 * flow, and the values are the rates of flow.
 * @return a mapping of the current flows through exits in this room
 * @see add_flow
 * @see delete_flow
 * @see query_flow
 */
mapping query_flows() {
  return copy(flows);
}

/**
 * This function returns the strength of the current flowing through a
 * particular exit, if any.  A positive value represents a current flowing from
 * this room into the next one, and a negative value represents a current
 * flowing from the next room into this one.
 * @param dir the exit which should have its current returned
 * @return the current through this ext
 * @see add_flow
 * @see delete_flow
 * @see query_flows
 */
int query_flow(string dir) {
  return flows[dir];
}

/**
 * This function returns the bonus that objects get to move along the bottom or
 * to resist such movement here.  If this should be anything unusual, such as
 * for a very smooth bottom or one with handles, this function should be masked
 * to return something different.
 * @param thing the object that is moving along the bottom
 * @param buoyancy the object's relative buoyancy
 * @return the traction bonus on the bottom here
 * @see swim_exit
 * @see drift
 * @see calc_buoyancy
 */
int query_water_traction_bonus(object thing, int buoyancy) {
  if (buoyancy < 0) {
    buoyancy = -buoyancy;
    return buoyancy/3 + random(buoyancy/3);
  }
  return 0;
}

/**
 * This function returns the room above this one, in the direction set by
 * set_up_dir.
 * @return the room above this one
 * @see set_up_dir
 * @see query_surface_room
 */
object query_above_room() {
  string destination = query_destination(up_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}

/**
 * This function returns the room below this one, in the direction set by
 * set_down_dir.
 * @return the room below this one
 * @see set_down_dir
 * @see query_bottom_room
 */
object query_below_room() {
  string destination = query_destination(down_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}

/**
 * This function returns the top room in a vertical stack of water rooms.  If
 * there is a surface water room, it is returned, else, if the top room is not
 * water, or there is no surface room, 0 is returned.
 * @return the first room above this one to be on the surface
 * @see query_above_room
 * @see query_surface
 */
object query_surface_room() {
  object next;
  if (query_surface()) {
    return this_object();
  }
  next = query_above_room();
  if (next && next->query_water()) {
    return next->query_surface_room();
  }
  return 0;
}

/**
 * This function returns the bottom room in a vertical stack of water rooms.
 * If there is a bottom water room, it is returned, else, if the bottom room is
 * not water, or there is no bottom room, 0 is returned.
 * @return the first room below this one to be on the bottom
 * @see query_below_room
 * @see query_bottom
 */
object query_bottom_room() {
  object next;
  if (query_bottom()) {
    return this_object();
  }
  next = query_below_room();
  if (next && next->query_water()) {
    return next->query_bottom_room();
  }
  return 0;
}

/**
 * @ignore yes
 */
void event_enter(object ob, string mess, object from)  {
  int effnum, buoyancy, *effects, *args;
  effects = ob->effects_matching(SWIM_EFFECT->query_classification());
 


  if (!effects || !sizeof(effects)) {
    if (from && !from->query_water() ) {
      if( !lives_in_water( ob ) ) 
        ob->add_effect(SWIM_EFFECT, 2);
    }
  }

  //Some of the code in this if relies on the water effect, some other code 
  //adds the water effect, either way, we don't want it for things that live in
  //water.
  if ( !lives_in_water( ob ) ) {
      effnum = get_swim_enum(ob);
      args = ob->arg_of(effnum);
      if (living(ob) && query_surface() && !ob->query_property("dead") && from &&
               from->query_water() && !from->query_surface()) {
        if (args[1] < 150 || ob->query_property(GILLS_PROP)) {
          tell_object(ob, "You break the surface.\n");
        }
        else {
          tell_object(ob, "You break the surface and take a deep breath.\n");
        }
        if (args[1] != 0) {
          ob->set_arg_of(effnum, ({args[0], 0}));
        }
      }
  }

  if (!living(ob)) {
    buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
    if (buoyancy < 0 && query_bottom()) {
      ob->add_property("there", on_bottom);
    }
    else if (buoyancy >= 0 && (buoyancy > ob->query_property(ANCHOR_PROP)
           || query_surface())) {
      ob->add_property("there", floating);
    }
    else if (buoyancy < 0 && buoyancy < -ob->query_property(ANCHOR_PROP)) {
      ob->add_property("there", sinking);
    }
    else {
      ob->add_property("there", non_float);
    }
  } else {
    ob->return_to_default_position();
  }
}

/**
 * This function makes things wet.  Anything entering a water room has this
 * function called on it by event_enter, and will have the wetness effect added
 * to it if appropriate, as well as to any appropriate objects inside it if it
 * isn't waterproof.  Open containers will also be filled with water.  The
 * function checks to see that the object is indeed inside the room, unless the
 * optional extra argument is non-zero.
 * @param ob the object to be soaked
 * @param ignore_location whether the object should be soaked wherever it is
 * @see get_water
 */
varargs void soak(object ob, int ignore_location) {
  int wetness = 0, *effects;
  object env, water, *things;
  env = ob;
  if (!ignore_location) {
    while (env && env = environment(env)) {
      if (env == this_object()) {
        break;
      }
      if ((env->query_closed() && env->query_waterproof()) ||
           env->query_dry_cargo()) {
        env = 0;
        break;
      }
    }
  }
  if (!env) {
    return;
  }
  if (ob->query_property(FLOATING_PROP) && query_surface()) {
    return;
  }
  if (living(ob)) {
    if (ob->query_property("dead") || lives_in_water( ob ) ) {
      return;
    }
    effects = ob->effects_matching(LIVING_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(LIVING_WET_EFFECT, wetness);
    }
  }
  else if (ob->id("towel")) {
    effects = ob->effects_matching(OBJECT_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = 200*ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(OBJECT_WET_EFFECT, wetness);
    }
  }
  if (ob->query_max_volume() && !ob->query_closed() &&
           ob->query_max_volume() - ob->query_volume() > 0) {
    water = get_water();
    water->set_amount(ob->query_max_volume() - ob->query_volume());
    water->move(ob);
  }
  if (!(ob->query_closed() && ob->query_waterproof()) &&
           !ob->query_dry_cargo()) {
    things = all_inventory(ob);

    if (things && sizeof(things)) {
      map(things, (: soak($1, 1) :));
    }
  }
}

/**
 * This function returns some appropriate water from the room.  Its appearance
 * will depend on the clarity and salinity set in the room.  The quantity of
 * the water object that it returns is not fixed, and will generally be set by
 * whatever function called it.
 * @return some water from the room
 * @see soak
 * @see set_clarity
 * @see set_turbidity
 * @see set_salinity
 */
object get_water() {
  object water = ARMOURY->request_item("water");
  switch (query_clarity()) {
  case 0..20:
    water->set_short("very muddy water");
    water->add_adjective(({"very", "muddy"}));
    water->set_long("This is $amount_size$ of very muddy water.\n");
    return water;
  case 21..50:
    water->set_short("muddy water");
    water->add_adjective("muddy");
    water->set_long("This is $amount_size$ of muddy water.\n");
    return water;
  case 51..80:
    water->set_short("slightly muddy water");
    water->add_adjective(({"slightly", "muddy"}));
    water->set_long("This is $amount_size$ of slightly muddy water.\n");
  }
  switch (query_salinity()) {
  case 51..100:
    water->set_short("brine");
    water->add_alias("brine");
    water->set_long("This is $amount_size$ of very salty water.\n");
    return water;
  case 11..50:
    water->set_short("salty water");
    water->add_adjective("salty");
    water->set_long("This is $amount_size$ of salty water.\n");
  }
  return water;
}

/**
 * This is an exit function set for any exits in a water room.  It finds the
 * difficulty of swimming through the exit, on the basis of the current through
 * that exit, the buoyancy of the object and the extra difficulty that it has
 * in swimming.  The swimming/immersion effect calculates the latter two with
 * calc_buoyancy and swim_difficulty respectively.  The object is subjected to
 * a skillcheck in other.movement.swimming to see if it can move through the
 * exit.
 * There is a guildpoint cost equal to 1/20th of the difficulty of the
 * skillcheck.
 * @param dir the direction in which the object is leaving
 * @param ob the object that is trying to leave
 * @param mess a weird extra string that isn't relevant here
 * @return whether or not the object can move through the exit
 * @see modify_exit
 * @see exit_function
 * @see calc_buoyancy
 * @see swim_difficulty
 * @see query_water_traction_bonus
 * @see perform_task
 */
int swim_exit(string dir, object ob, string mess) {
  int difficulty, buoyancy = 0, place, this_turb, gp_cost, effnum, *arg;
  string *places_to_go, *tm_messes;
  object destination;

  if (!living(ob) || ob->query_property("dead") || lives_in_water( ob ) ) {
    return 1;
  }

  effnum = get_swim_enum(ob);
  arg = ob->arg_of(effnum);
  if (-2 == arg[0]) {
    // If you're not moving of your own accord, assume that it's already been
    // checked that you can pass through the exit.
    return 1;
  }
  difficulty = -flows[dir];
  buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
  if (ob->query_weight()) {
    buoyancy /= ob->query_weight();
  }
  places_to_go = query_dest_dir();
  place = member_array(dir, places_to_go);
  if (-1 == place || !(destination = load_object(places_to_go[place+1]))) {
    return 0;
  }
  if (dir == up_dir) {
    // It's harder to go up if you're not buoyant.
    difficulty -= buoyancy + 50;
  } else if (dir == down_dir) {
    // It's harder to go down if you're buoyant.
    difficulty += buoyancy - 50;
  } else if (buoyancy < 0) {
    // It's harder to swim if you keep sinking.
    difficulty -= buoyancy/5;
  } else {
    // It's harder to swim if you keep floating.
    difficulty += buoyancy/5;
  }
  if (query_bottom() && (!destination->query_water() ||
           destination->query_bottom())) {
    // It's easier to walk along the bottom if you're not buoyant.
    difficulty -= query_water_traction_bonus(ob, buoyancy);
  } 
  this_turb = random(query_turbulence());
  difficulty += this_turb;
  if (arg[0] == -1) {
    // You get a bonus if you're desperately trying to reach the surface.
    difficulty -= 50;
  }
  if (!destination->query_water()) {
    // It's easier if you can pull yourself ashore.
    difficulty -= 50;
  }
  difficulty *= SWIM_EFFECT->swim_difficulty(ob);
  difficulty /= 100;
  if (difficulty <= 0) {
    return 1;
  }
  if (arg[0] != -1) {
    gp_cost = difficulty/20;
    if (gp_cost > 50) {
      gp_cost = 50;
    }
    else if (gp_cost < 1) {
      gp_cost = 1;
    }
    if (ob->query_specific_gp("other") < gp_cost) {
      tell_object(ob, "You're too "+({"fatigued", "tired", "weary",
           "exhausted"})[random(4)]+" to swim "+dir+" at the moment.\n");
      notify_fail("");
      return 0;
    }
  }
  ob->adjust_gp(-gp_cost);
  switch (TASKER->perform_task(ob, SWIMMING_SKILL, difficulty,
           TM_CONTINUOUS)) {
  case AWARD:
    tm_messes = ({"You move more surely as you glide through the water.",
                  "You discover a more efficient stroke.",
                  "You find a better way to streamline your body.",
                  "You find a more efficient swimming rhythm.",
                  "You begin to move more confidently through the water."});
    tell_object(ob, "%^YELLOW%^"+tm_messes[random(sizeof(tm_messes))]+
           "%^RESET%^\n");
  case SUCCEED:
    return 1;
  }
  notify_fail("");
  if (dir == up_dir && buoyancy < -50) {
    tell_object(ob, "You struggle to leave "+up_dir+" but, with the load "
           "you're carrying, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+up_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (dir == down_dir && buoyancy > 50) {
    tell_object(ob, "You struggle to leave "+down_dir+" but, with your "
           "buoyancy, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+down_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (flows[dir] < 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway against the current.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway against the current.\n", ob);
    return 0;
  }
  if (this_turb > 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway in the turbulent waters.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway.\n", ob);
    return 0;
  }
  tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway.\n");
  tell_room(this_object(), "$C$"+ob->one_short()+" $V$0=struggles,struggle$V$ "
           "to leave "+dir+", but can't make any headway.\n", ob);
  return 0;
}

/**
 * With this function here, creators will be able to point and laugh when
 * someone dies by drowning in a water room because they'll see the death
 * reason in an inform.  It will also show up in the death log.  It would be a
 * good idea to mask this function to return a reason more specific to the
 * place where the drowning may occur (such as "drowning in the Djel"), or at
 * least a humorous one (such as "failing to realise that scuba gear hasn't
 * been invented yet") so that creators will have something to laugh at.
 * @return the reason for death
 * @see do_death
 */
string query_death_reason() {
  return "drowning";
}

/**
 * @ignore yes
 */
int add_exit(string direc, mixed dest, string type) {
    mixed *messy = query_dest_other(direc);
  
    if (messy && arrayp(messy[ROOM_ENTER]) && sizeof(messy[ROOM_ENTER]) == 2){
        origins[direc] = messy[ROOM_ENTER][1];
    }
    modify_exit(direc, ({"function", "swim_exit",
                       "exit mess", (: get_exit_mess($1, $(direc)) :),
                       "enter mess", (: get_enter_mess($1, $(direc)) :)}));

    // We can't bury objects here if they can sink
    if( direc == "down" ) {
        add_property("no burial", 1);
    }

}

/**
 * This function returns the opposite to the direction of a particular exit.
 * This information is normally only accessible within the room handler, but it
 * is cached here in the origins mapping by the add_exit in this file.  If no
 * value is found, "elsewhere" will be returned.  This value is used in exit
 * messages to correctly display where they are coming from.
 * @param dir the exit for which the opposite direction should be found
 * @return the opposite of the specified direction
 * @see add_exit
 * @see room_handler
 */
string query_origin(string dir) {
  if (origins[dir]) {
    return origins[dir];
  }
  return "elsewhere";
}

/**
 * This function sets the next exit message from this room for a particular
 * object.  It is used automagically by the swim_exit function, but can be used
 * for other purposes if you feel like it.
 * @param ob the object for which the next exit message should be set
 * @param mess the next exit message for the object
 * @see get_exit_mess
 * @see add_enter_mess
 * @see get_enter_mess
 * @see swim_exit
 */
void add_exit_mess(object ob, string mess) {
  exit_messes[file_name(ob)] = mess;
}

/**
 * This function sets the next entry message from this room for a particular
 * object.  It is used automagically by the swim_exit function, but can be used
 * for other purposes if you feel like it.
 * @param ob the object for which the next entry message should be set
 * @param mess the next entry message for the object
 * @see get_enter_mess
 * @see add_exit_mess
 * @see get_exit_mess
 * @see swim_exit
 */
void add_enter_mess(object ob, string mess) {
  enter_messes[file_name(ob)] = mess;
}

/**
 * This function returns the appropriate exit message for the specified object
 * in the specified direction.  If a value has been set by add_exit_mess then
 * it is returned.  It is used automagically by the swim_exit function, but can
 * be overridden if you feel like it.
 * @param ob the object for which the exit message should be found
 * @param direc the direction in which the object is exiting
 * @return the exit message for this object
 * @see add_exit_mess
 * @see add_enter_mess
 * @see get_enter_mess
 */
string get_exit_mess(object ob, string direc) {
  string retval;
  if (retval = exit_messes[file_name(ob)]) {
    map_delete(exit_messes, file_name(ob));
    return retval;
  }
  return "$N $V$0=swims,swim$V$ $T.";
}

/**
 * This function returns the appropriate entry message for the specified object
 * in the specified direction.  If a value has been set by add_enter_mess then
 * it is returned.  The query_origin function is used to find a replacement for
 * the "$F" token.  It is used automagically by the swim_exit function, but can
 * be overridden if you feel like it.
 * @param ob the object for which the entry message should be found
 * @param direc the direction in which the object is exiting
 * @return the entry message for this object
 * @see add_enter_mess
 * @see add_exit_mess
 * @see get_exit_mess
 * @see query_origin
 */
string get_enter_mess(object ob, string direc) {
  string retval;
  if (retval = enter_messes[file_name(ob)]) {
    map_delete(enter_messes, file_name(ob));
  }
  else if (direc == up_dir) {
    retval = "$N $V$0=swims,swim$V$ up from $F.";
  }
  else if (direc == down_dir) {
    retval = "$N $V$0=swims,swim$V$ down from $F.";
  }
  else {
    retval = "$N $V$0=swims,swim$V$ in from $F.";
  }
  retval = replace(retval, "$F", query_origin(direc));
  return retval;
}

/**
 * @ignore yes
 */
void init()  {
  add_command("float", "", (: do_float() :));
  add_command("drift", "", (: do_drift() :));
  add_command("swim", "", (: do_swim() :));
}

/**
 * @ignore yes
 */
string mangle_speech(string type, string words, mixed target) {
  int drown;
  string garbled = "";
  if (query_surface() || !this_player() ||
           this_player()->query_property("dead")) {
    return words;
  }
  switch (type) {
  case "whisper":
    drown = 20 + random(20);
    break;
  case "lsay":
  case "mock":
    drown = 80 + random(80);
    break;
  case "shout":
    drown = 120 + random(120);
    break;
  default:
    drown = 40 + random(40);
  }
  for (int inc = (strlen(words) / 10) + 1;inc > 0;--inc) {
    garbled += ({"blub", "glub", "gloog", "arrrble"})[random(4)]+" ... ";
  }
  if (drown > 70) {
    garbled = garbled[0..(strlen(garbled) - 6)]+"!";
  } else {
    garbled = garbled[0..(strlen(garbled) - 2)];
  }
  garbled = capitalize(garbled);
  last_speech_volume = drown;
  return garbled;
}

/**
 * @ignore yes
 */
void event_person_say(object ob, string start, string mess, string lang,
           string accent) {
  int effnum, *args;
  if (!ob || ob->query_property("dead") || ob->query_property(GILLS_PROP) ||
      lives_in_water( ob ) || environment(ob) != this_object() || query_surface()) {
    last_speech_volume = 0;
    return;
  }

  if (!last_speech_volume) {
    last_speech_volume = 40 + random(40);
  }
  effnum = get_swim_enum(ob);
  args = ob->arg_of(effnum);
  args[1] += last_speech_volume;
  ob->set_arg_of(effnum, args);
  ob->adjust_tmp_con(-random((last_speech_volume / 50) + 1));
  switch (last_speech_volume) {
  case 0..30:
    tell_object(ob, "You inhale a bit of water.\n");
    break;
  case 31..80:
    tell_object(ob, "You inhale some water.\n");
    break;
  case 81..150:
    tell_object(ob, "You inhale a fair amount of water.\n");
    break;
  default:
    tell_object(ob, "You inhale about a lungful of water.\n");
  }
  last_speech_volume = 0;
}

/**
 * This function is for the float command, which will allow someone to start
 * floating freely rather than swimming.  It is identical to the drift command,
 * except for the messages.
 * @return whether the command succeeded
 * @see init
 * @see do_drift
 * @see do_swim
 */
int do_float()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already floating on the current.\n");
    }
    else {
      add_failed_mess("You are already floating freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to float freely on the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to float freely.\n", ""}));
  }
  return 1;
}

/**
 * This function is for the drift command, which will allow someone to start
 * drifting freely rather than swimming.  It is identical to the float command,
 * except for the messages.
 * @return whether the command succeeded
 * @see init
 * @see do_float
 * @see do_swim
 */
int do_drift()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already drifting with the current.\n");
    }
    else {
      add_failed_mess("You are already drifting freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to drift freely with the current.\n",
           ""}));
  }
  else {
    add_succeeded_mess(({"You begin to drift freely.\n", ""}));
  }
  return 1;
}

/**
 * This function is for the swim command, which will allow someone to stop
 * drifting freely and start swimming and resisting anything that tries to move
 * them.
 * @return whether the command succeeded
 * @see init
 * @see do_float
 * @see do_drift
 */
int do_swim()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already swimming against the current.\n");
    }
    else {
      add_failed_mess("You are already swimming.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({1, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to swim against the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to swim.\n", ""}));
  }
  return 1;
}

/**
 * This function returns the effect number of the swimming/immersion effect on
 * the object specified.  If there isn't one, it adds the effect.
 * @param thing the object for which the swimming effect number should be found
 * @return the swimming effect number
 * @see effects_matching
 * @see query_classification
 */
int get_swim_enum(object thing) {
  int *effects = thing->effects_matching(SWIM_EFFECT->query_classification());
  if (!effects || !sizeof(effects)) {
    thing->add_effect(SWIM_EFFECT, 1);
    effects = thing->effects_matching(SWIM_EFFECT->query_classification());
    call_out("soak", 1, thing);
  } else if (!random(50)) {
    call_out("soak", 1, thing);
  }
  return effects[0];
}

/**
 * This function returns 1 if this is a bottom room, and 0 otherwise.
 * @return whether this is a bottom room
 * @see set_bottom
 */
int query_bottom()  {
  if (bottom == -1) {
    return member_array(down_dir, query_exits()) == -1;
  }
  return bottom;
}

/**
 * This function returns 1 if this is a surface room, and 0 otherwise.
 * @return whether this is a surface room
 * @see set_surface
 * @see query_underwater
 */
int query_surface() {
    if (surface == -1) {
        return member_array(up_dir, query_exits()) == -1;
    }
    return surface;
}

/**
 * This function returns 1 if this room is underwater (that is, it is not a
 * surface room), and 0 otherwise.
 * @return whether this is an underwater room
 * @see query_surface
 * @see set_surface
 */
int query_underwater() {
  return !query_surface();
}

/**
 * This function returns 1 to indicate that this is a water room.  It fulfills
 * the same purpose as the inherits efun in this case, but may be slightly
 * easier to use.
 * @return 1
 * @see inherits
 */
int query_water()  {
  return 1;
}

int lives_in_water( object ob ) {
  string race_ob = ob->query_race_ob();

  //Corpses don't live in water.
  if ( !living( ob ) ) {
    return 0;
  }

  if(ob->query_property(LIVES_IN_WATER_PROP) ||
     ob->lives_in_water() ||
     (race_ob && race_ob->lives_in_water()))
    return 1;
  return 0;
}

// The colour this room should use for the terrain map.
string query_terrain_map_colour() { return "%^CYAN%^"; }
// --- END [/mnt/home2/grok/lib/std/room/basic/water.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/wall.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/wall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629547   Available: 13576901
Inodes: Total: 5242880    Free: 4960136
6242 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/wall.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629547   Available: 13576901
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: wall.c,v 1.6 2002/06/10 15:30:28 vashti Exp $
 *
 * $Log: wall.c,v $
 * Revision 1.6  2002/06/10 15:30:28  vashti
 * Added the "no_drop" option.
 *
 * Revision 1.5  2002/06/10 00:57:05  vashti
 * Added the "ghost_action" option.
 *
 */

/**
 * This is a wall object.  It is added to rooms when you use the set_wall()
 * function to add a climbable wall exit to a room.  If you wish to have
 * players climb somewhere this is the preferred method to use.
 *
 * @author Deutha
 * @see climb
 * @see /std/room.c
 * @see /std/rooftop.c
 */

string *belows, death_mess, old_here;
mixed *bottom, *moves;
mixed ghost_action;
int no_drop;
object room;

/**
 * @ignore yes
 */
void create() {
   belows = ({ });
   bottom = 0;
   ghost_action = 0;
   moves = ({ });
   no_drop = 0;
   death_mess = 0;
} /* create() */

/**
 * @ignore yes
 */
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   room = thing;
} /* setup_shadow() */

/**
 * @ignore yes
 */
void destruct_shadow( object thing ) {
   if ( thing == this_object() )
      destruct( this_object() );
   else
      thing->destruct_shadow( thing );
} /* destruct_shadow() */

string *query_belows() { return copy( belows ); }
mixed *query_bottom() { return copy( bottom ); }
mixed query_ghost_action() { return copy( ghost_action ); }
mixed *query_moves() { return copy( moves ); }
int query_no_drop() { return copy( no_drop ); }
string query_death_mess() { return death_mess; }
int query_at_bottom() { return !bottom; }

mixed *query_move( string word ) {
   int i;
   i = member_array( word, moves );
   if ( i == -1 )
      return 0;
   return moves[ i + 1 .. i + 3 ];
} /* query_move() */

void calc_co_ord() {
   int i, delta, *co_ord;
   string word, other;
   room->calc_co_ord();
   if ( co_ord )
      return;
   foreach ( word in ({ "down", "up" }) ) {
      i = member_array( word, moves );
      if ( i == -1 ) 
         continue;
      other = moves[ i + 2 ];
      if ( !find_object( other ) )
         continue;
      co_ord = copy( (int *)other->query_co_ord() );
      if ( !co_ord )
         continue;
      delta = (int)room->query_room_size_array()[2] + 
         (int)other->query_room_size_array()[2];
      if ( word == "down" )
         co_ord[ 2 ] += delta;
      else
         co_ord[ 2 ] -= delta;
      room->set_co_ord( co_ord );
      return;
   }
} /* calc_co_ord() */

void set_wall( mixed *args ) {
   int i, j;
   mixed arg;
    
   for ( i = sizeof( args ) - 2; i > -1; i -= 2 ) {
      arg = args[ i + 1 ];
      switch ( args[ i ] ) {
         case "bottom" :
            bottom = arg;
            if ( ! no_drop ) {
                old_here = room->query_property( "here" );
                room->add_property( "here", "falling past you" );
            }
            break;
         
         case "below" :
            belows += arg;
            break;
         
         case "move" :
            j = member_array( arg[ 0 ], moves );
            if ( j == -1 )
               moves += arg;
            else
               moves[ j + 1 .. j + 3 ] = arg[ 1 .. 3 ];
            break;
            
         case "death mess" :
         case "death_mess" :
            death_mess = arg;
            break;
         
         case "ghost action" :
         case "ghost_action" :
             ghost_action = arg;
             break;
         
         case "no drop" :
         case "no_drop" :
             no_drop = arg;
             if ( bottom ) {
                 if ( old_here )
                     room->add_property( "here", old_here );
                 else
                     room->remove_property( "here" );
             }
             break;
      }
   }
} /* set_wall() */

/**
 * @ignore yes
 */
void event_enter( object thing, string mess, object from ) {
   room->event_enter( thing, mess, from );
   if ( !living( thing ) && bottom && ( ! no_drop ) )
      call_out( "fall_down", 0, thing );
} /* event_enter() */

void fall_down( object thing ) {
   int damage;
   string word;
   if ( !thing )
      return;
   if ( environment( thing ) != room )
      return;
   damage = (int)room->query_room_size_array()[2];
   if ( sizeof( belows ) )
      foreach ( word in belows ) {
         tell_room( find_object( word ), (string)thing->a_short() +
               " $V$0=falls,fall$V$ past you and $V$0=is,are$V$ gone.\n" );
         damage += 2 * (int)word->query_room_size_array()[2];
      }
   if ( stringp( bottom ) ) {
      if ( living( thing ) )
         thing->move_with_look( bottom,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
      else
         thing->move( bottom,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
      return;
   }
   word = bottom[ 0 ];
   damage += (int)word->query_room_size_array()[2];
   if ( sizeof( bottom ) > 1 && stringp( bottom[ 1 ] ) )
      if ( living( thing ) )
         thing->move_with_look( word, call_other( word, bottom[ 1 ], thing,
               room ), "$N drop$s downwards out of sight." );
      else
         thing->move( word, call_other( word, bottom[ 1 ], thing, room ),
               "$N drop$s downwards out of sight." );
   else
      if ( living( thing ) ) {
         thing->move_with_look( word,
               "$N fall$s from above with a loud crunch.",
               "$N drop$s downwards out of sight." );
         damage *= bottom[ 1 ] * (int)thing->query_complete_weight();
         damage /= 10000;
         damage -= (int)thing->query_ac( "blunt", damage );
         if ( damage > 0 ) {
            if ( damage > thing->query_hp() ) {
               tell_object( thing, !death_mess ? "You hit the ground "
                  "with a sickening crunch.\n" : death_mess );
               thing->attack_by( room );
               thing->adjust_hp(-damage, room);
            } else {
               thing->adjust_hp(-damage, room);
               tell_object( thing, "Ouch, that hurt!\n" );
            }
         }
      } else
         thing->move( word,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
} /* fall_down() */
// --- END [/mnt/home2/grok/lib/std/room/basic/wall.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/basic/terrain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/basic/terrain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629545   Available: 13576899
Inodes: Total: 5242880    Free: 4960136
2209 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/basic/terrain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629545   Available: 13576899
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: terrain.c,v 1.1 1998/11/01 12:02:03 terano Exp $
 *
 *
 */

/*
 * $Locker:  $
 * $Id: terrain.c,v 1.1 1998/11/01 12:02:03 terano Exp $
 */
#include <dirs.h>
#include <terrain.h>

string terrain_name;
object room;

void setup_shadow(object thing, string word) {
  shadow(thing, 1);
  TERRAIN_MAP->setup_location(thing, word);
  thing->add_property("terrain name", word);
  terrain_name = word;
  room = thing;
} /* setup_shadow() */

void destruct_shadow(object thing) {
  if (thing == this_object()) {
    TERRAIN_MAP->delete_cloned_location(terrain_name, file_name(room));
    destruct(this_object());
  } else {
    thing->destruct_shadow( thing );
  }
} /* destruct_shadow() */

void event_exit(object thing, string message, object to) {
  if (!objectp(room)) {
    room = query_shadowing(this_object());
  }
  if (clonep(room)) {
    if (find_call_out("free_location") == -1) {
      call_out("free_location", 10);
    }
  }
  room->event_exit(thing, message, to);
} /* event_exit() */

void free_location() {
  if (sizeof(all_inventory(room)) || (int)this_object()->dont_free())
    return;
  TERRAIN_MAP->delete_cloned_location(terrain_name, file_name(room));
  room->dest_me();
} /* free_location() */

void set_destination(string direc) {
  int i, j, delta, *co_ords, *new_co_ords = allocate(3);
  string dest_name;
  object destination;

  if ((i = member_array(direc, STD_ORDERS)) == -1) {
    return;
  }
  if (!objectp(room)) {
    room = query_shadowing(this_object());
  }
  dest_name = (string)room->query_destination(direc);
  delta = (int)room->query_room_size() + TERRAIN_MAP->get_room_size(dest_name);
  co_ords = room->query_co_ord();
  for (j = 0; j < 3; j++) {
    new_co_ords[j] = co_ords[j] - delta * STD_ORDERS[i+1][j];
  }
  destination = TERRAIN_MAP->find_location(terrain_name, new_co_ords);
  if (!destination) {
    return;
  }
  room->modify_exit(direc, ({ "dest", file_name(destination) }));
} /* set_destination() */

string query_quit_handler() { return TERRAIN_LOG; }

mixed *query_cloning_info() {
  return ({ TERRAIN_MAP, "find_location",
            terrain_name, (int *)room->query_co_ord() });
} /* query_cloning_info() */
// --- END [/mnt/home2/grok/lib/std/room/basic/terrain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/voting_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/voting_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629545   Available: 13576899
Inodes: Total: 5242880    Free: 4960136
947 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/voting_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629545   Available: 13576899
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: voting_room.c,v 1.2 2001/02/20 03:25:41 pinkfish Exp $
 *
 */

#include <board.h>

#define DEFAULT_VOTE_DURATION 2600*24*7

inherit "/std/room/basic_room";
inherit "/std/room/inherit/voting_room";

/**
 * Generalised voting room intended to be inherited into rooms in the mud that
 * will setup the parameters and settings for votes.
 * <p>
 * The room does not inherantly support player initiated votes, however it is
 * a fairly simple matter to add this to your own room and have your room add
 * votes when players initiate them.
 *
 * @author Ceres
 */

/**
 * @ignore
 */
void create() {
  voting_room::create();
  do_setup++;
  add_help_file("voting_room");
  basic_room::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
}

/**
 * @ignore
 */
void init() {
   basic_room::init();
   voting_room::init();
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/voting_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/area/plain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/area/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629544   Available: 13576898
Inodes: Total: 5242880    Free: 4960136
602 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/area/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629544   Available: 13576898
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * plain.c - area implementation of /std/room/plain
 */

inherit "/std/outsides/plain";
inherit "/std/room/inherit/topography/aroom";

//
// Need to fix up the inherited functions.
//

mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, plain::query_dest_other(direc));
} /* query_dest_other() */

string query_look(string direc) {
   return aroom::query_look(direc, plain::query_look(direc));
} /* query_dest_other() */

void create() {
   set_not_replaceable(1);
   ::create();
} /* create() */

string query_room_letter() {
   return ".";
} /* query_room_letter() */
// --- END [/mnt/home2/grok/lib/std/room/topography/area/plain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/area/mountain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/area/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629544   Available: 13576898
Inodes: Total: 5242880    Free: 4960136
617 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/area/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629544   Available: 13576898
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * mountain.c - area implementation of /std/room/mountain
 */

inherit "/std/outsides/mountain";
inherit "/std/room/inherit/topography/aroom";

//
// Need to fix up the inherited functions.
//

mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, mountain::query_dest_other(direc));
} /* query_dest_other() */

string query_look(string direc) {
   return aroom::query_look(direc, mountain::query_look(direc));
} /* query_dest_other() */

void create() {
   set_not_replaceable(1);
   ::create();
} /* create() */

string query_room_letter() {
   return "^";
} /* query_room_letter() */
// --- END [/mnt/home2/grok/lib/std/room/topography/area/mountain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/area/water_inside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/area/water_inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629543   Available: 13576897
Inodes: Total: 5242880    Free: 4960136
693 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/area/water_inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629543   Available: 13576897
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * water_inside.c - area implementation of /std/room/water_inside.
 */

inherit "/std/room/water_inside";
inherit "/std/room/inherit/topography/aroom";

//
// Need to fix up the inherited functions.
//

mixed* query_dest_other(string direc) {
   mixed*fluff;

   fluff =  water_inside::query_dest_other(direc);
printf("%O\n", fluff);
   return aroom::query_dest_other(direc, fluff);
} /* query_dest_other() */

string query_look(string direc) {
   return aroom::query_look(direc, water_inside::query_look(direc));
} /* query_dest_other() */

void create() {
   set_not_replaceable(1);
   ::create();
} /* create() */

string query_room_letter() {
   return "~";
} /* query_room_letter() */
// --- END [/mnt/home2/grok/lib/std/room/topography/area/water_inside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/area/outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/area/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629543   Available: 13576897
Inodes: Total: 5242880    Free: 4960136
608 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/area/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629543   Available: 13576897
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * outside.c - area implementation of /std/room/outside
 */

inherit "/std/room/outside";
inherit "/std/room/inherit/topography/aroom";

//
// Need to fix up the inherited functions.
//

mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, outside::query_dest_other(direc));
} /* query_dest_other() */

string query_look(string direc) {
   return aroom::query_look(direc, outside::query_look(direc));
} /* query_dest_other() */

void create() {
   set_not_replaceable(1);
   ::create();
} /* create() */

string query_room_letter() {
   return ".";
} /* query_room_letter() */
// --- END [/mnt/home2/grok/lib/std/room/topography/area/outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/area/water_outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/area/water_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629543   Available: 13576897
Inodes: Total: 5242880    Free: 4960136
697 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/area/water_outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629543   Available: 13576897
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * water_inside.c - area implementation of /std/room/water_inside.
 */

inherit "/std/room/water_outside";
inherit "/std/room/inherit/topography/aroom";

//
// Need to fix up the inherited functions.
//

mixed* query_dest_other(string direc) {
   mixed*fluff;

   fluff =  water_outside::query_dest_other(direc);
printf("%O\n", fluff);
   return aroom::query_dest_other(direc, fluff);
} /* query_dest_other() */

string query_look(string direc) {
   return aroom::query_look(direc, water_outside::query_look(direc));
} /* query_dest_other() */

void create() {
   set_not_replaceable(1);
   ::create();
} /* create() */

string query_room_letter() {
   return "~";
} /* query_room_letter() */

// --- END [/mnt/home2/grok/lib/std/room/topography/area/water_outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/area/woodland.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/area/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629542   Available: 13576896
Inodes: Total: 5242880    Free: 4960136
617 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/area/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629542   Available: 13576896
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*
 * woodland.c - area implementation of /std/room/woodland
 */

inherit "/std/outsides/woodland";
inherit "/std/room/inherit/topography/aroom";

//
// Need to fix up the inherited functions.
//

mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, woodland::query_dest_other(direc));
} /* query_dest_other() */

string query_look(string direc) {
   return aroom::query_look(direc, woodland::query_look(direc));
} /* query_dest_other() */

void create() {
   set_not_replaceable(1);
   ::create();
} /* create() */

string query_room_letter() {
   return "%";
} /* query_room_letter() */
// --- END [/mnt/home2/grok/lib/std/room/topography/area/woodland.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/area/room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/area/room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629542   Available: 13576896
Inodes: Total: 5242880    Free: 4960136
711 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/area/room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629542   Available: 13576896
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: room.c,v 1.3 2001/05/10 22:44:58 pinkfish Exp $
 *
 *
 */

/*
** room.c - area implementation of /std/room.
*/

inherit "/std/room/basic_room";
inherit "/std/room/inherit/topography/aroom";

//
// Need to fix up the inherited functions.
//

mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, basic_room::query_dest_other(direc));
} /* query_dest_other() */

string query_look(string direc) {
   return aroom::query_look(direc, basic_room::query_look(direc));
} /* query_dest_other() */

void create() {
   set_not_replaceable(1);
   ::create();
} /* create() */

string query_room_letter() {
   return "b";
} /* query_room_letter() */
// --- END [/mnt/home2/grok/lib/std/room/topography/area/room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/iroom/plain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629542   Available: 13576896
Inodes: Total: 5242880    Free: 4960136
636 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629542   Available: 13576896
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: plain.c,v 1.1 2000/05/01 03:13:33 jeremy Exp $
 *
 *
 */

/*
** plain.c - iroom implementation of /std/outsides/plain.
*/

inherit "/std/outsides/plain";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/iroom.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  add_exit(motion_verb, "interroom", "hidden");
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/iroom/plain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/iroom/mountain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629541   Available: 13576895
Inodes: Total: 5242880    Free: 4960136
648 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629541   Available: 13576895
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mountain.c,v 1.1 2000/05/01 03:13:14 jeremy Exp $
 *
 *
 */

/*
** mountain.c - iroom implementation of /std/outsides/mountain.
*/

inherit "/std/outsides/mountain";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/iroom.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  add_exit(motion_verb, "interroom", "hidden");
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/iroom/mountain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/iroom/outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629541   Available: 13576895
Inodes: Total: 5242880    Free: 4960136
626 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629541   Available: 13576895
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: outside.c,v 1.1 2000/05/01 03:13:14 jeremy Exp $
 *
 *
 */

/*
** outside.c - iroom implementation of /std/outside.
*/

inherit "/std/outside";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/iroom.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  add_exit(motion_verb, "interroom", "hidden");
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/iroom/outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/iroom/woodland.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629541   Available: 13576895
Inodes: Total: 5242880    Free: 4960136
648 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629541   Available: 13576895
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: woodland.c,v 1.1 2000/05/01 03:13:43 jeremy Exp $
 *
 *
 */

/*
** woodland.c - iroom implementation of /std/outsides/woodland.
*/

inherit "/std/outsides/woodland";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/iroom.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  add_exit(motion_verb, "interroom", "hidden");
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/iroom/woodland.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/iroom/room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629540   Available: 13576894
Inodes: Total: 5242880    Free: 4960136
614 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/iroom/room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629540   Available: 13576894
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: room.c,v 1.1 2000/05/01 03:13:34 jeremy Exp $
 *
 *
 */

/*
** room.c - iroom implementation of /std/room.
*/

inherit "/std/room";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/iroom.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  add_exit(motion_verb, "interroom", "hidden");
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/iroom/room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/milestone/plain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629540   Available: 13576894
Inodes: Total: 5242880    Free: 4960136
738 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/plain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629540   Available: 13576894
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: plain.c,v 1.1 2000/05/01 03:14:12 jeremy Exp $
 *
 *
 */

/*
** plain.c - milestone implementation of /std/outsides/plain.
*/

inherit "/std/outsides/plain";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/milestone.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  // This is a dummy exit so we can print a helpful message
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/milestone/plain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/milestone/mountain.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629539   Available: 13576893
Inodes: Total: 5242880    Free: 4960136
750 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/mountain.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629539   Available: 13576893
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: mountain.c,v 1.1 2000/05/01 03:13:44 jeremy Exp $
 *
 *
 */

/*
** mountain.c - milestone implementation of /std/outsides/mountain.
*/

inherit "/std/outsides/mountain";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/milestone.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  // This is a dummy exit so we can print a helpful message
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/milestone/mountain.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/milestone/outside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629539   Available: 13576893
Inodes: Total: 5242880    Free: 4960136
728 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/outside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629539   Available: 13576893
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: outside.c,v 1.1 2000/05/01 03:14:11 jeremy Exp $
 *
 *
 */

/*
** outside.c - milestone implementation of /std/outside.
*/

inherit "/std/outside";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/milestone.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  // This is a dummy exit so we can print a helpful message
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/milestone/outside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/milestone/woodland.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629539   Available: 13576893
Inodes: Total: 5242880    Free: 4960136
750 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/woodland.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629539   Available: 13576893
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: woodland.c,v 1.1 2000/05/01 03:14:26 jeremy Exp $
 *
 *
 */

/*
** woodland.c - milestone implementation of /std/outsides/woodland.
*/

inherit "/std/outsides/woodland";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/milestone.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  // This is a dummy exit so we can print a helpful message
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/milestone/woodland.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/topography/milestone/room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629538   Available: 13576892
Inodes: Total: 5242880    Free: 4960136
716 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/topography/milestone/room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629538   Available: 13576892
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: room.c,v 1.1 2000/05/01 03:14:26 jeremy Exp $
 *
 *
 */

/*
** room.c - milestone implementation of /std/room.
*/

inherit "/std/room";

// My apologies for including .c files.  If anyone else has a better way,
// I'm open to suggestions (the main problem is I need to mask
// query_dest_other() in the base room).

#include "/std/room/inherit/topography/milestone.c"

void create() {

  do_setup++;
  ::create();
  do_setup--;

  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }

  // This is a dummy exit so we can print a helpful message
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/topography/milestone/room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/safe_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/safe_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629538   Available: 13576892
Inodes: Total: 5242880    Free: 4960136
6844 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/safe_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629538   Available: 13576892
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* Edded to put inside rather than outside. Deutha 23/8/93
 * Changed to make it more safe, also removes ran_talk. Olorin 7/4/96
 * Patch added to stop the few killings that seem to get through. Terano 10/3/98
 * "Attack" command wasn't blocked. Weird. Fixed it. Red Scharron will be
 *   unable to use it here. *sigh* Also, I added some "violent" souls to the
 *   list. - Fiona 7/6/98
 * Added restriction against "iai" command.  Dragonkin 98-07-18
 * Rewritten - 21 July, 1998. Terano
 * Added restriction against "hurl" and "guard", fixed bug with magic smoke.
 *    Aragorn 98-09-06
 * Added restriction against "plant" - Aragorn 98-09-30
 * Added restriction against "invoke" - Aragorn 98-11-07
 * Protection from range attacks (longshot) and KLK insects added.
 *    Aragorn 98-11-08
 * Made Brother David unique, hopefully this will protect him from fleas.
 *    Aragorn 98-11-08
 * Added restriction against "twist" and "hedgehog" - Aragorn 99-01-18
 * Added protection from longshot that actually works  -  Gerbil 13-3-1999
 * Added restriction against "berserk" - Saffra June 3, 2000
 * Added restrictions against "perform", which is used in some rituals - Twiggy,
 *    Dec 24, 2000
 * Added restriction against "backstab" - Saffra April 16, 2001
 *
 * Made it into an inheritable, filed into /std/room/ for common use throughout 
 * the Disc on April 2002 - Siel
 */


#include <armoury.h>

#define TP this_player()
#define SHAD "/std/shadows/misc/davidshad"

inherit "/std/room/basic_room";

object keeper;

void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(90);
    
    /* Dry them up a bit */
    add_property("warmth", 3);
    add_property( "los", "closed" );
    
    /* Special property for things to check when attempting to complete. */
    add_property("calm room", 1);
  
    if(!do_setup) {
      this_object()->setup();
      this_object()->reset();
  }
} /* create() */

int trap_action( string str ) {
    string st1;

    if( sscanf( str,"%s %s",str,st1 ) );
    switch(str) {
    /* these are in alphabetical order for ease of reference */
    case "ambush":
    case "attack":
    case "backstab":
    case "behead":
    case "bury":
    case "cast":
    case "circle":
    case "conflagrate":
    case "crush":
    case "decompose":
    case "drag":
    case "eat":
    case "ensumpf":
    case "fade":
    case "filch":
    case "fire":
    case "fuel":
    case "guard":
    case "hedgehog":
    case "hide":
    case "hurl":
    case "iai":
    case "inhume":
    case "inpale":
    case "invoke":
    case "kill":
    case "mock":
    case "order":
    case "tempt":
    case "palm":
    case "perform":
    case "plant":
    case "pyroscipate":
    case "scathe":
    case "scribe":
    case "scry":
    case "shroud":
    case "slip":
    case "snatch":
    case "sneak":
    case "steal":
    case "recharge":
    case "rifle":
    case "throw":
    case "twist":
    case "use":
    case "ventisepelate":
    case "zap":

    /* Here go some violent souls */
    case "skick":
    case "sburn":
    case "slap":
    case "spunch":
    case "berserk":
        tell_object( this_player(), "You feel too peaceful to do that.\n");
        return 1;

    default:
        return 0;
    }
} /* trap_action */

void event_exit(object ob, string message, object to);

void init() {

    this_player()->remove_hide_invis( "hiding" );
    clone_object( SHAD )->setup_shadow(TP);
    this_player()->command_override( (: trap_action :) );
    this_player()->add_command( "dream", this_object(), "" );
    this_player()->add_command( "rest", this_object(), "" );

    ::init();
} /* init() */

/**
 * This is the object that is the keeper of the safe room. This should "
 * be an NPC.
 * @param keeper The keeper NPC object.
 */
void set_keeper(object ob) { keeper = ob; }

void event_exit(object ob, string message, object to){
    ob->dest_shadow();
}

void event_enter( object ob, string stringy, string stringy2 ) {
    object thing;
    if ( base_name( ob ) == "/d/guilds/priests/summoned/dust_devil" ) {
        ob->do_leave();
    }

    if ( base_name( ob ) == "/d/am/chars/herrena" ) {
            int *enums = ob->effects_matching( "fighting.combat" );
            foreach( int i in enums ) ob->delete_effect( i );
    }

    foreach( thing in all_inventory(ob)) {
        if( base_name( thing ) == "/d/sur/items/crystal_ball" )
            thing->do_rub();
    }

    if ( living( ob ) )
        call_out("make_calm", 1, ob );
        call_out( "stop_sneaking", 1, ob );

} /* event_enter */

/* Rest function used by players in this room.  aids healing but costs GP */
int do_rest( string str ) {
    this_player()->adjust_hp( 4 );
    this_player()->adjust_gp( -( 2 + random( 4 ) ) );
    /* well nothing's free is it ? */
    this_player()->adjust_social_points( -( 2 + random(8)));
    tell_object( this_player() ,
      "You rest on one of the pillows, and feel much "
      "better for it.\n");
    return 1;
} /* do_rest */

/* Dream function used by players. Aids healing but costs GP */

int do_dream( string str ) {
    this_player()->adjust_hp( 4 );
    this_player()->adjust_gp( -( 2 + random( 4 ) ) );
    /* well nothing's free is it ? */
    this_player()->adjust_social_points( -( 2 + random(8)));
    tell_object( this_player(), ({
      "You dream of a world where cabbages roam free.\n",
      "You have a vision of penguin waiters serving giraffes in white leisure "
         "suits.\n",
      "You dream of imp-powered sheep leaping over fences.\n",
      "You dream uneasily of creators with cuddly teddy-bears.\n",
      "Visions of sugar-plums dance through your head.\n",
      "You count lemons as you try to get to sleep.\n" }) [ random(4) ] );
    return 1;
} /* do_dream */

/* Stops all fighting here ....  */

void event_fight_in_progress( object ob1, object ob2 ) {
    if ( keeper ) { tell_room ( this_object(),
    keeper->the_short() + " hums a peaceful tune softly and calm fils the "
      "room." ); }
    ob2->stop_all_fight();
    ob1->stop_all_fight();
} /* event_fight_in_progress */

void make_calm( object blue ) {

    int *enums;
    int wibble;

    enums = blue->effects_matching("fighting.combat");

    if ( sizeof( enums ) ) {
        foreach( wibble in enums ) { blue->delete_effect( wibble ); }
        keeper->do_command("smile "+ blue->query_name() );
        tell_object( blue, "You feel a lot calmer.\n");
    }

} /* end do_calm */

void stop_sneaking( object sneaker ) {

    int *enums;
    int wibble;

    enums = sneaker->effects_matching( "covert.sneaking" );

    if ( sizeof( enums ) ) {
        foreach( wibble in enums ) { sneaker->delete_effect( wibble ); }
        keeper->do_command("hug "+ sneaker->query_name() );
        tell_object( sneaker, "You feel less sneaky.\n");
    }

} /* end stop_sneaking */
// --- END [/mnt/home2/grok/lib/std/room/safe_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/voting_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/voting_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629536   Available: 13576890
Inodes: Total: 5242880    Free: 4960136
27447 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/voting_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629536   Available: 13576890
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: voting_room.c,v 1.9 2001/10/16 16:53:06 ceres Exp pinkfish $
 *
 */

#include <board.h>

#define DEFAULT_VOTE_DURATION (2600*24*7)

/**
 * Generalised voting room intended to be inherited into rooms in the mud that
 * will setup the parameters and settings for votes.
 * <p>
 * The room does not inherantly support player initiated votes, however it is
 * a fairly simple matter to add this to your own room and have your room add
 * votes when players initiate them.
 *
 * @author Ceres
 */

/**
 *  This class stores the essential information about a vote. It is only used
 *  internally to the voting room.
 * @element type used to setup vote types
 * @element desc the description of the vote
 */
class vote {
  string type;                  /* used to setup vote types */
  string desc;                  /* description of the vote */
  string *choices;              /* options in the vote */
  mixed *votes;
  int ending;                   /* when the vote ends */
  string *voted;                /* people who've voted */
}

/**
 *  This class stores the essential information about an election during the
 *  setup phase. It is only used internally to the voting room.
 */
class election {
  mixed *candidates;            /* who are the candidates */
  int closes;                   /* when does acceptance of nominees close */
}

private int vote_counter;               /* Used to give each vote a unique number */

private mapping votes;                  /* the votes themselves */
private mapping elections;              /* the elections being setup */

private nosave string _vote_file;        /* Controls which vote file to use */
private nosave mixed _vote_cond;
private nosave mixed _comp_action;       /* Completion action */
private nosave int _vote_duration;       /* The normal duration for a vote */
private nosave int _open_voting;         /* Make who voted for what known */
private nosave int _no_elections;
private nosave string _proxy;            /* A proxy room to use for votes. */

private nosave mixed _stand_cond;
private nosave mixed _second_cond;

private nosave mixed _election_announcement; /* The board, person and subject */

int list_votes();
int cast_vote( string words, int num );
int stand_for_election(string position);
int second_candidate(string who, string position);
int list_elections();
int do_create_vote(string choices);

/**
 * @ignore
 */
void create() {
  seteuid("Room");
  votes = ([ ]);
  elections = ([ ]);
}

/**
 * @ignore
 */
void init() {
   // commands for votes
   add_command("vote", "<string> on <number>", (: cast_vote($4[0], $4[1]) :) );
   add_command("list", "votes", (: list_votes :));
   add_command("votes", "", (: list_votes :));

   // commands for elections
   if (!_no_elections) {
      add_command( "stand", "[for] <string>", (: stand_for_election($4[0]) :));
      add_command( "second", "<string> [for] <string>",
                   (: second_candidate($4[0], $4[1]) :) );
      add_command("list", "elections", (: list_elections :));
      add_command("elections", "", (: list_elections :));
   }
} /* init() */

/**
 * This method is used to return the current votes.  This can be overridden
 * in higher functions to get the votes from somewhere else if nessessary.
 * @return the votes
 */
protected mapping query_our_votes() {
   if (_proxy) {
      return _proxy->query_votes();
   }
   if (votes) {
      return votes;
   }
   return ([ ]);
} /* query_our_votes() */

/**
 * This method adds in a vote.
 * @param id the id of the vote
 * @param data the vote data
 */
protected void add_our_vote(int id, class vote data) {
   if (!votes) {
      votes = ([ ]);
   }
   votes[id] = data;
} /* add_our_vote() */

/**
 * This method is used to return the current elections.  This can be
 * overridden in hgiher inherits to control things better.
 * @return the elections
 */
protected mapping query_our_elections() {
   if (_proxy) {
      return _proxy->query_elections();
   }
   if (elections) {
      return elections;
   }
   return ([ ]);
} /* query_our_elections() */

/**
 * This method adds in a election.
 * @param name the name of the election to add
 * @param data the election data
 */
protected void add_our_election(string name, class election data) {
   if (!elections) {
      elections = ([ ]);
   }
   elections[name] = data;
} /* add_our_election() */

/**
 * This is the init() which should be called as well as the default
 * init() if you wish to have player added votes.
 */
void init_add_vote() {
   add_command( "add", "vote with <string'choices'>",
               (: do_create_vote($4[0]) :));
} /* init_add_vote() */

/**
 * This setups all the stuff that  needs to be setup after the room has
 * been loaded.  Makes all the callouts for the right amount of time
 * and so on.
 */
void setup_after_load() {
  int i;
  string election;
  int *vote_ids;

  if (_proxy) {
    return ;
  }
  vote_ids = m_indices( query_our_votes() );

  for ( i = 0; i < sizeof( vote_ids ); i++ ) {
    if ( query_our_votes()[ vote_ids[ i ] ]->ending < time() ) {
      call_out( "end_vote", 10 * ( i + 1 ), vote_ids[ i ] );
    } else {
      call_out( "end_vote", query_our_votes()[ vote_ids[ i ] ]->ending - time(),
                vote_ids[ i ] );
    }
  }

  foreach(election in keys(query_our_elections())) {
    if(query_our_elections()[election]->closes < time()) {
      call_out( "start_election_vote", 30 * random(5), election);
    } else {
      call_out( "start_election_vote", query_our_elections()[election]->closes - time(),
                election);
    }
  }
} /* setup_after_load() */

/**
 * This method is called by the inheriting object to determine which save file
 * to use for votes.
 *
 * @param str The name of the file you want the voting info saved to
 * (without the .o)
 */
void set_save_file(string file) {
  
  _vote_file = file;
  if( file_size( _vote_file + ".o" ) > 0 ) {
    unguarded( (: restore_object, _vote_file :) );
    setup_after_load();
  } else {
    elections = ([ ]);
    votes = ([ ]);
  }
}

/**
 * This method returns the save file currently used for the room.
 * @return the current save file
 */
string query_save_file() { return _vote_file; }

/**
 * Private function to save the rooms data file.
 */
protected void save_room() {
   if (_vote_file) {
      unguarded( (: save_object, _vote_file :) );
   }
}

/**
 * This method sets up a proxy for the room.  A proxy is somewhere else
 * to get all the voting information from.
 * @param proxy the proxy tpo setup
 */
void set_proxy(string proxy) {
   _proxy = proxy;
} /* set_proxy() */

/**
 * This method sets the room to not allow elections and disable all the
 * election commands.
 * @param no_elections the flag
 */
void set_no_elections(int no_elections) {
   _no_elections = no_elections;
} /* set_no_elections() */

/**
 * This function setups if the votes should be open or not.  If a vote is
 * open then you know who voted for each thing.
 * @param open 1 for an open system 0 for closed
 */
void set_open_voting(int open) {
   _open_voting = open;
} /* set_open_voting() */

/**
 * This function queries if the votes should be open or not.  If a vote is
 * open then you know who voted for each thing.
 * @return 1 for an open system 0 for closed
 */
int query_open_voting(int open) {
   return _open_voting;
} /* set_open_voting() */

/**
 * This function defines a function to be called to determine if a player
 * is eligible to vote.
 *
 * @param cond This will usually be a mixed array of an object and a function.
 * It could also be a function pointer.
 *
 * Your function should return 1 if the player is eligible to vote or 0 if
 * they are not.
 */
void set_vote_conditions(mixed cond) { _vote_cond = cond; }

/**
 * This function defines a function to be called when the vote is complete.
 * Typically your function will post the vote results somewhere or somesuch.
 * The parameters passedinto the function are:<br>
 * ( string type, string description, string* choices, mapping votes, string* voted) <br>
 *
 * @param cond This will usually be a mixed array of an object and a function.
 * It could also be a function pointer.
 */
void set_completion_action(mixed cond) { _comp_action = cond; }

/**
 * This function is used to set the normal vote and election duration. It can
 * be overridden when calling add_vote. If it is not set and no duration is
 * given in add_vote then the default value of DEFAULT_VOTE_DURATION is used.
 *
 * @param duraction The number of seconds the vote should be open.
 *
 * @see add_vote()
 */
void set_vote_duration(int duration) { _vote_duration = duration; }

/**
 * This function is used to returns the normal vote and election duration.
 * If it is not set and no duration is
 * given in add_vote then the default value of DEFAULT_VOTE_DURATION is used.
 *
 * @param duraction The number of seconds the vote should be open.
 *
 * @see add_vote()
 */
int query_vote_duration() {
   if (!_vote_duration) {
      return DEFAULT_VOTE_DURATION;
   }
   return _vote_duration;
}

/**
 * This function defines a function to be called to determine if a player
 * is eligible to stand for election to a position.
 *
 * @param cond This will usually be a mixed array of an object and a function.
 * It could also be a function pointer.
 *
 * Your function should return 1 if the player is eligible to stand or 0 if
 * they are not.
 */
void set_stand_conditions(mixed cond) { _stand_cond = cond; }

/**
 * This function defines a function to be called to determine if a player
 * is eligible to second a canditate for election.
 *
 * @param cond This will usually be a mixed array of an object and a function.
 * It could also be a function pointer.
 *
 * Your function should return 1 if the player is eligible to second or 0 if
 * they are not.
 */
void set_second_conditions(mixed cond) { _second_cond = cond; }

/**
 * This function defines the board, person and subject for announcements
 * of elections.
 *
 * @param board This is the board to post to.
 * @param person This is who to post as.
 * @param subject This is the subject line to use.
 * @param prefix The text to preceed the message.  The default is
 *               "All eligible persons are requested to vote for the position "
 *               "of "
 * @param suffix The text to follow the message.
 */
void set_election_announcement(string board, string person, string subject,
                               string prefix, string suffix) {
  _election_announcement = ({ board, person, subject, prefix, suffix });
}

/**
 * This function is called when a player votes. The syntax is
 * "vote <choice> on <vote>".
 *
 * @see set_vote_conditions()
 */
int cast_vote( string which_str, int vote_id ) {
  string pname;
  int which, ok;
  class vote this_vote;
 
  if (_proxy) {
     return _proxy->cast_vote(which_str, vote_id);
  }
 
  if ( undefinedp(query_our_votes()[vote_id])) {
    add_failed_mess("There is no vote " + vote_id + ".\n");
    return 0;
  }

  this_vote = query_our_votes()[vote_id];
  which = member_array(which_str, this_vote->choices);
  if (which == -1) {
    if(strlen(which_str) > 1) {
      add_failed_mess("There is no choice " + which_str + " for vote id " +
           vote_id + ".\n");
      return 0;
    }

     which = upper_case( which_str )[ 0 ] - 65;
  }
  if(which < 0 || which > sizeof(this_vote->choices) -1) {
    add_failed_mess("There is no choice " + which_str + " for vote id " +
                           vote_id + ".\n");
    return 0;
  }
  
  ok = 1;
  if (functionp(_vote_cond)) {
    ok = evaluate(_vote_cond, this_player(), this_vote->desc);
  }
  if(arrayp(_vote_cond)) {
    ok = call_other(_vote_cond[0], _vote_cond[1], this_player(), this_vote->desc);
  }

  if(!intp(ok)) {
    ok = 0;
  }

  if(!ok) {
    add_failed_mess("Sorry, but you are not allowed to vote on this "
                       "subject.\n");
    return 0;
  }

  pname = this_player()->query_name();
  if(member_array(pname, this_vote->voted) != -1) {
    add_succeeded_mess(({"You have already voted on this subject.\n", ""}));
    return 1;
  }

  this_vote->voted += ({ pname });
  if (_open_voting) {
     this_vote->votes[which] += ({ pname });
  } else {
     if (arrayp(this_vote->votes[which])) {
        this_vote->votes[which] = sizeof(this_vote->votes[which]);
     }
     this_vote->votes[which]++;
  }
  save_room();
 
  add_succeeded_mess(({ "You cast your vote for "+which_str + " on " +
                        vote_id+".\n",
                        "$N casts a vote.\n" }));
  
  return 1;
} /* cast_vote() */

/**
 * This function is called when a player types 'list'. It lists the currently
 * open votes.
 */
int list_votes() {
  int i, j, *vote_ids;
  string text;
  class vote this_vote;
  
  if ( !m_sizeof( query_our_votes() ) ) {
    write( "There are no votes in progress.\n" );
    return 1;
  }
  
  vote_ids = m_indices( query_our_votes() );
  if ( sizeof( vote_ids ) > 1 )
    write( "The following votes are in progress:\n" );
  else
    write( "The following vote is in progress:\n" );
  text = "";

  for ( i = 0; i < sizeof( vote_ids ); i++ ) {
    this_vote = query_our_votes()[vote_ids[i]];
    text += "  "+ vote_ids[i] + ". " + this_vote->desc +"\n Choices are :\n";

    for(j=0; j<sizeof(this_vote->choices); j++) {
      text += sprintf("    %c. %s\n", 'A'+j, this_vote->choices[j]);
    }
    text += " Voting closes at "+ ctime( this_vote->ending ) +".\n\n";
  }
  
  this_player()->more_string(sprintf( "%-=*s",
                                      (int)this_player()->query_cols(),
                                      text ));
  return 1;
}

/**
 * This function is called to add a vote to the system.
 *
 * @param type Freeform string giving the type of vote. This is typically used
 * by your completion function so that it can perform different actions for
 * different types of votes.
 *
 * @param description The description of the vote as shown to the player.
 *
 * @param choices An array of vote options eg. ({"Yes", "No" })
 *
 * @param ending An integer time of when the vote should be terminated.
 *
 * @see set_completion_action()
 */
void add_vote(string type, string description, string *choices, int ending) {
  class vote new_vote;
  
  if (_proxy) {
     return _proxy->add_vote(type, description, choices, ending);
  }
  vote_counter++;
  
  new_vote = new(class vote);
  new_vote->type = type;
  new_vote->desc = description;
  new_vote->choices = choices;
  if (_open_voting) {
    new_vote->votes = allocate(sizeof(choices), (: ({ }) :));
  } else {
    new_vote->votes = allocate(sizeof(choices));
  }
  if(ending) {
    new_vote->ending = ending;
  } else if(_vote_duration) {
    new_vote->ending = (_vote_duration + time());
  } else {
    new_vote->ending = (DEFAULT_VOTE_DURATION + time());
  }
  new_vote->voted = ({ });

  add_our_vote(vote_counter, new_vote);
  //query_our_votes()[ vote_counter ] = new_vote;

  call_out( "end_vote", new_vote->ending - time(), vote_counter );

  save_room();
}

/**
 * @ignore
 */
mapping query_votes() { return query_our_votes() + ([ ]); }

/**
 * @ignore
 */
mapping query_elections() { return query_our_elections() + ([ ]); }

/**
 * This function is called to terminate a vote. It calls your completion
 * action.
 *
 * @see set_completion_action()
 */
void end_vote( int which ) {
  if ( !query_our_votes()[ which ] ) {
      return;
  }

  if(functionp(_comp_action)) {
      evaluate(_comp_action, query_our_votes()[which]->type, query_our_votes()[which]->desc,
               query_our_votes()[which]->choices, query_our_votes()[which]->votes,
               query_our_votes()[which]->voted);
  } else if(arrayp(_comp_action)) {
    call_other(_comp_action[0], _comp_action[1], query_our_votes()[which]->type,
               query_our_votes()[which]->desc, query_our_votes()[which]->choices, query_our_votes()[which]->votes,
               query_our_votes()[which]->voted);
  }

  map_delete(query_our_votes(), which);

  save_room();
}

/**
 * This function is provided for convenience to make it easy for your vote
 * end function to post to a board.
 *
 * @param board The name of the board to post to.
 * @param name The name of the person to post as.
 * @param subject The subject line to use.
 * @param message The message to post.
 */
void make_announcement(string board, string name, string subject,
                       string message ) {
  BOARD_HAND->add_message(board, name, subject,
                          sprintf( "%-=*s", 64, message));
}

/**
 * This function is used to initiate an election.
 * It sets up the election class and adds it to the mapping.
 *
 * @param position The name of the position the election is for.
 */
void initiate_election(string position) {
  class election tmp;

  if (_proxy) {
     return _proxy->initiate_election(position);
  }
  if(query_our_elections()[position])
    return;

  tmp = new(class election);
  tmp->candidates = ({});
  if(_vote_duration) {
    tmp->closes = time() + _vote_duration;
  } else {
    tmp->closes = time() + DEFAULT_VOTE_DURATION;
  }

  add_our_election(position, tmp);

  call_out("start_election_vote", tmp->closes + 60, position);
  
  save_room();
} /* initiate_election() */

/**
 * This method determines if there is already an election of the
 * specified type in progress.
 * @param position the name of the election in progress
 * @return 1 if there is an election in progress
 */
int query_election_in_progress(string position) {
   if (classp(query_our_elections()[position])) {
       return 1;
   }
   return 0;
} /* query_election_in_progress() */

/**
 * This function is used by players to stand for election. The syntax is:
 * "stand for <position>".
 *
 * @see set_stand_conditions()
 */
int stand_for_election(string position) {
  int ok, i;
  
  if (_proxy) {
     return _proxy->stand_for_election(position);
  }
  // check if they're eligible.
  ok = 1;
  if(functionp(_stand_cond)) {
    ok = evaluate(_stand_cond, this_player(), position);
  } else if(arrayp(_stand_cond)) {
    ok = call_other(_stand_cond[0], _stand_cond[1], this_player(), position);
  }

  if(!intp(ok))
    ok = 0;

  if(!ok) {
    add_succeeded_mess(({ "Sorry, but you are not allowed to stand for this "
                            "election.\n", ""}));
    return 1;
  }

  // check if there is an election for this position.
  if(!query_our_elections()[position]) {
    add_succeeded_mess(({"There is no election in progress for the post of " +
                    position + ".\n", ""}));
    return 1;
  }

  // check if they're already a candidate for this position.
  for(i=0; i<sizeof(query_our_elections()[position]->candidates); i++) {
    if(query_our_elections()[position]->candidates[i][0] == this_player()->query_name()) {
      add_succeeded_mess(({"You are already standing in this "
                             "election.\n", ""}));
      return 1;
    }
  }
    
  // add them to the list of candidates.
  query_our_elections()[position]->candidates += ({({ this_player()->query_name(), "" })});
  save_room();
  add_succeeded_mess(({"You have been added to the list of candidates for "
                         "the position of " + position + ".  You must now "
                         "find someone to second your candidacy.\n",
                         "$N stands for election.\n"}));
  return 1;
}

/**
 * This function is used by players to second candidates for election. If a
 * candidates isn't seconded he/she won't be in the election. The syntax is:
 * "second <player> for <position>".
 *
 * @see set_second_conditions()
 */
int second_candidate(string who, string position) {
  mixed *candidates;
  int i, found, ok;
  
  if (_proxy) {
     return _proxy->second_candidate(who, position);
  }
  // check if they're eligible.
  ok = 1;
  if(functionp(_second_cond)) {
    ok = evaluate(_second_cond, this_player(), position);
  } else if(arrayp(_second_cond)) {
    ok = call_other(_second_cond[0], _second_cond[1], this_player(), position);
  }

  if(!intp(ok))
    ok = 0;

  if(!ok) {
    add_succeeded_mess(({"Sorry, but you are not allowed to second candidates "
                           "in this election.\n", ""}));
    return 1;
  }

  // check the position is up for election
  if(!query_our_elections()[position]) {
    add_succeeded_mess(({"There is no election in progress for " + position +
                           ".\n", ""}));
    return 1;
  }

  // check the candidate is standing
  candidates = (query_our_elections()[position])->candidates;
  for(i=0; i< sizeof(candidates); i++) {
    if(candidates[i][0] == who)
      found = i+1;
  }

  if(!found) {
    add_succeeded_mess(({who + " is not standing for the position of " +
                           position + ".\n", ""}));
    return 1;
  }

  if(this_player()->query_name() == who) {
    add_succeeded_mess(({"You cannot second yourself.\n", ""}));
    return 1;
  }

  if(candidates[found-1][1] != "") {
    add_succeeded_mess(({candidates[found-1][0] +
                           " has already been seconded by " +
                           candidates[found-1][1] + ".\n", ""}));
    return 1;
  }
  
  // mark the candidate as seconded (supported).
  candidates[found-1][1] = this_player()->query_name();

  save_room();
  
  add_succeeded_mess(({candidates[found-1][0] +
                         " has been seconded in the election for "+
                         position+".\n", ""}));
  return 1;
}

/**
 * Once the candidacy phase is over this function starts the election vote
 * itself by taking all eligible candidates, setting them as choices in the
 * election and then posting an announcemment.
 */
void start_election_vote(string post) {
  string str, *choices;
  int i;
  
  if(!query_our_elections()[post])
    return;


  if(_election_announcement[3])
    str = _election_announcement[3];
  else
    str = "All eligible persons are requested to vote for the position of ";
  
  str += post + "\n\nThe candidates are:\n";
  
  choices = ({ });
  for(i=0; i<sizeof(query_our_elections()[post]->candidates); i++) {
    if(query_our_elections()[post]->candidates[i][1] != "") {
      str += sprintf("  %s seconded by %s.\n", 
                     query_our_elections()[post]->candidates[i][0],
                     query_our_elections()[post]->candidates[i][1]);
      choices += ({ query_our_elections()[post]->candidates[i][0] });
    }
  }

  if(!sizeof(choices)) {
    str = "In the election for the position of " + post +
      " no candidate stood for election therefore the election "
      "is null and void.\n";
  } else if(sizeof(choices) < 2) {
    str = "In the election for the position of " + post +
      " only one candidate stood for election therefore the election "
      "is null and void.\n";
  } else {

    if(_election_announcement[4])
      str += _election_announcement[4];

    add_vote("election", "Election for the post of " + post + "\n", choices,
             0);
  }
  
  make_announcement(_election_announcement[0], _election_announcement[1],
                    _election_announcement[2], str);

  map_delete(query_our_elections(), post);
  save_room();
}

/**
 * This function is called when a player types 'elections'. It lists the
 * elections currently accepting candidates.
 */
int list_elections() {
  class election this_election;
  string *posts, text;
  int i, j;
  
  if ( !m_sizeof( query_our_elections() ) ) {
    write( "There are no elections in progress.\n" );
    return 1;
  }
  
  posts = m_indices( query_our_elections() );
  if ( sizeof( posts ) > 1 )
    write( "The following elections are in progress:\n" );
  else
    write( "The following election is in progress:\n" );
  text = "";

  for ( i = 0; i < sizeof( posts ); i++ ) {
    this_election = query_our_elections()[posts[i]];
    text += "  Election to the post of "+ posts[i] + ".\n";

    if(!sizeof(this_election->candidates)) {
      text += "  No candidates have declared yet.\n";
    } else {
      text += "    Current candidates are :\n";
      
      for(j=0; j<sizeof(this_election->candidates); j++) {
        if(this_election->candidates[j][1] != "")
          text += sprintf("    %c. %s seconded by %s.\n", 'A'+j,
                          this_election->candidates[j][0],
                          this_election->candidates[j][1]);
        else
          text += sprintf("    %c. %s not yet seconded.\n", 'A'+j,
                          this_election->candidates[j][0]);
          
      }
    }
    text += " Candidacies must be declared by "+
      ctime( this_election->closes ) +".\n\n";
  }
  
  this_player()->more_string(sprintf( "%-=*s",
                                      (int)this_player()->query_cols(),
                                      text ));
  return 1;
}

/** @ignore yes */
string strip_spaces(string str) {
   if (!strlen(str)) {
      return str;
   }
   while (str[0] == ' ') {
      str = str[1..];
   }
   if (!strlen(str)) {
      return str;
   }
   while (str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
} /* strip_spaces() */

/**
 * This is an option function which can be defined in upper level inherits.
 * It allows the players to create their own votes with their own choices.
 */
int do_create_vote(string choices) {
   string* bits;

   bits = map(explode(choices, ","), (: strip_spaces($1) :)) - ({ "" });
   write("Choices: " + query_multiple_short(bits) + ".\n");
   write("What description would you like for your vote?\n");
   this_player()->do_edit("", "create_vote_desc", this_object(), 0, bits);
   add_succeeded_mess(({ "", "$N starts to create a new vote.\n" }));
   return 1;
} /* do_create_vote() */

/** @ignore yes */
void create_vote_desc(string str, string* choices) {
   if (!str) {
      write("Aborting.\n");
      return ;
   }
   write("Are you sure you wish to create a vote with a description of:\n" +
         str + "\nWith vote choices of " + query_multiple_short(choices) +
         ".\n");
   write("Please answer yes or no: ");
   input_to("create_vote_desc_confirm", 0, str, choices);
} /* create_vote_desc() */

/** @ignore yes */
void create_vote_desc_confirm(string str, string desc, string* choices) {
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
      write("Please answer yes or no: ");
      input_to("create_vote_desc_confirm", 0, str, choices);
   }

   if (str[0] == 'q' || str[0] == 'n') {
      write("Ok, quitting.\n");
      return ;
   }

   //
   // Now we add the vote.
   //
   add_vote("freeform", desc, choices, 0);
   write("Added in the vote.\n");
} /* create_vote_desc_confirm() */

/**
 * This is an administrative function to allow the removal/cancellation
 * of an election.
 * @param election The name of the election to be cancelled
 * @return Returns 1 for success, 0 for failure.
 */
int delete_election(string election) {
  if(!query_our_elections()[election])
    return 0;
  map_delete(query_our_elections(), election);
  save_room();
  return 1;
}

/**
 * This is an administrative function to allow the removal/cancellation
 * of a vote.
 * @param vote_id The id number of the vote to be cancelled.
 * @return Returns 1 for success, 0 for failure.
 */
int delete_vote(int vote_id) {
  if(!query_our_votes()[vote_id])
    return 0;
  
  map_delete(query_our_votes(), vote_id);
  save_room();
  return 1;
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/voting_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/topography/milestone.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/topography/milestone.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629529   Available: 13576883
Inodes: Total: 5242880    Free: 4960136
17500 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/topography/milestone.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629529   Available: 13576883
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: milestone.c,v 1.1 2000/05/01 03:15:00 jeremy Exp $
 *
 *
 */

/*
** milestone.c - this is the "regular" room along a road.  See interroom.c
**           for more info.  NOTE: this file isn't used
**           by itself.  It is included in other files that inherit the
**           proper base room.  I HATE doing it this way, but I couldn't
**           think of a way to make the inheritance work out.
*/
/**
 * This file contains the functions for creating "milestones", the
 * rooms that serve as the endpoints for a section of irooms.  The purpose
 * is to allow more resolution between widely-spaced rooms, such as
 * roads, without requiring the player to traverse them all.<p>
 * Between each pair of milestones is an array of irooms (short for
 * "interrooms"); irooms are generally cloned as needed, while milestones
 * are generally unique rooms.  The irooms between two milestones are
 * reached via exits with the same names as those connecting the milestones,
 * but prepended with a "motion verb" (eg, "walk", giving an iroom exit of
 * "walk east").<p>
 * <b>NOTE:<b> This file is not an object in itself.  It is meant to be
 * included in other files that implement the various types of rooms (I
 * know, I know: it's very ugly.  But it's the only way I could think to
 * handle the inheritance without copying this file in each room file).
 * @author Jeremy
 * @see iroom
 * @see interroom
 * @see topography
 */

#include <dirs.h>
#include <room.h>

mapping milestone_dirs = ([ ]);
mapping milestone_index = ([ ]);
mapping shorten = SHORTEN;

string topo_handler;

// This is the "actual" size, relative to the interrooms (is it possible
// each direction could need a different size?  If so, I could query the
// handler).
int *actual_room_size;

string motion_verb = "walk", short_mse;
string iroom_exit_mess = "$N $V$s away to the $T.";
string iroom_enter_mess = "$N $V$s in from the $F.";
// Note that move messages don't do $N subs.
string iroom_move_mess = "You $V a little to the $T.\n";
string *pass_mess = ({
  "You $V a long while.",
  "$N passes by heading $T.",
  "  On the way you pass $O.\n"

});

// These are for unspecified exits
mixed other_exits = ({ });
string *other_types = ({ });

mapping look_mess = ([ ]);

mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);

mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);

/**
 * @ignore
 */
void add_topo_exits_int();

/**
 * This method is deprecated.  Use set_topo_handler()
 */
void set_area_handler(string s) { topo_handler = s; }

/**
 * This method sets the topography handler for this milestone.
 * @param s pathname of topography handler
 * @see topography
 * @see query_topo_handler()
 */
void set_topo_handler(string s) { topo_handler = s; }

/**
 * This method returns the topography handler set for this milestone.
 * @return the topography handler for the milestone
 * @see set_topo_handler()
 */
string query_topo_handler() { return topo_handler; }

/**
 * This method sets the room size used by the topography handler to
 * determine if the room is entered or crossed.  This is generally
 * the same as the iroom size.  The normal room
 * size (set with set_room_size()) is used to determine the distance
 * between milestones.
 * @param s room size (three elements)
 * @see set_room_size()
 * @see query_actual_room_size()
 */
void set_actual_room_size(int *s) { actual_room_size = copy(s); }

/**
 * This method returns the actual room size.
 * @return room size (three elements)
 * @see set_actual_room_size()
 */
int *query_actual_room_size() { return actual_room_size; }

/**
 * This method sets the milestone's motion verb, the verb to be used in the
 * iroom exit names; eg, "walk", "swim".  The default is "walk".
 * @param s motion verb
 * @see interroom
 * @see query_motion_verb()
 */
void set_motion_verb(string s) { motion_verb = s; }

/**
 * This method returns the motion verb.
 * @return the motion verb
 * @see set_motion_verb()
 */
string query_motion_verb() { return motion_verb; }

/**
 * This method sets the exit message for exits to irooms.  The format
 * is the same as for normal exit messages, except that $V can be used
 * to represent the motion verb.  The default is<pre><br>
 *     <code>"$N $V$s away to the $T."</code>
 * </pre>
 * @param s iroom exit message
 * @see query_iroom_exit_mess()
 * @see modify_exit()
 */
void set_iroom_exit_mess(string s) { iroom_exit_mess = s; }

/**
 * This method returns the iroom exit message.
 * @return iroom exit message
 * @see set_iroom_exit_mess()
 */
string query_iroom_exit_mess() { return iroom_exit_mess; }

/**
 * This method sets the entrance message used when entering an
 * iroom.  The format is the same as for normal entrance messages, except
 * that $V represents the motion verb.  The default is<pre><br>
 *     <code>"$N $V$s in from the $F."</code>
 * </pre>
 * @param s iroom entrance message
 * @see query_iroom_enter_mess()
 * @see modify_exit()
 */
void set_iroom_enter_mess(string s) { iroom_enter_mess = s; }

/**
 * This method returns the iroom entrance message.
 * @return iroom entrance message
 * @see set_iroom_enter_mess()
 */
string query_iroom_enter_mess() { return iroom_enter_mess; }

/**
 * This method sets the "moving message" shown to the player when
 * leaving by an iroom exit.  The format is the same as for normal moving
 * messages, except that $V represents the motion verb.  The default
 * is<pre><br>
 *     <code>"You $V a little to the $T.\n"</code>
 * </pre>
 * @param s iroom moving message
 * @see query_iroom_move_mess()
 * @see modify_exit()
 */
void set_iroom_move_mess(string s) { iroom_move_mess = s; }

/**
 * This method returns the iroom moving message.
 * @return iroom moving message
 * @see set_iroom_move_mess()
 */
string query_iroom_move_mess() { return iroom_move_mess; }

/**
 * This method sets the messages printed when passing through a number
 * of irooms in one move.  The parameter should be an array of three
 * strings: the first is the one printed to the moving player; the
 * second is printed to all living objects that are passed.  Both follow
 * the same format as the other iroom messages.  The third is a string which
 * is appended to the first if any objects are passed along the way;
 * $O can be used to represent the list of objects.  Any or all of the
 * strings can be set to 0, in which case that string will not be printed.
 * The default passing messages are<pre><br><code>
 *    ({ "You $V a long while.",
 *       "$N passes by heading $T.",
 *       "  On the way you pass $O.\n"
 * </code></pre>
 * @param s iroom passing messages (array of 3 strings)
 * @see query_pass_mess()
 * @see modify_exit()
 */
void set_pass_mess(string *s) { pass_mess = s; }

/**
 * This method returns the current iroom passing messages.
 * @return iroom move messages
 * @set_pass_mess()
 */
string *query_pass_mess() { return pass_mess; }

/**
 * This method adds or changes the message printed when looking in a
 * certain direction.  Messages set with modify_exit() have priority.
 * If neither are set, the room's description is used.
 * @param m a mapping of messages in the form ([<direc>:<mess>])
 */
void add_look_mess(mapping m) { look_mess += m; }

/**
 * This method queries the message printed when looking in a certain
 * direction.
 * @return a mapping of messages in the form ([<direc>:<mess>])
 * @see add_look_mess()
 */
mapping query_look_mess() { return look_mess; }

/**
 * @ignore
 * This method keeps track of the iroom exits associated with a handler.
 * It is called by the iroom handler.
 */
void add_milestone_dir(string handler, string dir) {
  if (undefinedp(milestone_dirs[handler])) {
    milestone_dirs[handler] = ({ dir });
  } else {
    milestone_dirs[handler] += ({ dir });
  }
}

/**
 * @ignore
 * Debugging function
 */
mixed query(string s) { return fetch_variable(s); }

// This should be called in setup() for each handler used by this milestone,
// with no index.  The actual index will be set by the handler
// when setup_milestone() is called.

/**
 * This method needs to initially be called in the milestone's setup()
 * to set the path for the iroom handler.  The index must be unspecified.
 * It is later called by the handler to set the index.<p>
 * The method may be called more than once if the milestone uses more
 * than one handler (eg, at a crossroads).
 * @param handler the path of the iroom handler
 * @param index <b>should not be specified</b>, except by the handler
 * @see interroom
 */
varargs void set_milestone_index(string handler, int index) {
  milestone_index[handler] = index;
}

/**
 * This method must be called *via a callout* in the room's create()
 * or setup().  Generally this is done high up in the inheritance tree.
 * This is to allow all of the parameters to be set up before the
 * iroom handler is called.
 * @see interroom
 */
void setup_milestone() {
  string handler;

  foreach (handler in keys(milestone_index)) {
    handler->setup_milestone(this_object());
  }
  add_topo_exits_int();
}

/**
 * This method should be called instead of add_exit() to connect
 * two milestones.  It handles setting up the exits to the irooms
 * as well as the adjacent milestone.
 * @param s direction
 * @param dest path to next milestone
 * @param type type of exit
 * @return status
 * @see add_exit()
 */
int add_milestone_exit(string s, string dest, string type) {
  string ss, em, xm, mm;

  add_exit(s, dest, type);
  add_exit(motion_verb + " " + s, "interroom", "hidden");
  if (!undefinedp(shorten[s])) {
    ss = shorten[s];
    add_alias(motion_verb + " " + ss, motion_verb + " " + s);
  } else {
    ss = s;
  }
  if (type != "hidden") {
    remove_exit(motion_verb + " <" + short_mse + ">");
    if (!short_mse) {
      short_mse = ss;
    } else {
      short_mse += "/" + ss;
    }
    add_exit(motion_verb + " <" + short_mse + ">", "interroom", type);
  }
  em = replace(iroom_enter_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  xm = replace(iroom_exit_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  mm = replace(iroom_move_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  modify_exit(motion_verb + " " + s, ({
    "exit mess", "$N " + motion_verb + "$s away to the " + s + ".",
    "enter mess", "$N " + motion_verb + "$s in from the " + opposites[s] + ".",
    "move mess", "You " + motion_verb + " a little to the " + s + ".\n"
  }));
  return modify_exit(s, ({ "function", "passing_mess" }) );
}

/**
 * @ignore
 * This method is called when a player passes through more than one
 * iroom in a move.
 */
int passing_mess(string dir, object ob, string special_mess) {
  int i;
  object *obs, passed;
  string mess1, mess2, handler;

  foreach (handler in keys(milestone_dirs)) {
    i = member_array(dir, milestone_dirs[handler]);
    if (i < 0) {
      continue;
    }
    obs = handler->query_irooms_inv(milestone_index[handler], -1, i);
    if (stringp(pass_mess[0])) {
      mess1 = replace(pass_mess[0], ({ "$V", motion_verb, "$T", dir, "$F",
                                         opposites[dir] }));
      if (stringp(pass_mess[2]) && sizeof(obs)) {
        mess1 += replace(pass_mess[2], "$O", query_multiple_short(obs));
      }
      mess1 += "\n";
      tell_object(ob, mess1);
    }
    if (stringp(pass_mess[1])) {
      mess2 = replace(pass_mess[1], ({ "$V", motion_verb, "$T", dir, "$F",
                                         opposites[dir], "$N",
                                         ob->a_short() }));
      foreach (passed in obs) {
        if (living(passed) && ob->query_visible(passed)) {
          tell_object(passed, mess2 + "\n");
        }
      }
    }
    // No use going through the rest of the loop...
    return 1;
  }
  return 1;
}

/**
 * This method masks the standard query_dest_other() function.  It handles
 * the motion verb for iroom exits, and also the passing message
 * when moving through irooms.
 * @param direc room exit name
 * @return structure describing the exit
 * @see /std/room
 */
// This gives us time to clone the connecting room before the player
// moves into it.
varargs mixed *query_dest_other( string direc ) {
  int i;
  string verb, rest, *words, handler;
  object room;
  mixed ret;

  if (!stringp(direc)) {
    return ::query_dest_other(direc);
  }
  words = explode(direc, " ");
  verb = words[0];
  if (verb != motion_verb) {
    ret = ::query_dest_other(direc);
    if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
    (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
      room = (topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                               direc);
      if (!objectp(room)) {
        return 0;
      }
      ret[ROOM_DEST] = file_name(room);
    }
    return ret;
  }
  if (sizeof(words) < 2) {
    notify_fail(motion_verb + " which way?\n");
    return 0;
  }
  rest = implode(words[1..], " ");
  foreach (handler in keys(milestone_dirs)) {
    i = member_array(rest, milestone_dirs[handler]);
    if (i < 0) {
      continue;
    }
    if (i == 0) {
      room = handler->find_room_at_index(milestone_index[handler] - 1, -2);
    } else {
      room = handler->find_room_at_index(milestone_index[handler], 0);
    }
    if (!objectp(room)) {
      return 0;
    }
    ret = ::query_dest_other(direc);
    if (!sizeof(ret)) {
      return 0;
    }
    ret[ROOM_DEST] = file_name(room);
    return ret;
  }
  return 0;
} /* query_dest_other() */

/**
 * This method masks the standard query_look().  If the exit is along
 * an iroom path, motion_verb is appended to it.  If a "look" message has
 * been set with modify_exit(), it is returned.  Next, the look_mess
 * mapping is checked; if there is an entry for this exit, it is evaluated
 * and returned.  Finally, the room itself is loaded and the description
 * is returned.
 * @param direc exit name
 * @return the description of the adjoining room
 * @see modify_exit()
 * @see add_look_mess()
 */
string query_look(string direc) {
  int i, dark;
  string s, direc_s, h;
  mixed dest;

  direc_s = direc;
  foreach (h in keys(milestone_dirs)) {
    i = member_array(direc_s, milestone_dirs[h]);
    if (i >= 0) {
      direc_s = motion_verb + " " + direc_s;
      break;
    }
  }
  if (s = ::query_look(direc_s)) {
    return s;
  }
  if (s = look_mess[direc_s]) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    // it mustn't be dark in the destination room.
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      // The look command automatically adds a '\n'
      return s[0..<2];
    }
    return s;
  }
  return 0;
} /* query_look() */

/**
 * This method adds exits for the iroom if they don't already exist.
 * "compass4" and "compass8" can be specified as exit names to add
 * exits for all of the normal 4 or 8 compass directions, respectively.
 * Actually, the add_exit is deferred to add_topo_exits_int, so that these can
 * be added after the milestone exits.
 * @param e array of exit names
 * @param type type of exit ("path", "road", etc)
 */
void add_topo_exits(string *e, string type) {
  other_exits += ({ e });
  other_types += ({ type });
}

/**
 * @ignore
 * A dummy exit name of "/topography" is used to avoid null strings.
 */
void add_topo_exits_int() {
  int i;
  string s;

  for (i = 0; i < sizeof(other_exits); i++) {
    foreach (s in other_exits[i]) {
      if ((s == "compass4") || (s == "compass8")) {
        if (!query_exit("north")) add_exit("north", "/topography",
                                           other_types[i]);
        if (!query_exit("south")) add_exit("south", "/topography",
                                           other_types[i]);
        if (!query_exit("east")) add_exit("east", "/topography",
                                          other_types[i]);
        if (!query_exit("west")) add_exit("west", "/topography",
                                          other_types[i]);
        if (s == "compass8") {
          if (!query_exit("northeast")) add_exit("northeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("northwest")) add_exit("northwest", "/topography",
                                                 other_types[i]);
          if (!query_exit("southeast")) add_exit("southeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("southwest")) add_exit("southwest", "/topography",
                                                 other_types[i]);
        }
      } else {
        add_exit(s, "/topography", other_types[i]);
      }
    }
  }
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/topography/milestone.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/topography/iroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/topography/iroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629525   Available: 13576879
Inodes: Total: 5242880    Free: 4960136
17292 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/topography/iroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629525   Available: 13576879
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: iroom.c,v 1.1 2000/05/01 03:14:49 jeremy Exp $
 *
 *
 */

/*
** iroom.c - file for creating interrooms.  NOTE: this file isn't used
**           by itself.  It is included in other files that inherit the
**           proper base room.  I HATE doing it this way, but I couldn't
**           think of a way to make the inheritance work out.
**/
/**
 * This file contains the functions for creating "irooms" (short for
 * "interrooms"), rooms
 * that exist between two (generally much larger) rooms.  The purpose
 * is to allow more resolution between widely-spaced rooms, such as
 * roads, without requiring the player to traverse them all.<p>
 * The two rooms on either end of a set of irooms (called "milestones")
 * are reached via normal exit directions (eg, "east").  The irooms are
 * reached via exits named with the same direction, prepended with a
 * "motion verb" (eg, "walk", giving an iroom exit of "walk east").<p>
 * <b>NOTE:<b> This file is not an object in itself.  It is meant to be
 * included in other files that implement the various types of rooms (I
 * know, I know: it's very ugly.  But it's the only way I could think to
 * handle the inheritance without copying this file in each room file).
 * @author Jeremy
 * @see milestone
 * @see interroom
 * @see topography
 */

#include <dirs.h>
#include <room.h>

int *milestone_index;
string *milestone_dirs = ({ });
string iroom_handler;
mapping shorten = SHORTEN;

string topo_handler;

string motion_verb = "walk", exit_type = "road", short_mse;
string iroom_exit_mess = "$N $V$s away to the $T.";
string iroom_enter_mess = "$N $V$s in from the $F.";
// Note that move messages don't do $N subs.
string iroom_move_mess = "You $V a little to the $T.\n";
string *pass_mess = ({
  "You $V a long while.",
  "$N passes by heading $T.",
  "  On the way you pass $O.\n"
});

// These are for unspecified exits
mixed other_exits = ({ });
string *other_types = ({ });

mapping look_mess = ([ ]);

mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);

mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);

/**
 * This method is deprecated.  Use set_topo_handler()
 */
void set_area_handler(string s) { topo_handler = s; }

/**
 * This method sets the topology handler for this iroom.
 * @param s pathname of topology handler
 * @see topology
 * @see query_topo_handler()
 */
void set_topo_handler(string s) { topo_handler = s; }

/**
 * This method returns the topology handler set for this iroom.
 * @return the topology handler for the iroom
 * @see set_topo_handler()
 */
string query_topo_handler() { return topo_handler; }

/**
 * This method sets the iroom handler for this section of irooms
 * @param s pathname of iroom handler
 * @see interroom
 * @see query_iroom_handler()
 */
void set_iroom_handler(string s) { iroom_handler = s; }

/**
 * This method returns the iroom handler for this section of irooms
 * @return the iroom handler for this section of rooms
 * @see set_iroom_handler()
 */
string query_iroom_handler() { return iroom_handler; }

/**
 * This method sets the iroom's motion verb, the verb to be used in the
 * iroom exit names; eg, "walk", "swim".  The default is "walk".
 * @param s motion verb
 * @see interroom
 * @see query_motion_verb()
 */
void set_motion_verb(string s) { motion_verb = s; }

/**
 * This method returns the motion verb.
 * @return the motion verb
 * @see set_motion_verb()
 */
string query_motion_verb() { return motion_verb; }

/**
 * This method sets the exit message for exits to irooms.  The format
 * is the same as for normal exit messages, except that $V can be used
 * to represent the motion verb.  The default is<pre><br>
 *     <code>"$N $V$s away to the $T."</code>
 * </pre>
 * @param s iroom exit message
 * @see query_iroom_exit_mess()
 * @see modify_exit()
 */
void set_iroom_exit_mess(string s) { iroom_exit_mess = s; }

/**
 * This method returns the iroom exit message.
 * @return iroom exit message
 * @see set_iroom_exit_mess()
 */
string query_iroom_exit_mess() { return iroom_exit_mess; }

/**
 * This method sets the entrance message used when entering from an
 * iroom.  The format is the same as for normal entrance messages, except
 * that $V represents the motion verb.  The default is<pre><br>
 *     <code>"$N $V$s in from the $F."</code>
 * </pre>
 * @param s iroom entrance message
 * @see query_iroom_enter_mess()
 * @see modify_exit()
 */
void set_iroom_enter_mess(string s) { iroom_enter_mess = s; }

/**
 * This method returns the iroom entrance message.
 * @return iroom entrance message
 * @see set_iroom_enter_mess()
 */
string query_iroom_enter_mess() { return iroom_enter_mess; }

/**
 * This method sets the "moving message" shown to the player when
 * leaving an iroom.  The format is the same as for normal moving
 * messages, except that $V represents the motion verb.  The default
 * is<pre><br>
 *     <code>"You $V a little to the $T.\n"</code>
 * </pre>
 * @param s iroom moving message
 * @see query_iroom_move_mess()
 * @see modify_exit()
 */
void set_iroom_move_mess(string s) { iroom_move_mess = s; }

/**
 * This method returns the iroom moving message.
 * @return iroom moving message
 * @see set_iroom_move_mess()
 */
string query_iroom_move_mess() { return iroom_move_mess; }

/**
 * This method sets the messages printed when passing through a number
 * of irooms in one move.  The parameter should be an array of three
 * strings: the first is the one printed to the moving player; the
 * second is printed to all living objects that are passed.  Both follow
 * the same format as the other iroom messages.  The third is a string which
 * is appended to the first if any objects are passed along the way;
 * $O can be used to represent the list of objects.  Any or all of the
 * strings can be set to 0, in which case that string will not be printed.
 * The default passing messages are<pre><br><code>
 *    ({ "You $V a long while.",
 *       "$N passes by heading $T.",
 *       "  On the way you pass $O.\n"
 * </code></pre>
 * @param s iroom passing messages (array of 3 strings)
 * @see query_pass_mess()
 * @see modify_exit()
 */
void set_pass_mess(string *s) { pass_mess = s; }

/**
 * This method returns the current iroom passing messages.
 * @return iroom move messages
 * @set_pass_mess()
 */
string *query_pass_mess() { return pass_mess; }

/**
 * This method adds or changes the message printed when looking in a
 * certain direction.  Messages set with modify_exit() have priority.
 * If neither are set, the room's description is used.
 * @param m a mapping of messages in the form ([<direc>:<mess>])
 */
void add_look_mess(mapping m) { look_mess += m; }

/**
 * This method queries the message printed when looking in a certain
 * direction.
 * @return a mapping of messages in the form ([<direc>:<mess>])
 * @see add_look_mess()
 */
mapping query_look_mess() { return look_mess; }

/**
 * This method sets the exit type for the iroom exits.  The default is "road".
 * @param s exit type
 * @see query_exit_type()
 * @see add_exit()
 */
void set_exit_type(string s) { exit_type = s; }

/**
 * This method returns the exit type used for iroom exits.
 * @return exit type
 * @see set_exit_type()
 */
string query_exit_type() { return exit_type; }

/**
 * @ignore
 * This method is called by the interroom handler when it clones
 * the room.  The iroom is room # <milestone_index[1]>, between
 * <milestone_index[0]> and <milestone_index[0]+1> (eg, if
 * milestone_index == ({3, 6}), the room is iroom 6 between
 * milestones 3 and 4).
 */
void set_milestone_index(int *i) { milestone_index = i; }

/**
 * @ignore
 */
int *query_milestone_index() { return milestone_index; }

/**
 * @ignore
 * This method adds an iroom exit in the direction given.  The name comes
 * from the fact that that's the direction to one of the milestones.
 */
void add_milestone_dir(string s) {
  int i;
  string ss, em, xm, mm;

  i = sizeof(milestone_dirs);
  milestone_dirs += ({ s });
  if (!(iroom_handler)->query_endpoint(milestone_index[0],
                                       milestone_index[1], i)) {
    modify_exit(s, ({ "function", "passing_mess" }) );
  }
  add_exit(motion_verb + " " + s, "interroom", "hidden");
  if (!undefinedp(shorten[s])) {
    ss = shorten[s];
    add_alias(motion_verb + " " + ss, motion_verb + " " + s);
  } else {
    ss = s;
  }
  remove_exit(motion_verb + " <" + short_mse + ">");
  if (!short_mse) {
    short_mse = ss;
  } else {
    short_mse += "/" + ss;
  }
  add_exit(motion_verb + " <" + short_mse + ">", "interroom", exit_type);
  em = replace(iroom_enter_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  xm = replace(iroom_exit_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  mm = replace(iroom_move_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  modify_exit(motion_verb + " " + s, ({
    "exit mess", xm,
    "enter mess", em,
    "move mess", mm
  }));
} /* add_milestone_dir() */

/**
 * @ignore
 * This method returns all of the milestone directions.
 */
string *query_milestone_dirs() { return milestone_dirs; }

/**
 * @ignore
 * This method is called when a player passes through more than one
 * iroom in a move.
 */
int passing_mess(string dir, object ob, string special_mess) {
  int i;
  object *obs, passed;
  string mess1, mess2;

  i = member_array(dir, milestone_dirs);
  if (i < 0) {
    return 0;
  }
  obs = (iroom_handler)->query_irooms_inv(milestone_index[0],
                                          milestone_index[1], i);
  if (stringp(pass_mess[0])) {
    mess1 = replace(pass_mess[0], ({ "$V", motion_verb, "$T", dir, "$F",
                                       opposites[dir] }));
    if (stringp(pass_mess[2]) && sizeof(obs)) {
      mess1 += replace(pass_mess[2], "$O", query_multiple_short(obs));
    }
    mess1 += "\n";
    tell_object(ob, mess1);
  }
  if (stringp(pass_mess[1])) {
    mess2 = replace(pass_mess[1], ({ "$V", motion_verb, "$T", dir, "$F",
                                       opposites[dir], "$N", ob->a_short() }));
    foreach (passed in obs) {
      if (living(passed) && ob->query_visible(passed)) {
        tell_object(passed, mess2 + "\n");
      }
    }
  }
  return 1;
} /* passing_mess() */

/**
 * This method is called when the player quits, to save the current
 * room.  It uses a little-known alternate form that returns the
 * room path and the coordinates.
 * @return the iroom path and coordinates
 */
mixed query_quit_handler() {
  string s;

  s = explode(file_name(environment(this_player())), "#")[0];
  return ({ s, query_co_ord() });
} /* query_quit_handler() */

/**
 * This method is called at login, to move the player to the room.
 * Since these rooms are always clones, the master has the responsibility
 * of cloning one when a player logs in, and moving the player to it.
 * @param player the player logging in
 */
void enter(object player) {
  object new_room;

  // I used to use clonep() here, but the "parent" of virtual rooms were
  // coming up as clones.
  if (sizeof(explode(file_name(this_object()), "#")) > 1) {
    // We somehow called enter() from a clone...
    return;
  }
  new_room = (iroom_handler)->find_room_at_coord(
                 player->query_saved_co_ords());
  if (!objectp(new_room)) {
    tell_creator("jeremy", "Couldn't find iroom for %O at %O...\n",
                 player, player->query_saved_co_ords());
    player->move(player->query_start_pos());
    return;
  }
  tell_creator("jeremy", "Moving %O to %O...\n",
               player, new_room);
  player->move(new_room);
} /* enter() */

/**
 * This method masks the standard query_dest_other() function.  It handles
 * the motion verb for moving between irooms, and also the passing message
 * when moving through irooms.
 * @param direc room exit name
 * @return structure describing the exit
 * @see /std/room
 */
// This gives us time to clone the connecting room before the player
// moves into it.
varargs mixed *query_dest_other( string direc ) {
  int i;
  string verb, rest, *words;
  object room;
  mixed ret;

  //tell_creator("jeremy", "%O:query_dest_other(%s)\n", this_object(), direc);
  if (!stringp(direc)) {
    return ::query_dest_other(direc);
  }
  words = explode(direc, " ");
  verb = words[0];
  if (verb != motion_verb) {
    ret = ::query_dest_other(direc);
    if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
    (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
      room = (topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                               direc);
      if (!objectp(room)) {
        return 0;
      }
      ret[ROOM_DEST] = file_name(room);
    }
    return ret;
  }
  if (sizeof(words) < 2) {
    notify_fail(motion_verb + " which way?\n");
    return 0;
  }
  rest = implode(words[1..], " ");
  i = member_array(rest, milestone_dirs);
  if (i < 0) {
    notify_fail("You can't " + motion_verb + " that way.\n");
    return 0;
  }
  room = (iroom_handler)->find_room_at_index(milestone_index[0],
                                              milestone_index[1]+2*i-1);
  if (!objectp(room)) {
    return 0;
  }
  ret = ::query_dest_other(direc);
  if (!sizeof(ret)) {
    return 0;
  }
  ret[ROOM_DEST] = file_name(room);
  return ret;
} /* query_dest_other() */

/**
 * This method masks the standard query_look().  If the exit is along
 * an iroom path, motion_verb is appended to it.  If a "look" message has
 * been set with modify_exit(), it is returned.  Next, the look_mess
 * mapping is checked; if there is an entry for this exit, it is evaluated
 * and returned.  Finally, the room itself is loaded and the description
 * is returned.
 * @param direc exit name
 * @return the description of the adjoining room
 * @see modify_exit()
 * @see add_look_mess()
 */
string query_look(string direc) {
  int i, dark;
  string s, direc_s;
  mixed dest;

  direc_s = direc;
  i = member_array(direc_s, milestone_dirs);
  if (i >= 0) {
    direc_s = motion_verb + " " + direc_s;
  }
  if (s = ::query_look(direc_s)) {
    return s;
  }
  if (s = look_mess[direc_s]) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    // it mustn't be dark in the destination room.
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      // The look command automatically adds a '\n'
      return s[0..<2];
    }
    return s;
  }
  return 0;
} /* query_look() */

/**
 * This method adds exits for the iroom if they don't already exist.
 * "compass4" and "compass8" can be specified as exit names to add
 * exits for all of the normal 4 or 8 compass directions, respectively.
 * Actually, the add_exit is deferred to add_topo_exits_int, so that these can
 * be added after the milestone exits.
 * @param e array of exit names
 * @param type type of exit ("path", "road", etc)
 */
void add_topo_exits(string *e, string type) {
  other_exits += ({ e });
  other_types += ({ type });
} /* query_dest_other() */

/**
 * @ignore
 * A dummy exit name of "/topography" is used to avoid null strings.
 */
void add_topo_exits_int() {
  int i;
  string s;

  for (i = 0; i < sizeof(other_exits); i++) {
    foreach (s in other_exits[i]) {
      if ((s == "compass4") || (s == "compass8")) {
        if (!query_exit("north")) add_exit("north", "/topography",
                                           other_types[i]);
        if (!query_exit("south")) add_exit("south", "/topography",
                                           other_types[i]);
        if (!query_exit("east")) add_exit("east", "/topography",
                                          other_types[i]);
        if (!query_exit("west")) add_exit("west", "/topography",
                                          other_types[i]);
        if (s == "compass8") {
          if (!query_exit("northeast")) add_exit("northeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("northwest")) add_exit("northwest", "/topography",
                                                 other_types[i]);
          if (!query_exit("southeast")) add_exit("southeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("southwest")) add_exit("southwest", "/topography",
                                                 other_types[i]);
        }
      } else {
        add_exit(s, "/topography", other_types[i]);
      }
    }
  }
} /* add_topo_exits_int() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/topography/iroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/topography/aroom.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/topography/aroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629520   Available: 13576874
Inodes: Total: 5242880    Free: 4960136
7731 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/topography/aroom.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629520   Available: 13576874
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: aroom.c,v 1.4 2001/05/10 22:41:48 pinkfish Exp $
 *
 *
 */

/*
** area.c - file for creating areas.  NOTE: this file isn't used
**           by itself.  It is included in other files that inherit the
**           proper base room.  I HATE doing it this way, but I couldn't
**           think of a way to make the inheritance work out.
**/
/**
 * This file contains the functions used in rooms that make up "areas",
 * arbitrary polygons consisting of identical rooms.  This is similar
 * to the terrain system, but with certain advantages: the areas can
 * be any polygon, even non-convex ones; areas are integrated into the
 * topology system, which also handles roads through areas.<p>
 * Although all of the rooms in an area are cloned from the same file,
 * a number of tricks can be used to add variety (but that's beyond the
 * scope of this document).
 * @author Jeremy
 * @see area
 * @see topography
 */
#include <dirs.h>
#include <room.h>

private string _topo_handler;
private mapping _look_mess = ([ ]);

mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);

//
// Function pre-defs.
//
int* query_co_ord();
mixed* query_dest_other(string direc);
int query_door_open(string direc);
int query_exit(string str);
void add_exit(string dir, string location, string type);

/**
 * @ignore yes
 * This method is deprecated.  Use set_topo_handler()
 */
void set_area_handler(string s) { _topo_handler = s; }

/**
 * This method sets the topology handler for this area.  A simple area
 * handler can be used rather than a topology handler in limited cases.
 * @param s pathname of topology handler
 * @see topology
 * @see area
 * @see query_topo_handler()
 */
void set_topo_handler(string s) { _topo_handler = s; }
/**
 * This method returns the topology handler set for this room.
 * @return the topology handler for the room
 * @see set_topo_handler()
 */
string query_topo_handler() { return _topo_handler; }

/**
 * This method adds or changes the message printed when looking in a
 * certain direction.  Messages set with modify_exit() have priority.
 * If neither are set, the room's description is used.
 * @param m a mapping of messages in the form ([<direc>:<mess>])
 */
void add_look_mess(mapping m) { _look_mess += m; }
/**
 * This method returns the mapping associated with the looking messages.
 * @return the look message
 */
mapping query_look_mess() { return _look_mess; }

/**
 * This method is called when the player quits, to save the current
 * room.  It uses a little-known alternate form that returns the
 * room path and the coordinates.
 * @return the iroom path and coordinates
 */
mixed query_quit_handler() {
  string s;

  s = explode(file_name(environment(this_player())), "#")[0];
  return ({ s, query_co_ord() });
} /* query_quit_handler() */

/**
 * This method is called at login, to move the player to the room.
 * Since these rooms are always clones, the master has the responsibility
 * of cloning itself when a player logs in, and moving the player to it.
 * @param player the player logging in
 */
void enter(object player) {
  object new_room;

  // I used to use clonep() here, but the "parent" of virtual rooms were
  // coming up as clones.
  if (sizeof(explode(file_name(this_object()), "#")) > 1) {
    // We somehow called enter() from a clone...
    return;
  }
  new_room = (_topo_handler)->find_room_at_coord(
                 player->query_saved_co_ords());
  if (!objectp(new_room)) {
    tell_creator("jeremy", "Couldn't find area room for %O at %O...\n",
                 player, player->query_saved_co_ords());
    player->move(player->query_start_pos());
    return;
  }
  tell_creator("jeremy", "Moving %O to %O...\n",
               player, new_room);
  player->move(new_room);
} /* enter() */

// This gives us time to clone the connecting room before the player
// moves into it.
/**
 * This method masks the standard query_dest_other() function.  It calls
 * the topology handler to find the connecting room (which is usually
 * cloned on-the-fly).
 * @param direc room exit name
 * @return structure describing the exit
 * @see /std/room
 */
varargs mixed *query_dest_other( string direc, mixed* other_res) {
  object room;
  mixed ret;

//printf("%O %O %O\n", dirs, direc, other_res);
  //tell_creator("jeremy", "%O:query_dest_other(%s)\n", this_object(), direc);
  if (!stringp(direc)) {
    return other_res;
  }
  room = (_topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                           direc);
//printf("%O %O %O\n", dirs[direc], direc, room);
  if (!objectp(room)) {
    return 0;
  }
  ret = other_res;
  if (!sizeof(ret)) {
    return 0;
  }
  ret[ROOM_DEST] = file_name(room);
  return ret;
} /* query_dest_other() */

/**
 * This method masks the standard query_look().  If a "look" message has
 * been set with modify_exit(), it is returned.  Next, the look_mess
 * mapping is checked; if there is an entry for this exit, it is evaluated
 * and returned.  Finally, the room itself is loaded and the description
 * is returned.
 * @param direc exit name
 * @return the description of the adjoining room
 * @see modify_exit()
 * @see add_look_mess()
 */
string query_look(string direc, string other_result) {
  int dark;
  string s;
  string direc_s;
  mixed dest;

  direc_s = direc;
  if (other_result) {
    return s;
  }
  s = _look_mess[direc_s];
  if (s) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    // it mustn't be dark in the destination room.
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      // The look command automatically adds a '\n'
      return s[0..<2];
    }
    return s;
  }
  return 0;
} /* query_look() */

/**
 * This method adds exits for the room if they don't already exist.
 * "compass4" and "compass8" can be specified as exit names to add
 * exits for all of the normal 4 or 8 compass directions, respectively.
 * @param e array of exit names
 * @param type type of exit ("path", "road", etc)
 */
// A dummy exit name of "/topography" is used to avoid null strings.
void add_topo_exits(string *other_exits, string other_types) {
  string s;

  foreach (s in other_exits) {
    if ((s == "compass4") || (s == "compass8")) {
      if (!query_exit("north")) {
        add_exit("north", "/topography", other_types);
      }
      if (!query_exit("south")) {
        add_exit("south", "/topography", other_types);
      }
      if (!query_exit("east")) {
        add_exit("east", "/topography", other_types);
      }
      if (!query_exit("west")) {
        add_exit("west", "/topography", other_types);
      }
      if (s == "compass8") {
        if (!query_exit("northeast")) {
          add_exit("northeast", "/topography", other_types);
        }
        if (!query_exit("northwest")) {
          add_exit("northwest", "/topography", other_types);
        }
        if (!query_exit("southeast")) {
          add_exit("southeast", "/topography", other_types);
        }
        if (!query_exit("southwest")) {
          add_exit("southwest", "/topography", other_types);
        }
      }
    } else {
      add_exit(s, "/topography", other_types);
    }
  }
} /* add_topo_exits() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/topography/aroom.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629518   Available: 13576872
Inodes: Total: 5242880    Free: 4960136
5444 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629518   Available: 13576872
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is a stand alone feature handler for dealing with features that
 * span over multiple terrains.
 * @author Pinkfish
 * @started Mon Apr  1 12:15:24 PST 2002
 */

inherit "/std/room/inherit/terrain_map/distance_str";

private int _max_range;
private int _max_day_range;
private int _max_night_range;
private int _min_range = -1;
private int _range_offset;
private int _blocking;
private object _region;

class feature_pos {
   int xstart;
   int ystart;
   int width;
   int height;
}

/**
 * This method sets the region to use for the system.  If the region is
 * set as a string, then that region is cloned, if it is set as and
 * object, it is just used.
 * @param region the region to use
 */
void set_region(mixed region) {
   if (_region) {
      _region->dest_me();
   }

   if (stringp(region)) {
      _region = clone_object(region);
   } else if (objectp(region)) {
      _region = region;
   }
}

/**
 * This method returns the region object.  This should be used
 * for setup calls.
 * @return the region object
 */
object query_region_ob() {
   return _region;
}

/**
 * This method sets the range offset.  The offset is added to the
 * distance of the feature for calculating the distance.  If the
 * point is inside the offset the distance is ignored and the
 * distance it then calculated from the edge of the offset.  This
 * can be used to generate circular features.
 * @param offset the offset to use
 */
void set_range_offset(int offset) {
   _range_offset = offset;
}

/**
 * This method returns the range offset.  The offset is added to the
 * distance of the feature for calculating the distance.  If the
 * point is inside the offset the distance is ignored and the
 * distance it then calculated from the edge of the offset.  This
 * can be used to generate circular features.
 * @return the current range offset
 */
int query_range_offset() {
   return _range_offset;
}

/**
 * This method sets the maximum range for the feature to be seen at.
 * @param range the maximum range to be seen at
 */
void set_max_day_range(int range) {
  _max_day_range = range;
   if (_max_day_range > _max_range) {
      _max_range = _max_day_range;
   }
}

/**
 * This method returns the maximum range the feature can be seen at.
 * @return the maximum range of the feature
 */
int query_max_day_range() {
   return _max_day_range;
}

/**
 * This method sets the maximum range for the feature to be seen at.
 * @param range the maximum range to be seen at
 */
void set_max_night_range(int range) {
   _max_night_range = range;
   if (_max_night_range > _max_range) {
      _max_range = _max_night_range;
   }
}

/**
 * This method returns the maximum range the feature can be seen at.
 * @return the maximum range of the feature
 */
int query_max_night_range() {
   return _max_night_range;
}

/**
 * This method sets the minimum range for the feature to be seen at.
 * @param range the minimum range to be seen at
 */
void set_min_range(int range) {
  _min_range = range;
}

/**
 * This method returns the minimum range the  feature can be seen at.
 * @return the minimum range of the feature
 */
int query_min_range() {
   return _min_range;
}

/**
 * This method returns the maximum possible range the item can be seen
 * at.
 * @return the maximum possible range
 */
int query_max_range() {
   return _max_range;
}

/**
 * This method sets the blocking status of the feature.  This will only work
 * with local features and not distant features.
 * @param blocking the blocking flag
 */
int set_blocking(int blocking) {
   _blocking = blocking;
}

/**
 * This method returns the blocking status of the feature.  This will only work
 * with local features and not distant features.
 * @return the blocking status of the features
 */
int query_blocking() {
   return _blocking;
}

/**
 * This function needs to be overridden to display the actual
 * message to the feature.  The direc argument is a mapping of the
 * form, key = direction, value = distance.
 * @param direc the directions and distances
 * @param night the night feature
 * @return the feature descriptions
 */
string calc_feature_desc(mapping direc, int night, int visibility) {
   return "This needs to be set.";
}

/**
 * This method filters the returned descs to make sure they are all
 * within the needed range.
 * @param direcs the mappings of directions and distance
 */
mapping filter_distances(mapping direcs) {
   return filter(direcs, (: $2 <= _max_range :));
}

/**
 * This is the function used by the system to find the message for this
 * feature.
 * @param x the x-coordinate
 * @param y the y-coordinate
 * @param z the z-coordinate
 * @param no_filter whether or not to filter by distance
 */
mapping query_feature_desc_from(int x, int y, int z, int no_filter) {
   mapping bits;

   if (_region) {
      bits = _region->query_feature_desc_from(x, y, z);
      if (bits) {
        if(no_filter)
          return bits;
        else
          return filter_distances(bits);
      }
   }
   return ([ ]);
}

/**
 * This method determines if the feature is inside the specified region
 * or not.
 * @param x1 the top x
 * @param y1 the top y
 * @param x2 the bottom x
 * @param y2 the bottom y
 */
int is_inside_region(int x1, int y1, int x2, int y2) {
   return _region->is_inside_region(x1, y1, x2, y2, query_max_range());
}

/** @ignore yes*/
void dest_me() {
   if (_region) {
      _region->dest_me();
   }
   destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629517   Available: 13576871
Inodes: Total: 5242880    Free: 4960136
383 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629517   Available: 13576871
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is specifically for creating rooms in the world map system, where
 * it just makes and passes out the room details.  So it does not need to
 * include all the room crap.
 * @author Pinkfish
 * @started Fri Jun 28 16:14:19 PDT 2002
 */
#include <terrain_map.h>

inherit TERRAIN_MAP_FACTORY_BASE;

void create() {
   ::create();
   this_object()->setup();
} /* create() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/terrain_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/terrain_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629516   Available: 13576870
Inodes: Total: 5242880    Free: 4960136
30960 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/terrain_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629516   Available: 13576870
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: terrain_room.c,v 1.58 2003/07/15 11:59:02 taffyd Exp $
 * 
*/
/**
* @main
* Base inherit for a terrain_map room.
* <p>
* This file should be inherited by any room within a terrain mapped
* virtual area.
* <p>
* When inheriting from this file, it is essential that the function
* query_handler_path() be overriden to return the full pathname of
* the handler associated with this area.
* <p>
* To inherit from this file, use the following lines:
* <ul>
* <li>#include <terrain_map.h>
* <li>
* <li>inherit TERRAIN_MAP_OUTSIDE_BASE
* </ul>
* 
* @see terrain_map_handler
* @see terrain_map_intro
* @see terrain_map_example
* @author Dek
* @started Thurs April 12 2001 Too Damn Early BST
**/

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>

inherit TERRAIN_MAP_FACTORY_BASE;

#define BLOCKING_FLAG 2
#define INSTALLED_FLAG 1

private nosave int     _x_coord = -1;
private nosave int     _y_coord = -1;
private nosave int     _z_coord = -1;
private nosave int     _flag = 0;
private nosave string  _extra_long = "";
private nosave object  _map_handler;
private nosave mapping _dist_features = ([ ]);
private nosave mapping _features = ([ ]);
private nosave string  _outside_types;
private nosave string  _random_desc = 0;
private nosave object  _terrain_chatter = 0;
private nosave string* _variable_exits;
private nosave mapping _default_exits;
private nosave string  _terrain_handler;
private nosave string  _terrain_char;

varargs int add_property(string var, mixed val, int tim);

string  query_feature_item_desc(string title);
string  query_handler_path();
varargs void terrain_chat( mixed *args, object chatobj );
int do_outside_chats();
void add_zone(string zone);
void add_extra_look(object ob);
int remove_item(string word);
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int* query_co_ord();
int query_visibility();
string long(string str, int dark);
string query_terrain_handler();

class feature {
   mapping direcs;
   mixed items;
   int sentance;
   // Always the closest index.
   int index;
   int visible;
}

void create() {
   _variable_exits = ({ });
   _default_exits = ([ ]);
   this_object()->add_help_file("terrain_room");
   ::create();
} /* create() */

string long_test(string str, int dark) {
   string ret;
   string map;
   string* map_lines;

   ret = long(str, dark);
   // Now try and mangle together some formatting.
   map = query_terrain_handler()->query_player_map_template(_x_coord,
             _y_coord, _z_coord, query_visibility(), 9);
   // Now try and mangle them together.
   // For now, do this the hard way.
   map_lines = map(explode(map, "\n"), (: $1 + "   " :));
   ret = "$COLUMN$12=" + implode(map_lines, "\n") + "$COLUMN$" +
         ret;
   return ret;
}

/**
 * This method makes a deterministic hash value based on the real co-ordinates
 * of this room.
 * @param mod the modules to use on the return result
 * @return a deterministicly random number between 0..mod -1
 */
int hash(int mod) {
   mixed* my_coord; // Hmm -- there seems to be a class name called coord. 
   int x;
   int y;
   int z;
   int grid;
   int val;
   string str;

   my_coord = query_co_ord();
   if (!my_coord) {
      return 0;
   }
   grid = TERRAIN_MAP_GRID_SIZE / 10;
   x = (my_coord[0]) / grid;
   y = (my_coord[1]) / grid;
   z = (my_coord[2]) / grid;

   str = "" + x + ":" + y + ":" + z;
   //val = (x ^ 1693 + y ^ 6603 + z ^ 7919) % mod;
   val = crc32(str) % mod;
   if (val < 0) {
      return - val;
   }
   return val;
}

/**
 * This produces a deterministicly static value that only exists for a
 * specific period of time, before moving.  You can use this for movable
 * oasises for example.
 * @param mod the modulus to get the random number over
 * @param period the period the number should remain constant
 */
int hash_time(int mod, int period) {
   mixed* my_coord;
   int x;
   int y;
   int z;
   int grid;
   int val;
   string str;

   my_coord = query_co_ord();
   if (!my_coord) {
      return 0;
   }
   grid = TERRAIN_MAP_GRID_SIZE / 10;
   x = (my_coord[0]) / grid;
   y = (my_coord[1]) / grid;
   z = (my_coord[2]) / grid;

   //val = (x ^ 1693 + y ^ 6603 + z ^ 7919 + (time() / period) ^ 80147) % mod;
   str = x + ":" + y + ":" + z + ":" + (time() /period);
   val = crc32(str) % mod;
   if (val < 0) {
      return - val;
   }
   return val;
}

/**
 * This method returns the terrain handler for
 * the room.
 * @return the terrain handler
 */
string query_terrain_handler() {
   return _terrain_handler;
}

/**
 * This method sets the terrain handler for the room.
 * @param handler the terrain handler
 */
void set_terrain_handler(string handler) {
   _terrain_handler = handler;
}

/**
 * This returns the terrain coordinate of the room.
 * It returns an array that contains the x, y, z values
 * of the co-ordinate.
 * @return the terrain co-ordinate
 */
mixed *query_terrain_coords() { return ({ _x_coord, _y_coord, _z_coord }); }

/**
* @ignore
*/
void create_terrain_room()

{
// We set the coords to -1 -1 here, to account for rooms that are
// not virtual. Rooms that adjoin map areas need to inherit this
// file, hence the need to do this.
   _x_coord = -1;
   _y_coord = -1;
   _z_coord = -1;

   add_property("terrain_map", 1);
   add_extra_look(this_object());
   if (do_outside_chats())
      terrain_chat(({ 60, 120, ({ "#do_a_feature_chat",
                             "#do_an_outside_chat" }) }) );
}


/**
* @ignore
*/
void terrain_setup()

{
}

/**
* @ignore
*/
void set_terrain_coords(int x, int y, int z)

{
// Setup the main coordinates for this room. Please note that these
// are not DW coords, but local ones for the use of the handler. 
   _x_coord = x;
   _y_coord = y;
   _z_coord = z;
}


/**
* @return returns the handler object associated with this terrain map.
* @see query_handler_path()
*/
object query_map_handler()

{
   return load_object(query_terrain_handler());
}


/**
* This method destroys every single room in the associated terrain map.
* It is provided for development purposes only, and should be used cautiously
* as it will currently dump every single player in the map into the void.
* Plans are afoot to make the side-effects a little less dire.
*/
void reset_handler()

{
   if (query_map_handler())
      query_map_handler()->reset_handler();
}


/**
* @ignore
*/
void receive_message(string mess_class, string message, string title)

{
   class    feature feature;
   
   if (mess_class == "feature") {
      feature = _features[title];
      if (!feature) {
         return;
      }
      
      //message = replace(message, ({ "$D", feature->direc_str }));
   } else if (mess_class == "direction") {
      // Need to figure out the direction back to the source.
   }
   tell_room(this_object(), message);
}


/**
* @ignore
*/
void do_a_feature_chat()

{
   string   *chats = ({ });
   string   feature_chat;
   string   title;
   class  feature feature;
   //object   handler = query_map_handler();
   
   if ((_x_coord < 0) || (_y_coord < 0)) {
      return;
   }
      
   foreach(title, feature in _features) {
      //feature_chat = handler->get_a_feature_chat(title, feature->index, 
      //                                                  feature->direc_str);
      if (feature_chat) {
         chats += ({ feature_chat });
      }
   }
   if (sizeof(chats)) {
      tell_room(this_object(), chats[random(sizeof(chats))] + "\n");
   }
}
      
      
/**
* @ignore
*/
void do_an_outside_chat()

{
   string chat = query_map_handler()->get_an_outside_chat(_outside_types);

   if (chat && strlen(chat)) {
      tell_room(this_object(), chat + "\n");
   }
}

/**
 * If this can be seen from this location or not.  This can do things
 * like dealing with lower levels and stuff.
 * @param char the character of the item in the map
 * @param path the path of the room (0 if an obstacle)
 * @param z the z co-ordinate of the room
 * @param direc the direction in which the obstacle faces
 */
int can_view_adjacent_desc(string char, string key_here, string path,
                           int z, string direc) {
   return char != key_here;
}


/**
* This method may be overriden to mask out feature descriptions and chats
* from one or more features in the current terrain map.
* @param name the name of the feature being queried.
* @return return 1 if the feature can be viewed from this room, 0 otherwise
* @example
*    int can_view_feature(string name) 
*    
*    {
*       switch (name) {
*          case "mountain" : return 0;
*          case "tree"     : return 0;
*          default         : return 1;
*       }
*    }
* @see add_feature
* @see modify_feature
* @see set_feature_chats
* @see remove_feature
*/
int can_view_feature(string name)

{
   return 1;
}

/**
* This method may be overriden to mask out feature descriptions and chats
* from one or more features in the current terrain map.  It allows more
* detailed blocking, based on distance and direction.
* @param name the name of the feature being queried.
* @param direc the direction to the feature
* @param distance the range to the feature
* @return return 1 if the feature can be viewed from this room, 0 otherwise
* @example
*    int can_view_feature_from(string name, string direc, int distance) 
*    
*    {
*       switch (name) {
*          case "mountain" :
*             switch (direct) {
*             case "east" :
*                return 1;
*             default :
*                return 0;
*             }
*          case "tree"     : return 0;
*          default         : return 1;
*       }
*    }
* @see add_feature
* @see modify_feature
* @see set_feature_chats
* @see remove_feature
*/
int can_view_feature_from(string name, string direc, int distance)

{
   return 1;
}


/**
* This method may be overriden to prevent the handler from setting up
* exits to one or more types of location.
* @param type the type of location the exit would be to. This is the same as 
* the character used in the ASCII map.
* @return return 1 if the exits should be made, 0 otherwise
* @example
*    int can_exit_to(string type) 
*    
*    {
*       switch (type) {
*          case "#" : return 0;
*          case "*" : return 0;
*          default  : return 1;
*       }
*    }
* @see can_enter_from
* @see add_room_type
* @see add_road_type
* @see query_to_same
* @see query_to_other
* @see query_from_other
*/
int can_exit_to(string type, string direc, string base_path)

{
   return 1;
}


/**
* This method may be overriden to prevent the handler from setting up
* exits from one or more types of location.
* @param type the type of location the exit would be from. This is the same as 
* the character used in the ASCII map.
* @return return 1 if the exits should be made, 0 otherwise
* @example
*    int can_enter_from(string type) 
*    
*    {
*       switch (type) {
*          case "#" : return 0;
*          case "*" : return 0;
*          default  : return 1;
*       }
*    }
* @see can_exit_to
* @see add_room_type
* @see add_road_type
* @see query_to_same
* @see query_to_other
* @see query_from_other
*/
int can_enter_from(string type, string direc, string base_path)

{
   return 1;
}


/**
* This method may be overriden to allow the handler to setup diagonal exits
* between terrain types that are different.  What this does, here is
* a small explaination.  If you have a map below:
* <pre>
*    ff-
*    f-f
*    -ff
* <pre>
* Where the '-'s are roads, you do not want to let someone diagonaly
* jump the road.  So you make it so that you cannot go from the
* f on one side of the road to the other.  THis is the default behaviour,
* however you want people to be able to actualy walk diagonaly on the road
* so you need to override this to allow the road to be walked on.
* exits from one or more types of location.
* <p>
* The values passed in are the paths to the final object files.  Not the
* key values in the map.
* @param my_type our type
* @param direc the direction we are checking in
* @param first_type the first neighbouring path
* @param second_type the second neighbouring path
* @param new_base_path the path of the thing that is the destination
* @return return 1 if the exits should be made, 0 otherwise
* @see can_exit_to
* @see add_room_type
* @see add_road_type
* @see query_to_same
* @see query_to_other
* @see query_from_other
*/
int can_move_between(string my_type, string direc,
                     string first_type, string second_type,
                     string new_base_path)
{
   return 1;
}

/**
 * This method is used to setup any unusual sorts of entrances to 
 * specific room types.  For example so that you have to actually swim
 * to get into a river rather than acidentally walking into it.  If
 * this does return a string a default exit is not setup for this direction
 * so just going 'east' doesn't drop you in the river.
 * @param key the key of the map location we are coming from
 * @param key_here my key of the character in the map
 * @param direc the direction the exit is in
 * @param room the room being setup
 * @param base_path the base path of the object we are coming from
 * @return 0 to do nothing, a string to replace the main exit
 */
string query_enter_exit_direction(string key, string key_here,
                                  string direc, object room, string base_path) {
   return 0;
}


/**
* This method may be overriden to prevent the handler from setting up
* additional room_chats from appropriate adjacent locations.
* @return return 1 if the exits should be made, 0 otherwise
* @see set_external_chats
*/
int do_outside_chats()

{
   return 1;
}


/**
* @ignore
*/
varargs void terrain_chat( mixed *args, object chatobj ) {
   if (!args)  {
      /* This can happen if you have day chats w/o night chats, */
      /* and vice-versa */
      return;
   }
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
  if ( _terrain_chatter ) {
    _terrain_chatter->setup_chatter( this_object(), args );
    return;
  }
  if (objectp(chatobj)) {
    _terrain_chatter = chatobj;
    log_file("CHATTER", "%s cloned set terrain chatter: %O\n",
             file_name(this_object()), chatobj);
  } else {
    _terrain_chatter = clone_object( CHATTER_OBJECT );
    log_file("CHATTER", "%s cloned terrain chatter: %O\n",
             file_name(this_object()), _terrain_chatter);
  }
  _terrain_chatter->setup_chatter( this_object(), args );
}


/**
* @ignore
*/
void add_random_desc(string desc)

{
   if (!_random_desc) {
      _random_desc = "";
   }
   
   _random_desc += desc + " ";
}


/**
* @ignore
*/
void terrain_add_zone(string zone)

{
   add_zone(zone);
   
   query_map_handler()->add_room_to_zone(this_object(), zone);
}


/**
 * This function allows you to change the destination location of the room
 * if nessessary.  This is useful for bridges and other things which need to
 * move people up or down one z-coordinate when they cross the line.
 * @param x the x coordinate
 * @param y the y coordinate
 * @param z the z coordinate
 * @param direct the direction used to enter this location
 * @peram key the key of the room that is coming to us
 */
string query_dest_coordinate_string(int x, int y, int z,
                                    string direc, string key) {
   return ":" + x + ":" + y + ":" + z;
}


/**
* The handler calls this function when setting up exits to allow the
* room to set up any modify_exit parameters which should be applied
* to exits leading to other locations of the same type as this. 
* Override it to provide any extra exit modifiers.
* @param type the ASCII character representing this room type
* @return an array of exit modifiers. This should take the same form as
* used in modify_exit
* @example
* mixed *query_to_same(string type)
* 
* { 
*    return ({ "move mess", "You wade along the stream bed.\n",
*              "enter mess", "$N wades in from the $F.",
*              "exit mess", "$N wades off to the $T.",
*              "hidden", "1 });
* }
* @see modify_exit
* @see query_to_other
* @see query_from_other
*/
varargs mixed *query_to_same(string type, string to_direc, string from_direc, string path_to) {
   return 0;
}


/**
* The handler calls this function when setting up exits to allow the
* room to set up any modify_exit parameters which should be applied
* to exits leading to other locations of different types to this. 
* Override it to provide any extra exit modifiers.
* @param type the ASCII character representing the room type the exit leads to
* @return an array of exit modifiers. This should take the same form as
* used in modify_exit
* @example
* mixed *query_to_other(string type)
* 
* { 
*    return ({ "move mess", "You scramble up the stream bank.\n",
*              "enter mess", "$N scrambles up the stream bank from the $F.",
*              "exit mess", "$N scrambles up the stream bank to the $T.",
*              "hidden", "1 });
* }
* @see modify_exit
* @see query_to_same
* @see query_from_other
*/
varargs mixed *query_to_other(string type, string to_direc, string from_direc, string path_to) {
   return 0;
}


/**
* The handler calls this function when setting up exits to allow the
* room to set up any modify_exit parameters which should be applied
* to exits leading from other locations of different types to this. 
* Override it to provide any extra exit modifiers.
* @param type the ASCII character representing the room type the exit leads from
* @return an array of exit modifiers. This should take the same form as
* used in modify_exit
* @example
* mixed *query_from_other(string type)
* 
* { 
*    return ({ "move mess", "You scramble down the bank into the stream.\n",
*              "enter mess", "$N scrambles down the $F bank into the stream.",
*              "exit mess", "$N scrambles down the stream bank to the $T" });
* }
* @see modify_exit
* @see query_to_same
* @see query_from_other
*/
varargs mixed *query_from_other(string type, string to_direc, string from_direc, string path_from) {
   return 0;
}


// The next three are prettification functions for the above, and should
// never be called directly.
/**
* @ignore
*/
mixed *get_to_same(string from, string to, string type, string path_to)

{ 
   mixed *result = query_to_same(type, to, from);
   
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   
   return 0;
}


/**
* @ignore
*/
mixed *get_to_other(string from, string to, string type, string path_to)

{ 
   mixed *result = query_to_other(type, to, from);
   
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   
   return 0;
}


/**
* @ignore
*/
mixed *get_from_other(string from, string to, string type, string path_from)

{ 
   mixed *result = query_from_other(type, to, from);
   
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   
   return 0;
}


// Called by the handler to set our extra_look strings.
/**
* @ignore
*/
void set_extra_long(string extra)

{
   _extra_long = extra;
}


/**
* @ignore
*/
void set_outside_types(string types)

{
   _outside_types = types;
}

/** 
 * This method returns the actual file name of this object.
 */
string query_my_real_file_name() {
   return __FILE__;
}

// This handles all the extra parts of the room desc which are
// inserted by the handler.
/**
* @ignore
*/
string extra_look() {
   string   result = _extra_long;
   string   title;
   string*   tmp;
   class  feature feature;
   int new_line;
   //int index;
   //string* direc;
   string* descs;
   int visibility;
   
   new_line = query_map_handler()->query_newline_mode();
   descs = ({ });
   visibility = query_visibility();
   foreach (title, feature in _features) {
      tmp = query_map_handler()->query_feature_desc(title,
                                          feature->direcs, visibility);
      if (sizeof(tmp)) {
         feature->visible = 1;
         descs += tmp;
      }
   }

   foreach (title, feature in _dist_features) {
      tmp = query_map_handler()->query_distant_feature_desc(title,
                                        feature, visibility);
      if (sizeof(tmp)) {
         //feature->visible = 1;
         descs += tmp;
      }
   }

   if (sizeof(descs)) {
      result += "  " + capitalize(query_multiple_short(descs)) + ".";
   }

   if (_random_desc) {
      result = result + _random_desc;
   }

   if (new_line) {
      return result;
   } else { 
      return result + "\n";
   }
}


// Add a new visible feature to the room, so it knows to query the handler
// for descriptions and so on. The zone info is needed as an easy way for
// the handler to get access to which rooms see which features. 
/**
* @ignore
*/
void add_feature(string title, mapping bits, mixed items, int sentance)

{
   //string* descs;

   _features[title] = new(class feature,
                          items : items, direcs : bits);
   if (items) {
      add_item(items, (: query_feature_item_desc($(title)) :));
   }
}

// Add a new visible feature to the room, so it knows to query the handler
// for descriptions and so on. The zone info is needed as an easy way for
// the handler to get access to which rooms see which features. 
/**
* @ignore
*/
void add_distant_feature(string title, mapping bits) {
   _dist_features[title] = bits;
}


/**
* @ignore
*/
void remove_feature(string title)

{
   class feature  feature = _features[title];
   mixed    items;
   
   if (!feature) {
      return;
   }
   
   map_delete(_features, title);
   items = feature->items;
   if (stringp(items)) {
      remove_item(items);
   } else {
      remove_item(items[0]);
   }
}


/**
* @ignore
int query_feature_range(string title)

{
   class feature   feature = _features[title];
   
   if (!feature) {
      return -1;
   }
   
   return feature->index;
}
*/


/**
* @ignore
*/
string query_feature_item_desc(string title)
{
   if (_features[title]->visible) {
      return query_map_handler()->query_feature_item_desc(title);
   }
   return 0;
}


/**
* @ignore
*/
mapping query_features() { return _features; }

/**
* @ignore
*/
int query_installed() { return _flag & INSTALLED_FLAG; }
/**
* @ignore
*/
void set_installed() { _flag |= INSTALLED_FLAG; }

/**
 * This method sets if the particular room is see through or not.
 * @param blocking sets the blocking flag
 */
void set_terrain_map_block(int blocking) {
   if (blocking) {
      _flag |= BLOCKING_FLAG;
   } else {
      _flag &= ~BLOCKING_FLAG;
   }
}

/**
 * This method returns if the room is blocking or not.
 * @return if the room is blocking or not
 */
int query_terrain_map_block() {
   return _flag & BLOCKING_FLAG;
}

/**
 * This method sets the character to use for this terrain in the player
 * visible map.
 * @param char the character to use in the map
 */
void set_terrain_map_character(string terr) {
   _terrain_char = terr;
}

/**
 * This method returns the character to use for this terrain in the player
 * visible map.
 * @return the terrain character
 */
string query_terrain_map_character() {
   return _terrain_char;
}


/**
* @ignore
* God only knows whether anyone'll ever use this. But the standard
* terrain stuff implements it, so what the hell :-)
*/
string query_cloning_info()
{
  return file_name(this_object());
}



/**
* @ignore
* Handles the cloning of a room when it is specified as:
* path/name:x:y
*/
object create_virtual_object(string x_str, string y_str)
{
   int x = to_int(x_str);
   int y = to_int(y_str);
   
   return query_map_handler()->load_room_at(x, y);
}

/**
 * This method adds a variable exit into the list of variable exits.
 * @param exit the exit to make variable
 */
void add_variable_exit(string exit) {
   _variable_exits += ({ exit });
}

/**
 * This method adds a default exit into the list of default exits.
 * @param exit the exit to make variable
 * @param location this is the walk exit location
 */
void add_default_exit(string exit, string location) {
   _default_exits[exit] = location;
}

/**
 * This method returns the default exits mapping.
 * @return the default exits mapping
 */
mapping query_default_exits() {
   return _default_exits;
}

/**
 * This method returns the prefix to use for 'walk' exits in this room.
 */
string query_terrain_map_walk_exit() {
   return TERRAIN_MAP_WALK_EXIT;
}

/**
 * This method returns the prefix to use for 'journey' exits in this room.
 */
string query_terrain_map_journey_exit() {
   return TERRAIN_MAP_JOURNEY_EXIT;
}

/**
 * This method returns the path at the specific co-ordinate.
 * @param x the x co-ordinate
 * @param y the y co-ordinate
 * @param z the z co-ordinate
 * @return the file name of the new room
 */
string query_room_path(int x, int y, int z) {
   return sprintf("%s:%d:%d:%d", query_terrain_handler(), x, y, z);
}

/**
 * This method returns a string which says how far they have moved.
 * @param num how many steps in the direction
 * @param dir the direction
 */
string query_direction_distance_str(int num, string dir) {
   int dist;
   string dist_mess;

   dist = query_map_handler()->query_direction_distance(dir);
   switch (dist) {
   case 0..2 :
      if (dist > 1) {
         dist_mess = query_num(dist) + " foot section";
      } else {
         dist_mess = "foot";
      }
      break;
   case 3..TERRAIN_MAP_ONE_MILE / 2 - 1 :
      dist /= 3;
      if (dist > 1) {
         dist_mess = query_num(dist) + " yard section";
      } else {
         dist_mess = "yard";
      }
      break;
   case TERRAIN_MAP_ONE_MILE / 2..TERRAIN_MAP_ONE_MILE - 1 :
      dist /= TERRAIN_MAP_ONE_MILE / 2;
      if (dist > 1) {
         dist_mess = query_num(dist) + " miles section";
      } else {
         dist_mess = "mile";
      }
      break;
   default:
      dist /= TERRAIN_MAP_ONE_MILE;
      if (dist > 1) {
         dist_mess = query_num(dist) + " miles section";
      } else {
         dist_mess = "mile";
      }
      break;
   }
   switch(num) {
   case 0:
      return dist_mess + " " + dir;
   case 1:
      return query_num(num) + " " + dist_mess + " " +dir;
   default:
      return query_num(num) + " " + dist_mess + "s " + dir;
   }
}

/**
 * This messes with the return values of the rooms.
 * @param exit the exit to look at
 * @param data the actual data from the room code
 * @return the messed with data
 */
mixed* query_dest_other(string exit, mixed* data) {
   mixed* bing;
   string cur;
   string dir;
   int num;
   string* bits;
   int dist;
    

   // We need to return data here because data comes from 
   // /std/room->query_dest_other() lower down in the inheritance tree.
   if(!stringp(exit) || !_default_exits) {
     return data;
   }
   
   if (_default_exits[exit]) {
      if (this_player() &&
          this_player()->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY) &&
          member_array(query_terrain_map_journey_exit() + exit, _variable_exits) != -1) {
         exit = query_terrain_map_journey_exit() + exit;
      } else {
         data[ROOM_DEST] = _default_exits[exit];
         return data;
      }
   }

   if (member_array(exit, _variable_exits) != -1) {
      // Mess with it!
      bing = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, exit[strlen(query_terrain_map_journey_exit())..]);
      if (bing) {
         if (data[ROOM_DEST] != bing[0]) {
            data[ROOM_DEST] = bing[0];
            bits = ({ });
            foreach (dir in bing[1..]) {
               if (dir == cur) {
                  num++;
               } else {
                  if (cur) {
                     bits += ({ query_direction_distance_str(num, cur) });
                  }
                  cur = dir;
                  num = 1;
               }
            }
            dist = query_map_handler()->query_direction_distance(dir);
            bits += ({ query_direction_distance_str(num, dir) });
            if (sizeof(bits) > 1) {
               data[ROOM_MESS] = "You arrive after having journeyed " +
                                 implode(bits[0..<2], ", ") +
                                 " and " + bits[<1] +
                                 ".\n";
            } else {
               data[ROOM_MESS] = "You arrive after having journeyed " +
                                 bits[0] + 
                                 ".\n";
            }
            if (!arrayp(data[ROOM_ENTER]) ||
                !data[ROOM_ENTER][0]) {
               data[ROOM_ENTER] = "$N journey$s in from " +
                        ROOM_HANDLER->query_opposite_direction(bing[<1]) + ".\n";
            }
            if (!data[ROOM_EXIT]) {
               data[ROOM_EXIT] = "$N journey$s to the " + bing[1] + ".\n";
            }
         }
      }
   }
   return data;
}

/**
 * Mess with the data.
 */
mixed* query_dest_dir(mixed* data) {
   int i;
   int jump;
   mixed* bits;

   if (this_player() &&
       this_player()->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)) {
      jump = 1;
   }

   if (sizeof(_variable_exits)) {
      for (i = 0; i < sizeof(data); i += 2) {
         if (_default_exits[data[i]]) {
            if (jump) {
               bits = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, data[i]);
               if (bits) {
                  data[i+1] = bits[0];
               }
            } else {
               data[i+1] = _default_exits[data[i]];
            }
         } else if (member_array(data[i], _variable_exits) != -1) {
            bits = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, data[i][strlen(query_terrain_map_journey_exit())..]);
            if (bits) {
               data[i+1] = bits[0];
            }
         }
      }
   }
   return data;
}

/**
 * This method draws a little debug map for the creator.
 */
int do_map() {
   string map;

   map = query_map_handler()->query_debug_map(_x_coord, _y_coord, 13, _x_coord, _y_coord);
   write(map);
   add_succeeded_mess("");
   return 1;
}

/**
 * This method draws the map of the entire terrain.
 */
int do_map_terrain() {
   string map;

   map = query_map_handler()->query_debug_map(20, 20, 40, _x_coord, _y_coord);
   write(map);
   add_succeeded_mess("");
   return 1;
}


/**
* @ignore
*/
void init()

{
   tell_creator(this_player(), "Coords: (%d, %d, %d)\n", _x_coord, _y_coord, _z_coord);
   if (this_player()->query_creator()) {
      add_command("cremap", "", (: do_map :));
      add_command("cremap", "all", (: do_map_terrain :));
   }
}

mixed stats() {
   return ::stats() +
          ({ ({ "file", query_my_real_file_name() }),
             ({ "blocking", query_terrain_map_block() }) });
}

void dest_me() {
  if(_terrain_chatter) {
    log_file("CHATTER", "%s dested terrain chatter: %O\n",
             file_name(this_object()), _terrain_chatter);
    _terrain_chatter->dest_me();
    
  }
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/terrain_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_line.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_line.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629508   Available: 13576862
Inodes: Total: 5242880    Free: 4960136
7642 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_line.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629508   Available: 13576862
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is region handler for a polygon region.
 * @author Pinkfish
 * @started Mon Apr  1 12:15:24 PST 2002
 */
inherit "/std/room/inherit/terrain_map/geometry";

class vertex {
   int x;
   int y;
}

private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });

private class vertex* _vertexes = ({ });

/**
 * This method sets the position of the feature.
 * @param x the x coordinate of the feature
 * @param y the y coordinate of the feature
 * @param width the width of the feature
 * @param height the height of the feature
 */
void add_vertex(int x, int y) {
   class vertex vertex;

   vertex = new(class vertex, x : x, y : y);
   _vertexes += ({ vertex });
}

/**
 * This is the function that finds the distance and direction to the
 * current region.
 * @param x the x-coordinate
 * @param y the y-coordinate
 * @param z the z-coordinate
 * @return ({ direction, distance [, direc2, dist2, [...]] })
 */
mapping query_feature_desc_from(int x, int y, int z) {
   class vertex vert1;
   class vertex vert2;
   int i;
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float vm_x;
   float vm_y;
   float b;
   float dot1;
   float dot2;
   float min_distance;
   float distance;
   float xmod;
   float ymod;
   int xd;
   int yd;
   string direc;
   mapping dirs;
   class point p;

   dirs = ([ ]);
   // With a series of line segments we don't count the implied return segment
   for (i = 0; i < sizeof(_vertexes) - 1; i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      v1_x = to_float(vert1->x - vert2->x);
      v1_y = to_float(vert1->y - vert2->y);
      v2_x = to_float(x - vert2->x);
      v2_y = to_float(y - vert2->y);

      dot1 = v1_x * v2_x + v1_y * v2_y;
      if (dot1 <= 0.0) {
         // Distance to p1
         distance = sqrt(pow(vert2->x - x, 2) + pow(vert2->y - y, 2));
//printf("1) %O\n", distance);
         if ((!min_distance || distance < min_distance) && distance > 0.0001) {
            xmod = ((vert2->x - x) < 0) ? -0.5 : 0.5;
            ymod = ((vert2->y - y) < 0) ? -0.5 : 0.5;
            xd = to_int(xmod + to_float(vert2->x - x) / distance) + 1;
            yd = to_int(ymod + to_float(vert2->y - y) / distance) + 1;
            direc = _feature_direcs[yd][xd];
            min_distance = distance;
         }
      } else {
         dot2 = v1_x * v1_x + v1_y * v1_y;
         if (dot2 <= dot1) {
            // Distance to p2.
            distance = sqrt(pow(vert1->x - x, 2) + pow(vert1->y - y, 2));
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
//printf("2) %O\n", distance);
               xmod = ((vert1->x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vert1->y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vert1->x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vert1->y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         } else {
            b = dot1 / dot2;
            vm_x = to_float(vert2->x) + b * v1_x;
            vm_y = to_float(vert2->y) + b * v1_y;
            // Distance to vm.
            distance = sqrt(pow(vm_x - x, 2) + pow(vm_y - y, 2));
//printf("3) (%O, %O) %O\n", vm_x, vm_y, distance);
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vm_x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vm_y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vm_x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vm_y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         }
      }
      // Do specific direction checks.
      p = intersection_of_line_and_segment(0,0, 1,0, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->x > x) {
            if (dirs["east"] && dirs["east"] > p->x) {
               dirs["east"] = p->x;
            }
         } else {
            if (dirs["west"] && dirs["west"] > p->x) {
               dirs["west"] = p->x;
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 0,1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->y > y) {
            if (dirs["north"] && dirs["north"] > p->y) {
               dirs["north"] = to_int(p->y);
            }
         } else {
            if (dirs["south"] && dirs["south"] > p->y) {
               dirs["south"] = to_int(p->y);
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->x > x) {
            if (dirs["northeast"] && dirs["northeast"] > p->x) {
               dirs["northeast"] = to_int(p->x);
            }
         } else {
            if (dirs["southwest"] && dirs["southwest"] > p->x) {
               dirs["southwest"] = to_int(p->x);
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,-1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->y > y) {
            if (dirs["northwest"] && dirs["northwest"] > p->y) {
               dirs["northwest"] = p->y;
            }
         } else {
            if (dirs["southeast"] && dirs["southeast"] > p->y) {
               dirs["southeast"] = p->y;
            }
         }
      }
//printf("%O of %O: %O %O\n", i, sizeof(_vertexes), direc, min_distance);
   }

   dirs[direc] = to_int(min_distance);

/*
   ret = ({ direc, to_int(min_distance) });
   foreach (direc, i in dirs) {
       ret += ({ direc, i });
   }
 */
   return dirs;
}

/**
 * Find out if this polygon is inside the region, given the specified range
 * at which it can be seen.  This will work by adding the ranges onto the
 * lines and checking for distance from the points of the polygon to the line
 * bordering the region and also checking for intersection with the bordering
 * line.  It also checks to see if all of the points are inside the region.
 * @param x1 the top x
 * @param y1 the top y
 * @param x2 the bottom x
 * @param y2 the bottom y
 */
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class vertex vertex;
   class vertex vert1;
   class vertex vert2;
   int i;

   foreach (vertex in _vertexes) {
      if (vertex->x >= x1 && vertex->x <= x2 &&
          vertex->y >= y1 && vertex->y <= y2) {
         return 1;
      }
   }

   // Now check distances to the edges of the polygon.
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      if (distance_between_two_line_segments(x1, y1, x1, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y1, x2, y1,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x2, y1, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y2, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
   }
   return 0;
}

/** @ignore yes */
void dest_me() {
   destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_line.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_poly.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_poly.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629506   Available: 13576860
Inodes: Total: 5242880    Free: 4960136
9414 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_poly.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629506   Available: 13576860
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is region handler for a polygon region.
 * @author Pinkfish
 * @started Mon Apr  1 12:15:24 PST 2002
 */
inherit "/std/room/inherit/terrain_map/geometry";

class vertex {
   int x;
   int y;
}

private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });

private class vertex* _vertexes = ({ });
private int _inside;

/**
 * This method sets the inside flag for the region.  If the region is an
 * inside region then it makes a loop around the region which can be seen
 * from the inside, but not the outside.
 * @param flag the inside region flag
 */
void set_inside(int flag) {
   _inside = flag;
}

/**
 * This method sets the position of the feature.
 * @param x the x coordinate of the feature
 * @param y the y coordinate of the feature
 * @param width the width of the feature
 * @param height the height of the feature
 */
void add_vertex(int x, int y) {
   class vertex vertex;

   vertex = new(class vertex, x : x, y : y);
   _vertexes += ({ vertex });
}

/**
 * This is the function that finds the distance and direction to the
 * current region.
 * @param x the x-coordinate
 * @param y the y-coordinate
 * @param z the z-coordinate
 * @param only_shortest only find the shortest distance
 * @return ({ direction, distance [, direc2, dist2, [...]] })
 */
mapping query_feature_desc_from(int x, int y, int z, int only_shortest) {
   class vertex vert1;
   class vertex vert2;
   int i;
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float vm_x;
   float vm_y;
   float b;
   float dot1;
   float dot2;
   float min_distance;
   float distance;
   float xmod;
   float ymod;
   int xd;
   int yd;
   string direc;
   int counter;
   mapping dirs;
   class point p;

   dirs = ([ ]);
   if (_vertexes[0]->y == y && _vertexes[0]->x == x) {
      return 0;
   }
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      v1_x = to_float(vert1->x - vert2->x);
      v1_y = to_float(vert1->y - vert2->y);
      v2_x = to_float(x - vert2->x);
      v2_y = to_float(y - vert2->y);

      //
      // Do inside check first.  If counter ends up as non-zero
      // then the point is inside.
      //
      if (vert2->y == y && vert2->x == x) {
         return 0;
      }
      if (vert1->y == vert2->y) {
         // Horizontal line.
         if (y == vert1->y &&
             ((vert1->x <= x && x <= vert2->x) ||
              (vert1->x >= x && x >= vert2->x))) {
            return 0;
         }
      }
      if ((((vert1->y < y) && (y <= vert2->y)) ||
           ((vert2->y < y) && (y <= vert1->y))) &&
          (x < (vert2->x - vert1->x) * (y - vert1->y) / (vert2->y - vert1->y) + vert1->x)) {
         counter = !counter;
      }

      dot1 = v1_x * v2_x + v1_y * v2_y;
      if (dot1 <= 0.0) {
         // Distance to p1
         distance = sqrt(pow(vert2->x - x, 2) + pow(vert2->y - y, 2));
//printf("1) %O\n", distance);
         if (distance <= 0.0001) {
            // We are on top of it, so escape.
            return 0;
         }
         if ((!min_distance || distance < min_distance) && distance > 0.0001) { 
            xmod = ((vert2->x - x) < 0) ? -0.5 : 0.5;
            ymod = ((vert2->y - y) < 0) ? -0.5 : 0.5;
            xd = to_int(xmod + to_float(vert2->x - x) / distance) + 1;
            yd = to_int(ymod + to_float(vert2->y - y) / distance) + 1;
            direc = _feature_direcs[yd][xd];
            min_distance = distance;
         }
      } else {
         dot2 = v1_x * v1_x + v1_y * v1_y;
         if (dot2 <= dot1) {
            // Distance to p2.
            distance = sqrt(pow(vert1->x - x, 2) + pow(vert1->y - y, 2));
//printf("2) %O\n", distance);
            if (distance <= 0.0001) {
               // We are on top of it, so escape.
               return 0;
            }
            if ((!min_distance || distance < min_distance) && distance > 0.0001) { 
               xmod = ((vert1->x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vert1->y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vert1->x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vert1->y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         } else {
            b = dot1 / dot2;
            vm_x = to_float(vert2->x) + b * v1_x;
            vm_y = to_float(vert2->y) + b * v1_y;
            // Distance to vm.
            distance = sqrt(pow(vm_x - x, 2) + pow(vm_y - y, 2));
//printf("3) (%O, %O) %O\n", vm_x, vm_y, distance);
            if (distance <= 0.0001) {
               // We are on top of it, so escape.
               return 0;
            }
            if ((!min_distance || distance < min_distance) && distance > 0.0001) { 
               xmod = ((vm_x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vm_y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vm_x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vm_y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         }
      }
      if (!only_shortest) {
         // Do specific direction checks.
         p = intersection_of_line_and_segment(0,0, 1,0, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->x > x) {
               if (dirs["east"] && dirs["east"] > p->x) {
                  dirs["east"] = p->x;
               }
            } else {
               if (dirs["west"] && dirs["west"] > p->x) {
                  dirs["west"] = p->x;
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 0,1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->y > y) {
               if (dirs["north"] && dirs["north"] > p->y) {
                  dirs["north"] = to_int(p->y);
               }
            } else {
               if (dirs["south"] && dirs["south"] > p->y) {
                  dirs["south"] = to_int(p->y);
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 1,1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->x > x) {
               if (dirs["northeast"] && dirs["northeast"] > p->x) {
                  dirs["northeast"] = to_int(p->x);
               }
            } else {
               if (dirs["southwest"] && dirs["southwest"] > p->x) {
                  dirs["southwest"] = to_int(p->x);
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 1,-1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->y > y) {
               if (dirs["northwest"] && dirs["northwest"] > p->y) {
                  dirs["northwest"] = p->y;
               }
            } else {
               if (dirs["southeast"] && dirs["southeast"] > p->y) {
                  dirs["southeast"] = p->y;
               }
            }
         }
      }
   //printf("%O of %O: %O %O\n", i, sizeof(_vertexes), direc, min_distance);
   }

   // So if inside is set to 1 the the counter has to be 0, if it is 0
   // then the counter has to be 1.
   if (counter != _inside) {
      return 0;
   }
   dirs[direc] = to_int(min_distance);

/*
   ret = ({ direc, to_int(min_distance) });
   foreach (direc, i in dirs) {
       ret += ({ direc, i });
   }
 */
   return dirs;
}

/**
 * Find out if this polygon is inside the region, given the specified range
 * at which it can be seen.  This will work by adding the ranges onto the
 * lines and checking for distance from the points of the polygon to the line
 * bordering the region and also checking for intersection with the bordering
 * line.  It also checks to see if all of the points are inside the region.
 * @param x1 the top x
 * @param y1 the top y
 * @param x2 the bottom x
 * @param y2 the bottom y
 */
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class vertex vertex;
   class vertex vert1;
   class vertex vert2;
   int i;

   foreach (vertex in _vertexes) {
      if (vertex->x >= x1 && vertex->x <= x2 &&
          vertex->y >= y1 && vertex->y <= y2) {
         return 1;
      }
   }

   // Now check distances to the edges of the polygon.
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      if (distance_between_two_line_segments(x1, y1, x1, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y1, x2, y1,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x2, y1, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y2, x2, y2, 
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
   }
   return 0;
}

/** @ignore yes */
void dest_me() {
   destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_poly.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/handler_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/handler_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629504   Available: 13576858
Inodes: Total: 5242880    Free: 4960136
116433 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/handler_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629504   Available: 13576858
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: handler_base.c,v 1.116 2003/07/14 19:44:09 pinkfish Exp $
 *
*/
/**
* @main
* Base inherit for terrain map handler.
* <p>
* When creating a new terrain map, inherit from this file to make your area
* handler.
* <p>
* When inheriting from this file, it is essential that the functions
* query_map_file() and setup_handler() be overriden to return the full
* pathname of the area map, and to set up type mappings.
* <p>
* To inherit from this file, use the following lines:
* <ul>
* <li>#include <terrain_map.h>
* <li>
* <li>inherit TERRAIN_MAP_HANDLER_BASE
* </ul>
*
* @index terrain_map_handler
* @see terrain_map_inside
* @see terrain_map_outside
* @see terrain_map_intro
* @see terrain_map_example
* @author Dek
* @started Thurs April 12 2001 Too Damn Early BST
**/

#include <weather.h>
#include <terrain_map.h>
#include <player.h>

#define   AREA_OBSTACLE    0
#define   AREA_ROOM        1
#define   AREA_ROAD        2
#define   AREA_WORLD       3
#define   RANDOM_HANDLER   "/obj/handlers/random_num"

inherit "/std/room/inherit/terrain_map/distance_str";

#define X_DIFF 1
#define Y_DIFF 0
#define XY_DIFF 2

class char_map_data {
   string char;
   string colour;
   string path;
   string room_desc;
   mixed items;
   mixed item_desc;
   mixed chats;
   int type;
   int height;
   mapping height_rooms;
   int whole_sentance;
   string adjacent_desc;
   // How many rooms to jump with each movement.
   int room_jump;
   // If this is 1 then we treat is as a road and try to follow twists.
   // If it is 0 then we go in the direction as far as we can.
   int room_jump_matching;
}

class feature_data {
   int range;
   string* descs;
   string* night_descs;
   mixed f_items;
   mixed f_item_desc;
   mixed f_item_night_desc;
   int whole_sentance;
   mixed chats;
   mixed night_chats;
   object feature_ob;
}

class sign_data {
   string long;
   string read_mess;
   string short;
   string name;
   string language;
}

class real_coords {
   int x1;
   int y1;
   int x2;
   int y2;
   int xdiff;
   int ydiff;
   int xydiff; // Diff in a diagonal.
   int zdiff;
   int in_world_map;
}


private mixed     *_room_map = 0;
private mixed     *_area_map = 0;
private mixed     *_zone_map = 0;
private int       _visible_distance;
private int       _width = 0;
private int       _height = 0;
private int       _normal_skip_size = 1;
private int       _random_desc_limit = 2;
private int       _random_chat_limit = 4;
private int       _newline_mode = 1;
private mapping   _room_zones = ([ ]);
private mapping   _feature_rooms = ([ ]);
private mapping   _char_map = ([ ]);
private mapping   _zone_types = ([ ]);
private mapping   _features = ([ ]);
private mapping   _signposts = ([ ]);
private mapping   _standard_exits = ([ ]);
private mapping   _adjacent_terrains = ([ ]);
private mapping   _random_descs = ([ ]);
private mapping   _random_chats = ([ ]);
private class real_coords _real_coords;
private mapping _key = ([ ]);
private mapping   _direcs = ([ "north":     ({ 0, 1, "south", Y_DIFF, 0 }),
                       "northeast": ({ 1, 1, "southwest", XY_DIFF, ({ "obvious", 0 }) }),
                       "east":      ({ 1, 0, "west", X_DIFF, 0 }),
                       "southeast": ({ 1, -1, "northwest", XY_DIFF, ({ "obvious", 0 }) }),
                       "south":     ({ 0, -1, "north", Y_DIFF, 0 }),
                       "southwest": ({ -1, -1, "northeast", XY_DIFF, ({ "obvious", 0 }) }),
                       "west":      ({ -1, 0, "east", X_DIFF, 0 }),
                       "northwest": ({ -1, 1, "southeast", XY_DIFF, ({ "obvious", 0 }) }) ]);
// This is the order to do the directions in.  Make sure we do the
// main cardinal ones first.
private string* _direc_order = ({
                        "north", "east", "south", "west",
                        "northeast", "southeast", "southwest", "northwest" });

private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });

void load_area_map();
void load_zone_map();
class char_map_data query_char_map(int x, int y);
void setup_area_map();
void setup_room(object room, string base_path);
string find_adjacent_terrain(int x, int y);

// A load of accessor functions to make debugging a lot easier.
mixed   *query_room_map() { return _room_map; }
mixed   *query_area_map() { return _area_map; }
mixed   *query_zone_map() { return _zone_map; }
mapping query_zone_types() { return _zone_types; }
mapping query_feature_rooms() { return _feature_rooms; }
mapping query_features() { return _features; }
mapping query_room_zones() { return _room_zones; }
mapping query_char_maps() { return _char_map; }
mapping query_signposts() { return _signposts; }
mapping query_random_descs() { return _random_descs; }
mapping query_random_chats() { return _random_chats; }
mapping query_standard_exits() { return _standard_exits; }
mapping query_adjacent_terrains() { return _adjacent_terrains; }
class real_coords query_debug_real_coord() { return _real_coords; }
mixed* query_real_coords() { return ({ ({ _real_coords->x1, _real_coords->y1 }), ({ _real_coords->x2, _real_coords->y2 }) }); }
int     *query_dimensions() { return ({ _width, _height }); }
void    setup_handler() { }
string  query_map_file() { return ""; } // OVERRIDE to return the map file path.

// No, this makes us have a 700M driver and end up swapping like crazy!
//int     clean_up() { return 0;  }

/**
 * This method sets the real coordinates for the room without informing
 * the map handler.
 * @param x1 the start x location
 * @param y1 the start y location
 * @param x1 the end x location
 * @param y1 the end y location
 */
void set_real_coordinates_no_inform(int x1, int y1, int x2, int y2) {
   int tmp;

   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   _real_coords = new(class real_coords, x1:x1, y1:y1, x2:x2, y2:y2);
   _real_coords->xdiff = (x2 - x1) / _width;
   _real_coords->ydiff = (y2 - y1) / _height;
   // All z differentials in 15 foot lengths
   _real_coords->zdiff = 15;
   _real_coords->xydiff = to_int(sqrt(to_float(_real_coords->xdiff) * to_float(_real_coords->xdiff)+
                               to_float(_real_coords->ydiff) * to_float(_real_coords->ydiff)));
}

/**
 * @param x1 the start x location
 * @param y1 the start y location
 * @param x1 the end x location
 * @param y1 the end y location
 */
void set_real_coordinates(int x1, int y1, int x2, int y2) {
   set_real_coordinates_no_inform(x1, y1, x2, y2);
   _real_coords->in_world_map = TERRAIN_MAP_WORLD_MAP->add_terrain(base_name(this_object()),
                                      _real_coords->x1, _real_coords->y1,
                                      _real_coords->x2, _real_coords->y2);
}

/**
 * This method sets the real offsets for movement in the rooms.  This
 * is needed in rooms that do not have real co-ordinates set but still
 * require movement to generate the correct messages.
 * @param xoff how far you move in the x direction
 * @param yoff how far you move in the y direction
 * @param zoff how far you move in the z direction
 */
void set_real_offsets(int xoff, int yoff, int zoff) {
   _real_coords = new(class real_coords);
   _real_coords->xdiff = xoff;
   _real_coords->ydiff = yoff;
   _real_coords->xydiff = to_int(sqrt(to_float(_real_coords->xdiff) * to_float(_real_coords->xdiff)+
                               to_float(_real_coords->ydiff) * to_float(_real_coords->ydiff)));
}

/**
 * This method returns the room coordinates from the real coordinates.
 * @param x the x coordinate
 * @param y the y coordinate
 */
class coord query_terrain_from_real_coord(int x, int y, int z) {
   return new(class coord,
       x: (x - _real_coords->x1)  / _real_coords->xdiff,
       y: (y - _real_coords->y1) / _real_coords->ydiff,
       z: z / _real_coords->zdiff
        );
}

/**
 * This method returns the real coordinates from the terrain coordinates.
 * For simplicity we always assume the terrain sits at the water level.
 * @param x the x coordinate
 * @param y the y coordinate
 */
class coord query_real_from_terrain_coord(int x, int y, int z) {
   if (!_real_coords) {
      return new(class coord, x : 0, y : 0);
   }
   return new(class coord,
      x: _real_coords->x1 + x * _real_coords->xdiff,
      y: _real_coords->y1 + y * _real_coords->ydiff,
      z: z * _real_coords->zdiff
     );
}

/**
* @ignore
*/
int query_newline_mode() { return _newline_mode; }


/**
* This method sets the 'newline' mode for room description extras.
* If set to 1, a newline will be inserted after all feature and
* neighbouring room items. 1 is the default.
* @param mode the new mode.
*/
void set_newline_mode(int mode)

{
  _newline_mode = mode;
}

/**
 * This method sets the distance you can see in this terrain based on the
 * map.  The distance is used to determine nice little map things to show
 * the players.
 * @param distance the distance you can see
 */
void set_visible_distance(int distance) {
   _visible_distance = distance;
}

/**
 * This method returns the distance that you can see in this terrain.
 * @return the visible distance in the terrain
 */
int query_visible_distance() {
   return _visible_distance;
}

/**
* @ignore
*/
void create()

{
   setup_area_map();
   setup_handler();
}


// Loads in the maps, and if the array of rooms hasn't been allocated, do so.
/**
* @ignore
*/
void setup_area_map()

{
   int   index;

   load_area_map();
   load_zone_map();

   if (!arrayp(_room_map)) {
      _room_map = ({ });
      for (index = 0; index < _width; index++)
         _room_map += ({ allocate(_width) });
   }
}


// Install a room in the room array, and set up the descs and
// exits if need be.
/**
 * Not needed.
* @ignore
void install_room(object room)

{
   int   *room_coords = room->query_terrain_coords();
   int   x = room_coords[0];
   int   y = room_coords[1];

   if (!_room_map[y][x]) {
      _room_map[y][x] = room;
   }

   if (!room->query_installed()) {
      setup_room(room, "No base path");
   }
}
*/

/**
 * This method returns the region used when calculating the extents of the
 * feature.
 * @param name the name of the feature to find the region of
 * @return the feature region
 */
object query_feature_ob(string name) {
   return _features[name]->feature_ob;
}


// Calculate whether any of the features are visible from this room.
// If so, put in the relevant descs and add_items.
/**
* @ignore
* @return the blocking data
*/
mapping calc_features(object room)
{
   class feature_data    feature;
   string     title;
   int        *room_coords = room->query_terrain_coords();
   int        x = room_coords[0];
   int        y = room_coords[1];
   int        z = room_coords[2];
   mapping    data;
   string direc;
   int range;
   mapping block_feature;
   mixed* features;
   mixed* tmp;

   block_feature = ([ ]);
   features = ({ });
   foreach(title, feature in _features) {
      if (!room->can_view_feature(title)) {
         continue;
      }

      if (!feature || !feature->feature_ob) {
         debug_printf("Unable to find feature object for %O\n", title);
         continue;
      }

      data = feature->feature_ob->query_feature_desc_from(x, y, z);
      if (!data || !sizeof(data)) {
         continue;
      }

      if (feature->feature_ob->query_blocking()) {
         foreach (direc, range in data) {
            if (!block_feature[direc]) {
               if (block_feature[direc] > range) {
                  block_feature[direc] = range;
               } else {
                  map_delete(data, direc);
               }
            }
         }
      }

      if (sizeof(data)) {
         features += ({ ({ title, feature, data }) });
      }
   }
   foreach (tmp in features) {
      data = tmp[2];
      // Check and see if we are blocked.
      if (sizeof(block_feature)) {
         foreach (direc, range in data) {
            if (block_feature[direc] && block_feature[direc] < range) {
               map_delete(data, direc);
            }
         }
      }
      if (sizeof(data)) {
         feature = tmp[1];
         title = tmp[0];
         room->add_feature(title, data, feature->f_items, feature->whole_sentance);
         if (!_feature_rooms[title]) {
            _feature_rooms[title] = ({ });
         } else {
            _feature_rooms[title] = filter(_feature_rooms[title], (: $1 && objectp($1) :));
         }

         _feature_rooms[title] |= ({ room });
      }
   }
}


// See if this room has a signpost. If so, make it.
/**
* @ignore
*/
void add_signposts(object room)

{
   class sign_data sign;
   int     *coords = room->query_terrain_coords();
   int     x = coords[0];
   int     y = coords[1];
   string  title = sprintf("%d:%d", x, y);
   object  sign_ob;

   //tell_creator("dek", "Looking for a sign: %s.\n", title);

   sign = _signposts[title];
   if (!sign) {
      return;
   }

   sign_ob = room->add_sign(sign->long, sign->read_mess,
                  sign->short, sign->name,
                  sign->language);
   sign_ob->move(room);
}


// See what zones (if any) this room should belong to, and add them.
/**
* @ignore
*/
void setup_zones(object room)

{
   string  *zones;
   int     *coords = room->query_terrain_coords();
   int     x = coords[0];
   int     y = coords[1];
   string  type;
   string  zone;

   if (!sizeof(_zone_map)) {
      return;
   }

   type = _zone_map[y][x..x];
   zones = _zone_types[type];
   if (!zones) {
      return;
   }

   foreach (zone in zones) {
      room->add_zone(zone);
   }
}


void calc_random_descs(object room, string key)

{
   int      limit = _random_desc_limit;
   int      *indices = ({ });
   int      *coords = room->query_terrain_coords();
   int      seed = (coords[0] * 2) + coords[1];
   mapping  desc;
   mixed    *descs = _random_descs[key];
   int      index;

   if (limit > sizeof(descs)) {
      limit = sizeof(descs);
   }

   if (!limit) {
      return;
   }

   while (sizeof(indices) < limit) {
      index = RANDOM_HANDLER->random(sizeof(descs), seed++);
      if (member_array(index, indices) >= 0) {
         continue;
      }

      indices += ({ index });
   }
   for (index = 0; index < limit; index++) {
      desc = descs[indices[index]];
      room->add_random_desc(desc["desc"]);
      room->add_item(desc["items"], desc["item_desc"]);
   }
}


void calc_random_chats(object room, string key)

{
}

/**
 * This method finds the co-ordinates to use for getting to the
 * next room.  THis handles messing about to make bridges and things
 * @param x the x coordinate
 * @param y the y coordinate
 * @param z the z coordinate
 * @param direc the direction it is from
 * @param key the key is it from
 * @return the new mangled co-ordinates
 */
string query_dest_coordinate_string(int x, int y, int z, string direc, string key) {
   class char_map_data  room_setup;

   room_setup = query_char_map(x, y);

   if (room_setup->type == AREA_WORLD) {
      return room_setup->path->query_dest_coordinate_string(x, y, z, direc, key);
   }
   return 0;
}

/**
 * This method returns the ground room for a specific co-ordinate.
 * @param x the x location
 * @param y the y location
 * @return the terrain co-ordinates of the ground room
 */
int* query_ground_room_co_ords(int x, int y) {
   class char_map_data  room_setup;
   
   room_setup = query_char_map(x, y);
   return ({ x, y, room_setup->height });
}

/**
 * This method returns the location of the ground room.  It is basically
 * just the co-ordates connected onto the terrain_handler definition.
 * @param x the x location
 * @param y the y location
 * @return the string name of the ground room
 */
string query_ground_room(int x, int y) {
   int* co_ords;

   co_ords = query_ground_room_co_ords(x, y);
   return base_name(this_object()) + ":" + co_ords[0] + ":" + co_ords[1] + ":" + co_ords[2];
}

/**
 * This method returns the basic room as the specified location.  A climb
 * room type means a room that is up or down on the z axis from where we
 * are, but we are allowed to climb to.
 * @param x the x location
 * @param y the y location
 * @param z the z location
 * @param map_room check down through the air for the room for the map
 * @param base the updated base (for climbing rooms)
 * @return the basic room for the location
 */
string query_climb_base_room(int x, int y, int z, int map_room, string ref base) {
   class char_map_data  room_setup;
   string *tmp;
   
   room_setup = query_char_map(x, y);

   if (!room_setup) {
      return 0;
   }
   if (room_setup->type == AREA_WORLD) {
     // Pass off the creation to the room file.
     if(file_size(room_setup->path + ".c") == -1) {
       tmp = explode(room_setup->path, "_edge");
       if(sizeof(tmp) && file_size(tmp[0] + ".c") > 0)
         room_setup->path = tmp[0];
     }
     
     return room_setup->path->find_base_terrain_room(x, y, z, room_setup->path, map_room, ref base);
   } else if (room_setup->height_rooms) {
      // Find the new room.
      if (z > room_setup->height) {
         if (map_room == TERRAIN_MAP_ROOM_MAP) {
            return room_setup->path;
         }
         if (map_room != TERRAIN_MAP_ROOM_CLIMB) {
            // air room.
            return TERRAIN_MAP_DEFAULT_AIR_ROOM;
         }
         return 0;
      }
      if (z == room_setup->height) {
         return room_setup->path;
      }
      if (room_setup->height_rooms[z]) {
         return room_setup->height_rooms[z];
      }
      if (room_setup->height_rooms["minimum"] > z) {
         return 0;
      }
      return room_setup->height_rooms["default"];
   } else if (z == room_setup->height) {
      return room_setup->path;
   } else if (map_room && z > room_setup->height) {
      return room_setup->path;
   } else if (z > room_setup->height) {
      if (map_room != TERRAIN_MAP_ROOM_CLIMB) {
         return TERRAIN_MAP_DEFAULT_AIR_ROOM;
      }
   }
   return 0;
}

/**
 * This returns the destination room in the given directoin, initially
 * it tries for a normal exit type.  If that fails, it tries for a climbing
 * exit type.  A climbing exit type is one that moves up or down from the
 * current z height.
 * @param x the x co-ordinate
 * @param y the y co-ordinate
 * @param z the z co-ordinate
 * @param base the base path of the parent terrain handler
 */
string query_base_room(int x, int y, int z, int map_room) {
   string dest;

   dest = "bing";
   return query_climb_base_room(x, y, z, map_room, ref dest);
}

/**
 * The main nasty func for setting up a room. It adds all the necessary exits,
 * and adds to the room's extra_look & add_items for anything outside the room
 * which should be visible. It's fairly nasty. But hey - it works.
 */
void setup_room(object room, string base_path)
{
   string main_base;
   string base;
   int      *room_coords = room->query_terrain_coords();
   mixed    *coords;
   int      x;
   int      y;
   string   direc;
   class char_map_data  room_setup;
   string*  dirs;
   mapping  adjacent_descs = ([ ]);
   mapping  adjacent_sent = ([ ]);
   mapping  distant;
   string   adjacent;
   string   key;
   string   room_long = "";
   string   key_here;
   mixed    *exit_mods;
   object   new_room;
   string   outside_types = "";
   mixed    *exits;
   mapping  exit;
   string   *sentances;
   mixed   tmp;
   int z;
   int road_jump;
   class coord fluff;
   string* miss_road;
   mapping ignore_exits;
   string  walk_pre;
   string  walk_full;
   string  journey_pre;
   string  new_base_path;

   if (!arrayp(room_coords)) {
      debug_printf("Unable to find room coordinates from %O\n", file_name(room));
      return ;
   }
   room_setup = query_char_map(room_coords[0], room_coords[1]);
   key_here = room_setup->char;

   if (room_setup->room_desc) {
      adjacent_descs[room_setup->room_desc] = ({ "here" });
      adjacent_sent[room_setup->char] = 1;
      if( room_setup->items ) {
          if( stringp( room_setup->items ) &&
              stringp( room_setup->item_desc ) ) {
              room->add_item( room_setup->items, room_setup->item_desc );
          } else if( arrayp( room_setup->items ) &&
              arrayp( room_setup->item_desc ) && sizeof( room_setup->items ) ) {
              if( sizeof( room_setup->items ) !=
                  sizeof( room_setup->item_desc ) ) {
                  debug_printf( "Error, unequal arrays.  Item not set." );
              } else {
                  int i;

                  for( i = 0; i < sizeof( room_setup->items ); i++ ) {
                      room->add_item( room_setup->items[i],
                          room_setup->item_desc[i] );
                  }
              }
          }
      }

   }

   if (room_setup->room_jump_matching) {
      road_jump = room_setup->room_jump;
   }

   walk_pre = room->query_terrain_map_walk_exit();
   journey_pre = room->query_terrain_map_journey_exit();

   exits = _standard_exits[sprintf("%d:%d:%d", room_coords[0], room_coords[1], room_coords[2])];
   ignore_exits = ([ ]);
   if (exits) {
      foreach(exit in exits) {
         room->add_exit(exit["direc"], exit["dest"], exit["type"]);
         if (exit["modifiers"]) {
            room->modify_exit(exit["direc"], exit["modifiers"]);
         }
         ignore_exits[exit["direc"]] = 1;
      }
   }

   //
   // This is the start of the pre-caclulated exits for the terrain.
   // All the cardinal directions are checked for their ability to be
   // gone up and down.
   // Most checks are done on the base object (if possible) to avoid
   // loading everything in sight.
   //

   // Check the up and down exits first.
   main_base = base_name(this_object());
   if (room_setup->height_rooms ||
       room_setup->type == AREA_WORLD) {
      int i;

      x = room_coords[0];
      y = room_coords[1];
      // Ok, zip through this mapping and see if we match anything.
      // This finds if there is a room above or below us at all.
      for (i = 0; i < 2; i++) {
         z = room_coords[2];
         if (!i) {
            direc = "up";
            tmp = "down";
            z++;
         } else {
            direc = "down";
            tmp = "up";
            z--;
         }
         base = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
         if (base) {
            // There is a room!  Check and see if we can get in it or not.
            new_room = load_object(base);
            new_base_path = base;
            if (!new_room) {
               continue;
            }
            if (new_room->can_enter_from(key_here, direc, base_path) &&
                room->can_exit_to(key_here, direc, new_base_path)) {
               room->add_exit(direc, main_base + ":" + x + ":" + y + ":" + z, "path");
               exit_mods = room->get_to_same(tmp, direc, key, new_base_path);
               if (exit_mods) {
                   room->modify_exit(direc, exit_mods);
               }
            }
         }
      }
   }

   //
   // This is to check for crossing over roads/rivers on a diagonal.
   //
   miss_road = allocate(3 * 3);

   // Check the other exits.
   foreach(direc in _direc_order) {
      coords = _direcs[direc];
      x = coords[0] + room_coords[0];
      y = coords[1] + room_coords[1];
      z = room_coords[2];
      if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
         // Check and see if we have an adjacent terrain or not
         base = find_adjacent_terrain(x, y);
         if (!base) {
            continue;
         }
         fluff = query_real_from_terrain_coord(x, y, z);
         fluff = base->query_terrain_from_real_coord(fluff->x, fluff->y, fluff->z);
         room_setup = base->query_char_map(fluff->x, fluff->y);
         if (room_setup && room_setup->type != AREA_OBSTACLE) {
            tmp = base->query_base_room(fluff->x, fluff->y, z, TERRAIN_MAP_ROOM_EXACT);
            if (tmp) {
               new_base_path = tmp;
               new_room = load_object(tmp);
               base += ":" + fluff->x + ":" + fluff->y + ":" + z;
            } else {
               new_room = 0;
               new_base_path = 0;
            }
         }
      } else {
         room_setup = query_char_map(x, y);
         if (room_setup && room_setup->type != AREA_OBSTACLE) {
            tmp = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
            new_base_path = tmp;
            if (tmp) {
               new_room = load_object(tmp);
               base = main_base + ":" + x + ":" + y + ":" + z;
            } else {
               new_room = 0;
            }
         }
      }
      if (!room_setup || !new_room) {
         continue;
      }

      key = room_setup->char;
      // Make sure it is cardinal.  Check to see if we can leap this
      // location or not.
      // We use the file name of the new room to check for the diagonal
      // exit policy problems.  This should solve the problems of moving
      // across maps.
      if (!coords[0] || !coords[1]) {
         miss_road[(coords[0] + 1) * 3 + coords[1] + 1] = new_base_path;
      } else {
         // Only do this if the values are not 0 too.
         if ((miss_road[(coords[0] + 1) * 3 + 1] != new_base_path ||
              miss_road[coords[1] + 4] != new_base_path) &&
             miss_road[coords[1] + 4] &&
             miss_road[(coords[0] + 1) * 3 + 1] &&
             !miss_road[coords[1] + 4]->can_move_between(key, direc,
                                    miss_road[(coords[0] + 1) * 3 + 1],
                                    miss_road[coords[1] + 4], new_base_path)) {
            // Don't allow this to happen.
            continue;
         }
      }

      switch(room_setup->type) {
         case AREA_OBSTACLE   :
            break;
         case AREA_ROAD       :
         case AREA_ROOM       :
         case AREA_WORLD      :
           if (ignore_exits[direc]) {
              break;
           }
           if (new_room->can_enter_from(key_here, direc, base_path) &&
                room->can_exit_to(key, direc, new_base_path)) {

              // Now check and see if we need to modify the exit to this
              // room at all.
              tmp = new_room->query_enter_exit_direction(key, key_here, direc, room, base_path);
              if (tmp) {
                 room->add_exit(tmp, base, "road");
                 walk_full = tmp;
              } else {
                 // If they are not doing anything, setup all the default
                 // hop stuff.
                 room->add_exit(direc, base, "road");
                 room->add_exit(walk_pre + direc, base, "road");
                 room->add_default_exit(direc, base);
                 walk_full = walk_pre + direc;
              }
              if (coords[4]) {
                 room->modify_exit(walk_full, coords[4]);
                 room->modify_exit(direc, coords[4]);
              }
              if (key_here == key ||
                  (road_jump &&
                   room_setup->room_jump_matching &&
                   room_setup->room_jump == road_jump)) {
                 exit_mods = room->get_to_same(_direcs[direc][2], direc, key, new_base_path);
                 if (exit_mods) {
                    room->modify_exit(direc, exit_mods);
                    room->modify_exit(walk_full, exit_mods);
                 }
                 if (room_setup->room_jump > 1) {
                    //room->modify_exit(direc, ({ "obvious", 0 }));
                    room->modify_exit(walk_full, ({ "obvious", 0 }));
                    room->add_variable_exit(journey_pre + direc);
                    room->add_exit(journey_pre + direc, base, "road");
                    exit_mods = room->get_to_same(walk_full, journey_pre + direc, key, new_base_path);
                    if (coords[4]) {
                       room->modify_exit(journey_pre + direc, coords[4]);
                    }
                    if (exit_mods) {
                        room->modify_exit(journey_pre + direc, exit_mods);
                    }
                 }
              } else {
                 exit_mods = room->get_to_other(_direcs[direc][2], direc, key, new_base_path);
                 if (exit_mods) {
                     room->modify_exit(walk_full, exit_mods);
                 }
                 exit_mods = new_room->
                             get_from_other(_direcs[direc][2], direc, key_here, base_path);
                 if (exit_mods) {
                     room->modify_exit(walk_full, exit_mods);
                 }
              }
              room->modify_exit(direc, ({ "obvious", 0 }));
           }
           break;
      }
      if ((key_here != key) && (member_array(key[0], outside_types) < 0)) {
         outside_types += key;
      }
      adjacent = room_setup->adjacent_desc;
      if (adjacent && strlen(adjacent) > 1) {
         if (room->can_view_adjacent_desc(room_setup->char,
                                          key_here,
                                          room_setup->path,
                                          z,
                                          direc)) {
            if (!room_setup->whole_sentance) {
               adjacent_sent[adjacent] = 1;
            }
            if (!adjacent_descs[adjacent]) {
               adjacent_descs[adjacent] = ({ });
               if( room_setup->items ) {
                   if (!adjacent_sent[room_setup->char]) {
                      adjacent_sent[room_setup->char] = 1;
                      if( stringp( room_setup->items ) &&
                          stringp( room_setup->item_desc ) ) {
                          room->add_item( room_setup->items,
                              room_setup->item_desc );
                      } else if( arrayp( room_setup->items ) &&
                          arrayp( room_setup->item_desc ) &&
                          sizeof( room_setup->items ) ) {
                          if( sizeof( room_setup->items ) !=
                              sizeof( room_setup->item_desc ) ) {
                              debug_printf( "Error, unequal arrays.  Item not "
                                  "set." );
                          } else {
                              int i;
   
                              for( i = 0; i < sizeof( room_setup->items ); i++) {
                                  room->add_item( room_setup->items[i],
                                      room_setup->item_desc[i] );
                              }
                          }
                      }
                   }
               }
            }
            adjacent_descs[adjacent] += ({ direc });
         }
      }
   }

   sentances = ({ });
   foreach(adjacent, dirs in adjacent_descs) {
      tmp = replace_string(adjacent,
                "$D", query_multiple_short(dirs, "the", 1));
      if (adjacent_sent[adjacent]) {
         if (strlen(tmp) > 1) {
            sentances += ({ tmp });
         }
      } else if (tmp != "") {
         if (query_newline_mode()) {
            room_long += tmp + "\n";
         } else {
            room_long += "  " + tmp;
         }
      }
   }

   if (sizeof(sentances)) {
      if (!query_newline_mode()) {
         room_long += "  ";
      }
      room_long += capitalize(query_multiple_short(sentances, "the", 1)) + ".";
      if (query_newline_mode()) {
         room_long += "\n";
      }
   }

   room->set_outside_types(outside_types);
   add_signposts(room);
   setup_zones(room);

   // Do the features.
   exit = calc_features(room);
   if (_real_coords && (_real_coords->x1 || _real_coords->x2)) {
      fluff = query_real_from_terrain_coord(room_coords[0], room_coords[1], 0);
      foreach (string title in TERRAIN_MAP_WORLD_MAP->query_features_at(fluff->x, fluff->y)) {
         if (!room->can_view_feature(title)) {
            continue;
         }
         distant = title->query_feature_desc_from(fluff->x, fluff->y, fluff->z);
         if (sizeof(distant)) {
            // Check and see if the distant features are blocked.
            if (sizeof(exit)) {
               foreach (direc, int range in distant) {
                  if (exit[direc] && exit[direc] < range) {
                     map_delete(distant, direc);
                  }
               }
            }
            if (sizeof(distant)) {
               room->add_distant_feature(title, distant);
            }
         }
      }
   }


   calc_random_descs(room, key_here);
   calc_random_chats(room, key_here);

   room->set_extra_long(room_long);

   room->set_installed(1);
   room->calc_exits();
}

/**
 * THis method finds a terrain adjacent to us from this location
 * in the specific direction.
 * @param x the x location
 * @param y the y location
 */
string find_adjacent_terrain(int x, int y)
{
   string index;
   class coord real;

   if (!_real_coords || !_real_coords->in_world_map) {
      return 0;
   }

   index = x + ":" + y;
   if (!undefinedp(_adjacent_terrains[index])) {
      return _adjacent_terrains[index];
   }

   real = query_real_from_terrain_coord(x, y, 0);
//printf("%O, %O) %O\n", x, y, real);
   // Ok, now see whayt we can find on the world map handler.
   _adjacent_terrains[index] = TERRAIN_MAP_WORLD_MAP->find_terrain_at(real->x, real->y);
   return _adjacent_terrains[index];
}

/**
 * This is specifically for debug.  It finds al the adjacent terrains.
 */
void find_all_adjacent_terrains() {
   find_adjacent_terrain(-1,-1);
   find_adjacent_terrain(-1,0);
   find_adjacent_terrain(-1,40);
   find_adjacent_terrain(0,40);
   find_adjacent_terrain(40,40);
   find_adjacent_terrain(40,0);
   find_adjacent_terrain(40,-1);
   find_adjacent_terrain(0,-1);
}

string* debug_adjacent_terrains() {
   return ({ find_adjacent_terrain(-1, 0),
             find_adjacent_terrain(0, -1),
             find_adjacent_terrain(0, _height),
             find_adjacent_terrain(_width, 0) });
}

/**
 * This method find the specific squence of rooms in the given direction
 * with the given room jump.  We do not worry about contents here.  Only if
 * it is a special interest marker or if there are two different ways from
 * the location of the same type.  Items in the map are set as being
 * special interest to stop a jump.
 * @param x the x co-ordinate to start from
 * @param y the y co-ordinate to start from
 * @return the list of rooms
 */
mixed* query_rooms_to(int x, int y, int z, string direc, int len,
                       string main_key, int jump_len, int road_type ) {
   class char_map_data  room_setup;
   class coord real;
   string new_direc;
   string found_direc;
   string terr;
   string bit;
   int num;
   int found;
   int old_x;
   int old_y;
   int new_x;
   int new_y;
   mixed* ret;
   mixed* data;

   ret = ({ ({ }), ({ }) });
   do {
      data = _direcs[direc];
      if (!data) {
         debug_printf("Bad direction %O\n", direc);
         continue;
      }
      old_x = x;
      old_y = y;
      x += data[0];
      y += data[1];
      if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
         terr = find_adjacent_terrain(x, y);
         if (!terr) {
            return ret;
         }
         real = query_real_from_terrain_coord(x, y, 0);
         data = terr->query_more_terrains_rooms_from(real->x, real->y, real->z, direc,
                                 len - num, jump_len,
                                 main_key, road_type);
         if (sizeof(data)) {
            ret[0] += data[0];
            ret[1] += data[1];
         }
         return ret;
      }
      ret[0] += ({ direc });
      bit = sprintf("%d:%d:%d", x, y, z);
      ret[1] += ({ sprintf("%s:%s", base_name(this_object()), bit) });
      // Always stop if there is an exit forced in the room.
      if (_standard_exits[bit]) {
         break;
      }

      if (road_type) {
         // Search around for the next location.
         found = 0;
         foreach (new_direc, data in _direcs) {
            new_x = x + data[0];
            new_y = y + data[1];
            if (new_x != old_x || new_y != old_y) {
               if ((new_x < 0) || (new_x >= _width) || (new_y < 0) || (new_y >= _height)) {
                  terr = find_adjacent_terrain(new_x, new_y);
                  if (terr) {
                     real = query_real_from_terrain_coord(new_x, new_y, z);
                     real = terr->query_terrain_from_real_coord(real->x, real->y, z);
                     room_setup = terr->query_char_map(real->x, real->y);
                  } else {
                     room_setup = 0;
                  }
               } else {
                  room_setup = query_char_map(new_x, new_y);
               }
               if (room_setup && room_setup->room_jump == jump_len) {
//printf("Found! %O %O %O\n", new_direc, room_setup->room_jump, jump_len);
                  found_direc = new_direc;
                  found++;
               }
            }
         }
//printf("(%O, %O) %O %O %O\n", x, y, found, found_direc, jump_len);
         if (found == 1) {
            direc = found_direc;
         } else {
            // dead end or junction.
            break;
         }
      } else {
         room_setup = query_char_map(x + data[0], y + data[1]);
         if (!room_setup || room_setup->char != main_key) {
            break;
         }
      }
   } while (num++ < len);

   return ret;
} /* query_rooms_to() */

/**
 * This method is used by connecting terrains to find the next room in
 * sequence.
 * @param x the real x coordinate
 * @param y the real y coordinate
 * @param moves_left the number of moves left to pop along
 * @param jump the jump length we are looking for
 * @param main_key the key, this is only used for non-road jumps
 * @param road_jump is this a road jump
 */
mixed* query_more_terrains_rooms_from(int x, int y, int z, string direc,
                                       int moves_left, int jump,
                                       string main_key, int road_jump) {
   class coord bing;
   class char_map_data  room_setup;
   int found;
   string found_direc;
   string new_direc;
   mixed* data;
   int new_x;
   int new_y;

//tell_creator("pinkfish", "%O: %O %O %O %O %O\n", base_name(this_object()), x, y, direc, road_jump, main_key);
   bing = query_terrain_from_real_coord(x, y, 0);
   room_setup = query_char_map(bing->x, bing->y);
   if (road_jump) {
      // Is the jump value set correctly here?
      if (room_setup->room_jump != jump) {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
         // Try and find it from here.  We move away from the edge of the
         // terrain and search from there (the room we came from).
         foreach (new_direc, data in _direcs) {
            new_x = bing->x + data[0];
            new_y = bing->y + data[1];
            room_setup = query_char_map(new_x, new_y);
            if (room_setup && room_setup->room_jump == jump) {
               found = 1;
               found_direc = new_direc;
               break;
            }
         }
         if (!found) {
            return ({ });
         }
         direc = found_direc;
      } else {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
      }
      return query_rooms_to(bing->x, bing->y, bing->z, direc, moves_left,
                            main_key, jump, road_jump);
   } else {
      // Find where we are.
      if (room_setup->char == main_key) {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
         return query_rooms_to(bing->x, bing->y, bing->z, direc, moves_left,
                            main_key, jump, road_jump);
      }
      return ({ });
   }
}

/**
 * This method finds the next room in the path.  It returns the next
 * room as the first element in the array and the list of the directions
 * to get there as the second element.
 * @param x the start x position
 * @param y the start y position
 * @param z the start z position
 * @param direc the direction to go from here
 * @return ({ the end location, directions... })
 */
string* find_next_room_from(int x, int y, int z, string direc) {
   class char_map_data  room_setup;
   string test;
   object ob;
   object* obs;
   mixed* stuff;
   int pos;

   //direc = direc[strlen(SKIP_EXIT_PRE)..];

   room_setup = query_char_map(x, y);
   stuff = query_rooms_to(x, y, z, direc, room_setup->room_jump,
                          room_setup->char, room_setup->room_jump,
                          room_setup->room_jump_matching);
   foreach (test in stuff[0]) {
      ob = find_object(test);
      if (ob) {
         obs = filter(all_inventory(ob), (: living($1) :));
         if (sizeof(obs) > 0) {
            return ({ test }) + stuff[0..pos];
         }
      }
      pos++;
   }
   if (sizeof(stuff[1])) {
      return ({ stuff[1][<1] }) + stuff[0];
   }
   return 0;
} /* find_next_room_from() */

// Called by the room-inherit when a room has a zone added. Lets us maintain
// a list of what rooms are in what zones, so we can do snazzy things with them.
/**
* @ignore
*/
void add_room_to_zone(object room, string zone)

{
   object *zones = _room_zones[zone];
   if (!zones)
      zones = ({ room });
   else if (member_array(room, zones) == -1)
      zones += ({ room });

   _room_zones[zone] = zones - ({ 0 });
}


/**
* This method queries the path of a room. If it takes the form:
* '/d/full/path/name.c:x:y' where x and y are integers, it clones
* a new room at the specified coordinates, sets it up fully, and returns it.
* If the room path is of the standard form, it simply returns the loaded
* room.
* @param room_path the full pathname of the room to be cloned.
* @return the cloned/loaded room, or 0 if it could not be cloned/loaded
* @see load_room_at
* @see query_room_at
*/
mixed query_room(int x, int y, int z)

{
   class char_map_data room_map = query_char_map(x, y);
   string base_path;
   object room;
   class coord real;

   base_path = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
   if (!base_path) {
      return 0;
   }

   //
   // Not in the driver mapping, so we must need to create it.
   // We assume the external stuff is doing the correct name stuff.
   //
   room = clone_object(base_path);
   if (!room) {
      debug_printf("Unable to create room from %O at %O %O %O\n", base_path, x, y, z);
   } else {
      room->create_terrain_room();
      room->set_terrain_coords(x, y, z);
      real = query_real_from_terrain_coord(x, y, z);
      room->set_co_ord(({ real->x, real->y, real->z }));
      if (classp(_real_coords)) {
         room->set_room_size(({ _real_coords->xdiff, _real_coords->ydiff, _real_coords->zdiff }));
      }
      room->set_terrain_handler(base_name(this_object()));
      room->terrain_setup();
      room->add_property("base path", base_path);
      _room_map[y][x] = room;
      setup_room(room, base_path);
      if (room_map->type == AREA_WORLD && base_path != room_map->path) {
         // Use this to do any useful special stuff (like river flows).
         room_map->path->setup_in_terrain(room, x, y, z);
      }
   }

   return room;
}


/**
* This method is used to find a room at the specified coordinates,
* if one has already been cloned.
* If a room has been cloned at those coordinates, it is returned,
* @param x the x coordinate of the room (internal coordinate system)
* @param y the y coordinate of the room (internal coordinate system)
* @return the room at those coordinates, or 0 if none has been cloned
* @see load_room_at
* @see query_room
* @see query_rooms_in_block
* @see query_rooms_in_range
*/
object query_room_at(int x, int y, int z)

{
   if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height))
      return 0;

   return find_object(sprintf("%s:%d:%d:%d", base_name(this_object()), x, y, z));
}


/**
* This method is used to find all the rooms currently cloned within a
* specified rectangular area.
* @param x the x coordinate of rectangle's bottom left corner
* @param y the y coordinate of rectangle's bottom left corner
* @param width the width of the rectangle
* @param height the height of the rectangle
* @return an array containing any rooms currently cloned within the
* specified rectangle
* @see query_room_at
* @see query_rooms_in_range
* @see query_rooms_in_zone
*/
object *query_rooms_in_block(int x, int y, int z, int width, int height)

{
   int      h, v;
   mixed    *result = ({ });
   object   room;

   for (h = x; h < (x + width); h++) {
      for (v = y; v < (y + height); v++) {
         room = query_room_at(h, v, z);
         if (room)
            result = result + ({ room });
      }
   }

   return result;
}


/**
* This method is used to find all the rooms currently cloned within a
* specified distance of the specified coordinates.
* @param x the x coordinate of the center point
* @param y the y coordinate of the center point
* @param max the maximum distance of rooms to be returned
* @param min the minimum distance of rooms to be returned. Defaults to 0
* @return an array containing any rooms currently cloned within the
* specified range
* @see query_room_at
* @see query_rooms_in_block
* @see query_rooms_in_zone
*/
varargs object *query_rooms_in_range(int x, int y, int z, int max, int min)

{
   int      h, v;
   mixed    *result = ({ });
   object   room;
   int    dist;

   for (h = x - max; h <= (x + max); h++) {
      for (v = y - max; v <= (y + max); v++) {
        dist = to_int(sqrt(pow(x - h, 2) + pow(y - v, 2)) + 0.4999);
     //   tell_creator("dek", "Coords: (%d, %d), Range: %d, Dist: %d\n", h, v, max, dist);
        if ((dist > max) || (dist < min))
           continue;
         room = query_room_at(h, v, z);
         if (room)
            result = result + ({ room });
      }
   }

   return result;
}


/**
* This method is used to find a room at the specified coordinates,
* or to clone and setup a new one if none exists so far.
* @param x the x coordinate of the room (internal coordinate system)
* @param y the y coordinate of the room (internal coordinate system)
* @return the room at those coordinates, or 0 if none can be cloned
* @see load_room_at
* @see query_room
*/
object load_room_at(int x, int y, int z)

{
   class char_map_data room_map = query_char_map(x, y);

   if (!room_map) {
      debug_printf("Unable to load room at %d %d\n", x, y);
      return 0;
   }

   if (room_map->type == AREA_OBSTACLE) {
      return 0;
   }

   return load_object(sprintf("%s:%d:%d:%d", base_name(this_object()), x, y, z));
}


// Given coordinates, get the mapping which controls what goes in the room.
/**
* @ignore
*/
class char_map_data query_char_map(int x, int y)
{
   string   type;
   class char_map_data  room_map;

   if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
      return 0;
   }

   if (x >= sizeof(_area_map[y])) {
      debug_printf("The x value is out of range: %d > %d", x, sizeof(_area_map[y]));
      return 0;
   }

   type = _area_map[y][x..x];

   room_map = copy(_char_map[type]);

   if (!room_map) {
      debug_printf("There is no char type for '%s'", type);
      return 0;
   }

   room_map->char = type;
   return room_map;
}

/**
 * This method returns a grid of the specified size around the center
 * point to give creators an overview of where they are currently.
 * @param x the x co-ordinate
 * @param y the y co-ordinate
 * @param width the width of the box
 */
string query_debug_map(int x, int y, int width, int showx, int showy) {
   int i;
   int j;
   int sx;
   int sy;
   int ny;
   string ret;
   string base;
   string new_base;
   string colour;

   ret = "";
   sx = x - width / 2;
   sy = y + width / 2;
   for (j = 0; j < width; j++) {
      if (sy - j >= 0 && sy - j < _height) {
         for (i = 0; i < width; i++) {
            if (sx + i >= 0 && sx + i < _width) {
               if (sx +i == showx && sy - j == showy) {
                  ret += "%^YELLOW%^" + _area_map[sy - j][sx + i..sx + i] +
                         "%^RESET%^";
                  colour = 0;
               } else {
                  if (colour) {
                     ret += "%^RESET%^";
                     colour = 0;
                  }
                  ret += _area_map[sy - j][sx + i..sx + i];
               }
            } else {
               // Need to get the character from a nearby terrain instead.
               if (sx + i >= _width) {
                  base = find_adjacent_terrain(_width + 1, sy - j);
               } else {
                  base = find_adjacent_terrain(-1, sy - j);
               }
//printf("Base %O (%d,%d)\n", base, sx + i, sy - j);
               if (base) {
                  //ret += "-";
                  if (colour != "%^CYAN%^") {
                     ret += "%^BOLD%^%^CYAN%^";
                     colour = "%^CYAN%^";
                  }
                  if (sx + i >= _width) {
                     //ret += "-" + (sx + i - _width) + "-";
                     // Assume same size.
                     ret += base->query_debug_map_char(sx + i - _width, sy - j);
                  } else {
                     //ret += "-" + (sx + i + _width) + "-";
                     ret += base->query_debug_map_char(sx + i + _width, sy - j);
                  }
               } else {
                  ret += " ";
               }
            }
         }
         if (colour) {
            ret += "%^RESET%^";
            colour = 0;
         }
         ret += "\n";
      } else {
         // Need to get the character from a nearby terrain instead.
         base = find_adjacent_terrain(sx + i, sy - j);
         if (base) {
            if (sy - j < 0) {
               ny = sy - j + _height;
            } else {
               ny = sy - j - _height;
            }
            for (i = 0; i < width; i++) {
               if (sx + i >= 0 && sx + i < _width) {
                  if (colour != "%^MAGENTA%^") {
                     ret += "%^BOLD%^%^MAGENTA%^";
                     colour = "%^MAGENTA%^";
                  }
                  ret += base->query_debug_map_char(sx + i, ny);
               } else {
                  new_base = find_adjacent_terrain(sx + i, sy - j);
                  if (new_base) {
                     if (colour != "%^RED%^") {
                        ret += "%^BOLD%^%^RED%^";
                        colour = "%^RED%^";
                     }
                     if (sx + i >= _width) {
                        // Assume same size.
                        ret += new_base->query_debug_map_char(sx + i - _width, ny);
                     } else {
                        ret += new_base->query_debug_map_char(sx + i + _width, ny);
                     }
                  } else {
                     ret += " ";
                  }
               }
            }
            ret += "%^RESET%^\n";
            colour = 0;
         }
      }
   }
   return ret;
}

/**
 * This method returns the specific debug map character at the
 * given location.
 * @param x the x location
 * @param y the y location
 * @return the map character
 */
string query_debug_map_char(int x, int y) {
   return _area_map[y][x..x];
}

/**
 * This method returns a grid of the specified size around the center
 * point to give creators an overview of where they are currently.
 * @param x the x co-ordinate
 * @param y the y co-ordinate
 * @param width the width of the box
 */
string query_debug_map_feature(string name) {
   int x;
   int y;
   class feature_data feature;
   mixed data;
   string ret;
   int colour;
   int found;
   //string direc;
   //int distance;

   feature = _features[name];
   ret = "";
   colour = 0;
   for (y = _height - 1; y >= 0; y--) {
      for (x = 0; x < _width; x++) {
         data = feature->feature_ob->query_feature_desc_from(x, y, 0, 1);
         found = sizeof(data);
         if (found) {
            if (!colour) {
               ret += "%^YELLOW%^";
               colour = 1;
            }
         } else {
            if (colour) {
               ret += "%^RESET%^";
               colour = 0;
            }
         }
         ret += _area_map[y][x..x];
      }
      ret += "%^RESET%^\n";
      colour = 0;
   }
   return ret;
}

/**
 * This method returns a grid of the specified size around the center
 * point to give creators an overview of where they are currently.
 * @param x the x co-ordinate
 * @param y the y co-ordinate
 * @param width the width of the box
 */
string query_debug_map_feature_distant(string feature) {
   int x;
   int y;
   mixed data;
   string ret;
   int colour;
   class coord fluff;

   ret = "";
   colour = 0;
   for (y = _height - 1; y >= 0; y--) {
      for (x = 0; x < _width; x++) {
         fluff = query_real_from_terrain_coord(x, y, 0);
         data = feature->query_feature_desc_from(fluff->x, fluff->y, fluff->z);
         if (data && sizeof(data)) {
            if (!colour) {
               ret += "%^YELLOW%^";
               colour = 1;
            }
         } else {
            if (colour) {
               ret += "%^RESET%^";
               colour = 0;
            }
         }
         ret += _area_map[y][x..x];
      }
      ret += "%^RESET%^\n";
      colour = 0;
   }
   return ret;
}

/**
 * This adds the new string to the key.
 */
private void add_key(mapping key, string char, string str) {
  if(strsrch(str, "intersection") != -1)
    return;
  
  if(!key[char])
    key[char] = str;
  else if(strsrch(key[char], str) == -1 ) {
    key[char] += ", " + str;
  }
}

/**
 * This updates the map and makes the data.
 */
private int update_map(mapping data, mixed* map, mapping key, mixed *colours,
                       int x, int y, int z, int offx, int offy) {
   class char_map_data info;
   string char, colour, tmp;
   string room;
   int block;
   object ob;
   
   if (x < 0) {
      if (y < 0) {
         data["-y-x"] = 1;
      } else if (y >= _height) {
         data["+y-x"] = 1;
      } else {
         data["-x"] = 1;
      }
      return 0;
   } else if (x >= _width) {
      if (y < 0) {
         data["-y+x"] = 1;
      } else if (y >= _height) {
         data["+y+x"] = 1;
      } else {
         data["+x"] = 1;
      }
      return 0;
   } else if (y < 0) {
      data["-y"] = 1;
      return 0;
   } else if (y >= _height) {
      data["+y"] = 1;
      return 0;
   }

   info = query_char_map(x, y);
   if (!info) {
      return 1;
   }
   if (info->type == AREA_OBSTACLE) {
      map[y - offy][x - offx] = info->char;
      colours[y - offy][x - offx] = info->colour;
      if(!info->colour) {
        colours[y - offy][x - offx] = "%^BLUE%^";
      }
      if (info->room_desc == "Obstacle" && stringp(info->items)) {
        add_key(key, info->char, info->items);
      } else if (info->room_desc != "") {
        add_key(key, info->char, info->room_desc);
      } else {
         map[y - offy][x - offx] = " ";
      }
      data["block" + info->char] = 1;
      return 1;
   } else {
      char = data[info->char];
      colour = data[info->colour];
      if (!char || !colour) {
         room = query_base_room(x, y, z, TERRAIN_MAP_ROOM_MAP);
         if (room) {
            ob = load_object(room);
            if (ob) {
               char = ob->query_terrain_map_character();
               colour = ob->query_terrain_map_colour();
               block = ob->query_terrain_map_block();

               if(char && ob) {
                  tmp = ob->query_key_desc();
                  if(!tmp) {
                     tmp = ob->query_short();
                  }
                  if(!tmp) {
                     debug_printf("Room %s has no short.", base_name(ob));
                  } else {
                     add_key(key, char, tmp);
                  }
               }

               if (block || info->height > z) {
                  data["block" + info->char] = 1;
               }
            } else {
               debug_printf("Unable to find %O\n", room);
            }
         }
         if (!char) {
            char = info->char;
         }
         if(!colour) {
            colour = info->colour;
         }

         data[info->char] = char;
      }
      map[y - offy][x - offx] = char;
      colours[y - offy][x - offx] = colour;
   }
   if(char && !key[char] && !data["nokey"+info->char]) {
      data["nokey" + info->char] = 1;
      debug_printf("No key for %s", char);
   }
   return data["block" + info->char];
}

/**
 * This method fills in the line with stuff if it is needed.
 * @param map the map to fill in
 * @param sx the startx
 * @param sy the starty
 * @param width the width of the map
 */
private string line_in_map(mapping data, mixed* map, mapping key,
                           mixed *colours, int offx, int offy,
                           int sx, int sy, int ex, int ey, int z) {
   int x;
   int y;
   int dx;
   int dy;
   int incx;
   int incy;
   int balance;

   if (ex >= sx) {
      dx = ex - sx;
      incx = 1;
   } else {
      dx = sx - ex;
      incx = -1;
   }

   if (ey >= sy) {
      dy = ey - sy;
      incy = 1;
   } else {
      dy = sy - ey;
      incy = -1;
   }

   x = sx;
   y = sy;
   if (dx >= dy) {
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      while (x != ex) {
         if (update_map(data, map, key, colours, x, y, z, offx, offy)) {
            break;
         }
         if (balance >= 0) {
            y += incy;
            balance -= dx;
         }
         balance += dy;
         x += incx;
      }
   } else {
      dx <<= 1;
      balance = dx - dy;
      dy <<= 1;
      while (y != ey) {
         if (update_map(data, map, key, colours, x, y, z, offx, offy)) {
            break;
         }
         if (balance >= 0) {
            x += incx;
            balance -= dy;
         }
         balance += dx;
         y += incy;
      }
   }
   // Last pixel...
   update_map(data, map, key, colours, x, y, z, offx, offy);
}

/**
 * Updates the blocking structures.
 */
private void update_blocking(mapping data,
                             mixed* map, mixed* colours, int x, int y,
                             int distance) {
   int dx;
   int dy;
   int adx;
   int ady;
   int dist;
   int nx;
   int ny;
   int tx;
   int ty;
   int incx;
   int incy;
   string* template;
   string str;

   dx = (x - distance);
   dy = (y - distance);

   //str = sprintf("%d", x % 10);
   str = " ";
   if (dx < 0) {
      adx = - dx;
      incx = -1;
   } else {
      adx = dx;
      incx = 1;
   }
   if (dy < 0) {
      ady = - dy;
      incy = -1;
   } else {
      ady = dy;
      incy = 1;
   }

   if (incx != incy) {
      incx = -incx;
      incy = - incy;
   }

   if (adx > ady) {
      template = TERRAIN_MAP_WORLD_MAP->query_blocking_template(ady, adx, 0);
   } else {
      template = TERRAIN_MAP_WORLD_MAP->query_blocking_template(adx, ady, 0);
   }
   // Error.
   if (!template) {
      debug_printf("Error with the template");
      return ;
   }
   dist = distance + 1;
   for (tx = 0; tx < dist; tx++) {
      for (ty = 0; ty < dist; ty++) {
         if (template[tx][ty] == '*') {
            // Zap the structures.
            if (adx > ady) {
               nx = distance + tx * incx;
               ny = distance + ty * incy;
            } else {
               nx = distance + ty * incx;
               ny = distance + tx * incy;
            }
            if (nx < sizeof(map) && ny < sizeof(map[nx]) &&
                nx >= 0 && ny >= 0) {
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            }
            if (adx == ady) {
               nx = distance + tx * incx;
               ny = distance + ty * incy;
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            } else if (adx == 0) {
               nx = distance + ty * incx;
               ny = distance - tx * incy;
               map[nx][ny] = str;
            } else if (ady == 0) {
               nx = distance - tx * incx;
               ny = distance + ty * incy;
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            }
         }
      }
   }
}

/**
 * This method does the updating of the map based on the template.
 * Pretty easy really, check each location in the map to see if it
 * exists and what we should do with it.
 */
mapping query_player_map_internal_template(mixed* map, mapping key,
                                  mixed *colours, int x_c, int y_c, int z_c,
                                  int distance) {
   int offx;
   int offy;
   int x;
   int y;
   mapping data;


   data = ([ ]);
   offx = x_c - distance;
   offy = y_c - distance;
   // Go from the top corner to the bottom corner.
   for (x = 0; x < sizeof(map); x++) {
      for (y = 0; y < sizeof(map[x]); y++) {
         if (map[y][x] == 1) {
            // Update it.
            if (update_map(data, map, key, colours, x + offx, y + offy, z_c, offx, offy)) {
               // Need to update the blocking.
               // Check for diagonals and blocking.
               if (x > 0) {
                  if (y > 0 && data["block" + map[y-1][x-1]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x, y-1, distance);
                     //map[y-1][x] = "#";
                  } else if (y < sizeof(map) - 1 && data["block" + map[y+1][x-1]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x, y + 1, distance);
                     //map[y+1][x] = "#";
                  } else if (y > 0 && data["block" + map[y-1][x]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x - 1, y - 1, distance);
                  } else {
                     update_blocking(data, map, colours, x, y, distance);
                  }
               } else {
                  update_blocking(data, map, colours, x, y, distance);
               }
            }
         }
      }
   }
   return data;
}

/**
 * This method generates a player map using templates instead of using
 * lines from the center point.  This is more efficent than a
 * line drawing method.  THe max_size is used to
 * make sure the size of the visible area is squashed, if we want a
 * smaller partial map for other displays.  The max size must be
 * an odd number.
 */
string query_player_map_template(int x_c, int y_c, int z_c, int visibility,
             int max_size) {
   string ret, item, base, current, *keys;
   mixed *map, *colours;
   mapping data, key;
   int i, j;
   int distance;
   //class char_map_data tmp;

   distance = _visible_distance * visibility / 100;
   if (!distance) {
      distance = 1;
   }
   data = ([ ]);
   key = ([ ]);
   map = ({ });
   colours = ({ });
   // Returns a template for the given visiblity distance.
   map = TERRAIN_MAP_WORLD_MAP->query_map_template(distance);
   colours = TERRAIN_MAP_WORLD_MAP->query_map_template(distance);

   // Slice the map down to size.
   if (max_size && (max_size % 2) != 1) {
      max_size--;
   }
   if (max_size && sizeof(map) > max_size) {
      j = (max_size - 1) / 2;
      map = map[distance - j..distance + j];
      colours = colours[distance - j..distance + j];
      for (i = 0; i < sizeof(map); i++) {
         map[i] = map[i][distance - j..distance + j];
         colours[i] = colours[i][distance - j..distance + j];
      }
      // Need to mess with x_c and y_c
      x_c += (distance - j);
      y_c += (distance - j);
   }

   data = query_player_map_internal_template(map, key, colours, x_c, y_c, z_c,
                                    distance);
   if (data["-y"]) {
     base = find_adjacent_terrain(x_c, -1);
     if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c,
                                            y_c + _height, z_c, distance);
         }
      }
   }
   if (data["+y"]) {
      base = find_adjacent_terrain(x_c, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c,
                                            y_c - _height, z_c, distance);
         }
      }
   }
   if (data["-x"]) {
      base = find_adjacent_terrain(-1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["+x"]) {
      base = find_adjacent_terrain(_width + 1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["-y+x"]) {
      base = find_adjacent_terrain(_width + 1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y+x"]) {
      base = find_adjacent_terrain(_width + 1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y-x"]) {
      base = find_adjacent_terrain(-1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["-y-x"]) {
      base = find_adjacent_terrain(-1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   
   map[sizeof(map) / 2][sizeof(map) / 2] = "@";

   if(!this_player()->query_property(PLAYER_PLAIN_MAPS)) {
     colours[sizeof(map) / 2][sizeof(map) / 2] = "%^YELLOW%^";
     for(i=0; i<sizeof(map); i++) {
       current = "";
       for(j=0; j<sizeof(map); j++) {
         if(map[i][j] == "\r" || !stringp(map[i][j])) {
           map[i][j] = " ";
         }
         
         if (!current || current == " ") {
           current = "";
         }
         if(!colours[i][j] || colours[i][j] == " ") {
           colours[i][j] = "";
         }
         
         if(colours[i][j] != current) {
           if (colours[i][j] == "" || !stringp(colours[i][j])) {
             if(current != "" && current != " ") {
               map[i][j] = "%^RESET%^" + map[i][j];
               current = "";
             }
           } else if (colours[i][j] != "\r") {
             map[i][j] = colours[i][j] + map[i][j];
             current = colours[i][j];
           }
         }
         //map[i][j] = "[" + map[i][j] + "]";
         if(i == x_c && j == y_c && current != "") {
           map[i][j] += current;
         }
       }
       if(current) {
         map[i][j-1] += "%^RESET%^";
       }
     }
   }

   //ret = replace(ret, "%^", "");
   if(_key && !max_size) {
     keys = ({ });
     foreach(item in keys(key)) {
       keys += map(explode(sprintf("%s %-=40s", item, key[item]), "\n"),
                   (: "     " + $1 :));
     }
   }
   
   ret = "";
   for(i = sizeof(map) - 1; i >= 0; i--) {
     ret += implode(map(map[i], (: stringp($1) ? $1 : " " :)), "");
     if(!max_size && sizeof(map)-2-i>= 0 && sizeof(map)-2-i < sizeof(keys)) {
       ret += keys[sizeof(map)-2-i];
     }
     ret += "\n";
   }
   
   return ret;
}

/**
 * This updates the player map based on the input.
 * @ignore yes
 */
mapping query_player_map_internal(mixed* map, mapping key, mixed *colours,
                                  int x_c, int y_c, int z_c, int distance) {
   int x, y, e, u, v;
   int endx, endy, offx, offy;
   mapping data;

   data = ([ ]);

   offx = x_c - distance;
   offy = y_c - distance;
   x = 0;
   y = distance;
   u = 1;
   v = 2 * distance - 1;
   e = 0;

   while (x < y) {
      // point 1.
      endx = x_c + x;
      endy = y_c + y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      // point 2.
      endx = x_c + y;
      endy = y_c - x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      // point 3.
      endx = x_c - x;
      endy = y_c - y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      // point 4.
      endx = x_c - y;
      endy = y_c + x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      x++;
      e += u;
      u += 2;
      if (v < 2 * e) {
         y--;
         e -= v;
         v -= 2;
      }
      if (x > y) {
         break;
      }
      // point 5.
      endx = x_c + y;
      endy = y_c + x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      // point 6.
      endx = x_c + x;
      endy = y_c - y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      // point 7.
      endx = x_c - y;
      endy = y_c - x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      // point 8.
      endx = x_c - x;
      endy = y_c + y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
   }

   // The algorithm for a circle misses a few so we'll fill them in here.
   // The "gap" rooms always have filled-in locations on either side so
   // test for that condition and fill-in as necessary.
   for(y=0; y<sizeof(map); y++)
     for(x=1; x<sizeof(map[y])-1; x++)
       if(map[y][x] == "\r" && map[y][x-1] != "\r" && map[y][x+1] != "\r") {
         update_map(data, map, key, colours, x + offx, y + offy, z_c, offx,
                    offy);
       }

   return data;
}

/**
 * This method returns the player line of sight view of the current terrain.
 * It depends on height and other wonderful things.
 * @param x_c the x center point
 * @param y_c the y center point
 * @param z_c the z center point
 * @param visibility the visibility percentage currently
 */
string query_player_map(int x_c, int y_c, int z_c, int visibility) {
   string ret, item, base, current, *keys;
   mixed *map, *colours;
   mapping data, key, colour_key;
   int i, j;
   int distance;
   //class char_map_data tmp;

   distance = _visible_distance * visibility / 100;
   if (!distance) {
      distance = 1;
   }
   data = ([ ]);
   key = ([ ]);
   map = ({ });
   colours = ({ });
   for (i = 0; i < distance * 2 + 1; i++) {
      map += ({ allocate(distance * 2 + 1, "\r") });
      colours += ({ allocate(distance * 2 + 1, "\r") });
      
   }

   data = query_player_map_internal(map, key, colours, x_c, y_c, z_c,
                                    distance);
   if (data["-y"]) {
     base = find_adjacent_terrain(x_c, -1);
     if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c,
                                            y_c + _height, z_c, distance);
         }
      }
   }
   if (data["+y"]) {
      base = find_adjacent_terrain(x_c, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c,
                                            y_c - _height, z_c, distance);
         }
      }
   }
   if (data["-x"]) {
      base = find_adjacent_terrain(-1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["+x"]) {
      base = find_adjacent_terrain(_width + 1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["-y+x"]) {
      base = find_adjacent_terrain(_width + 1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y+x"]) {
      base = find_adjacent_terrain(_width + 1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y-x"]) {
      base = find_adjacent_terrain(-1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["-y-x"]) {
      base = find_adjacent_terrain(-1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   
   y_c -= y_c - distance;
   x_c -= x_c - distance;

   if(!this_player()->query_property(PLAYER_PLAIN_MAPS)) {
     colour_key = ([ ]);
     map[y_c][x_c] = "%^YELLOW%^@%^RESET%^";

     // This is going to go through the 2d map array and put in colour and
     // reset codes as necessary.
     for(i=0; i<sizeof(map); i++) {
       current = "";
       for(j=0; j<sizeof(map); j++) {
         if(map[i][j] == "\r")
           map[i][j] = " ";
         
         if(!current || current == " ") current = "";
         if(!colours[i][j] || colours[i][j] == " ") colours[i][j] = "";

         // Make a colour coded map.
         if(key[map[i][j]])
           colour_key[colours[i][j] + map[i][j] + "%^RESET%^"] =
             key[map[i][j]]; 

         if(colours[i][j] != current) {
           if(colours[i][j] == "") {
             if(current != "" && current != " ") {
               map[i][j] = "%^RESET%^" + map[i][j];
               current = "";
             }
           } else if(colours[i][j] != "\r") {
             map[i][j] = colours[i][j] + map[i][j];
             current = colours[i][j];
           }
         }
         
         //map[i][j] = "[" + map[i][j] + "]";
         if(i == x_c && j == y_c && current != "")
           map[i][j] += current;
       }
       if(current)
         map[i][j-1] += "%^RESET%^";
     }
   } else {
     map[y_c][x_c] = "@";
     colour_key = key;
   }
   
   if(_key) {
     keys = ({ });
     foreach(item in keys(colour_key)) {
       keys += map(explode(sprintf("%s %-=40s", item, colour_key[item]), "\n"),
                           (: "     " + $1 :));
     }
   }

   ret = "";
   for(i = sizeof(map) - 1; i >= 0; i--) {
     ret += implode(map[i], "");
     if(sizeof(map)-2-i>= 0 && sizeof(map)-2-i < sizeof(keys))
       ret += keys[sizeof(map)-2-i];
     ret += "\n";
   }

   // This is normally done in the colour section.
   if(this_player()->query_property(PLAYER_PLAIN_MAPS))
     ret = replace_string(ret, "\r", " ");
   
   return ret;
}

/**
 * This is used by the terrain system to work out what is beside
 * us.
 * @param x the x position
 * @param y the y position
 */
class char_map_data query_char_map_real_coord(int x, int y)
{
   class coord our;

   our = query_terrain_from_real_coord(x, y, 0);
   return query_char_map(our->x, our->y);
}

/**
* This method is used to find all rooms currently loaded within the
* specified room zone.
* @param zone the name of the room zone
* @return an array containing all the currently cloned rooms within this zone
* @see query_rooms_in_block
* @see query_rooms_in_range
*/
object *query_rooms_in_zone(string zone)

{
   if (_room_zones[zone]) {
      _room_zones[zone] -= ({ 0 });
      return _room_zones[zone];
   }
   return ({ });
}


/**
* This method displays a message in all the currently loaded rooms
* within the specified zone(s).
* @param zones a zone name as a string, or an array of zone names
* @param message the message to be displayed
* @param mess_class the message type. Normally this need not be specified
* @see query_rooms_in_zone
* @see tell_feature
*/
varargs void tell_zones(mixed zones, string message, mixed mess_class)

{
   object  *rooms = ({ });
   string  zone;

   if (!mess_class)
      mess_class = "zone_shout";

   if (stringp(zones))
      zones = ({ zones });

   foreach (zone in zones)
      rooms += query_rooms_in_zone(zone);

   if (sizeof(rooms))
      message(mess_class, message, rooms);
}


/**
* This message displays messages in all rooms within range of a feature.
* The message can be either a string, which goes to all the rooms, or an
* array of strings, in which case they get spread across the distances (in
* which case you should supply the same number of array elements as in the
* descriptions in the original add_feature. Any occurences of $D in the
* message(s) will be replaced in each room with the direction that the
* feature lies in.
* @param title the name of the feature, as used in add_feature
* @param message the message to be displayed
* @see tell_rooms_in_zone
* @see add_feature
* @see modify_feature
* @see set_feature_chats
*/
varargs void tell_feature(string title, mixed message)

{
   int     index;
   string  mess_class = sprintf("feature:%s", title);

   if (!_feature_rooms[title]) {
      return;
   }

   _feature_rooms[title] -= ({ 0 });
   if (!sizeof(_feature_rooms[title])) {
      return;
   }

   if (stringp(message)) {
      message(mess_class, message, _feature_rooms[title]);
   }

   if (arrayp(message)) {
      for (index = 0; index < sizeof(message); index++) {
         message(sprintf("%s:%d", mess_class, index), message[index],
         _feature_rooms[title]);
      }
   }
}


// Called by rooms to get the feature description that applies to them.
// It'll do direction substitution if it's supplied with a direc to subs.
/**
* @ignore
*/
varargs string* query_distant_feature_desc(string title, mapping direcs,
                                           int visibility) {
   int       night = (WEATHER->query_tod() == "night");
   string str;

   str = title->calc_feature_desc(direcs, night, visibility);
   if (str) {
      return ({ str });
   }
   return ({ });
}


// Called by rooms to get the item desc of a feature.
// It'll do direction substitution if it's supplied with a direc to subs.
/**
* @ignore
*/
varargs string* query_feature_desc(string title, mapping direcs,
                                   int visibility) {
   class feature_data   feature;
   string*   item_desc;
   string*   dirs;
   int       night = (WEATHER->query_tod() == "night");
   string    direc;
   int       range;
   mapping   bits;
   int       index;
   string    str;
   int       new_range;

   if (!feature) {
      feature = _features[title];
   }

   if (!feature) {
      return ({ });
   }

   if( visibility == 0 ) {
      return ({ });
   }

   if (!sizeof(feature->descs)) {
      str = feature->feature_ob->calc_feature_desc(direcs, night,
                                                       visibility);
      if (str) {
         return ({ str });
      }
      return ({ });
   }

   bits = ([ ]);
   foreach (direc, range in direcs) {
      if (night) {
         item_desc = feature->night_descs;
      } else {
         item_desc = feature->descs;
      }
      if (!item_desc) {
         debug_printf("Bad night description for %O", title);
         continue;
      }
      new_range = range * 100 / visibility;
      // Make sure the modified range is less the visibility
      if (feature->range > new_range && sizeof(item_desc)) {
         index = sizeof(item_desc) * new_range / feature->range;
         str = item_desc[index];
         if (str && str != "") {
            if (!bits[str]) {
               bits[str] = ({ });
            }
            bits[str] += ({ direc });
         }
      }
   }

   item_desc = ({ });
   foreach (str, dirs in bits) {
      item_desc += ({ replace_string(str, "$D", query_multiple_short(dirs)) });
   }

   return item_desc;
}

/**
 * This method returns the item description.
 * @param title the title of the feature
 * @return the feature item description
 */
varargs string query_feature_item_desc(string title) {
   class feature_data   feature;
   mixed   item_desc;
   int       night = (WEATHER->query_tod() == "night");

   if (!feature) {
      feature = _features[title];
   }

   if (!feature) {
      return "";
   }

   if (night) {
      item_desc = feature->f_item_night_desc;
   } else {
      item_desc = feature->f_item_desc;
   }

   if (!pointerp(item_desc)) {
      return item_desc;
   }
   return item_desc[0];
}


// Called by rooms when chatting, to get feature chats.
/**
* @ignore
*/
varargs string get_a_feature_chat(string title, int range, string direc)

{
   class feature_data   feature;
   mixed     chat;
   int       night = (WEATHER->query_tod() == "night");

   if (!feature) {
      feature = _features[title];
   }

   if (!feature) {
      return "";
   }

   if (night) {
      chat = feature->night_chats;
   } else {
      chat = feature->chats;
   }

   if (!chat) {
      return "";
   }

   if (arrayp(chat)) {
      chat = chat[random(sizeof(chat))];
   }

   if (arrayp(chat)) { // ranged chat
      if ((range < 0) || (range >= sizeof(chat))) {
         return "";
      }
      chat = chat[range];
   }
   if (!stringp(chat)) {// Something's wrong.
      return "";
   }

   if (direc) {
      chat = replace(chat, ({ "$D", direc }));
   }

   return chat;
}




// Called by rooms when chatting, to get outside chats.
/**
* @ignore
*/
string get_an_outside_chat(string types)

{
   class char_map_data   item;
   string    *chats = ({ });
   int       index;
   mixed     *item_chats;

   for (index = 0; index < sizeof(types); index++) {
      item = _char_map[types[index..index]];
      if (!item) {
         continue;
      }

      item_chats = item->chats;
      if (!item_chats) {
         continue;
      }

      if (stringp(item_chats))
         chats += ({ item_chats });
      else if (arrayp(item_chats))
         chats += item_chats;
   }
   if (!sizeof(chats))
      return "";

   return chats[random(sizeof(chats))];
}


/**
* This method is used to add an 'obstacle' to an area map. An obstacle is
* effectively an area on the map which cannot be entered, and can be seen
* from adjacent locations. Any occurences of $D in the description will
* be replaced with the direction(s) in which the obstacle can be seen.
* An add_item is automatically performed to allow for consistency.
* @param type the ASCII type used on the map to denote the obstacle
* @param description the description of the obstacle, as seen from
* neighbouring rooms
* @param items a string, or array of strings giving the corresponding
* add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding item desc
* @param room_desc allows a description for the obstacle in the key
* @example
*   add_obstacle("*", "Thick green bushes block your way to the $D.",
                      ({ "bush", "bushes" }), "Thick and green.", "Thick bushes");
* @see add_room_type
* @see add_road_type
* @see set_external_chats
* @see add_item
*/
varargs void add_obstacle_type(string type, string description, mixed items, mixed item_desc, string room_desc)

{
   if (!type) {
      throw("Bad type");
   }
   if (!items) {
      items = ({ });
      item_desc = ({ });
   }
   if (!room_desc) {
      room_desc = "Obstacle";
   }
   _char_map[type] = new(class char_map_data,
                         type: AREA_OBSTACLE, adjacent_desc:description,
                         room_desc : room_desc,
                         items:items, item_desc:item_desc);
}


/**
* This method is used to add a standard skip room type to the terrain map.
* Mapped to an ASCII character as used in the ASCII room map.  A skipped
* room is one in which every nth room in the terrain will be skipped
* unless it has something interesting in it.  The height is used to
* do specific sorts of checks, like if a specific direction is passable or not.
* @param type the ASCII type used on the map to denote the room
* @param base_path the full pathname of the source file for the room
* @param size the number of rooms in each clump to skip over
* @param road_skip if this is 1 then the skip type is a 'road skip', this
* will assume the path is one wide and try to follow around curves
* @param height the height of the room
* @param height_rooms is a mapping containing what rooms to use at different height levels
* @example
*    add_room_type(".", ROOMS + "field");
* @see add_room_type
* @see add_road_type
* @see add_obstacle_type
*/
void add_special_type(string type, string base_path, int size, int road_skip, int height,
                      mapping height_rooms)

{
   _char_map[type] = new(class char_map_data,
                         type: AREA_ROOM, path:base_path,
                         room_jump : size,
                         room_jump_matching : road_skip,
                         height : height,
                         height_rooms : height_rooms);
}

/**
* This method is used to add a standard room type to the terrain map,
* mapped to an ASCII character as used in the ASCII room map.
* @param type the ASCII type used on the map to denote the room
* @param base_path the full pathname of the source file for the room
* @example
*    add_room_type(".", ROOMS + "field");
* @see add_room_type
* @see add_road_type
* @see add_obstacle_type
*/
void add_room_type(string type, string base_path)

{
   _char_map[type] = new(class char_map_data,
                         type: AREA_ROOM, path:base_path);
}


/**
* This method is used to add a standard road type to the terrain map,
* mapped to an ASCII character as used in the ASCII room map.
* A road is a terrain map room which can be seen from adjacent locations.
* The handler uses 'room_desc' to add an entry to the room description,
* describing where the road goes. 'description' is added to the
* descriptions of adjacent locations, to enable the road to be seen.
* In 'room_desc' and 'description', $D will be expanded to the relevant
* directions.
* @param type the ASCII type used on the map to denote the room
* @param base_path the full pathname of the source file for the room
* @param room_desc the 'continuation' description, which added to the room description to show where the road leads
* @param description the 'adjacent' description, which is seen from adjacent locations.
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding item desc
* @example
*    add_road_type("+", ROOMS + "path", "The dusty path leads $D.",
*                  "There is a dusty path to the $D.",
*                  "path", "Hey! Look! A path!");
* @see add_room_type
* @see add_road_type
* @see set_external_chats
* @see add_item
*/
varargs void add_road_type(string type, string base_path, string room_desc,
              string description, mixed items, mixed item_desc)

{
   _char_map[type] = new(class char_map_data,
                        type: AREA_ROAD, adjacent_desc:description,
                        items:items, item_desc:item_desc,
                        room_desc:room_desc, path:base_path);
}

/**
* This method is used to add a world map based file into the terrain.
* It handles all the options like a special road type, but queries all the
* details off the base room instead.
* @param type the ASCII type used on the map to denote the room
* @param base_path the full pathname of the source file for the room
* @example
*    add_world_room_type("+", ROOMS + "path", "The dusty path leads $D.",
*                  "There is a dusty path to the $D.",
*                  "path", "Hey! Look! A path!");
* @see add_room_type
* @see add_road_type
* @see set_external_chats
* @see add_item
*/
varargs void add_world_room_type(string type, string base_path) {
   mapping bits;
   string *tmp;

   // If the world type doesn't exist see if we can find a more
   // generic version instead.
   if(file_size(base_path + ".c") == -1) {
     tmp = explode(base_path, "_edge");
     if(sizeof(tmp) && file_size(tmp[0] + ".c") > 0) {
       debug_printf("%s doesn't exist, using %s",
                    base_path, tmp[0]);
       base_path = tmp[0];
     }
   }     
   
   if (file_size(base_path + ".c") > 0) {
      bits = base_path->query_adjacent_items();
      if (!mapp(bits)) {
         debug_printf("Incorrect room type %O", type);
      } else {
         _char_map[type] = new(class char_map_data,
                        type: AREA_WORLD,
                        path: base_path,
                        adjacent_desc:base_path->query_adjacent_description(),
                        items:keys(bits),
                        item_desc:values(bits),
                        //room_desc:room_desc,
                         room_jump : base_path->query_room_jump_size(),
                         height : base_path->query_default_height(),
                         room_jump_matching : base_path->query_follow_road());
      }
   } else {
      debug_printf("Unable to add %O since %O doesn't exist.", type, base_path);
   }
}

/**
* This method is used to add a standard road type to the terrain map,
* mapped to an ASCII character as used in the ASCII room map.
* A road is a terrain map room which can be seen from adjacent locations.
* The handler uses 'room_desc' to add an entry to the room description,
* describing where the road goes. 'description' is added to the
* descriptions of adjacent locations, to enable the road to be seen.
* In 'room_desc' and 'description', $D will be expanded to the relevant
* directions.
* A skipped
* room is one in which every nth room in the terrain will be skipped
* unless it has something interesting in it.
* @param type the ASCII type used on the map to denote the room
* @param base_path the full pathname of the source file for the room
* @param size the number of rooms in each clump to skip over
* @param road_skip if this is 1 then the skip type is a 'road skip', this
* will assume the path is one wide and try to follow around curves
* @param height the height of the room
* @param room_desc the 'continuation' description, which added to the room description to show where the road leads
* @param description the 'adjacent' description, which is seen from adjacent locations.
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding item desc
* @param height_rooms is a mapping containing what rooms to use at different height levels
* @example
*    add_road_type("+", ROOMS + "path", "The dusty path leads $D.",
*                  "There is a dusty path to the $D.",
*                  "path", "Hey! Look! A path!");
* @see add_room_type
* @see add_road_type
* @see set_external_chats
* @see add_item
*/
varargs void add_road_special_type(string type, string base_path,
              int size, int road_skip, int height,
              string room_desc,
              string description, mixed items, mixed item_desc,
              mapping height_rooms)

{
   _char_map[type] = new(class char_map_data,
                        type: AREA_ROAD, adjacent_desc:description,
                        items:items, item_desc:item_desc,
                        room_desc:room_desc, path:base_path,
                         room_jump : size,
                         height : height,
                         height_rooms : height_rooms,
                         room_jump_matching : road_skip);
}


/**
* This method is used to add a standard exit to a specified location
* in a terrain map. The chief use is to insert exits to standard rooms
* or other terrain maps.
* @param x the x coordinate of the room (internal coordinate system)
* @param y the y coordinate of the room (internal coordinate system)
* @param direc the direction of the exit (as in add_exit)
* @param dest the path of the exit's destination (as in add_exit)
* @param type the type of exit (as in add_exit)
* @param modifiers an optional array of exit modifiers (as in modify_exit)
* @example
*    add_exit_at(8, 0, "south", PEARWOOD + "stream_entrance", "road",
*                       ({ "move mess", "You wade along the stream bed.\n",
*                          "enter mess", "$N wades in from the north.",
*                          "exit mess", "$N wades off to the $T." }));
*
* @see add_room_type
* @see add_road_type
* @see add_obstacle_type
* @see add_exit
* @see modify_exit
*/
varargs void add_exit_at(int x, int y, string direc, string dest,
                         string type, mixed modifiers)

{
   string   title = sprintf("%d:%d:%d", x, y, 0);

   if (!dest)
      return;
   if (!type)
      type = "road";

   if (!_standard_exits[title])
      _standard_exits[title] = ({ });

   _standard_exits[title] += ({ ([ "direc":direc, "dest":dest,
                                   "type":type, "modifiers":modifiers ]) });
}

/**
* This method is used to add a standard exit to a specified location
* in a terrain map. The chief use is to insert exits to standard rooms
* or other terrain maps.
* @param x the x coordinate of the room (internal coordinate system)
* @param y the y coordinate of the room (internal coordinate system)
* @param direc the direction of the exit (as in add_exit)
* @param dest the path of the exit's destination (as in add_exit)
* @param type the type of exit (as in add_exit)
* @param modifiers an optional array of exit modifiers (as in modify_exit)
* @example
*    add_exit_at(8, 0, "south", PEARWOOD + "stream_entrance", "road",
*                       ({ "move mess", "You wade along the stream bed.\n",
*                          "enter mess", "$N wades in from the north.",
*                          "exit mess", "$N wades off to the $T." }));
*
* @see add_room_type
* @see add_road_type
* @see add_obstacle_type
* @see add_exit
* @see modify_exit
*/
varargs void add_z_exit_at(int x, int y, int z, string direc, string dest,
                         string type, mixed modifiers)

{
   string   title = sprintf("%d:%d:%d", x, y, z);

   if (!dest)
      return;
   if (!type)
      type = "road";

   if (!_standard_exits[title])
      _standard_exits[title] = ({ });

   _standard_exits[title] += ({ ([ "direc":direc, "dest":dest,
                                   "type":type, "modifiers":modifiers ]) });
}


/**
* This method is used to limit the number of random descs that are
* picked out for each room.
* @param new_limit the new desc limit
* @see set_random_chat_limit
* @see add_random_desc
* @see add_random_chat
*/
void set_random_desc_limit(int new_limit)

{
   _random_desc_limit = new_limit;
}


/**
* This method is used to limit the number of random chats that are
* picked out for each room.
* @param new_limit the new chat limit
* @see set_random_desc_limit
* @see add_random_desc
* @see add_random_chat
*/
void set_random_chat_limit(int new_limit)

{
   _random_chat_limit = new_limit;
}


/**
* This method is to add to the list of random descriptions that can be added to
* specific room types. A specific random sequence is used so that the randoms
* won't vary over time.
* @param types the string of ASCII character type(s) that this desc could apply to
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding item desc
* @see set_random_desc_limit
* @see set_random_chat_limit
* @see add_random_chat
* @see add_item
*/
void add_random_desc(string types, string description, mixed items, mixed item_desc)

{
   int   index;

   for (index = 0; index < sizeof(types); index++) {
      if (!_random_descs[types[index..index]])
         _random_descs[types[index..index]] = ({ });

      _random_descs[types[index..index]] += ({ ([ "desc": description,
                               "items":items, "item_desc":item_desc ]) });

   }

}


/**
* This method is to add to the list of random chats that can be added to
* specific room types. A specific random sequence is used so that the randoms
* won't vary over time.
* @param types the string of ASCII character type(s) that this desc could apply to
* @param chats an array of chats to add. Usual add_chat format.
* @see set_random_desc_limit
* @see set_random_chat_limit
* @see add_random_chat
*/
void add_random_chat(string types, string *chats)

{
   int   index;

   for (index = 0; index < sizeof(types); index++) {
      if (!_random_chats[types[index..index]])
         _random_chats[types[index..index]] = ({ });
      _random_chats[types[index..index]] += chats;
   }

}


/**
* This method is used to setup 'external' chats for a road or obstacle,
* which will be added to the room chats of adjacent locations. You
* should supply the ASCII character corresponding to the road/obstacle
* type, and an array of chat strings (in the same format as supplied to
* room_chat)
* @param type the ASCII type used on the map to denote the room
* @param base_path the full pathname of the source file for the room
*    set_external_chats("=",
*                 ({ "The stream bubbles merrily on its way.",
*                    "You hear a faint splashing sound from the stream." }));
* @see add_road_type
* @see add_obstacle_type
* @see set_feature_chats
* @see room_chat
*/
void set_external_chats(string type, mixed chats)

{
   if (!_char_map[type]) {
      return;
   }

   ((class char_map_data)_char_map[type])->chats = chats;
}


/**
* This method is called to add a new 'feature' to a terrain map.
* Features have no real existance, but add atmosphere to a whole area,
* by being visible across a large number of locations.
* You define location, size, item desc, and add an array of 'longs'
* sorted by distance, plus the usual item descriptions. Any occurrences
* of $D in the longs array will be replaced by the direction in which
* the feature lies.
* @param title the name of the feature
* @param x the x coordinate of the room (internal coordinate system)
* @param y the y coordinate of the room (internal coordinate system)
* @param width the width of the feature
* @param height the height of the feature
* @param range the distance (number of rooms) it can be seen for
* @param descs array of descriptions to be shown at different ranges.
* These are divided equally along the total range
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding
* @param night_descs the night description array
* @param night_items the descriptions for the items at night
* @example
*   add_feature("northmountain", 3, 0, 5, 1, 7,
*            ({ "A huge snowy mountain towers over you to the $D.",
*               "A huge snowy mountain looms to the $D.",
*               "A fair way off to the $D, you can see a huge snowy mountain.",
*               "A long way $Dwards, you glimpse the snowy peak of a "
*               "mountain." }),
*               "mountain", "From here, it looks quite astoundingly huge.",
*            ({ "A huge black bulk obscures the sky to the $D.",
*               "A huge black bulk covers the horizon to the $D.",
*               "A black lump obscures the horizon to the $D",
*               "" }),
*               "The dark black silloette looks like a mountain.");
* @see add_road_type
* @see add_obstacle_type
* @see set_feature_chats
* @see modify_feature
* @see add_item
*/
void add_feature(string title, int x, int y, int width, int height,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs,
                 mixed night_items)

{
   object region;
   object feature;

   region = clone_object(TERRAIN_MAP_REGION_RECTANGULAR);
   region->add_feature_position(x, y, width, height);
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         f_item_night_desc : night_items,
                         whole_sentance:1,
                         feature_ob : feature,
                         night_descs : night_descs);
}

/**
* This method is called to add a new 'feature' to a terrain map.
* Features have no real existance, but add atmosphere to a whole area,
* by being visible across a large number of locations.  This method is
* different to the normal add_feature in that the system will try
* and construct a sentance from the features instead of once sentance
* per feature.
* You define location, size, item desc, and add an array of 'longs'
* sorted by distance, plus the usual item descriptions. Any occurrences
* of $D in the longs array will be replaced by the direction in which
* the feature lies.
* @param title the name of the feature
* @param x the x coordinate of the room (internal coordinate system)
* @param y the y coordinate of the room (internal coordinate system)
* @param width the width of the feature
* @param height the height of the feature
* @param range the distance (number of rooms) it can be seen for
* @param descs array of descriptions to be shown at different ranges.
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding
* These are divided equally along the total range
* @example
*   add_feature_sentance("northmountain", 3, 0, 5, 1, 7,
*            ({ "a huge snowy mountain towers over you to the $D",
*               "a huge snowy mountain looms to the $D",
*               "a fair way off to the $D, you can see a huge snowy mountain",
*               "a long way $Dwards, you glimpse the snowy peak of a "
*               "mountain" }),
*               "mountain", "From here, it looks quite astoundingly huge." );
* @see add_road_type
* @see add_obstacle_type
* @see set_feature_chats
* @see modify_feature
* @see add_item
*/
void add_feature_sentance(string title, int x, int y, int width, int height,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs, mixed night_items)

{
   object region;
   object feature;

   region = clone_object(TERRAIN_MAP_REGION_RECTANGULAR);
   region->add_feature_position(x, y, width, height);
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         feature_ob : feature,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         f_item_night_desc : night_items,
                         whole_sentance:0,
                         night_descs : night_descs);
}


/**
* This method is called to add a new 'feature' to a terrain map.
* Features have no real existance, but add atmosphere to a whole area,
* by being visible across a large number of locations.
* You define location, size, item desc, and add an array of 'longs'
* sorted by distance, plus the usual item descriptions. Any occurrences
* of $D in the longs array will be replaced by the direction in which
* the feature lies.
* @param title the name of the feature
* @param region the region object to use in calculating the feature
* @param range the distance (number of rooms) it can be seen for
* @param descs array of descriptions to be shown at different ranges.
* These are divided equally along the total range
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding
* @param whole_sentance use a whole sentance for the descriptions or wrap
* them up into fragments
* @example
*   region = clone_object(TERRAIN_MAP_REGION_POLYGON);
*   region->add_vertex(12, 13);
*   region->add_vertex(14,15);
*   region->add_vertex(17,18);
*   add_feature_region("northmountain", region, 7,
*            ({ "A huge snowy mountain towers over you to the $D.",
*               "A huge snowy mountain looms to the $D.",
*               "A fair way off to the $D, you can see a huge snowy mountain.",
*               "A long way $Dwards, you glimpse the snowy peak of a "
*               "mountain." }),
*               "mountain", "From here, it looks quite astoundingly huge.",
*            ({ }), 0 );
* @see add_road_type
* @see add_obstacle_type
* @see set_feature_chats
* @see modify_feature
* @see add_item
*/
void add_feature_region(string title, object region,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs,
                 mixed night_items,
                 int whole_sentance)

{
   object feature;

   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         whole_sentance:whole_sentance,
                         f_item_night_desc : night_items,
                         feature_ob : feature,
                         night_descs : night_descs);
}

/**
* This method is called to add a new 'feature' to a terrain map.
* Features have no real existance, but add atmosphere to a whole area,
* by being visible across a large number of locations.
* You define location, size, item desc, and add an array of 'longs'
* sorted by distance, plus the usual item descriptions. Any occurrences
* of $D in the longs array will be replaced by the direction in which
* the feature lies.
* @param title the name of the feature
* @param region the region object to use in calculating the feature
* @param range the distance (number of rooms) it can be seen for
* @param descs array of descriptions to be shown at different ranges.
* These are divided equally along the total range
* @param items add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding
* @param whole_sentance use a whole sentance for the descriptions or wrap
* them up into fragments
* @example
*   region = clone_object(TERRAIN_MAP_REGION_POLYGON);
*   region->add_vertex(12, 13);
*   region->add_vertex(14,15);
*   region->add_vertex(17,18);
*   add_feature_region("northmountain", region, 7,
*            ({ "A huge snowy mountain towers over you to the $D.",
*               "A huge snowy mountain looms to the $D.",
*               "A fair way off to the $D, you can see a huge snowy mountain.",
*               "A long way $Dwards, you glimpse the snowy peak of a "
*               "mountain." }),
*               "mountain", "From here, it looks quite astoundingly huge.",
*            ({ }), 0 );
* @see add_road_type
* @see add_obstacle_type
* @see set_feature_chats
* @see modify_feature
* @see add_item
*/
void add_feature_ob(string title, object feature) {
   if (_real_coords && _real_coords->xdiff) {
      feature->set_distance_multiplier(_real_coords->xdiff);
   }
   _features[title] = new(class feature_data,
                          f_items : feature->query_items(),
                          f_item_desc : feature->query_day_items(),
                          f_item_night_desc : feature->query_night_items(),
                          feature_ob : feature);
}

/**
* This method is used to modify the descriptions and/or item descs of
* an established feature. Changes will be instantly seen in all the
* rooms the feature is visible from.
* @param title the name of the feature
* @param descs array of descriptions to be shown at different ranges.
* add_item name(s) (identical to the 'shorts' parameter in add_item)
* @param item_desc a string, or array of strings giving the corresponding
* These are divided equally along the total range
* @see set_feature_chats
* @see add_feature
* @see add_item
*/
varargs void modify_feature(string title, string *descs, mixed item_desc)

{
   if (!_features[title]) {
      return;
   }

   if (descs) {
      _features[title]->descs = descs;
   }
   if (item_desc) {
      _features[title]->f_item_desc = item_desc;
   }
}


/**
* This method is used to add room chats to locations that can view a
* particular feature. $D substitution is carried out on the chats.
* @param title the name of the feature
* @param chats an array of strings (room chats related to the feature)
* @see add_feature
* @see modify_feature
* @see room_chat
*/
void set_feature_chats(string title, mixed *chats, mixed* night_chats)

{
   if (!_features[title]) {
      return;
   }

   ((class feature_data)_features[title])->chats = chats;
   ((class feature_data)_features[title])->night_chats = night_chats;
}


/**
* This method is used to remove a named feature from the terrain map
* @param title the name of the feature
* @see add_feature
*/
void remove_feature(string title)

{
   object room;

   if (!_features[title]) {
      return;
   }

   map_delete(_features, title);
   if (!_feature_rooms[title]) {
      return;
   }

   _feature_rooms[title] -= ({ 0 });
   foreach(room in _feature_rooms[title]) {
      room->remove_feature(title);
   }

   map_delete(_feature_rooms, title);
}


/**
* This method is used to add a signpost into a specified location in a
* terrain_map. It is identical to the /std/room/ add_sign, except for
the x and y coordinates which specify where the sign should go.
* @param title the name of the feature
* @param x the x coordinate of the center point
* @param y the y coordinate of the center point
* @example
*   add_sign(4, 3, "A wooden signpost.\n",
*                  "\n-----------------\n"
*                    "| Ladder: East  |\n"
*                    "| Bridge: South |\n"
*                    "-----------------",
*                  "signpost", ({ "signpost", "sign" }), "common");
*
* @see add_sign
*/
void add_sign(int x, int y, string sign_long, mixed sign_read_mess,
              string sign_short, mixed sign_name, string sign_language)

{
   string   title = sprintf("%d:%d", x, y);

   _signposts[title] = new(class sign_data,
                         long:sign_long, read_mess:sign_read_mess,
                         short:sign_short, name:sign_name,
                         language:sign_language);
}


/**
* This method is used to map ASCII characters used in the zone map onto
* one or more actual room zones.
* @param type the ASCII character used in the zone map
* @param zones a zone name or an array of zone names
* @example
*   add_zones("*", ({ "zone2", "zone1" }));
*/
void add_zones(string type, string *zone_names)

{
   _zone_types[type] = zone_names;
}


// Dests all the rooms, and reloads all the maps.
/**
* @ignore
*/
void reset_handler()

{
   mixed *rooms;

   if (arrayp(_room_map)) {
      foreach(rooms in _room_map) {
         rooms->dest_me();
      }
   }
   _room_map = 0;
   _area_map = 0;
   setup_area_map();
}


// Load up the zone map. Based on the map_file name.
/**
* @ignore
*/
void load_zone_map()

{
   string   map_path = query_map_file() + ".zones";
   int      index = 1;
   string   line;
   int      width;
   int      height;

   _zone_map = ({ });
   while (line = read_file(map_path, index++, 1)) {
      if (width < sizeof(line))
         width = sizeof(line);
      _zone_map += ({ line });
   }
   height = index - 1;

   if ((width != _width) || (height != _height))
      _zone_map = ({ });
}


// Load up the area map. Based on the map_file name.
/**
* @ignore
*/
void load_area_map()

{
   string   map_path = query_map_file() + ".map";
   int      index = 1;
   int      height;
   string   line;

   _area_map = ({ });
   while (line = read_file(map_path, index++, 1)) {
      if (sizeof(line)) {
         line = line[0..<2];
         if (_width < sizeof(line)) {
            _width = sizeof(line);
         }
         //if (sizeof(line) < _width)
            //continue;
         _area_map = ({ line }) + _area_map;
         height++;
      }
   }
   _height = height;
   if (!height) {
      printf("Unable to open %O\n", map_path);
   }
}

/**
* @ignore
* Handles the cloning of a room when it is specified as:
* path/name:x:y
*/
object create_virtual_object(string x_str, string y_str, string z_str)

{
   int x = to_int(x_str);
   int y = to_int(y_str);
   int z = to_int(z_str);

   if (!stringp(x_str) || !stringp(y_str) || !stringp(z_str)) {
      return 0;
   }

   return query_room(x, y, z);
}

/**
 * This method finds the room at the specific real coordinate.
 * @param x the x location
 * @param y the y location
 * @return the room, or 0 on failure
 */
string find_room_at_real_coord(int x, int y, int z) {
   class char_map_data room_map;
   class coord our;

   our = query_terrain_from_real_coord(x, y, z);
   if (!our) {
      return 0;
   }
   room_map = query_char_map(our->x, our->y);
   if (!room_map) {
      debug_printf("Unable to load room at %d %d (%d %d)\n", our->x, our->y, x, y);
      return 0;
   }

   if (room_map->type == AREA_OBSTACLE) {
      return 0;
   }

   return sprintf("%s:%d:%d:%d", base_name(this_object()), our->x, our->y, our->z);
} /* find_room_at_real_coord() */

/**
 * This method returns the distance that is moved if you go in the
 * specified direction.
 * @return the distance
 */
int query_direction_distance(string dir) {
  switch (_direcs[dir][3]) {
   case X_DIFF :
      return _real_coords->xdiff;
   case Y_DIFF :
      return _real_coords->ydiff;
   case XY_DIFF :
      return _real_coords->xydiff;
   }
   return 0;
}

/** @ignore yes */
void dest_me() {
   class feature_data womble;
   string name;

   foreach (name, womble in _features) {
      if (womble->feature_ob) {
         womble->feature_ob->dest_me();
      }
   }

   destruct(this_object());
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/handler_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/air_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/air_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629475   Available: 13576829
Inodes: Total: 5242880    Free: 4960136
1339 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/air_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629475   Available: 13576829
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: air_base.c,v 1.1 2003/06/23 22:46:02 pinkfish Exp $
 * 
*/
/**
* @main
* Base inherit for an air room using the terrain map system.
* <p>
* This file should be inherited by any air room within a terrain mapped
* virtual area.
* <p>
* To inherit from this file, use the following lines:
* <ul>
* <li>#include <terrain_map.h>
* <li>
* <li>inherit TERRAIN_MAP_AIR_BASE
* </ul>
* 
* @index terrain_map_outside
* @see terrain_map_handler
* @see terrain_map_intro
* @see terrain_map_example
* @author Dek
* @started Thurs April 12 2001 Too Damn Early BST
**/

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>

inherit "/std/room/outside";
inherit TERRAIN_MAP_ROOM_BASE;

void create() {
   set_not_replaceable(1);
   terrain_room::create();
   outside::create();
}

void init() {
   terrain_room::init();
   outside::init();
} /* init() */

/** @ignore yes */
varargs mixed* query_dest_other(string exit) {
   mixed* data;

   data = outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}

/** @ignore yes */
mixed* query_dest_dir(object thing) {
   mixed* data;

   data = outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}

/** @ignore yes */
mixed stats() {
   return outside::stats() + terrain_room::stats();
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/air_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/geometry.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/geometry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629475   Available: 13576829
Inodes: Total: 5242880    Free: 4960136
5755 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/geometry.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629475   Available: 13576829
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This does a few geometric calculations to make life easier for
 * us.
 * @author Pinkfish
 * @started Fri Apr  5 15:47:05 PST 2002
 */

class point {
   int x;
   int y;
}

// A nice small number  so we avoid division errors.
#define SMALL_NUM 0.00001

/**
 * Return the intersection of a line and a line segment.
 * @param lx1 the line x top
 * @param ly1 the line y top
 * @param lx2 the line x bottom
 * @param ly2 the line y bottom
 * @param sx1 the line segement x start
 * @param sy1 the line segement y start
 * @param sx2 the line segement x end
 * @param sy2 the line segement y end
 * @return the intersection point
 */
class point intersection_of_line_and_segment(int lx1, int ly1, int lx2, int ly2,
                                             int sx1, int sy1, int sx2, int sy2) {
   float den;
   float uanum;
   float ubnum;
   float ua;
   float ub;
   class point p;

   den = to_float(sy2 - sy1) * to_float(lx2 - lx1) - to_float(sx2 - sx1) * to_float(ly2 - ly1);
   if (den == 0.0) {
      return 0;
   }
   ubnum = to_float(lx2 - lx1) * to_float(ly1 - sy1) - to_float(ly2 - ly1) * to_float(lx1 - sx1);
   ub = ubnum / den;
   if (ub < 0.0 || ub > 1.0) {
      return 0;
   }
   uanum = to_float(sx2 - sx1) * to_float(ly1 - sy1) - to_float(sy2 - sy1) * to_float(lx1 - sx1);
   ua = uanum / den;
   //printf("%O %O %O (%O %O)\n", den, ua, ub, ua / den, ub / den);
   p = new(class point);
   p->x = lx1 + to_int(ua * (lx2 - lx1));
   p->y = ly1 + to_int(ub * (ly2 - ly1));
   //printf("%O\n", p);
   return p;
}

/**
 * Finds the distance from a point to a line segment.
 * @param x1 the start of the line segment
 * @param y1 the start of the line segment
 * @param x2 the end of the line segment
 * @param y2 the end of the line segment
 * @param point_x the point
 * @param point_y the point
 * @return the distance
 */
int distance_point_to_line_segment(int x1, int y1, int x2, int y2,
                           int point_x, int point_y) {
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float distance;
   float dot1;
   float dot2;
   float b;
   float vm_x;
   float vm_y;

   v1_x = to_float(x1 - x2);
   v1_y = to_float(y1 - y2);
   v2_x = to_float(point_x - x2);
   v2_y = to_float(point_y - y2);
   dot1 = v1_x * v2_x + v1_y * v2_y;
   if (dot1 <= 0.0) {
      // Distance to p1
      distance = sqrt(pow(x2 - point_x, 2) + pow(y2 - point_y, 2));
   } else {
      dot2 = v1_x * v1_x + v1_y * v1_y;
      if (dot2 <= dot1) {
         // Distance to p2.
         distance = sqrt(pow(x1 - point_x, 2) + pow(y1 - point_y, 2));
      } else {
         b = dot1 / dot2;
         vm_x = to_float(x2) + b * v1_x;
         vm_y = to_float(y2) + b * v1_y;
         // Distance to vm.
         distance = sqrt(pow(vm_x - point_x, 2) + pow(vm_y - point_y, 2));
      }
   }
   return to_int(distance);
}

/**
 * This method finds the minimum distance between two line segments.
 * @param x1_1 the start of the first line
 * @param y1_1 the start of the first line
 * @param x2_1 the end of the first line
 * @param y2_1 the end of the first line
 * @param x1_2 the start of the second line
 * @param y1_2 the start of the second line
 * @param x2_2 the end of the second line
 * @param y2_2 the end of the second line
 * @return the minimum distance
 */
int distance_between_two_line_segments(
     int x1_1, int y1_1, int x2_1, int y2_1,
     int x1_2, int y1_2, int x2_2, int y2_2) {
   float ux;
   float uy;
   float vx;
   float vy;
   float wx;
   float wy;
   float dpx;
   float dpy;
   float a;
   float b;
   float c;
   float d;
   float e;
   float dist;
   float sc;
   float sn;
   float sd;
   float tc;
   float tn;
   float td;

   ux = to_float(x2_1) - to_float(x1_1);
   uy = to_float(y2_1) - to_float(y1_1);
   vx = to_float(x2_2) - to_float(x1_2);
   vy = to_float(y2_2) - to_float(y1_2);
   wx = to_float(x1_1) - to_float(x1_2);
   wy = to_float(y1_1) - to_float(y1_2);
   a = ux * ux + uy * uy;
   b = ux * vx + uy * vy;
   c = vx * vx + vy * vy;
   d = ux * wx + uy * wy;
   e = vx * wx + vy * wy;
   dist = a * c - b * b;
   sd = dist;
   td = dist;

   if (dist < SMALL_NUM) {
      // Almost parallel.
      // Set one bit as 0.
      sn = 0.0;
      sd = 1.0;
      tn = e;
      td = c;
   } else {
      // get  the closest points on the infinte lines.
      sn = b * e - c * d;
      tn = a * e - b * d;
      if (sn < 0.0) {
         // sc < 0 => the s=0 edge is visible.
         sn = 0.0;
         tn = e;
         td = c;
      } else if (sn > sd) {
         // sc > 1 => s1 = edge is visible.
         sn = sd;
         tn = e + b;
         td = c;
      }

      if (tn < 0.0) {
         // tc < 0 -> t0 edge is visible.
         tn = 0.0;
         if (-d < 0.0) {
            sn = 0.0;
         } else if (-d > a) {
            sn = sd;
         } else {
            sn = -d;
            sd = a;
         }
      } else if (tn > td) {
         // tc > 1 => the t1 edge is visible
         tn = td;
         if ((-d + b) < 0) {
            sn = 0.0;
         } else if ((-d + b) > a) {
            sn = sd;
         } else {
            sn = -d + b;
            sd  = a;
         }
      }
   }

   // finally do the division to get sc and tc
   sc = sn / sd;
   tc = tn / td;
//printf("%O / %O = %O, %O / %O = %O\n", sn, sd, sc, tn, td, tc);

   // get the difference between the two closet points
   dpx = wx + (sc * ux) - (tc * vx);
   dpy = wy + (sc * uy) - (tc * vy);
//printf("%O + %O = %O -- %O %O\n", dpx * dpx, dpy * dpy, dpx * dpx + dpy * dpy, sqrt(dpx * dpx + dpy * dpy), to_int(sqrt(dpx * dpx + dpy * dpy)));

   dist = sqrt(dpx * dpx + dpy * dpy);
   if (dist > pow(2, 30)) {
      return to_int(pow(2, 30));
   }

   return to_int(sqrt(dpx  * dpx + dpy * dpy));
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/geometry.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/simple_feature.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/simple_feature.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629473   Available: 13576827
Inodes: Total: 5242880    Free: 4960136
2840 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/simple_feature.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629473   Available: 13576827
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This type of feature generates distance messages to the feature
 * based on how far away it is.  It uses a small basic string as the
 * main part of the description and adds in distance messages to show
 * how far away the item is.
 * @author Pinkfish
 * @started Mon Apr  1 12:50:02 PST 2002
 */
#include <terrain_map.h>

inherit TERRAIN_MAP_FEATURE_BASE;

private string _base_desc;
private int _very_close_distance;
private int _distance_multiplier = 1;

/**
 * This method sets the distance at which the description is set to
 * very close instead of a distance measurement.
 * @param close the distance to use
 */
void set_very_close_distance(int close) {
   _very_close_distance = close;
}

/**
 * This method returns the basic description for the feature.
 */
string query_base_description() {
   return _base_desc;
} 

/**
 * This method sets the basic description for the feature.
 * @param desc the basic description
 */
void set_base_description(string desc) {
   _base_desc = desc;
} 

/**
 * This method sets the distance multiplier for the feature.  This is amount
 * to multiply the range by to find the actual distance.
 */
void set_distance_multiplier(int mult) {
   _distance_multiplier = mult;
}

/** @ignore yes */
string calc_feature_desc(mapping direcs, int night, int visibility) {
   string direc;
   int dist;
   int new_dist;
   string* bits;

   bits = ({ });
   if(visibility < 1 && visibility != -1)
     visibility = 1;
   
   foreach (direc, dist in direcs) {
      dist += query_range_offset() ;
      new_dist = dist * 100 / visibility;
      if (visibility == -1 ||
          (new_dist < query_max_range() && dist > query_min_range())) {
         if (dist < _very_close_distance) {
            bits += ({ "very close to the " + direc });
         } else {
            bits += ({ query_distance_str(dist * _distance_multiplier) + " to the " + direc });
         }
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}

/** @ignore yes */
string calc_map_feature_desc(mapping direcs, int fudge) {
   string direc;
   int dist;
   string* bits;

   bits = ({ });
   foreach (direc, dist in direcs) {
      dist += query_range_offset();
      if (dist < _very_close_distance * 5) {
        bits += ({ "very close to the " + direc });
      } else {
        bits += ({ ({"approximately ", "about ", "roughly "})[random(3)] +
                     query_distance_str(dist * _distance_multiplier) +
                     " to the " + direc });
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/simple_feature.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629472   Available: 13576826
Inodes: Total: 5242880    Free: 4960136
4292 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629472   Available: 13576826
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is specifically for creating rooms in the world map system, where
 * it just makes and passes out the room details.  So it does not need to
 * include all the room crap.
 * @author Pinkfish
 * @started Fri Jun 28 16:14:19 PDT 2002
 */
#include <terrain_map.h>

private int _room_jump_size;
private int _follow_road;
private int _default_height;
private int _min_height;
private string _adjacent_desc;
private mapping _height_info;
private mapping _adjacent_items;

void create() {
   _adjacent_items = ([ ]);
} /* create() */

/**
 * This method sets the room jump size for the room.
 * @param jump the room jump size
 */
void set_room_jump_size(int jump) {
   _room_jump_size = jump;
}

/**
 * This method returns the room jump size for the room
 * @return the room jump size
 */
int query_room_jump_size() {
   return _room_jump_size;
}

/**
 * This method sets the flag that makes us follow the road.
 * @param follow the follow road flag
 */
void set_follow_road(int follow) {
  _follow_road = follow;
}

/**
 * This method returns the follow road flag for the road.
 * @return the follow road flag
 */
int query_follow_road() {
   return _follow_road;
}

/**
 * This method sets the default height for the room.
 * @param def the default height for the room
 */
void set_default_height(int height) {
   _default_height = height;
}

/**
 * This method sets the string to use for adjancent descriptions.  THis is
 * the bit tacked onto the end of the long in another room.
 * @param desc the adjacent description
 */
void set_adjacent_description(string desc) {
   _adjacent_desc = desc;
}

/**
 * This method returns the string to use for adjancent descriptions.  THis is
 * the bit tacked onto the end of the long in another room.
 * @return the adjacent description
 */
string query_adjacent_description() {
   return _adjacent_desc;
}

/**
 * This method returns the default height for the room.
 * @return the default height for the room
 */
int query_default_height() {
   return _default_height;
}

/**
 * This method sets the minimum height, this is only really useful
 * in locations which have multiple depth rooms.
 * @param height the minimum height */
void set_minimum_height(int height) {
   _min_height = height;
}

/**
 * This method returns the mimum height allowed for this factory.
 * @return the mimuim height
 */
int query_minimum_height() {
   return _min_height;
}

/**
 * This method sets the height information for the room, setting up
 * which rooms are used at which heights.
 * @param heights the heights for the rooms
 */
void set_height_rooms(mapping map) {
   _height_info = map;
}

/**
 * This method figures out the base path to use for the specified room.
 * @param x the x position
 * @param y the y position
 * @param z the z position
 * @param air checking upwards in air land.
 * @return the base room
 */
string find_base_terrain_room(int x, int y, int z, string base_name, int map_room, string ref base) {
   // If there is a set room at a location, use it.
   if (_height_info && _height_info[z]) {
      return _height_info[z];
   }

   // Find the new room.
   if (z > _default_height) {
      // air room
      if (map_room == TERRAIN_MAP_ROOM_CLIMB) {
         return 0;
      }
      if (map_room == TERRAIN_MAP_ROOM_EXACT) {
         return TERRAIN_MAP_DEFAULT_AIR_ROOM;
      }
      if (!_height_info) {
         return base_name;
      }
      return _height_info[_default_height];
   }
   if (!_height_info) {
      if (z == _default_height) {
         return base_name;
      }
      return 0;
   }
   if (_min_height > z) {
      return 0;
   }
   if (z == _default_height) {
      return base_name; //__FILE__[0..<3];
   }
   return _height_info["default"];
}

/**
 * This method sets an item which will be visible from adjacent rooms.
 * @param name the name of the item
 * @param desc the description of the item
 */
void add_adjacent_item(string name, string desc) {
   _adjacent_items[name] = desc;
}

/**
 * This method returns all the adjacent items.
 * @return the mapping of all the adjacent items
 */
mapping query_adjacent_items() {
   return _adjacent_items;
}

mixed stats() {
   return ({
  ({ "room jump", _room_jump_size }),
  ({ "follow road", _follow_road }),
  ({ "adjacent desc", _adjacent_desc }) });
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/factory_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_inside_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_inside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629471   Available: 13576825
Inodes: Total: 5242880    Free: 4960136
2795 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_inside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629471   Available: 13576825
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: water_inside_base.c,v 1.4 2002/08/27 00:21:44 presto Exp $
 * 
*/
/**
* @main
* Base inherit for an inside water room using the terrain map system.
* <p>
* This file should be inherited by any inside room within a terrain mapped
* virtual area, and by any file with an exit to one of said areas.
* <p>
* When inheriting from this file, it is essential that the function
* query_handler_path() be overriden to return the full pathname of
* the handler associated with this area.
* <p>
* To inherit from this file, use the following lines:
* <ul>
* <li>#include <terrain_map.h>
* <li>
* <li>inherit TERRAIN_MAP_OUTSIDE_BASE
* </ul>
* 
* @index terrain_map_inside
* @see terrain_map_handler
* @see terrain_map_intro
* @see terrain_map_example
* @author Dek
* @started Thurs April 12 2001 Too Damn Early BST
**/

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>

inherit "/std/room/water_inside";
inherit TERRAIN_MAP_ROOM_BASE;

void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_inside::create();
}

void init() {
   terrain_room::init();
   water_inside::init();
} /* init() */

/* @ignore yes */
varargs mixed* query_dest_other(string exit) {
   mixed* data;

   data = water_inside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}

/* @ignore yes */
mixed* query_dest_dir(object thing) {
   mixed* data;

   data = water_inside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}

/** @ignore yes */
mixed stats() {
   return water_inside::stats() + terrain_room::stats();
}

/** @ignore yes */
string query_terrain_map_walk_exit() {
   return "swim ";
}

/** @ignore yes */
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}

/** @ignore yes */
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_inside_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_outside_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_outside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629470   Available: 13576824
Inodes: Total: 5242880    Free: 4960136
3563 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_outside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629470   Available: 13576824
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: water_outside_base.c,v 1.9 2003/07/14 21:56:10 pinkfish Exp $
 * 
*/
/**
* @main
* Base inherit for an outside water room using the terrain map system.
* <p>
* This file should be inherited by any outside room within a terrain mapped
* virtual area, and by any file with an exit to one of said areas.
* <p>
* When inheriting from this file, it is essential that the function
* query_handler_path() be overriden to return the full pathname of
* the handler associated with this area.
* <p>
* To inherit from this file, use the following lines:
* <ul>
* <li>#include <terrain_map.h>
* <li>
* <li>inherit TERRAIN_MAP_OUTSIDE_BASE
* </ul>
* 
* @index terrain_map_outside
* @see terrain_map_handler
* @see terrain_map_intro
* @see terrain_map_example
* @author Dek
* @started Thurs April 12 2001 Too Damn Early BST
**/

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>

inherit "/std/room/water_outside";
inherit TERRAIN_MAP_ROOM_BASE;

void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_outside::create();
}

void init() {
   terrain_room::init();
   water_outside::init();
} /* init() */

/* @ignore yes */
varargs mixed* query_dest_other(string exit) {
   mixed* data;

   data = water_outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}

/* @ignore yes */
mixed* query_dest_dir(object thing) {
   mixed* data;

   data = water_outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}

/** @ignore yes */
mixed stats() {
   return water_outside::stats() + terrain_room::stats();
}

/** @ignore yes */
string query_terrain_map_walk_exit() {
   return "swim ";
}

/** @ignore yes */
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}

/** @ignore yes */
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}

/**
 * Make it so that anyone attempting to enter a water room from a non-water
 * room has to specifically wade into it.
 * @ignore yes
 */
string query_enter_exit_direction(string key, string key_here, string direct,
                                  object room, string base_path) {
   if (!room->query_water()) {
      return "wade " + direct;
   }
   return 0;
}

/** @ignore yes */
int can_move_between(string my_type, string direc,
                     string first_type, string second_type, string new_base_path)

{
   return first_type->query_water() && second_type->query_water() &&
          new_base_path->query_water() ||
          (!new_base_path->query_water() &&
           (!first_type->query_water() || !second_type->query_water()));
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/water_outside_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/inside_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/inside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629469   Available: 13576823
Inodes: Total: 5242880    Free: 4960136
1577 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/inside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629469   Available: 13576823
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: inside_base.c,v 1.7 2003/04/10 18:10:22 pinkfish Exp $
 * 
*/
/**
* @main
* Base inherit for an inside room using the terrain map system.
* <p>
* This file should be inherited by any outside room within a terrain mapped
* virtual area, and by any file with an exit to one of said areas.
* <p>
* When inheriting from this file, it is essential that the function
* query_handler_path() be overriden to return the full pathname of
* the handler associated with this area.
* <p>
* To inherit from this file, use the following lines:
* <ul>
* <li>#include <terrain_map.h>
* <li>
* <li>inherit TERRAIN_MAP_INSIDE_BASE
* </ul>
* 
* @index terrain_map_inside
* @see terrain_map_handler
* @see terrain_map_intro
* @see terrain_map_example
* @author Dek
* @started Thurs April 12 2001 Too Damn Early BST
**/

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>

inherit "/std/room/basic_room";
inherit TERRAIN_MAP_ROOM_BASE;

void create() {
   set_not_replaceable(1);
   terrain_room::create();
   basic_room::create();
}

void init() {
   terrain_room::init();
   basic_room::init();
} /* init() */

/* @ignore yes */
varargs mixed* query_dest_other(string exit) {
   mixed* data;

   data = basic_room::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}

/* @ignore yes */
mixed* query_dest_dir(object thing) {
   mixed* data;

   data = basic_room::query_dest_dir(thing);
   return terrain_room::query_dest_dir();
}

mixed stats() {
   return basic_room::stats() + terrain_room::stats();
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/inside_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_local.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_local.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629468   Available: 13576822
Inodes: Total: 5242880    Free: 4960136
1093 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_local.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629468   Available: 13576822
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <terrain_map.h>

inherit TERRAIN_MAP_SIMPLE_FEATURE_BASE;
inherit "/std/basic/setup";

private string* _items;
private string* _night_descs;
private string* _day_descs;

void create() {
   _items = ({ });
   _night_descs = ({ });
   _day_descs = ({ });
   do_setup();
   do_reset();
}

/**
 * This method adds an item with a night/day description.
 * @param item the name of the item
 * @param night the night description
 * @param day the day description
 */
void add_item(string item, string day, string night) {
   _items += ({ item });
   _night_descs += ({ night });
   _day_descs += ({ day });
}

/**
 * This method returns the names of all the items on this feature.
 * @return the names of the items
 */
string* query_items() {
   return _items;
}

/**
 * This method returns the names of all the items on this feature.
 * @return the names of the items
 */
string* query_day_items() {
   return _day_descs;
}

/**
 * This method returns the names of all the items on this feature.
 * @return the names of the items
 */
string* query_night_items() {
   return _night_descs;
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/feature_local.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/distance_str.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/distance_str.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629468   Available: 13576822
Inodes: Total: 5242880    Free: 4960136
1812 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/distance_str.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629468   Available: 13576822
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * An inherit to use in the terrain stuff to deal with distance messages
 * when they are needed.
 * @author Pinkfish
 * @started Mon Apr  1 12:40:00 PST 2002
 */
#include <terrain_map.h>

/**
 * This method returns a string displaying how long the specified
 * distance is.
 * @param dist the distance
 */
private string query_distance_str_int(int dist, int show_one) {
   if (dist < 3) {
      if (dist > 1) {
         return query_num(dist) + " feet";
      } else if (show_one) {
         return "one foot";
      } else {
         return "foot";
      }
   } else if (dist < TERRAIN_MAP_HALF_MILE) {
      dist /= 3;
      if (dist > 50) {
         dist = dist / 50 * 50;
      }
      if (dist > 1) {
         return query_num(dist) + " yards";
      }
      if (show_one) {
         return "one yard";
      } else {
         return "yard";
      }
   } else if (dist < TERRAIN_MAP_ONE_MILE) {
      return "half mile";
   } else {
      dist /= TERRAIN_MAP_ONE_MILE;
      if (dist > 10) {
         dist = dist / 10 * 10;
      }
      if (dist > 100) {
         dist = dist / 50 * 50;
      }
       if (dist > 1000) {
         dist = dist / 500 * 500;
      }
      if (dist > 1) {
         return query_num(dist) + " miles";
      } else {
         if (show_one) {
            return "one mile";
         } else {
            return "mile";
         }
      }
   }
}

/**
 * This method returns a string displaying how long the specified
 * distance is.
 * @param dist the distance
 */
string query_distance_str(int dist) {
   return query_distance_str_int(dist, 1);
}

/**
 * This method returns a string displaying how long the specified
 * distance is, without any ones.
 * @param dist the distance
 */
string query_distance_str_no_ones(int dist) {
   return query_distance_str_int(dist, 0);
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/distance_str.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/outside_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/outside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629467   Available: 13576821
Inodes: Total: 5242880    Free: 4960136
1538 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/outside_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629467   Available: 13576821
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: outside_base.c,v 1.10 2003/04/18 21:08:46 ceres Exp $
 * 
*/
/**
* @main
* Base inherit for an outside room using the terrain map system.
* <p>
* This file should be inherited by any outside room within a terrain mapped
* virtual area.
* <p>
* To inherit from this file, use the following lines:
* <ul>
* <li>#include <terrain_map.h>
* <li>
* <li>inherit TERRAIN_MAP_OUTSIDE_BASE
* </ul>
* 
* @index terrain_map_outside
* @see terrain_map_handler
* @see terrain_map_intro
* @see terrain_map_example
* @author Dek
* @started Thurs April 12 2001 Too Damn Early BST
**/

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>

inherit "/std/room/outside";
inherit TERRAIN_MAP_ROOM_BASE;

void create() {
   set_not_replaceable(1);
   do_setup++;
   terrain_room::create();
   outside::create();
   do_setup--;

   if ( !do_setup ) {
     this_object()->setup();
     this_object()->reset();
   }
}

void init() {
   terrain_room::init();
   outside::init();
} /* init() */

/** @ignore yes */
varargs mixed* query_dest_other(string exit) {
   mixed* data;

   data = outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}

/** @ignore yes */
mixed* query_dest_dir(object thing) {
   mixed* data;

   data = outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}

/** @ignore yes */
mixed stats() {
   return outside::stats() + terrain_room::stats();
}

void dest_me() {
  terrain_room::dest_me();
  outside::dest_me();
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/outside_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_rect.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_rect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629467   Available: 13576821
Inodes: Total: 5242880    Free: 4960136
4686 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_rect.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629467   Available: 13576821
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is region handler for a rectangular region.  This can also work
 * for circular regions by making a 0 width/height feature.
 * @author Pinkfish
 * @started Mon Apr  1 12:15:24 PST 2002
 */
inherit "/std/room/inherit/terrain_map/geometry";

class feature_pos {
   int xstart;
   int ystart;
   int width;
   int height;
}

private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });

private class feature_pos* _positions = ({ });

/**
 * This method sets the position of the feature.
 * @param x the x coordinate of the feature
 * @param y the y coordinate of the feature
 * @param width the width of the feature
 * @param height the height of the feature
 */
void add_feature_position(int x, int y, int width, int height) {
   class feature_pos pos;

   pos = new(class feature_pos, xstart : x, ystart : y,
                                width : width, height : height);
   _positions += ({ pos });
}

/**
 * This is the function that finds the distance and direction to the
 * current region.
 * @param x the x-coordinate
 * @param y the y-coordinate
 * @param z the z-coordinate
 * @return ({ direction, distance })
 */
mapping query_feature_desc_from(int x, int y, int z) {
   int h;
   int v;
   int width;
   int height;
   float distance;
   float min_distance;
   string direc;
   class feature_pos pos;
   float xmod;
   float ymod;
   int xd;
   int yd;

   foreach (pos in _positions) {
      h = pos->xstart;
      v = pos->ystart;
      width = pos->width;
      height = pos->height;
      if (x >= (h + width)) {
         h = h + width - 1;
      } else if (x >= h) {
         h = x;
      }
      if (y >= (v + height)) {
         v = v + height - 1;
      } else if (y >= v) {
         v = y;
      }

      distance = sqrt(pow(x - h, 2) + pow(y - v, 2));
      if (distance > 0.0000001 && (distance < min_distance || !min_distance)) {
         xmod = ((h - x) < 0) ? -0.5 : 0.5;
         ymod = ((v - y) < 0) ? -0.5 : 0.5;
         xd = to_int(xmod + to_float(h - x) / distance) + 1;
         yd = to_int(ymod + to_float(v - y) / distance) + 1;
         direc = _feature_direcs[yd][xd];
         min_distance = distance;
      }
   }

   if (!direc) {
      return ([ ]);
   }

   return ([ direc : to_int(min_distance) ]);
}

/** @ignore yes */
void dest_me() {
   destruct(this_object());
}

/**
 * Find out if this rectangle is inside the region, given the specified range
 * at which it can be seen.  This will work by adding the ranges onto the
 * lines and checking for distance from the points of the polygon to the line
 * bordering the region and also checking for intersection with the bordering
 * line.  It also checks to see if all of the points are inside the region.
 * @param x1 the top x
 * @param y1 the top y
 * @param x2 the bottom x
 * @param y2 the bottom y
 */
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class feature_pos position;
   int height;
   int width;

   foreach (position in _positions) {
      height = position->height;
      width = position->width;
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }

/*
      if (distance_between_two_line_segments(x1, y1, x1, y2,
          position->xstart + width, position->ystart, position->xstart +width, position->ystart + height) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y1, x2, y1,
          position->xstart, position->ystart + height, position->xstart +width, position->ystart + height) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x2, y1, x2, y2,
          position->xstart, position->ystart, position->xstart, position->ystart + height) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y2, x2, y2, 
          position->xstart, position->ystart, position->xstart +width, position->ystart) < range) {
         return 1;
      }
 */
   }
   return 0;
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map/region_rect.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/punishment_inherit.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/punishment_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629465   Available: 13576819
Inodes: Total: 5242880    Free: 4960136
4065 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/punishment_inherit.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629465   Available: 13576819
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the basic inheritable punishment class.
 * @author Pinkfish
 * @started Tue Sep 19 14:37:28 PDT 2000
 */
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <nroff.h>

private nosave string _short;
private nosave string _mail_information;
private nosave string _desc_file;

void create() {
   _mail_information = "";
   this_object()->setup();
} /* create() */

/**
 * This method sets the base short description of the punishment.
 * @param name the base short description
 */
void set_short(string short) {
   _short = short;
} /* set_short() */

/**
 * This method sets the description file for this type of punishment.  What it
 * does and so on.
 * @param str the description
 */
void set_description_file(string str) {
   _desc_file = str;
} /* set_description() */

/** 
 * This method returns the description file for the punishment.
 * @return the description file
 */
string query_description_file() {
   return _desc_file;
} /* query_description_file() */

/**
 * This method sets the mail information to use when sending out a mail for
 * this punishment.
 * @param info the mail information
 */
void set_mail_information(string mail) {
   _mail_information = mail;
} /* set_mail_information() */

/**
 * The short desscription of the punishement.
 * @param area the area the case is in
 * @param the_case the case
 * @param type the type name of the punishment
 * @param data the data associated with the type
 * @return the short description
 */
string query_short(string area, class nomic_case the_case, string type, mixed data) {
   return _short;
} /* query_short() */

/**
 * The desscription of the punishement.
 * @param area the area the case is in
 * @param type the type name of the punishment
 * @return the description
 */
string query_description(string area, string type) {
   string str;

   if (_desc_file) {
      str = unguarded( (: NROFF_HAND->cat_file(_desc_file+"_nroff", 1) :) );
      if (!str) {
         unguarded( (: NROFF_HAND->create_nroff(_desc_file, _desc_file+"_nroff") :) );
         str = unguarded( (: NROFF_HAND->cat_file(_desc_file+"_nroff", 1) :) );
      }
      if (str) {
         return str;
      }
   }
   return "Nothing particularly special.\n";
} /* query_description() */

/**
 * The start of the punishment stuff, figure out any extra data.  The
 * default result calls the function back with a 0 data arguement.
 * @param area the area the case is in
 * @param the_case the case
 * @param type the type name of the punishment
 * @param finish_func the function to call when we are finished
 */
void start_punishment(string area, class nomic_case the_case, string type, function finish) {
   evaluate(finish, the_case, type, 0);
} /* start_punishment() */

/**
 * Complete the punishment, this actually does anythign that really needs to
 * be done to do the real work.
 * @param area the area the case is in
 * @param the_case the case to work on
 * @param type the type of the punishement
 * @param data any extra data to use
 */
void complete_punishement(string area, class nomic_case the_case, string type, mixed data) {
   return ;
} /* complete_punishment() */

/**
 * This method suspends the punishment.
 * @param area the area the case is in
 * @param the_case the case to work on
 * @param type the type of the punishment
 * @param data the data associated with the punishment
 */
void suspend_punishment(string area, class nomic_case the_case, string type, mixed data) {
   return ;
} /* suspend_punishment() */

/**
 * This method is used to print extra data in the mail message which
 * gets sent.  This should tell the person how to go about dealing with
 * whatever has happened to them.
 * @param area the area the case is in
 * @param the_case the case to work on
 * @param type the type of the punishment
 * @param data the data associated with the punishment
 */
string query_mail_information(string area, class nomic_case the_case,
                              string type, mixed data) {
   return _mail_information;
} /* query_mail_information() */

// --- END [/mnt/home2/grok/lib/std/room/inherit/punishment_inherit.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/owned_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/owned_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629464   Available: 13576818
Inodes: Total: 5242880    Free: 4960136
5470 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/owned_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629464   Available: 13576818
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is an owned room inherit.  It allows controllable entrance and
 * things like 'allow' and 'throwout' and stuff.  Make sure the create on
 * this is called after the create in the basic room.
 * @author Pinkfish
 * @started 30th of June
 */
#include <room.h>

private string _owner;
private string* _allowed;
private nosave string _save_file;
private nosave string _front_door;

protected int do_allow(string name);
protected int do_throwout(string name);
protected int do_disallow(string name);
void load_room();
varargs mixed call_door( string direc, 
                         string func, 
                         mixed arg1, 
                         mixed arg2, 
                         mixed arg3);
string query_owner();

void create() {
   _allowed = ({ });
   load_room();
} /* create() */

/** @ignore yes */
void init() {
   if (this_player()->query_name() == query_owner()) {
      add_command("room",
                  "allow <string'person'>",
                  (: do_allow($4[0]) :));
      add_command("room",
                  "disallow <string'person'>",
                  (: do_disallow($4[0]) :));
      add_command("room",
                  "throwout <indirect:living'person'>",
                  (: do_throwout($4[0]) :));
   }
} /* init() */

/**
 * This method sets the save file for the owned room.
 * @param save_file the name of the save file
 */
void set_save_file(string name) {
   _save_file = name;
} /* set_save_file() */

/**
 * This method returns the save file the owned room.
 * @return the save file for the owned room
 */
string query_save_file() {
   return _save_file;
} /* query_save_file() */

/**
 * This method returns the current allowed list on the room.
 * @return the current allowed array
 */
string *query_allowed() {
   return _allowed;
} /* query_allowed() */

/**
 * This method sets the allowed array for the room.
 * @param allowed the new allowed array.
 */
protected void set_allowed(string *allowed) {
   _allowed = allowed;
} /* set_allowed() */

/**
 * This method returns the owner of the room.
 * @return the owner of the room
 */
string query_owner() {
   return _owner;
} /* query_owner() */

/**
 * This method sets the owner of the room.
 * @param owner the new owner of the room
 */
void set_owner(string owner) {
   _owner = owner;
} /* set_owner() */

/**
 * This the main entry point for the allow command.
 * @paran name the name of the person to allow
 */
protected int do_allow(string name) {
   name = lower_case(name);
   if (member_array(name, _allowed) != -1) {
      add_failed_mess("The person " + name + " is already allowed.\n");
      return 0;
   }
   _allowed += ({ name });
   write("Ok, you have allowed " + name + " to enter your room.\n");
   return 1;
} /* do_allow() */

/**
 * This the main entry point for the disallow command.
 * @paran name the name of the person to disallow
 * @return 1 on succes, 0 on failure
 */
protected int do_disallow(string name) {
   name = lower_case(name);
   if (member_array(name, _allowed) == -1) {
      add_failed_mess("The person " + name + " is not allowed to disallow.\n");
      return 0;
   }
   _allowed -= ({ name });
   write("Ok, you have disallowed " + name + " from entering your room.\n");
   return 1;
} /* do_disallow() */

/**
 * This is the main entry point for the throwout command.
 * @param name the name of the person to throwout
 * @return 1 on success, 0 on failure
 */
protected int do_throwout(object *people) {
   object per;
   object *moved;

   moved = ({ });

   foreach (per in people) {
      if ( ROOM_HANDLER->exit_move( _front_door, 0, 0, per) ) {
         moved += ({ per });
      }
   }

   if (!sizeof(moved)) {
      add_failed_mess("Unable to move $I for some reason.\n", people);
      return 0;
   }

   add_succeeded_mess("$N throw$s $I out of the room.\n", moved);
   return 1;
} /* do_throwout() */

/**
 * This method sets the exit that is the front door.
 * @param exit the exit to use as the front door
 */
void set_front_door(string exit) {
   _front_door = exit;
} /* set_front_door() */

/**
 * This method queries the current front door.
 * @return the current front door
 */
string query_front_door() {
   return _front_door;
} /* query_front_door() */

/**
 * This method checks to see if they are allowed in.  Allow anyone in
 * if the room is not locked.
 * @param person the person to check
 * @return 1 if they are allowed in, 0 if not
 */
int is_allowed_in(string person) {
   person = lower_case(person);
   if (person != query_owner()) {
      if (call_door(_front_door,
                    "query_locked")) {
         if (member_array(person, _allowed) != -1) {
            return 0;
         }
      }
   }
   return 1;
} /* is_allowed_in() */

/**
 * This method tests to see if the person in question is either the owner
 * or is allowed.
 * @param person the person to check
 */
int is_allowed(string person) {
   if (person == query_owner() ||
       member_array(person, query_allowed()) != -1) {
      return 1;
   }
   return 0;
} /* is_allowed() */

/**
 * This method loads the room setup.
 */
void load_room() {
   if (_save_file) {
      restore_object(_save_file);
      // Default the room to a locked door.
      call_door(_front_door,
                "set_locked",
                1);
   }
} /* load_room() */

/**
 * This method saves the room setup.
 */
void save_room() {
   if (_save_file) {
      save_object(_save_file);
   }
} /* save_room() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/owned_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/honours.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/honours.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629462   Available: 13576816
Inodes: Total: 5242880    Free: 4960136
7317 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/honours.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629462   Available: 13576816
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room keeps track of the people who have been given the specified
 * honoury title and why.  It also makes sure that anyone who logs on
 * with the title is allowed to have it.
 * <p>
 * Don't forget to add the room to the title handler as controlling
 * this title.
 * @author Pinkfish
 * @started Wed Oct 17 13:15:03 PDT 2001
 */
#include <player_handler.h>
#include <player.h>

class honour {
   int time_added;
   string reason;
   string cap_name;
   string added_by;
}

private nosave string* _titles;
mapping _honours;


// This needs to be defined in the higher level.
int is_allowed_to_change(string person);
void save_me();

void create() {
   _honours = ([ ]);
   _titles = ({ });
} /* create() */

/**
 * This method does any informing about the change in the honour
 * status.
 * @param type add/remove
 * @param person the person being added/removed
 * @param reason the reason for the addition/removal
 * @param changed_by the person who did the change
 */
void inform_of_honour_change(string type, string person,
                      string reason, string changed_by) {
} /* inform_of_honour_change() */

/**
 * This method sets the title we are to control.
 * @param title the title to control
 */
void set_controlled_titles(string* title) {
   _titles = title;
} /* set_controlled_title() */

/**
 * This method returns the controlled title for the inherit.
 * @return the controlled title
 */
string* query_controlled_titles() {
   return _titles;
} /* quey_controlled_titles() */

/**
 * This method adds a person into the honour role with the specifed
 * reason.
 * @param person the person to honour
 * @param reason the reason they were added
 * @param added_by the person added by
 */
void add_to_honour_roll(string person, string reason, string added_by) {
   string title;

   if (_honours[person]) {
      return ;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      return ;
   }
   _honours[person] = new(class honour);
   _honours[person]->time_added = time();
   _honours[person]->reason = reason;
   _honours[person]->added_by = added_by;
   _honours[person]->cap_name = PLAYER_HANDLER->query_cap_name(person);
   foreach (title in _titles) {
      PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
   }
   save_me();
} /* add_to_honour_roll() */

/**
 * This removes the person from the honour role.
 * @param person the person to remove
 */
void remove_from_honour_roll(string person) {
   string title;

   if (!_honours[person]) {
      return ;
   }

   map_delete(_honours, person);
   if (find_player(person)) {
      foreach (title in _titles) {
         find_player(person)->remove_player_title(title);
      }
   }
   save_me();
} /* remove_from_honour_roll() */

/**
 * This method checks to see if the person is on the honour role.
 * @param person the person to check
 */
int is_on_honour_roll(string person) {
   return classp(_honours[person]);
} /* is_on_honour_roll() */

/**
 * List everyone on the honour roll.
 */
int do_list_honour() {
   string person;
   class honour roll;
   string ret;
   string* people;

   if (!_honours) {
      _honours = ([ ]);
   }
   if (!sizeof(_honours)) {
      add_failed_mess("There is no one on the honour roll.\n");
      return 0;
   }
   ret = "";
   people = sort_array(keys(_honours), (: _honours[$1]->time_added - _honours[$2]->time_added :));
   foreach (person in people) {
      roll = _honours[person];
      ret += "$I$3=%^YELLOW%^" + roll->cap_name + "%^RESET%^ at " +
             amtime(roll->time_added) +
             " for " + roll->reason + " by " + roll->added_by + "\n";
   }
   write("$P$Honour Roll$P$" + ret);
   return 1;
}

/**
 * This allows a person to be added to the honour roll.
 * @param person person to add
 * @param reason reason to add them
 */
int do_honour_add(string person) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }

   if (is_on_honour_roll(person)) {
      add_failed_mess("They are already on the honour roll.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("The person " + person + " does not exist.\n");
      return 0;
   }

   write("Enter the reason for adding " + person + " to the honour roll:\n");
   this_player()->do_edit("", "end_honour_add", this_object(), 0, person);
   add_succeeded_mess("");
   return 1;
} /* do_honour_add() */

/**
 * This is called by the editor when the reason has been set.
 * @param reason the reason for the addition
 * @param persno the person being added
 */
void end_honour_add(string reason, string person, string bing) {
   if (reason == "" || !reason) {
      write("Aborting.\n");
      return ;
   }

   write("Adding the person " + person + " to the honour roll with a reason "
         "of:\n" + reason + "\nAre you sure? ");
   input_to("honour_roll_confirm", 0, person, reason);
}

/**
 * This is called by the system to confirm the addition.
 * @Param response the yes/no response
 * @param reason the reason for the addition
 * @param persno the person being added
 */
void honour_roll_confirm(string response, string person, string reason) {
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting.\n");
      return ;
   }

   add_to_honour_roll(person, reason, this_player()->query_cap_name());
   inform_of_honour_change("add", person, reason,
                           this_player()->query_name());
   add_succeeded_mess("$N add$s " + person + " to the honour roll.\n");
   return ;
} /* honour_roll_confirm() */

/**
 * This allows a person to be removed from the honour roll.
 * @param person person to add
 * @param reason reason to add them
 */
int do_honour_remove(string person, string reason) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }

   if (!is_on_honour_roll(person)) {
      add_failed_mess("They are not on the honour roll.\n");
      return 0;
   }

   remove_from_honour_roll(person);
   inform_of_honour_change("remove", person, reason,
                           this_player()->query_cap_name());
   add_succeeded_mess("$N remove$s " + person + " to the honour roll.\n");
   return 1;
} /* do_honour_remove() */

/**
 * A method to go through and specifically readd everyone to the list.
 * This helps if something goes wrong and all the titles get lost.
 */
void readd_all_titles() {
   string person;
   class honour roll;

   foreach (person, roll in _honours) {
      foreach (string title in _titles) {
         PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
      }
   }
} /* readd_all_titles() */

void init() {
   if (!sizeof(_titles)) {
      return 0;
   }
   add_command("list", "honour [roll]", (: do_list_honour() :));
   if (is_allowed_to_change(this_player()->query_name())) {
      add_command("add",
                  "<string'person'> to honours",
                  (: do_honour_add($4[0]) :));
      add_command("remove",
                  "<string'person'> from honours because <string'reason'>",
                  (: do_honour_remove($4[0], $4[1]) :));
   }
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/honours.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/carriage/carriage.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/carriage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629461   Available: 13576815
Inodes: Total: 5242880    Free: 4960136
15602 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/carriage.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629461   Available: 13576815
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: carriage.c,v 1.8 2003/01/19 23:34:52 ceres Exp $
 *
 *
 */

/*** New and Improved Carriage
     Coded by Wodan, Deutha, Gototh, Terano, Pinkfish.
     Coded on 25th February, 1998

     Added a carriage bell, 24th March. Terano

     Mangled hacked and mostly rewrote by Pinkfish 2002.

***/

#include <room/carriage.h>

#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45

inherit "/std/room/basic_room";

private class route_details _route_info;
private string _carriage_name;
private string _exit_name;

private int _current_stop;
private int _next_stop;

private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;

private string _n_name;
private string _p_name;

int do_ring();
string query_environ_long();

/*
This mapping holds a few things:
The name of the location of the stop, the path of the stop,
how long it takes to get there from the last stop and how long
it will wait there.

ie:

route_info= (\ "Lancre Town", "/d/ram/lancre.c",100,60 \),
            (\ "Ohulan Cutash", "/d/ram/oc.c",100,45 \)
            (\ "Ankh Morpork", "/d/am/blue.c",200, 75 \)


This info is then referenced by an index.

*/

void create() {
    do_setup++;
    ::create();
    do_setup--;

    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );

    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);

   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );

   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );

   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }

} /* setup() */


void init() {

  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );

}//end init();

/**
 * This method should be overriden by higher level carriages to setup
 * the driver correctly.
 * @return the driver to use for this carriage
 */
object create_carriage_driver() {
   return 0;
}

/**
 * This method returns the name of the route the carriage is on.
 * @return the name of the carriage route.
 */
string query_carriage_name() { return _carriage_name; }

/**
 * This method returns the details of the current stop.
 * @return the details of the current stop
 */
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }

/**
 * This method returns the details of the next stop.
 * @return the details of the next stop
 */
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }

/**
 * This method returns the object that is the outside of us.
 * @return the environment of the carriage
 */
object query_outside() { return _outside; }

/**
 * This method returns the entire details of the route used by this
 * carriage.
 * @return the entire route details
 */
class route_details query_route_map() { return _route_info; }

/**
 * This method returns the indexes of the current stop and the
 * next stop.
 * @return ({ current stop, next stop })
 */
int *query_stop_info() { return ({ _current_stop, _next_stop }); }

/**
 * This is called by the handler to update the current route information
 * @param name the name of the rotue
 * @param new_route_info the new route to use
 * @param handler the handler for the carriage
 */
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   // Mess with the stop stuff.
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}

/**
 * This is called by the handler to originaly setup the current route
 * information.
 * @param name the name of the rotue
 * @param new_route_info the new route to use
 * @param handler the handler for the carriage
 */
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{

    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;

    _current_stop = 0;
    _next_stop = 1;


  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }

  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }

  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);

  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }

  return 1;
}//end make_carriage()


/**
 * Stop at the next location.
 */
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;

   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);

   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);

   _outside = load_object(path);

   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }


    /* Carriage has arrived at the new destination */

   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }

   if (!_fake_carriage) {

     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }

   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");

   /* Configure the inside of the carriage so passengers can disembark */
   add_exit("leave carriage", path, "corridor");

   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));

   add_alias("out", "leave carriage");


   /* Display information about the carriage to people outside. */
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n" 
      "The driver opens the carriage door.\n");

   if(objectp(_car_driver)) { 
     _car_driver->do_command("leave carriage");
     if( environment(_car_driver) != _outside ) {  
       _car_driver->move(_outside, "The " + _carriage_name + 
                         " carriage driver hops out of the carriage.", 
                         "The driver opens the door and leaps out.");
     }
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name
               + ".\n"); 
   }

   /* Let new passengers enter */

   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";

   _outside->add_exit(_exit_name, this_object(), "corridor"); 
   name_parts = explode(lower_case(_carriage_name), " "); 
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name); 
      _outside->add_alias("enter " + np + "s carriage", _exit_name); 
   }  
   _outside->add_alias("enter carriage", _exit_name);

/* Changed the modify exit to try to solve problems with messages in rooms
 * which use a linker object.  -- Furcifer, with thanks to Oaf for
 * pointing out this buglet.
 */
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;

      _outside->modify_exit(_exit_name, ({ 
                   "enter", "$N enter$s the carriage.\n", 
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({ 
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop, $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );

      linked_rooms = ( _outside->query_linker() )->query_rooms() 
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }

   /* Add the carriage to the description of the outside room */
   stop_room_chats();

   /* Start the Carriage on its way */
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
} /* reach_stop() */

int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
} /* check_can_leave() */

void give_warning(string this_stop_name, string next_stop_name) {

  if(objectp(_outside) && objectp(_car_driver) && 
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave for " +
                             next_stop_name + ".\n");
  }
} /* give_warning() */

void move_on() {
  string np;
  string* name_parts;

  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->do_command("enter " + lower_case(_carriage_name) + 
                            " carriage"); 
    if( environment(_car_driver) != this_object() ) {
      debug_printf("Driver: Tried to \"enter " +
                   lower_case(_carriage_name) + " carriage\" and "
                   "failed."); 
      _car_driver->move(this_object(), "The driver hops back in to the "
                        "carriage and gets ready to drive again.",
                        "The " + _carriage_name + " driver hops back "
                        "onto " + _car_driver->query_possessive() +  
                        " carriage.");  
    }
    _car_driver->next_stop_from_carriage(_n_name);  
    tell_room(this_object(), "The carriage starts moving again.\n");
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }

  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");

  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");

    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " "); 
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name); 
      _outside->remove_alias("enter " + np + "s carriage", _exit_name); 
    }  
    _outside->remove_alias("enter carriage", _exit_name);

    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }


  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);

  /* Clear the outside object */
  _outside = 0;

  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );

  this_object()->check_chat();

  call_out("make_stop", 30 );
} /* move_on() */

void dest_me() {
  string path;
  object ob;
  string np;
  string* name_parts;

  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " "); 
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name); 
      _outside->remove_alias("enter " + np + "s carriage", _exit_name); 
    }  
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }

  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  
  ::dest_me();

} /* dest_me() */

/** @ignore yes */
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
} /* query_quit_handler() */

mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}

int do_ring() {

  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));

    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->bell_ring(_n_name);
    } else {
      tell_room(this_object(), "Nothing much happens.\n");
    } 
    return 1;
  }

  call_out("move_on",2);
  if(objectp(_car_driver) && environment(_car_driver) == this_object()) {     
    _car_driver->do_command(":wakes with a start.");
  }
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;

} /* do_ring() */

string query_environ_long() {

  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to " 
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
} /* query_environ_long() */



// --- END [/mnt/home2/grok/lib/std/room/inherit/carriage/carriage.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/carriage/testhandler.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/testhandler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629456   Available: 13576810
Inodes: Total: 5242880    Free: 4960136
10558 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/testhandler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629456   Available: 13576810
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: handler.c,v 1.7 2002/08/19 00:39:01 pinkfish Exp $
 *
 *
 */

/**
 * Pinkfish's rewrite of the carriages.  March 2002.
 * @author Pinkfish
 * @started Mon Mar  4 23:34:31 PST 2002
 */

#include <room.h>
#include <data.h>
#include <room/carriage.h>

#define CARRIAGE ITEMS "carriage"

private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;

private void load_data();
private void map_carriages();

private void save_file() {
   unguarded((: save_object(_save_file) :));
}

void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}

/**
 * This method sets up the carriage handler stuff.  It sets up the pole
 * and the carriage items.
 * @param dir the directory of the data files
 * @param base_dir the base directory to use on the front of paths
 * @param carriage what to clone for the carriage
 * @param pole what to clone for a pole
 * @param save_file where to save the data
 */
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}

/**
 * Query the details of the route.  This returns everything about the
 * details and should not be used.
 * @return all the route details
 */
mapping query_route_details() { return _routedetails; }

/**
 * This method returns all the actual actual routes and where they are.
 * This should only be used for debugging purposes.
 * @return the actual route details
 */
mapping query_route_actual() { return _routesactual; }

/**
 * This method returns all the names of all the different routes in the
 * system.
 * @return the route names
 */
string* query_route_names() { return keys(_routesactual); }

/**
 * This method returns the location of the stop, the actual room.
 * @param name the name of the stop
 * @return the location of the stop
 */
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
} /* query_stop_location() */

/**
 * This method returns the name of the stop, the actual room.
 * @param name the name of the stop
 * @return the name of the stop
 */
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
} /* query_stop_name() */

/**
 * This method returns the delay of the stop, the actual room.
 * @param name the name of the stop
 * @return the delay of the stop
 */
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
} /* query_stop_delay() */

/**
 * This method returns the list of stops associated with the
 * route.
 * @param route the name of the route
 * @return the stops on the route
 */
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
} /* query_route_stops() */

/**
 * This method returns the carriage object on the specified route.
 * @param route the route to look for the carriage on
 * @return the carriage on the route
 */
object query_carriage_on_route(string route) {
   return _carriages[route];
}

private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;

   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }

   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
} /* parse_stop() */

private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;

   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }

   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];

   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }

   _routesactual[data["name"]] = info;
   save_file();
}

/** @ignore yes */
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;

   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }

   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}

/**
 * This method scans through all the files and sees if anything has
 * changed.
 */
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;

   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         // Directory!
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
} /* scan_for_new_data() */

private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}

void load_data() {
   scan_for_new_data();
} /* load_data() */

private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  //  class stop_details stop;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;

  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }

    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }

    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("test pole")) { 
          pole = room->query_property("test pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {   
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j], 
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }

    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else { 
       new_rods = rods;
    }

    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
} /* map_carriages() */

/** @ignore yes */
mixed* stats() {
   mixed* ret;
   string route;
   object ob;

   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) }); 
//      ret += ({ ({ route + "-stops", query_multiple_short(_routesactual[route]->stoplist) })  });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/carriage/testhandler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/carriage/testcar.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/testcar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629454   Available: 13576808
Inodes: Total: 5242880    Free: 4960136
14952 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/testcar.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629454   Available: 13576808
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: carriage.c,v 1.5 2002/08/19 00:39:11 pinkfish Exp $
 *
 *
 */

/*** New and Improved Carriage
     Coded by Wodan, Deutha, Gototh, Terano, Pinkfish.
     Coded on 25th February, 1998

     Added a carriage bell, 24th March. Terano

     Mangled hacked and mostly rewrote by Pinkfish 2002.

***/

#include <room/carriage.h>

#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45

inherit "/std/room/basic_room";

private class route_details _route_info;
private string _carriage_name;
private string _exit_name;

private int _current_stop;
private int _next_stop;

private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;

private string _n_name;
private string _p_name;

int do_ring();
string query_environ_long();

/*
This mapping holds a few things:
The name of the location of the stop, the path of the stop,
how long it takes to get there from the last stop and how long
it will wait there.

ie:

route_info= (\ "Lancre Town", "/d/ram/lancre.c",100,60 \),
            (\ "Ohulan Cutash", "/d/ram/oc.c",100,45 \)
            (\ "Ankh Morpork", "/d/am/blue.c",200, 75 \)


This info is then referenced by an index.

*/

void create() {
    do_setup++;
    ::create();
    do_setup--;

    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );

    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);

   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );

   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );

   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }

} /* setup() */


void init() {

  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );

}//end init();

/**
 * This method should be overriden by higher level carriages to setup
 * the driver correctly.
 * @return the driver to use for this carriage
 */
object create_carriage_driver() {
   return 0;
}

/**
 * This method returns the name of the route the carriage is on.
 * @return the name of the carriage route.
 */
string query_carriage_name() { return _carriage_name; }

/**
 * This method returns the details of the current stop.
 * @return the details of the current stop
 */
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }

/**
 * This method returns the details of the next stop.
 * @return the details of the next stop
 */
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }

/**
 * This method returns the object that is the outside of us.
 * @return the environment of the carriage
 */
object query_outside() { return _outside; }

/**
 * This method returns the entire details of the route used by this
 * carriage.
 * @return the entire route details
 */
class route_details query_route_map() { return _route_info; }

/**
 * This method returns the indexes of the current stop and the
 * next stop.
 * @return ({ current stop, next stop })
 */
int *query_stop_info() { return ({ _current_stop, _next_stop }); }

/**
 * This is called by the handler to update the current route information
 * @param name the name of the rotue
 * @param new_route_info the new route to use
 * @param handler the handler for the carriage
 */
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   // Mess with the stop stuff.
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}

/**
 * This is called by the handler to originaly setup the current route
 * information.
 * @param name the name of the rotue
 * @param new_route_info the new route to use
 * @param handler the handler for the carriage
 */
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{

    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;

    _current_stop = 0;
    _next_stop = 1;


  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }

  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }

  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);

  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }

  return 1;
}//end make_carriage()


/**
 * Stop at the next location.
 */
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;

   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);

   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);

   _outside = load_object(path);

   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }


    /* Carriage has arrived at the new destination */

   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }

   if (!_fake_carriage) {

     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }

   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");

   /* Configure the inside of the carriage so passengers can disembark */
   add_exit("leave carriage", path, "corridor");

   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));

   add_alias("out", "leave carriage");


   /* Display information about the carriage to people outside. */
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n" 
      "The driver opens the carriage door.\n");

   if(objectp(_car_driver)) { 
     _car_driver->move(_outside, "The " + _carriage_name + " carriage "
       "driver hops out of the carriage.", "The driver opens the door "
       "and leaps out.");
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name + ".\n");
   }

   /* Let new passengers enter */

   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";

   _outside->add_exit(_exit_name, this_object(), "corridor"); 
   name_parts = explode(lower_case(_carriage_name), " "); 
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name); 
      _outside->add_alias("enter " + np + "s carriage", _exit_name); 
   }  
   _outside->add_alias("enter carriage", _exit_name);

/* Changed the modify exit to try to solve problems with messages in rooms
 * which use a linker object.  -- Furcifer, with thanks to Oaf for
 * pointing out this buglet.
 */
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;

      _outside->modify_exit(_exit_name, ({ 
                   "enter", "$N enter$s the carriage.\n", 
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({ 
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );

      linked_rooms = ( _outside->query_linker() )->query_rooms() 
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }

   /* Add the carriage to the description of the outside room */
   stop_room_chats();

   /* Start the Carriage on its way */
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
} /* reach_stop() */

int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
} /* check_can_leave() */

void give_warning(string this_stop_name, string next_stop_name) {

  if(objectp(_outside) && objectp(_car_driver) && 
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave to " +
                             next_stop_name + ".\n");
  }
} /* give_warning() */

void move_on() {

  string* name_parts;

  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->move(this_object(), "The driver hops back in to the carriage "
      "and gets ready to drive again.", "The " + _carriage_name + 
      " driver hops back onto " + _car_driver->query_possessive() + 
      " carriage.");  
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }

  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");

  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");

    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " "); 
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name); 
      _outside->remove_alias("enter " + np + "s carriage", _exit_name); 
    }  
    _outside->remove_alias("enter carriage", _exit_name);

    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }

  if (objectp(_car_driver)) {
     _car_driver->next_stop_from_carriage(_n_name);	
  }

  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);

  /* Clear the outside object */
  _outside = 0;

  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );

  this_object()->check_chat();

  call_out("make_stop", 30 );
} /* move_on() */

void dest_me() {
  string path;
  object ob;
  string* name_parts;

  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " "); 
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name); 
      _outside->remove_alias("enter " + np + "s carriage", _exit_name); 
    }  
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }

  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  
  ::dest_me();

} /* dest_me() */

/** @ignore yes */
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
} /* query_quit_handler() */

mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}

int do_ring() {

  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));

    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->do_command("scowl");
      _car_driver->do_command("'We won't reach " + _n_name + " any faster just "
        "cause you ring that danged bell!");
    }
    return 1;
  }

  call_out("move_on",2);
  _car_driver->do_command(":wakes with a start.");
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;

} /* do_ring() */

string query_environ_long() {

  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to " 
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
} /* query_environ_long() */



// --- END [/mnt/home2/grok/lib/std/room/inherit/carriage/testcar.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_pole.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_pole.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629450   Available: 13576804
Inodes: Total: 5242880    Free: 4960136
2246 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_pole.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629450   Available: 13576804
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
inherit "/std/object";

void setup_route(string *ss, string c, string r);
string *notes = ({});

void setup() {

  set_name( "pole" );

  set_short("wooden pole");
  add_adjective( "wooden" );
  
  set_long("This is a wooden pole.  It's fairly unexciting.\n");
  set_weight( 10000 );

  add_property( "there", ( ({"casually placed in a corner",
                             "here",
                             "standing on the side of the road",
                             "trying to be noticed"})
                          [random(4)]));
  add_extra_look(this_object());

  reset_get();

} /* setup() */


void setup_route( string *stops, string colour, string route) {

  object note;
  string language; // Part of a Bad, Temp Solution
  string pathofhere;

  if(member_array(colour + " note", notes) != -1) {
    return;
  }

  notes += ({ colour + " note" });

  pathofhere = file_name(environment(this_object()));

  /* Right. The following is a horrible hack, it'd be much nicer if
   * there was a way to find out the correct language for an area,
   * preferrably through some sort of query() somewhere. :)
   *
   * - Danbala, Aug 2002
   */
  if(strsrch(pathofhere, "/d/am/") != -1) 
    language = "morporkian";
  if(strsrch(pathofhere, "/d/cwc/") != -1) 
    language = "agatean";
  if(strsrch(pathofhere, "/d/klatch/") != -1) 
    language = "djelian";
  if(strsrch(pathofhere, "/d/ram/") != -1) 
    language = "morporkian";
  if(strsrch(pathofhere, "/d/ram/Uberwald/") != -1) 
    language = "uberwaldean"; 
  if(strsrch(pathofhere, "/d/sur/") != -1) 
    language = "morporkian";

  note = clone_object(__DIR__ + "carriage_note"); 
  note->setup_route(stops, colour, route, language);
  environment(this_object())->add_hidden_object(note);
  environment(this_object())->add_property("carriage pole",
    this_object());   

  if(sizeof(notes)) {
    set_short("wooden pole with " + (query_multiple_short(map( notes,
    (: add_a($1) :)))) + " attached to it") ;
  }

} /*setup_route()*/

string extra_look() {

  if(sizeof(notes)) {
    return capitalize((query_multiple_short(map( notes, (: add_a($1) :)))) + 
      ((sizeof(notes) > 1) ? " are" : " is") + " attached to the pole.\n") ;
  }

  return "";

} /* extra look */

// --- END [/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_pole.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_note.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_note.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629449   Available: 13576803
Inodes: Total: 5242880    Free: 4960136
1092 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_note.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629449   Available: 13576803
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

inherit "/std/object";

void setup_route(string* a, string b, string c, string d);

void setup() {

  set_name( "note" );

  set_short(  "Test note" ) ;

  set_long( "This note is probably broken, please contact a "
    "creator. :)\n" ); 
  reset_get();

  add_alias( "table" );

} /* setup() */

void setup_route(string* stops, string colour, string route, string language) {

  string prettystops = "";
  int i;

  set_short(route + " table");
  add_adjective(map(explode(route, " "), (: lower_case($1) :))); 
  add_adjective(colour);
  add_alias("table");
  add_alias("cardboard");
  add_adjective(({"piece", "of", colour}));

  set_long("This is the table for the " + route + " route.  It is "
    "printed on a piece of sturdy " + colour + " cardboard, and stuck "
    "firmly to the pole.\n");   

  for(i = 0; i < sizeof(stops) - 1; i++) {
    prettystops += capitalize(stops[i]) + "\n";
  }
  prettystops += "and back to " + stops[sizeof(stops) - 1];

  add_read_mess("\nThe " + route + " route:\n" +
    prettystops + ".\n",
    "bold letters", language);

} /* setup_route() */


// --- END [/mnt/home2/grok/lib/std/room/inherit/carriage/carriage_note.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/carriage/handler.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629449   Available: 13576803
Inodes: Total: 5242880    Free: 4960136
10565 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/carriage/handler.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629449   Available: 13576803
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker:  $
 * $Id: handler.c,v 1.8 2002/08/30 11:21:08 danbala Exp $
 *
 *
 */

/**
 * Pinkfish's rewrite of the carriages.  March 2002.
 * @author Pinkfish
 * @started Mon Mar  4 23:34:31 PST 2002
 */

#include <room.h>
#include <data.h>
#include <room/carriage.h>

#define CARRIAGE ITEMS "carriage"

private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;

private void load_data();
private void map_carriages();

private void save_file() {
   unguarded((: save_object(_save_file) :));
}

void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}

/**
 * This method sets up the carriage handler stuff.  It sets up the pole
 * and the carriage items.
 * @param dir the directory of the data files
 * @param base_dir the base directory to use on the front of paths
 * @param carriage what to clone for the carriage
 * @param pole what to clone for a pole
 * @param save_file where to save the data
 */
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}

/**
 * Query the details of the route.  This returns everything about the
 * details and should not be used.
 * @return all the route details
 */
mapping query_route_details() { return _routedetails; }

/**
 * This method returns all the actual actual routes and where they are.
 * This should only be used for debugging purposes.
 * @return the actual route details
 */
mapping query_route_actual() { return _routesactual; }

/**
 * This method returns all the names of all the different routes in the
 * system.
 * @return the route names
 */
string* query_route_names() { return keys(_routesactual); }

/**
 * This method returns the location of the stop, the actual room.
 * @param name the name of the stop
 * @return the location of the stop
 */
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
} /* query_stop_location() */

/**
 * This method returns the name of the stop, the actual room.
 * @param name the name of the stop
 * @return the name of the stop
 */
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
} /* query_stop_name() */

/**
 * This method returns the delay of the stop, the actual room.
 * @param name the name of the stop
 * @return the delay of the stop
 */
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
} /* query_stop_delay() */

/**
 * This method returns the list of stops associated with the
 * route.
 * @param route the name of the route
 * @return the stops on the route
 */
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
} /* query_route_stops() */

/**
 * This method returns the carriage object on the specified route.
 * @param route the route to look for the carriage on
 * @return the carriage on the route
 */
object query_carriage_on_route(string route) {
   return _carriages[route];
}

private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;

   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }

   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
} /* parse_stop() */

private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;

   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }

   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];

   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }

   _routesactual[data["name"]] = info;
   save_file();
}

/** @ignore yes */
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;

   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }

   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}

/**
 * This method scans through all the files and sees if anything has
 * changed.
 */
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;

   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         // Directory!
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
} /* scan_for_new_data() */

private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}

void load_data() {
   scan_for_new_data();
} /* load_data() */

private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  //  class stop_details stop;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;

  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }

    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }

    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("carriage pole")) { 
          pole = room->query_property("carriage pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {   
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j], 
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }

    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else { 
       new_rods = rods;
    }

    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
} /* map_carriages() */

/** @ignore yes */
mixed* stats() {
   mixed* ret;
   string route;
   object ob;

   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) }); 
//      ret += ({ ({ route + "-stops", query_multiple_short(_routesactual[route]->stoplist) })  });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
} /* stats() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/carriage/handler.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/scripting.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/scripting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629446   Available: 13576800
Inodes: Total: 5242880    Free: 4960136
25476 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/scripting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629446   Available: 13576800
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the standard inheritable to enable players to script npcs.
 * <p>
 * All you need to do is inherit this file, make sure you call the ::init,
 * and make sure you have a few functions defined in your context.
 * <p>
 * If you are not using a player shop inherit then you must ensure that
 * is_allowed( name ) returns 1 if the player is allowed to edit scripts
 * in this object.
 * <p>
 * You will need to write your own find_npc() function, since this is
 * extremely sensitive to the implementation.  For reference check out
 * the one which will be written for player controlled shops.
 * <p>
 * It is assumed that a save object will be inherited, if not
 * then event_save() will need to be defined.
 *
 *
 * @example
 * inherit "/std/room/scripting";
 * inherit "/std/room";
 *
 * void init(){
 *    scripting::init();
 *    ..
 * }
 *
 * void setup(){
 *    ..
 *    add_help_file( DOCS +"scripting" );
 * }
 * @see trigger_thingy(), return_script()
 *
 * @author Nofear
 */
#include <expressions.h>
#include "nroff.h";
//edit
//#define PATH "/w/nofear/scripting/"

inherit "/std/basic/expressions";

#define SCRIPTING_WAIT_COMMAND  1
#define SCRIPTING_COMMAND       2
#define SCRIPTING_EXPRESSION    3
#define SCRIPTING_GOTO          4
#define SCRIPTING_TRIGGER_EVENT 5

/**
 * This class contains each element of the script itself.
 * @param type if it is a simple string or a complex expression
 * @param actor the person doing stuff
 * @param action the action to preform
 * @param expr the expression
 * @param number a number
 */
class script_data {
   int type;
   string actor;
   string str;
   class parse_node* expr;
   int number;
}

class script {
   string* valid_actors;
   class script_data* data;
   int priority;
}

class running_script {
   class script script;
   int position;
   object who;
   string who_name;
   string who_short;
   int run_priority;
}

private mapping _script_data;

private nosave int _callout_tag;

// Stack them.  We will only do one at a time, but we could potentially
// do another after the first one has finished.
private nosave class running_script* _running_scripts;

// Predefines.

object find_npc( string what );

int is_allowed( string name );
void event_save( object ob );

/* public functions */

/**
 * This returns the script associated with the event.
 * @param name The name of the script.
 * @returns *string The content of the script, or an empty array.
 */
class script query_script( string name ){
   return _script_data[name];
} /* return_script() */

private void add_running_script(class running_script script) {
   if (!sizeof(_running_scripts)) {
      _running_scripts += ({ script });
      return ;
   }
}

/**
 * This function is called to activate a script in this object.
 * ( Can be left blank, best to use file_name( this_player() ) ).
 * @param event the name of the event to be triggered,
 * @param who a reference to the object who triggered the event
 * @param override the override for the priority
 */
void trigger_script( string event, object who, int override ){
   int i;
   class script this_script;
   class running_script running;

   this_script = query_script( event );

   if (!this_script || !objectp(who)) {
      return;
   }

   running = new(class running_script);
   running->script = this_script;
   running->who = who;
   running->position = 0;
   running->who_name = who->query_name();
   running->who_short = who->the_short();
   if (undefinedp(override)) {
      running->run_priority = this_script->priority;
   } else {
      running->run_priority = override;
   }
   add_running_script(running);
} /* trigger_thingy() */

/**
 * This function is called by trigger_thingy and by itself.
 * <p>
 * You could mask this if you need to restrict what the npcs are allowed
 * to say.
 *
 * @param this_script the script contents,
 * @param num the line number we are up to
 * @param who the person we are looking at
 */
void repeat_loop() {
   object npc;
   class script_data data;
   string str;
   class parse_node node;

   if (!sizeof( _running_scripts ) ) {
      return;
   }

   if (_running_scripts[0]->position >= sizeof(_running_scripts[0]->script)) {
      _running_scripts = _running_scripts[1..];
      if (!sizeof( _running_scripts ) ) {
         return;
      }
   }

   data = _running_scripts[0]->script->data[_running_scripts[0]->position];
   _running_scripts[0]->position++;
   _callout_tag = call_out( "repeat_loop", 2);

   switch ( data->type) {
   case SCRIPTING_WAIT_COMMAND :
      remove_call_out(_callout_tag);
      _callout_tag = call_out( "repeat_loop",  data->number);
      return;
   case SCRIPTING_COMMAND :
      npc = find_npc( data->actor );

      if( !npc ){
         repeat_loop();
         return;
      }

      npc->do_command( data->str );
      break;
   case SCRIPTING_EXPRESSION :
      node = evaluate_expresion(data->expr);
      if (node->type == EXPRESSION_TYPE_STRING) {
         npc = find_npc( data->actor );

         if (!npc) {
            repeat_loop();
            return ;
         }
         npc->do_command( data-> str );
      }
      break;
   case SCRIPTING_GOTO :
      _running_script[0]->position = data->number;
      break;
   case SCRIPTING_TRIGGER_EVENT :
      // Make this one happen first.
      trigger_script(data->name, _running_script[0]->npc, 
                     _running_script[0]->run_priority | PRIORITY_FRONT);
      break;
   }

   call_out("repeat_loop");
} /* repeat_loop() */

/**
 * This method sets the script to the new value.
 * @param name the event to override
 * @param script the new script
 */
void set_script(string name, class script script) {
   _script_data[name] = script;
   event_save(this_object());
} /* set_script() */

/**
 * This method sets the script data.
 * @param name the event to set the data for
 * @param data the script data
 */
void set_script_data(string name, class script_data* data) {
   if (_script_data[name]) {
      _script_data[name]->data = data;
      event_save(this_object());
   }
} /* set_script_data() */

/**
 * This method sets the actors associated with the script.
 * @param name the name of the event to set the data for
 * @param actors the actors for the script
 */
void set_script_actors(string name, string* actors) {
   if (_script_data[name]) {
      _script_data[name]->actors = actors;
      event_save(this_object());
   }
} /* set_script_actors() */

/**
 * This method replaces the script data at the specified location in
 * the script with a new item.
 * @param name the script name
 * @param pos the position to replace
 * @param data the data to replace it with
 * @return 1 on success, 0 on failure
 */
int set_script_data_location(string name, int pos, class script_data data) {
   if (_script_data[name] &&
       pos >= 0 && pos < sizeof(_script_data[name]->data)) {
      _script_data[name]->data[pos] = data;
      event_save(this_object());
      return 1;
   }
   return 0;
} /* set_script_data_location() */

/**
 * This method deletes the script data at the specified location.
 * @param name the script name
 * @param pos the position to replace
 * @return 1 on success, 0 on failure
 */
int delete_script_data_location(string name, int pos) {
   if (_script_data[name] &&
       pos >= 0 && pos < sizeof(_script_data[name]->data)) {
      _script_data[name]->data = _script_data[name]->data[0..pos-1] +
                                 _script_data[name]->data[pos+1..];
      event_save(this_object());
      return 1;
   }
   return 0;
} /* delete_script_data_location() */

/**
 * This method inserts a data element before the specified position in the
 * script.  If the position is 0 then the element is inserted at the start,
 * if the position is beyond the end of the array, then the item is inserter
 * at the end.
 * @param name the script name
 * @param pos the position to insert before
 * @param data the data to replace it with
 */
int insert_script_data_before(string name, int pos, class script_data data) {
   if (_script_data[name]) {
      _script_data[name]->data = _script_data[name]->data[0..pos-1] +
                                 ({ data }) +
                                 _script_data[name]->data[pos..];
      event_save(this_object());
      return 1;
   }
   return 0;
} /* insert_script_data_before() */

/* Internal workings - not much use to anything else. */


/** @ignore yes 
 *  This occurs during script creation.
 */
void menu_prompt(string name, class* script) {
   tell_object( this_player(), "Enter the name of the person who should "
      "perform an action ( or another command such as \"wait\" ).\n" );
   print_commands();
   input_to( "menu_input", 0, name, script );
} /* name_prompt() */

private int query_pos_from_string(string str) {
   if (bits[2] == "begining") {
      return 0;
   } else if (bits[2] == "end") {
      return sizeof(script->data);
   } else {
      pos = to_int(bits[2]);
   }
   if (pos < 0 || pos > sizeof(script->data)) {
      return -1;
   }
   return pos;
} /* query_pos_from_string() */

/** @ignore yes 
 *  This occurs during script creation.
 */
void menu_input( string input, string name, class script script ){
   string* bits;

   bits = explode(lower_case(input), " ");
   switch (lower_case(bits[0])) {
   case "h" :
   case "help" :
      show_help();
      break;
   case "s" :
   case "save" :
      set_script(name, script);
      break;
   case "q" :
   case "quit" :
      write("Are you sure you want to quit and "
         "lose the current script?\n" );
      input_to( "check_quit", 0, name, script );
      return ;
   case "l" :
   case "list" :
      write(query_script_string(script));
      break;
   case "a" :
   case "add" :
      // add <person> <pos|end|begining>
      if (sizeof(bits) != 3) {
         write("Syntax: add <person> <pos|end|begining>\n");
      } else if (lower_case(bits[1]) != "wait" &&
                 member_array(bits[1], script->actors) == -1) {
         write("The actor must be one of " +
               query_multiple_short(script->actors)  + " not " +
               bits[1] + ".\n");
      } else {
         pos = query_pos_from_string(bits[2]);
         if (pos != -1) {
            write("Which command do you want to execute for " + bits[1] +
                  "?\n: ");
            input_to("enter_command", 0, name, script, bits[1], pos);
         } else {
            write("The position must be in the range 0.." +
                  sizeof(script->data) + " or 'begining' or 'end'.\n");
         }
      }
      break;
   case "d" :
   case "delete" :
      if (sizeof(bits) != 2) {
         write("Syntax: delete <pos|end|begining>\n");
      } else {
         pos = query_pos_from_string(bits[2]);
         if (pos != -1) {
         } else {
            write("The position must be in the range 0.." +
                  sizeof(script->data) + " or 'begining' or 'end'.\n");
         }
      }
      break;
   default :
      write("Invalid command " + bits[1] + ".\n");
   }

   menu_prompt(name, script);
} /* input_name() */

/** @ignore yes 
 *  This occurs during script creation.
 */
protected void enter_command( string input, string name, class script script ) {
   if( _temp_script->script[sizeof( _temp_script->script ) - 1] == "wait" ){
      if( !to_int(input) ){
         tell_object( this_player(), "%^BOLD%^For the wait command you "
            "must enter a whole value for the number of seconds "
            "to wait%^RESET%^.\n" );
         prompt_command();
         return;
      }
   }

   _temp_script->script = _temp_script->script + ({input});

   tell_object( this_player(), "Enter the name of the person who should "
      "perform an action ( or another command such as \"wait\" ).\n" );
   print_commands();
   input_to( "input_name" );
} /* input_command() */

/** @ignore yes 
 *  This occurs during script creation.
 */
void print_commands(){
   tell_object( this_player(), "Command [ h for help ]:\n" );
} /* print_commands() */

/** @ignore yes 
 *  This occurs during script creation.
 */
void show_help(){
   string str;
//edit change path or filename of nroff file.
   str = unguarded((: NROFF_HAND->cat_file("/doc/room/scripting_nroff", 1) :));
   if(!str){
     unguarded((: NROFF_HAND->create_nroff(PATH +"scripting_online_help",
        PATH +"scripting_nroff") :));
     str = unguarded((:NROFF_HAND->cat_file(PATH +"scripting_nroff", 0):));
   }

   write(str);
} /* show_help() */

/** @ignore yes 
 *  This occurs during script creation if player enters "q".
 */
void query_quit( string input, string func ){
   if( (input == "y") || (input == "yes") || (input == "Y") ){
      write("Okay, quitting.\n" );
   }else{
      write("%^BOLD%^You did not enter \"y\" "
         "or \"yes\" so you are not being quitted.%^RESET%^\n" );
      call_other( this_object(), func );
   }
} /* query_quit() */

/**
 * This sets the specific script to the new value.
 */
void set_script(string name, class scripting* script) {
   write("Saving current script and exiting.\n" );

   _scripts[name] = script;

   event_save( this_object() );
} /* save_script() */

/**
 * This returns a printable string of the script.
 * @param  script the script to turn into a string
 * @return the string version of the script
 */
string query_script_string( class scripting* script ){
   int i;
   string str;

   if( _temp_script->tag == "" ) {
      return;
   }

   str = "\nScript name \""+ _temp_script->tag + ":\n\n";

   for( i = 0; i < sizeof(_temp_script->script); i++ ){
      str += _temp_script->script[i]->name +"  :  ";
      str += _temp_script->script[i]->action +"\n";
   }

   str += "\n";

   return str;
} /* view_script() */

/** @ignore yes 
 *  This is called by delete_script_command.
 *  Num is the index of script to delete.
 */
void query_delete( string input, int num ){
   if( (input == "y") || (input == "yes") || (input == "Y") ){
      tell_object( this_player(), "Okay, removing script.\n" );
      if( sizeof(_script_data) == 1 ){
         _script_data = ({});
      }else if( sizeof(_script_data) == 2 ){
         _script_data = ({_script_data[!num]});
      }else{
         if( !num ){
            _script_data = _script_data[1..];
         }else{
            _script_data = _script_data[0..(num - 1)] +
               _script_data[(num + 1)..];
         }
      }
      event_save( this_object() );
   }else{
      tell_object( this_player(), "%^BOLD%^You did not enter \"y\" or "
         "\"yes\" so the script will not be deleted.%^RESET%^\n" );
   }
   _temp_script->tag = "";
   _temp_script->script = ({});
} /* query_delete() */

/** @ignore yes
  * This function returns the index of the script "input", or -1.
  */
int get_index( mixed input ){
   int i;

   if( to_int( input ) ){
      i = to_int( input );
      if( i > sizeof(_script_data) ){
         tell_object( this_player(), "Invalid option, quitting.\n" );
         return -1;
      }else{
         return i - 1;
      }
   }else{
      for( i = 0; i < sizeof(_script_data); i++ ){
         if( _script_data[i]->tag == input ) return i;
      }
      tell_object( this_player(), "Invalid option, quitting.\n" );
      return -1;
   }
} /* get_index() */

/** @ignore yes
  * Ugly function alert!
  * This recalls itself until the player is done editing.
  */
void edit_script( string input, int which ){
   string *comm, command, text;
   int line, i;

   if( input == "" ){
      input_to( "edit_script", 0, which );
      tell_object( this_player(), "Command [ R(eplace), D(elete), "
         "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
      return;
   }

   command = "";
   line = -1;
   text = "";

   comm = explode( input, " " );
   if( sizeof(comm) ) command = comm[0];
   if( sizeof(comm) > 1) line = to_int(comm[1]) - 1;
   if( sizeof(comm) > 2){
      comm = comm[2..];
      text = implode(comm, " ");
   }

   switch (command){
      case "s" :
      case "S" :
         tell_object( this_player(), "Done editing script.\n" );
         _script_data[which]->script = _temp_script->script;
         return;
      case "q" :
      case "Q" :
         tell_object( this_player(), "Quitting without saving changes.\n");
         return;
      case "v" :
      case "V" :
         for( i = 0; i < sizeof(_temp_script->script); i++ )
            tell_object(this_player(),(i+1) +"  "+
               _temp_script->script[i] +"\n");
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
            return;

      case "d" :
      case "D" :
         if( (line < 0) || ((line +1) > sizeof(_temp_script->script)) ){
            tell_object( this_player(), "For this command you need to "
               "enter a valid line number.\n" );
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n");
            return;
         }
         if( sizeof(_temp_script->script) == 1 ){
            _temp_script->script = ({});
         }else if( sizeof(_temp_script->script) == 2 ){
            _temp_script->script = ({_temp_script->script[!line]});
         }else{
            _temp_script->script = _temp_script->script[0..(line-1)] +
                _temp_script->script[line+1..];
         }
         tell_object( this_player(), "Line "+ (line+1) +" deleted.  "
            "Please note that the line numbers for the rest of the "
            "script may have been effected by this change.\n" );
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;

      case "r" :
      case "R" :
         if( (line < 0) || ((line +1) > sizeof(_temp_script->script)) ){
            tell_object( this_player(), "For this command you need to "
               "enter a valid line number.\n" );
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
            return;
         }
         tell_object( this_player(), "Replacing line "+ (line+1) +" with \""+
            text +"\".\n" );
         _temp_script->script[line] = text;
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;
      case "i" :
      case "I" :
         if( (line < 0) || ((line +1) > sizeof(_temp_script->script)) ){
            tell_object( this_player(), "For this command you need to "
               "enter a valid line number.\n" );
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
            return;
         }
         tell_object( this_player(), "Inserting \""+ text +"\" at line "+
            (line+1) +".  Please note that the line numbers for the rest "
            "of the script may have been effected by this change.\n" );
         if( !line ){
            _temp_script->script = ({text}) + _temp_script->script;
         }else{
            _temp_script->script = _temp_script->script[0..(line-1)] +
               ({text}) + _temp_script->script[line..];
         }
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;

      default :
         tell_object( this_player(),"%^BOLD%^Unknown command.\n%^RESET%^");
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;
   } /* switch */
} /* edit_script() */

/* Command functions */

/** @ignore yes 
 *  Command response 
 */
int do_add_script( string input ){
   if( input == "" ){
      tell_object( this_player(),
         "You must enter a name for the script.\n" );
      add_succeeded_mess( "" );
      return 1;
   }

   if( return_script( input ) != ({}) ){
      tell_object( this_player(), "%^BOLD%^There is already a script for \""+
         input +"\", if you wish to keep the existing version then quit "
         "now and start over, if you continue the new version will "
         "replace the old one.%^RESET%^\n" );
   }else{
      tell_object( this_player(), "This script will be known as \""+
         input +"\".\n" );
   }

   _temp_script = new(class fancy_hat, tag : input, script : ({}) );

    tell_object( this_player(), "Enter the name of the person who should "
      "perform an action, or another command such as \"wait\". eg\n\n"
      "  \"mike\"\n"
      "  \"thug1\"\n"
      "  \"wait\"\n" );
   print_commands();
   input_to( "input_name" );
   add_succeeded_mess( "$N begin$s to write a new script.\n" );
   return 1;
} /* do_add_script() */

/** @ignore yes 
 *  Command response 
 */
int do_list_scripts(){
   int i;
   if( !sizeof(_script_data) ){
      this_player()->add_failed_mess( this_object(),
         "No scripts found.\n" );
      return 0;
   }

   tell_object(this_player(), sizeof(_script_data) +" scripts found:\n\n");

   for( i = 0; i < sizeof(_script_data); i++ )
      tell_object( this_player(), (i +1) +"  "+ _script_data[i]->tag +"\n");

   add_succeeded_mess( "" );
   return 1;
} /* do_list_scripts() */

/** @ignore yes 
 *  Command response 
 */
int do_view_script( mixed input ){
   int num;

   num = get_index( input );

   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }

   if( undefinedp( _temp_script ) ){
      _temp_script = new( class fancy_hat,
      tag : _script_data[num]->tag, script : _script_data[num]->script );
   }else{
      _temp_script->tag = _script_data[num]->tag;
      _temp_script->script = _script_data[num]->script;
   }

   view_script(1);
   add_succeeded_mess( "" );
   return 1;
} /* do_view_script() */

/** @ignore yes 
 *  Command response 
 */
int do_test_script( mixed input ){
   int num;

   num = get_index( input );

   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }

   tell_object( this_player(), "Triggering event \""+
      _script_data[num]->tag +"\".\n" );

   trigger_thingy( _script_data[num]->tag, file_name( this_player()) );
   add_succeeded_mess( "" );
   return 1;
} /* do_test_script() */

/** @ignore yes 
 *  Command response 
 */
int do_delete_script( mixed input ){
   int num;

   num = get_index( input );

   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }

   if( undefinedp( _temp_script ) ){
      _temp_script = new( class fancy_hat,
      tag : _script_data[num]->tag, script : _script_data[num]->script );
   }else{
      _temp_script->tag = _script_data[num]->tag;
      _temp_script->script = _script_data[num]->script;
   }

   tell_object( this_player(), "Are you sure that you want to "
      "permanently remove the script \""+ _temp_script->tag +"\"?\n" );
   input_to( "query_delete", 0, num );
   add_succeeded_mess( "" );
   return 1;
} /* do_delete_script() */

/** @ignore yes 
 *  Command response 
 */
int do_edit_script( mixed input ){
   int num, i;

   num = get_index( input );

   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }

   if( undefinedp( _temp_script ) ){
      _temp_script = new( class fancy_hat,
      tag : _script_data[num]->tag, script : _script_data[num]->script );
   }else{
      _temp_script->tag = _script_data[num]->tag;
      _temp_script->script = _script_data[num]->script;
   }

   tell_object( this_player(), "Editing script \""+ _temp_script->tag +
      "\".\n\nThis is a complete listing of the script:\n" );

   for( i = 0; i < sizeof(_temp_script->script); i++ ){
      tell_object(this_player(),(i+1) +"  "+ _temp_script->script[i] +"\n");
   }

   tell_object( this_player(), "Command [ R(eplace), D(elete), I(nsert), "
      "V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
   input_to( "edit_script", 0, num );

   add_succeeded_mess( "" );
   return 1;
} /* do_edit_script() */

/** @ignore yes */
void init(){
   if( !is_allowed( this_player()->query_name() ) ) {
      return;
   }

   add_command( "add",
      "script <string'name'>", (: do_add_script( $4[0] ) :) );

   add_command( "list", "scripts",
      (: do_list_scripts() :) );

   add_command( "view",
      "script <string'name'>", (: do_view_script( $4[0] ) :) );
   add_command( "view",
      "script <number>", (: do_view_script( $4[0] ) :) );

   add_command( "test",
      "script <string'name'>", (: do_test_script( $4[0] ) :) );
   add_command( "test", this_object(),
      "script <number>", (: do_test_script( $4[0] ) :) );

   add_command( "delete",
      "script <string'name'>", (: do_delete_script( $4[0] ) :) );
   add_command( "delete",
      "script <number>", (: do_delete_script( $4[0] ) :) );

   add_command( "edit",
      "script <string'name'>", (: do_edit_script( $4[0] ) :) );
   add_command( "edit",
      "script <number>", (: do_edit_script( $4[0] ) :) );
} /* init() */

// --- END [/mnt/home2/grok/lib/std/room/inherit/scripting.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/club_owned_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/club_owned_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629439   Available: 13576793
Inodes: Total: 5242880    Free: 4960136
1370 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/club_owned_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629439   Available: 13576793
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the same as an owned room, but it is controlled by a club
 * instead.
 * @author Pinkfish
 * @started 16th of May
 */
inherit "/std/room/inherit/owned_room";

private nosave string _club_controller;
private nosave string _club_owned_id;

/** @ignore yes */
string query_owner() {
   return _club_controller->query_owner_of(_club_owned_id);
} /* query_owner() */

/**
 * This method sets the club controller of the room.
 * @param club_controller the club controller
 */
void set_club_controller(string club_controller) {
   _club_controller = club_controller;
} /* set_club_controller() */

/**
 * This method returns the club controller for the club.
 * @return the club controller
 */
string query_club_controller() {
   return _club_controller;
} /* query_club_controller() */

/**
 * This method sets the owned id to use for this room.  The id is then
 * used to query the club controller to see who owns the room.
 * @param id the id to set the room to use
 * @see query_owned_id()
 */
void set_owned_id(string id) {
   _club_owned_id = id;
} /* set_owned_id() */

/**
 * This method sets the owned id to use for this room.  The id is then
 * used to query the club controller to see who owns the room.
 * @param id the id to set the room to use
 * @see query_owned_id()
 */
string query_owned_id() {
   return _club_owned_id;
} /* set_owned_id() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/club_owned_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/player_housing.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/player_housing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629439   Available: 13576793
Inodes: Total: 5242880    Free: 4960136
30282 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/player_housing.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629439   Available: 13576793
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is an inheritable for player-owned housing.<p>
 * It handles the internals for player housing. When creating a house you
 * should inherit "/std/room/player_housing" rather than this inheritable.
 *
 * @author Belle, Gototh, Ceres
 */
#include <dirs.h>
#include <housing.h>
#include <login_handler.h>
#include <player_handler.h>

inherit "/std/room/inherit/placement";
inherit "/std/room/inherit/room_save";

#define STANDARD_EXITS ({ "north", "northeast", "east", "southeast", \
                          "south", "southwest", "west", "northwest"})

#undef PLAYTESTING
#define DEBUG

private nosave int _setup_callout;

//
// The predefines for the functions.
//
varargs string* query_direc(object thing);
int query_relative(string direc);
varargs mixed query_door_control(string direc);
varargs mixed* query_dest_other(string direc);
int modify_exit(string dir, mixed* arr);
varargs int add_item(mixed shorts, mixed desc, int no_plural);
string the_short();
string* query_exits();
int query_exit(string direc);
void setup_doors();
void update_doors();
private void update_short_cache(string direc);
int test_occupier(string name);
string show_surface(string direc);
int allow_list();
int do_deny(string player, string location);
int do_allow(object player, string location);
int add_allowed(string pname);
int remove_allowed(string pname);
string query_owner();

/**
 * This class is used to store information on the decoration of this room (for
 * walls, floor etc.)
 */
class decoration {
  string short;
  string covering;
}

/**
 * This class stores information that we need to save about exits.  For example
 * if the player has changed the lock or added a trap.
 */
class exit_data {
  string long;
  string key;
  int difficulty;
  int closed;
  int locked;
  int autolock;
  int transparent;
  mixed trap_data;
}

/**
 * This class is used to cache short names for exits so we don't go loading
 * rooms all over the place.
 */
class exit_shorts {
  string one_short;
  string a_short;
}

private class decoration *decorations;
private string base_long;
private mapping exits;
private mapping exit_shorts;
private nosave mapping coverings; // here coz of sort_array
private nosave string owner;
private string *allowed = ({ });
private string *tell_denied = ({ });
private nosave string decoration_desc = "";
private nosave string quit_location;
private nosave int done_setup;
private nosave int setup_counter;

// used to track which surfaces this room actually has. decorations would
// include any it used to have too.
private nosave string *surfaces; 

#ifdef DEBUG
void debug_log(string fmt, mixed args ...) {
    debug_printf(fmt + "\n", args ...);
  if(base_name(this_object()) == "/d/cwc/Bes_Pelargic/Pong_Ping/roads/phoenix_avenue/housing/05entrycorridor") {
    log_file("HOUSING_DEBUG", "%s (%s): " + fmt + "\n", 
       ctime(time())[4..18], base_name(this_object()), args ...);
  }
}
#endif

/** @ignore yes */
void create() {
  room_save::create();
  exits = ([ ]);
  exit_shorts = ([ ]);
  decorations = ({ });
  tell_denied = ({ });
  this_object()->add_item("left", (: show_surface("left") :));
  this_object()->add_item("right", (: show_surface("right") :));
  this_object()->add_item("forward", (: show_surface("forward") :));
  this_object()->add_item("backward", (: show_surface("backward") :));
  this_object()->add_item("up", (: show_surface("up") :));
  this_object()->add_item("down", (: show_surface("down") :));

  /*
   * We try setup_doors() twice. The first time, if it succeeds is
   * good because it doesn't leave an opportunity for someone to get into
   * a room before the door locks. However sometimes this is too early
   * and no exits have been setup yet so the second one catches that case.
   */
  done_setup = 0;
  setup_doors(); 
  call_out("setup_doors", 0);
  //  call_out("setup_doors", 1);
} /* create() */

/** @ignore yes
 * Called by the add_item to describe a wall, floor or ceiling.
 */
string show_surface(string direc) {
  class decoration tmp;
  int found;
  string lstr, dstr;
  mixed tmp2;

  switch(direc) {
  case "left":
  case "right":
  case "forward":
  case "backward":
    // Find relative directions.
    tmp2 = this_player()->query_facing();
    direc = (string)this_player()->find_abs(direc, tmp2[0]);
    break;
  case "up":
    direc = "ceiling";
    break;
  case "down":
    direc = "floor";
    break;
  }
  
  if(!decorations) {
    decorations = ({ });
  } else {
    // Check it doesn't already exist.
    foreach(tmp in decorations) {
      // remove any old surfaces that got saved somehow.
      if(member_array(tmp->short, surfaces) == -1)
        decorations -= ({ tmp });
      
      if(tmp->short == direc || tmp->short == direc + " wall") {
        found = 1;
        break;
      }
    }
  }

  if(found) {
    direc = replace(direc, ({ " wall", "" }));
    if(member_array(direc, query_direc()) != -1) {
      lstr = "$C$";
      update_short_cache(direc);
      if(exit_shorts[direc] && exit_shorts[direc]->one_short) {
        if(query_door_control(direc))
          lstr += query_door_control(direc)->one_short() + " leads";
        else
          lstr = "an exit leads";
        lstr += " to " + exit_shorts[direc]->one_short;
      } else {
        if(query_door_control(direc))
          lstr += "is the " + query_door_control(direc)->one_short();
        else
          lstr += "is an exit";
      }
      lstr += " and the ";
    } else
      lstr = "The ";

    dstr = desc_surface(direc);
    if(dstr != "")
      dstr = "  " + dstr;
    
    return lstr + tmp->short + " is " + tmp->covering + "." + dstr;
  }
  
  return "";
} /* show_surface() */

/** @ignore yes
 * Called by the add_item to describe a wall, floor or ceiling.
 */
string show_corner(string direc) {
  string tmp;

  tmp = desc_surface(direc);
  if(tmp == "") {
    tmp = "The " + direc + " corner is empty.";
  }
  return tmp;
} /* show_corner() */

/** @ignore yes
 * This function handles producing the long text for the exits.
 */
string exit_long() {
  string *direcs, lstr;
  int i, j;
  object door;
  
  direcs = query_direc();

  if(!sizeof(direcs))
    return "";

  lstr = "  $C$";
  for(i=0; i<sizeof(direcs); i++) {
    update_short_cache(direcs[i]);

    if(query_relative(direcs[i])) {
      j = member_array(this_player()->find_rel(direcs[i]), REL_DIRS);
      lstr += REL_DIRS[j+2];
      if(exit_shorts[direcs[i]]) {
        if(query_door_control(direcs[i]))
          lstr += " " + query_door_control(direcs[i])->a_short() + " leads "
            "to " + exit_shorts[direcs[i]]->a_short;
        else
          lstr += " an exit leads to " + exit_shorts[direcs[i]]->a_short;
      } else {
        if(query_door_control(direcs[i]))
          lstr += " is " + query_door_control(direcs[i])->a_short();
        else
          lstr += " is an exit";
      }
    } else {
      door = query_door_control(direcs[i]);
      if(door) {
        if(member_array("window", door->query_name()) != -1)
          lstr += door->a_short() + " looks out";
        else
          lstr += door->a_short() + " leads " + direcs[i];
      } else
        lstr += "an exit leads " + direcs[i];
    }

    if(i < sizeof(direcs)-2)
      lstr += ", ";
    if(i == sizeof(direcs)-2)
      lstr += " and ";
    if(i == sizeof(direcs)-1)
      lstr += ".";
  }

  return lstr;
} /* exit_long() */

/**
 * @ignore yes
 * This function handles producing the long text for the decorations.
 */
string decoration_long() {
  class decoration tmp;
  string lstr, wstr, tmpstr, *tmparray, *names;
  int i;

#ifdef 0
  // Can't use this coz tables etc. have variable shorts and we can't tell
  // when they change.
  if(decoration_desc != "")
    return decoration_desc;
#endif
  
  lstr = "";
  if(sizeof(decorations)) {
    coverings = ([ ]);
    names = ({ "walls" });
    foreach ( tmp in decorations ) {
      if(!coverings[tmp->covering])
        coverings[tmp->covering] = ({ tmp->short });
      else
        coverings[tmp->covering] += ({ tmp->short });
      if(classp(tmp) && strsrch(tmp->short, "wall") == -1)
        names += ({ tmp->short });
    }

    i = 0;
    tmparray = sort_array(keys(coverings),
                        (: sizeof(coverings[$1]) - sizeof(coverings[$2]) :));

    // Too many surfaces so lets just describe them as multicoloured.
    if(sizeof(tmparray) > 3) {
      lstr += "  The " + query_multiple_short(names) + " are multicoloured.  ";
    } else if(sizeof(tmparray) == 1) {
      lstr += "  The surfaces are all " + decorations[0]->covering + ".  ";
    } else {
      foreach(tmpstr in tmparray) {
        if(i == 0)
          wstr = "  The ";
        else
          wstr = "the ";
        
        if(i == sizeof(tmparray)-1 && sizeof(coverings[tmpstr]) > 1)
          wstr += "other surfaces";
        else
          wstr += query_multiple_short(coverings[tmpstr], "", 1);
        
        if(sizeof(coverings[tmpstr]) > 1)
          wstr += " are ";
        else
          wstr += " is ";
        wstr += tmpstr;
        
        if(i < sizeof(tmparray) -2)
          wstr += ", ";
        else if(i == sizeof(tmparray) -2)
          wstr += " and ";
        else if(i == sizeof(tmparray) -1)
          wstr += ".  ";
        i++;
        lstr += wstr;
      }
    }
  }
  decoration_desc = lstr;
  return decoration_desc;
}

/** @ignore yes
 * Internal function to update the dynamic long description of the room.
 */
string query_long() {
  string lstr, tmp;
  
  if(base_long)
    lstr = "This is " + base_long + ".";
  else
    lstr = "";
  tmp = decoration_long(); 
  if(tmp != "")
    lstr += tmp;
  else
    lstr += "  ";
  
  return (lstr + furniture_long() + exit_long() + "\n");
}

/** @ignore yes
 * Just makes sure room exits are relative inside houses and that doors
 * are closed.
 */
int setup_exit(string direc, int relative) {
  if(member_array(direc, STANDARD_EXITS) != -1 && relative)
    modify_exit(direc, ({ "relative", 1 }));

  modify_exit(direc, ({ "closed", 1 }));

  return 1;
}

/**
 * Set the fixed part of the long description.
 * @param desc The description. (eg. a small and cosy front room)
 */
void set_base_desc(string desc) {
  base_long = desc;
}

/**
 * Query the fixed part of the description.
 * @return the description
 *
 * @see set_base_desc
 */
string query_base_desc() {
  return base_long;
}

/**
 * Set the room into which people should be placed if they quit in this room
 * but are not allowed to control this room.
 *
 * @param filename the filename of a room.
 */
void set_quit_handler(string filename) {
  quit_location = filename;
}

/**
 * This method returns the room that people will be placed in if they logout
 * while in this room and not allowed to control this room.
 * @see set_quit_handler
 * @return string the filename of the room.
 */
string query_quit_handler() {
  if(this_player() && !test_occupier(this_player()->query_name()) &&
     quit_location)
    return quit_location;
  
  return base_name(this_object());
}

/**
 * Add a surface (wall, floor etc.) and give the basic covering the surface
 * has prior to decoration.
 *
 * @param short The short name of the surface (eg. north wall)
 * @param covering The text of the covering (eg. finished pine board)
 */
void add_surface(string short, string covering ){
  class decoration tmp;
  string dir;

  if(!surfaces)
    surfaces = ({ });
  
  surfaces += ({ short });
  
  if(!decorations)
    decorations = ({ });
  else {
    // Check it doesn't already exist.
    foreach(tmp in decorations)
      if(tmp->short == short) {
        add_item(tmp->short, (: show_surface($(tmp->short)) :));
        short = replace(short, ({" wall", ""}));
        foreach(dir in keys(ABS_FACING)) {
          if(ABS_FACING[short] &&
             ABS_FACING[dir] == (ABS_FACING[short] % 8 ) + 1) {
            add_item(dir+" corner", (: show_corner($(dir)) :));
            break;
          }
        }
        return;
      }
  }
  
  tmp = new(class decoration );
  tmp->short = short;
  tmp->covering = covering;
  decorations += ({ tmp });
  add_item(tmp->short, (: show_surface($(tmp->short)) :));
  short = replace(short, ({" wall", ""}));
  foreach(dir in keys(ABS_FACING))
    if(ABS_FACING[short] &&
       ABS_FACING[dir] == (ABS_FACING[short] + 1) % 8) {
      add_item(dir+" corner", (: show_corner($(dir)) :));
      break;
    }
  
  decoration_desc = "";
}

/** @ignore yes
 * return a list of surfaces
 */
string *query_surfaces() {
  string *stmp;
  class decoration tmp;

  stmp = ({ });
  foreach(tmp in decorations) {
    stmp += ({ replace(tmp->short, ({" wall", ""})) });
  }
  return stmp;
}

/**
 * Modify a surface (wall, floor etc.) and give it a new covering.
 *
 * @param short The short of the surface.
 * @param covering The new covering decsription.
 * @return 1 for success, 0 for failure
 *
 * @see add_surface
 */
int decorate_surface(string short, string covering ){
  class decoration tmp;

  foreach(tmp in decorations)
    if(tmp->short == short) {
      tmp->covering = covering;
      event(this_object(), "save");
      decoration_desc = "";
      return 1;
    }
  
  return 0;
}


/** @ignore yes */
void query_decorations() {
  printf("%O\n", decorations);
}

/** @ignore yes
 * Determine which items in this room should be saved.
 */
int test_save(object thing) {
  return thing->query_furniture() || thing->query_missing_item_receipt();
}

/** @ignore yes
 * Call the test_remove functions in both placement & room_save
 */
int test_remove(object thing, int flag, mixed dest) {
  if(!placement::test_remove(thing, flag, dest))
    return 0;
  return room_save::test_remove(thing, flag, dest);
}

/** @ignore yes
 * Stops positioned objects from showing.  If it has a CURRENT_ROOM_VERB
 * property it's obviously a placed object and shouldn't been seen.
 */
object *my_process_non_living(object *int_non_livings, int start) {
  object *not_positioned;

  not_positioned = filter(int_non_livings,
                          (: !$1->query_property("current room position") &&
                           !$1->query_property("current room hidden") :) );
  return not_positioned;
} /* process_non_living() */

/** @ignore yes */
void init() {
  placement::init();

  // If this player is an occupier (and really an occupier not just an
  // authorised player) then give them the ability to allow/deny people
  // control in this room
  if(!allowed) {
    allowed = ({ });
  }
  
  add_command("allow", "list", (: allow_list() :));
  if(test_occupier(this_player()->query_name()) ||
     this_player()->query_creator()) {

    if(!HOUSING->query_house(base_name(this_object()))) {
      add_command("allow", "<indirect:player:here>",
                  (: do_allow($1[0], "room") :));
      add_command("deny", "<word'player'>",
                  (: do_deny($4[0], "room") :));
    } else {
      add_command("allow", "<indirect:player:here> <word'house|room'>",
                  (: do_allow($1[0], $4[1]) :));
      add_command("deny", "<word'player'> <word'house|room'>",
                  (: do_deny($4[0], $4[1]) :));
    }
  }
}

/**
 * This method is used to setup things when someone enters the room.
 * @param ob the object that entered the room
 */
protected void event_enter_checks(object ob) {
  if(!tell_denied) {
    tell_denied = ({ });
  }
  
  if(ob && interactive(ob) &&
     member_array(ob->query_name(), tell_denied) != -1) {
    write("%^YELLOW%^%^BOLD%^You are no longer allowed to control this "
          "room.%^RESET%^\n");
    tell_denied -= ({ ob->query_name() });
  }
}

/** @ignore yes */
void event_enter(object ob, string message, object from) {
#ifdef PLAYTESTING
  if(interactive(ob) &&
     (!ob->query_creator() &&
     !"/obj/handlers/playtesters"->query_playtester(ob->query_name())) &&
     ob->query_name() != "gumboot") {
    tell_object(ob, "Sorry, this area is only open to playtesters.\n");
    ob->move(from);
  }
#endif
  event_enter_checks(ob);
} /* event_enter() */

/** @ignore yes
 * List who can control this room.
 */
int allow_list() {
  string *tmp;

  if(owner && owner != "For Sale" && owner != "Under Offer") {
    tmp = ({ owner }) + allowed;
  } else {
    tmp = allowed;
  }

  if (!test_occupier(this_player()->query_name()) &&
      !this_player()->query_creator()) {
    add_failed_mess("You are not allowed to control this room.\n", ({ }));
    return 0;
  }

  switch(sizeof(tmp)) {
  case 0:
    add_succeeded_mess(({"Noone is allowed to control this room.\n",
                           "$N messes with something in " + the_short() +
                           ".\n"}));
    break;
  case 1:
    add_succeeded_mess(({query_multiple_short(tmp) +
                           " is allowed to control this room.\n",
                           "$N messes with something in " + the_short() +
                           ".\n"}));
    break;
  default:
    add_succeeded_mess(({query_multiple_short(tmp) +
                           " are allowed to control this room.\n",
                           "$N messes with something in " + the_short() +
                           ".\n"}));
  }
  return 1;
}

/** @ignore yes
 *
 * Allows a player to do things in the room as though they were the
 * owner/occupier.
 * This function is called by the 'allow' add_command.
 */
/* NOTE: This uses object player and requires the owner and the player to be
 * logged in  and present to be allowed. This is a deliberate security
 * feature to prevent people allowing their alts and so using houses to
 * multiplay!
 */
int do_allow(object player, string location) {
  string pname;
  string *rooms;
  string room;
  int failed;

  if((query_owner() != this_player()->query_name()) &&
     !this_player()->query_creator()) {
    add_failed_mess("You are not allowed to control this room.\n", ({ }));
    return 0;
  }

  if(environment(player) != this_object()) {
    return add_failed_mess("$I is not here.\n", ({ player }));
  }

  pname = lower_case(player->query_name());
  if(test_occupier(pname)) {
    add_failed_mess("$I is already able to control this room.\n");
    return 0;
  }

  if(location == "house") {
    rooms = HOUSING->query_rooms(base_name(this_object()));
    failed = 1;
    foreach(room in rooms) {
      failed &= room->add_allowed(pname);
    }
  } else {
    failed = add_allowed(pname);
  }

  if (failed) {
     add_failed_mess("Failed to add " + pname + " as being able to control "
                     "the " + location + ".\n");
     return 0;
  }

  tell_object(player, "You are now permitted to control this " + location +
              ".\n");
  add_succeeded_mess(({ pname + " is allowed to control this " + location +
                          ".\n", ""}));
  return 1;
} /* do_allow() */

/** @ignore yes
 *
 * Takes a player off the allowed list.
 * This function is called by the 'deny' add_command.
 */
int do_deny(string player, string location) {
  object ob;
  string *rooms, room;
  
  if(member_array(player, allowed) == -1) {
    add_failed_mess(player + " is not on the allow list.\n");
    return 0;
  }

  if (!test_occupier(this_player()->query_name()) &&
      !this_player()->query_creator()) {
    add_failed_mess("You are not allowed to control this room.\n");
    return 0;
  }

  if(!test_occupier(player)) {
    add_failed_mess(player + " is already not allowed to control this room.\n");
    return 0;
  }

  if(location == "house") {
    rooms = HOUSING->query_rooms(base_name(this_object()));
    foreach(room in rooms)
      room->remove_allowed(player);
  } else {
    remove_allowed(player);
  }

  ob = find_player(player);
  if(ob && environment(ob) == this_object()) {
    tell_object(ob, "%^YELLOW%^%^BOLD%^You are no longer allowed to control " +
                the_short() + ".\n%^RESET%^");
  } else {
    tell_denied += ({ player });
  }

  add_succeeded_mess(({player + " is no longer allowed to control this " +
                     location + ".\n", "" }));
  return 1;
} /* do_deny() */

/** @ignore yes
 *
 * Update our cache of short exit names.
 */
private void update_short_cache(string direc) {
  string ostr, astr;

  if(!exit_shorts)
    exit_shorts = ([ ]);
  
  if(find_object(query_dest_other(direc)[0])) {
    ostr = query_dest_other(direc)[0]->one_short();
    if(this_player())
      ostr = this_player()->convert_message(ostr);
    
    astr = query_dest_other(direc)[0]->a_short();
    if(this_player())
      astr = this_player()->convert_message(astr);
    
    if(!exit_shorts[direc] ||
       ostr != exit_shorts[direc]->one_short ||
       astr != exit_shorts[direc]->a_short) {
      exit_shorts[direc] = new(class exit_shorts,
                               one_short : ostr,
                               a_short : astr);
    }
  }
}

/** @ignore yes
 * Update the door info when the room is dested, prior to saving.
 */
void update_doors() {
  string exit;
  object door_ob;

  if(!done_setup)
    setup_doors();

  if(!exits)
    exits = ([ ]);
  
  foreach(exit in query_exits()) {
    door_ob = query_door_control(exit);
    if(door_ob) {
      if(door_ob->query_key() == "generic_key") {
#ifdef DEBUG
        if(exits[exit])
          debug_log("update_doors", "Door %s has generic_key, exit data "
                    "has %s", exit, exits[exit]->key);
        else
          debug_log("update_doors", "Door %s has generic_key, no existing "
                    "exit data.", exit);
#endif
      }
      
      exits[exit] = new(class exit_data,
                        long : door_ob->query_long(),
                        key : door_ob->query_key(),
                        difficulty: door_ob->query_difficulty(),
                        closed : door_ob->query_closed(),
                        locked : door_ob->query_locked(),
                        autolock : door_ob->query_autolock(),
                        transparent : door_ob->query_transparent(),
                        trap_data : door_ob->query_trap_data());

#ifdef DEBUG2
      debug_log("update_doors: Door %s: key: %s, difficulty: %d, closed: %d, "
                "locked: %d, owner: %s", exit, exits[exit]->key,
                exits[exit]->difficulty, exits[exit]->closed,
                exits[exit]->locked, owner);
#endif
    }
  }
}

/** @ignore yes
 * Initialise the doors when the room is loaded.
 */
void setup_doors() {
  string exit;
  object door;
  string other, other_id;
  
#ifdef DEBUG2
  debug_log("Setup doors called.");
#endif

  if(!this_object()->query_exits()) {
    this_object()->calc_exits();
  }

  if(!exits || !sizeof(exits)) {
    if(!this_object()->query_exits()) {
#ifdef DEBUG2
      debug_log("Leaving setup_doors, No exits to setup.");
#endif
    } else if(query_inventory_loaded()) {
#ifdef DEBUG
      debug_log("Leaving setup_doors, exits not setup %O, autoloading: %d "
                "inventory loaded: %d.",
                exits, query_auto_loading(), query_inventory_loaded());
#endif
    }
    return;
  }

  foreach(exit in keys(exits)) {
    door = query_door_control(exit);
    if(!door) {
      if(!query_exit(exit)) {
        map_delete(exits, exit);
      }
      continue;
    }

    if(!owner)
      catch(owner = HOUSING->query_owner(base_name(this_object())));

    //if(!done_setup) {
#ifdef DEBUG2
      if(exit == "out")
        debug_log("Setting up %s: key: %s, difficulty: %d, closed: %d, "
                  "locked: %d, owner: %s", exit, exits[exit]->key,
                  exits[exit]->difficulty, exits[exit]->closed,
                  exits[exit]->locked, owner);
#endif
      modify_exit(exit, ({ "key", exits[exit]->key,
                             "difficulty", exits[exit]->difficulty,
                             "closed", exits[exit]->closed,
                             "locked", exits[exit]->locked,
                             "autolock", exits[exit]->autolock,
                             "lock owner", owner,
                             }));
    
      if(exits[exit]->trap_data && arrayp(exits[exit]->trap_data)) {
        door->setup_trap(exits[exit]->trap_data[0],
                         exits[exit]->trap_data[1],
                         exits[exit]->trap_data[2],
                         exits[exit]->trap_data[3],
                         exits[exit]->trap_data[4]);
        if(exits[exit]->trap_data[5])
          door->set_trap_armed(1);
      }
      //}
    
    // This prevents rooms causing other rooms to load. Hopefully it's ok to
    // have it commented out.
    other = door->query_dest();
    other_id = door->query_other_id();

    // This prevents the room causing other playerhousing rooms to be loaded.
    // The check for "out" just makes certain we do the front door.
#ifdef NO_SLOW_LOAD
    // I've disabled this for the moment to see if having the cascade of
    // room loads will be ok with the ramdisk and whether it'll fix any
    // door issues.
    if(!find_object(other) && exit != "out")
      continue;
#endif
    if(!other_id) {
      door->force_other();
      other_id = door->query_other_id();
    }

    // If we have no other_id we need to try again later.
    if(!other_id) {
#ifdef DEBUG2
      debug_log("No other_id, adding call_out.");
#endif
      if(!_setup_callout) {
        _setup_callout = call_out("setup_doors", 0);
        return;
      }
    }
  
    other->modify_exit(other_id, ({ "key", exits[exit]->key,
                                      "difficulty", exits[exit]->difficulty,
                                      "closed", exits[exit]->closed,
                                      "locked", exits[exit]->locked,
                                      "autolock", exits[exit]->autolock,
                                      "lock owner", owner,
                                      }));
    if(exits[exit]->trap_data && arrayp(exits[exit]->trap_data)) {
      door = other->query_door_control(other_id);
      if(door && objectp(door)) {
        door->setup_trap(exits[exit]->trap_data[0],
                         exits[exit]->trap_data[1],
                         exits[exit]->trap_data[2],
                         exits[exit]->trap_data[3],
                         exits[exit]->trap_data[4]);
        if(exits[exit]->trap_data[5])
          door->set_trap_armed();
      }
    }
  }
  done_setup = 1;
}

/**
 * This method returns the current owner of the house.
 */
string query_owner() {
  if(owner)
    return owner;
  return HOUSING->query_owner(base_name(this_object()));
}

/**
 * This method locally sets the owner of the house.
 */
string set_owner(string who) { owner = who; }

/**
 * This function adds a name to the allow list of this room.
 *
 * @param pname The name of a player.
 * @return 1 for success, 0 for failure
 */
int add_allowed(string pname) {
  if(test_occupier(pname))
    return 0;

  allowed += ({ pname });
  event(this_object(), "save");

  return 0;
}

/**
 * This function removes a name from the allow list of this room.
 *
 * @param pname The name of a player.
 * @return 1 for success, 0 for failure
 */
int remove_allowed(string pname) {
  if(!test_occupier(pname))
    return 0;

  allowed -= ({ pname });
  event(this_object(), "save");

  return 1;
}

/**
 * This function determines if a given individual can be considered to be the
 * occupier of this house. Normally this means the person currently renting or
 * owning this house.
 *
 * For shared ownership houses simply mask this function and do whatever you
 * have to. :)
 *
 * @param name The person to be tested
 * @return 1 if they are the occupier, 0 if not.
 */
int test_occupier(string name) {
  if(!owner)
    catch(owner = HOUSING->query_owner(base_name(this_object())));

  // If there is no owner then anyone in the house is considered the occupier.
  if(!owner || lower_case(owner) == "for sale" ||
     lower_case(owner) == "under offer")
    return 1;
  
  if(PLAYER_HANDLER->test_creator(name))
    return 1;

  if(!allowed)
    allowed = ({ });

  return (owner == name || (member_array(name, allowed) != -1));
}

/**
 * This function informs the house that its owner has changed, it does not
 * actually change the owner since that is done in the handler.
 *
 * @param old_owner The name of the old owner
 * @param new_owner The name of the new owner
 * @return 1 for success, 0 for failure.
 */
int ownership_change(string old_owner, string new_owner) {
  if(old_owner != new_owner) {
    owner = new_owner;
    allowed = ({ });
    return 1;
  }
  return 0;
}

/**
 * This method returns the current list of people allowed to modify this
 * room.
 * @return the allowed people to change this room
 */
string *query_allowed() {
   if (allowed) {
     return allowed;
   }
   return ({ });
} /* query_allowed() */

/**
 * This method tells us if the person is allowed to use this room.
 * @param name the name of the person
 */
int is_allowed(string name) {
  // The owner, those on the allow list and creators are allowed.
  if((query_owner() && (lower_case(name) == lower_case(query_owner()))) ||
     (member_array(lower_case(name), query_allowed()) != -1) ||
     PLAYER_HANDLER->test_creator(name)) {
    return 1;
  }
   
   return 0;
}

/** @ignore yes */
void dest_me() {
#ifdef NOT_USED
  if (base_name(this_object()) + ".c" != __FILE__)
    update_doors();
#endif
  ::dest_me();
}

/** @ignore yes */
void event_open(object door, object opener) {
#ifdef DEBUG2
  debug_log("door opened by %s [%d]", opener->query_name(), done_setup);
#endif
  if(done_setup) {
    ::event_open(door, opener);
    update_doors();
  }
}

/** @ignore yes */
void event_close(object door, object closer) {
#ifdef DEBUG2  
    debug_log("door closed by %s [%d]", closer->query_name(), done_setup);
#endif
  if(done_setup) {
    ::event_close(door, closer);
    update_doors();
  }
}

/** @ignore yes */
void event_unlock(object door, object unlocker) {
#ifdef DEBUG2
  debug_log("door unlocked by %s [%d]", 
            unlocker?unlocker->query_name():"noone", done_setup);
#endif
  if(done_setup) {
    ::event_unlock(door, unlocker);
    update_doors();
  }
}

/** @ignore yes */
void event_lock(object door, object locker) {
#ifdef DEBUG2
  debug_log("door locked by %s [%d]", locker?locker->query_name():"noone",
            done_setup);
#endif
  if(done_setup) {
    ::event_lock(door, locker);
    update_doors();
  }
}

// --- END [/mnt/home2/grok/lib/std/room/inherit/player_housing.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/bath_house.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/bath_house.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629431   Available: 13576785
Inodes: Total: 5242880    Free: 4960136
6050 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/bath_house.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629431   Available: 13576785
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Bath house inheritable!
 * @author Taffyd
 * @started 30/04/00 12:08
 */
#include <effect.h>

#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
#define WET_EFFECT "/std/effects/other/wetness"

/**
 * @ignore yes
 * Function prototypes!
 */
protected int add_wash_effect( string classification, function func );
protected int add_finished_func( function func );
protected void advanced_antiseptic( object ob, string classification, mixed arg, int effect_enum, object effect_ob );
protected void basic_cleaning( object ob, int effect_enum, string message );
protected void apply_soap( object ob, string *applied_effects );
protected void wet_person( object ob, string *applied_effects );

private mapping _wash;
private function *_finished_funcs;


/** @ignore yes */
void create() {
    _wash = ([ ]);
    _finished_funcs = ({ });

    add_wash_effect( "body.smell", (: advanced_antiseptic :) );
    add_wash_effect( "misc.ketchup", (: basic_cleaning( $1, $3,
        "The soap rinses the ketchup off your face." ) :) );
    add_wash_effect( "object.label", (: basic_cleaning( $1, $3,
        "The labels stuck to your body peel off in the water." ) :) );
    add_wash_effect( "body.frog-adhesive", (: basic_cleaning( $1, $3,
        "The frantic ribbiting fades away as the frog adhesive washes "
        "off." ) :) );
    add_finished_func( (: apply_soap :) );
    add_finished_func( (: wet_person :) );

    this_object()->add_setup_wash_command();
} /* create() */

/** @ignore yes */
void init() {
    /* Call this function in this_object() to add any commands */
    this_object()->add_init_wash_command();
} /* init() */


/**
 * This method adds an effect to be removed when washing here.
 * If the effect is matched, then func is evaluated.
 * @param classification the effect classification to match.
 * @param func the function to evaluate when the effect is matched.
 * @return 1 if the effect classification was added, 0 if it could not be
 * (most likely a duplicate effect classification).
 * @example
 * add_wash_effect( "body.smell", (: advanced_antiseptic :) );
 * @example
 * add_wash_effect( "object.label", (: basic_cleaning( $1, $3,
 *    "The labels stuck to your body peel off in the water." ) :) );
 */
protected int add_wash_effect( string classification, function func ) {
    if ( !_wash[ classification ] ) {
        _wash[ classification ] = func;
        return 1;
    }

    return 0;
} /* add_wash_effect() */

/**
 * This adds a function to be evalauted when all of the wash effects
 * have been evaluated.
 * @param func the function to be evaluated
 * @return 1
 */
protected int add_finished_func( function func ) {
    _finished_funcs += ({ func });
    return 1;
} /* add_finish_func() */

/**
 * This returns a list of all the effect classifications that are currently
 * being managed.
 * @return an array of strings.
 */
public string *query_wash_classifications() {
    return keys( _wash );
} /* query_wash_classifications() */

/**
 * This method removes a wash effect.
 * @param the classification of the effect to be removed.
 * @return 1 if the effect was successfully removed, 0 if it wasn't.
 */
protected int remove_wash_effect( string classification ) {
    if ( _wash && _wash[ classification ] ) {
        map_delete( _wash, classification );
        return 1;
    }

    return 0;
} /* remove_wash_effect() */

/**
 * This is a basic cleaning method that can be used to remove a few
 * default things.
 */
protected void advanced_antiseptic( object ob, string classification, int effect_enum, mixed arg, object effect_ob ) {
    tell_object( ob,
        "The antiseptic power of the soap defeats " +
        effect_ob->smell_string( ob, arg ) + ".\n" );
    ob->delete_effect( effect_enum );
} /* advanced_antiseptic() */

/**
 * This is a small cut down cleaning effect that displays a message.
 */
protected void basic_cleaning( object ob, int effect_enum, string message ) {
    tell_object( ob, message + "\n" );
    ob->delete_effect( effect_enum );
} /* basic_cleaning() */

/**
 * This is the default finished func. It adds soap.
 */
protected void apply_soap( object ob, string *applied_effects ) {
    ob->add_effect( SOAP_EFFECT, 10000 );
} /* apply_soap() */

protected void wet_person( object ob, string *applied_effects ) {
    ob->add_effect( WET_EFFECT, 250 );
} /* wet_person() */

/**
 * This method washes a player.  Any wash commands that are defined
 * must ultimately call this function, so that all of the wash
 * functions can be evaluated.
 * <p>
 * When an effect is found on the player for a matching wash effect
 * classification, the function specified is evaluated with the following
 * parameters:
 * <ul>
 *  <li>ob, the player who is being washed
 *  <li>classification, the classification of the effect that was matched.
 *  <li>arg, the arguments to the effect.
 *  <li>effect_enum, the position of the effect in the player's effect list.
 *  <li>effect_ob, the object that the effect is found in.
 * </ul>
 * <p>
 * After this, the finished functions are evaluated with two arguments, the first
 * one being ob, the second one being an array of all the wash effect classifications
 * that were matched correctly.
 * @param ob the object to wash
 * @return 1 if the player was washed successfully, 0 if they weren't.
 */

public int wash_player( object ob ) {
    function func;
    string eff;
    string *cleaned;
    int *enums, eff_enum;

    cleaned = ({ });

    if ( !objectp( ob ) ) {
        return 0; 
    }


    foreach( eff, func in _wash ) {
        enums = ob->effects_matching( eff );

        if ( sizeof( enums ) ) {
            foreach( eff_enum in enums ) {
                evaluate( func, ob, eff, eff_enum, ob->arg_of( eff_enum ),
                    ob->eff_of( eff_enum ) );
            }

            cleaned += ({ eff });
        }
    }

    foreach( func in _finished_funcs ) {
        evaluate( func, ob, cleaned );
    }

    return 1;
} /* wash_player() */

int query_baths() {
    return 1;
} /* query_baths() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/bath_house.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/terrain_map_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629430   Available: 13576784
Inodes: Total: 5242880    Free: 4960136
11343 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/terrain_map_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629430   Available: 13576784
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * The overall room inherit for a 'mapped area'
 * all mapped area rooms should inherit from this.
 * <p>
 * MUST OVERRIDE:
 * <p>
 * query_map_file()
 * @author  Dek
 * @started March 2001
 */
#include <room.h>
#include <login_handler.h>

private int     _x_coord = -1;
private int     _y_coord = -1;
private int     _installed = 0;
private string  _extra_long = "";
private object  _map_handler;
private mapping _features = ([ ]);
private string  _outside_types;

string query_feature_item_desc(string title);
int    do_gocoords(int x, int y);
void add_extra_look(object ob);
void setup_room_chat();
object query_chatter();
varargs void room_chat(mixed* args, object chatob);
void add_item(mixed type, mixed desc);
void remove_item(string name);

/**
 * This method returns the co-ordinates of this room.
 */
mixed *query_coords() { return ({ _x_coord, _y_coord }); }


// We set the coords to -1 -1 here, to account for rooms that are
// not virtual. Rooms that adjoin map areas need to inherit this
// file, hence the need to do this.
void create()

{
   _x_coord = -1;
   _y_coord = -1;

}

/**
 * This needs to be called by the upper inherit to set us to womble.
 */
void setup_room() {
   add_extra_look(this_object());
   setup_room_chat();
} /* setup_room() */

/**
 * Setup the main coordinates for this room. Please note that these
 * are not DW coords, but local ones for the use of the handler. 
 */
void set_coords(int x, int y)

{
   _x_coord = x;
   _y_coord = y;
}


void init()

{
   tell_creator(this_player(), "Coords: (%d, %d)\n", _x_coord, _y_coord);
   if (this_player()->query_creator()) {
      add_command("gocoords", "<number'x'> <number'y'>", (: do_gocoords($4[0], $4[1]) :));
   }
}


/**
 * This method returns the map handler associated with this room.
 */
object query_map_handler()

{
   return _map_handler;
}


/**
 * This is a command used by creators to go to specific locations in the grid.
 */
int    do_gocoords(int x, int y)

{
   object   room = query_map_handler()->load_room_at(x, y);
   string   msgin = this_player()->query_mmsgin();
   string   msgout = this_player()->query_mmsgout();
   
   
   if (!room) {
     this_player()->add_failed_mess(this_object(), 
                           "No room at those coordinates.\n", ({ }));
     return 0;
   }

   msgin = replace(msgin, ({ "$N", this_player()->a_short() }) );
   msgout = replace(msgout, ({ "$N", this_player()->a_short() }) );
   if (!this_player()->move_with_look(room, msgin, msgout))
      add_succeeded_mess("Move attempt failed.\n");
   
   return 1;
}
   

/**
 * Added for convenience. BEWARE! When called, this will dest every single 
 * room in this terrain, dumping everything in the void. When I think of
 * a decent way to handle this, I will.
 */
void reset_handler()

{
   if (query_map_handler())
      query_map_handler()->reset_handler();
}


/**
 * Receive messages from the handler.
 * @Param mess_class the class of the message
 * @param message the actual message
 */
void receive_message(string mess_class, string message)

{
   string   *bits = explode(mess_class, ":");
   mapping  feature;
   int      range = -1;
   
   if (bits[0] == "feature") {
      feature = _features[bits[1]];
      if (!feature)
         return;
      
      if (sizeof(bits) >= 3)
         range = to_int(bits[2]);
         
         if ((range >= 0) && (range != feature["range"]))
            return;
      message = replace(message, ({ "$D", feature["direc"] }));
   }
   tell_creator("dek", "receive_message\n");
   tell_room(this_object(), message);
}


/**
 * This makes one of the features in the terrain send us a chat.
 */
void do_a_feature_chat()

{
   string   *chats = ({ });
   string   feature_chat;
   string   title;
   mapping  feature;
   object   handler = query_map_handler();
   
   foreach(title, feature in _features) {
      feature_chat = handler->get_a_feature_chat(title, feature["range"], 
                                                        feature["direc"]);
      if (feature_chat) {
         chats += ({ feature_chat });
      }
   }
   if (sizeof(chats)) {
      tell_room(this_object(), chats[random(sizeof(chats))] + "\n");
   }
}

/**
 * This method will print an outside chat.
 */ 
void do_an_outside_chat()

{
   string chat = query_map_handler()->get_an_outside_chat(_outside_types);

   if (chat && strlen(chat))
      tell_room(this_object(), chat + "\n");
}


/**
 * This sets the map handler, OBSOLETE. This should be done by overriding query_map_handler()
 * in the main inherited file. It doesn't get set fast enough otherwise.
 * @param handler the new handler
 */
void set_map_handler(mixed handler)

{
   if (objectp(handler))
      _map_handler = handler;
   else
      _map_handler = load_object(handler);
}


/**
 * Checks to see if the feature can be viewed or not.
 * @param type the type of the feature
 * @return 1 if it can be seen
 */
int can_view_feature(string type)

{
   return 1;
}


/**
 * Can we go to rooms of type x? Override if you want to use it - 
 * 1 means yes.
 * @param type the type of room to check
 */
int can_exit_to(string type)

{
   return 1;
}


/**
 * Can we enter from rooms of type x? Override if you want to use it - 
 * 1 means yes.
 * @param type the type of room to check
 */
int can_enter_from(string type)

{
   return 1;
}


/**
 * Do we *want* outside and feature chats? Override if you want to use 
 * 1 means yes.
 */
int do_outside_chats()

{
   return 1;
}


/**
 * Setup the feature chats and basic room chats.
 */
varargs void setup_room_chat(mixed *args, object chatobj)

{
   if (do_outside_chats() && !query_chatter()) {
      room_chat(({ 60, 120, ({ "#do_a_feature_chat",
                                  "#do_an_outside_chat" }) }) );
   }

   // For some reason, the chatting won't start if we don't kick-start it.
   call_out("make_chat", 10);
}


// Kick-start the bloody chatter. Damn' thing won't do anything else.
/** @ignore yes */
void make_chat()

{
  if (query_chatter()) {
     query_chatter()->make_chat();
  }
}

// override to generate modify_exits between rooms of various types.
/** @ignore yes */
mixed *query_to_same(string type) { return 0; }
/** @ignore yes */
mixed *query_to_other(string type) { return 0; }
/** @ignore yes */
mixed *query_from_other(string type) { return 0; }


// The next three are prettification functions for the above, and should
// never be called directly.
/** @ignore yes */
mixed *get_to_same(string from, string to, string type)

{ 
   mixed *result = query_to_same(type);
   
   if (arrayp(result))
      return map(result, (: replace($1, ({ "$T", $2, "$F", $3 }) ) :), to, from);
   
   return 0;
}


/** @ignore yes */
mixed *get_to_other(string from, string to, string type)

{ 
   mixed *result = query_to_other(type);
   
   if (arrayp(result))
      return map(result, (: replace($1, ({ "$T", $2, "$F", $3 }) ) :), to, from);
   
   return 0;
}


/** @ignore yes */
mixed *get_from_other(string from, string to, string type)

{ 
   mixed *result = query_from_other(type);
   
   if (arrayp(result))
      return map(result, (: replace($1, ({ "$T", $2, "$F", $3 }) ) :), to, from);
   
   return 0;
}


/**
 * Called by the handler to set our extra_look strings.
 */
void set_extra_long(string extra)

{
   _extra_long = extra;
}


void set_outside_types(string types)

{
   _outside_types = types;
}


// This handles all the extra parts of the room desc which are
// inserted by the handler.
/** @ignore yes */
string extra_look() 

{
   string   result = _extra_long;
   string   title;
   mapping  feature;
   
   foreach (title, feature in _features) {
      result += query_map_handler()->query_feature_desc(title, feature["range"], 
                                    feature["direc"]) + "\n";
   }
   return result;
}


// For internal use. Talks to the handler to convert a pathname of type:
// /w/dek/map.c:3:4 to something useable.
/** @ignore yes */
mixed query_room(string room_path)

{
   string   *bits = explode(room_path, ":");
   object   room;
   object   handler;
   
   if (sizeof(bits) < 3)
      return room_path;
   
   room = load_object(bits[0]);
   handler = room->query_map_handler();
   
   return handler->query_room(room_path);
}


/**
 * Add a new visible feature to the room, so it knows to query the handler
 * for descriptions and so on. The zone info is needed as an easy way for
 * the handler to get access to which rooms see which features. 
 * @param title the title of the feature
 * @param direc the direction of the feature
 * @param range the range to the feature
 * @param items any add_items associated with the feature
 */
void add_feature(string title, string direc, int range, mixed items)

{
   _features[title] = (["direc":direc, "range":range, "items":items]);
   add_item(items, (: query_feature_item_desc($(title)) :));
}


/**
 * Removes the specified feature.
 * @param title the feature to remove
 */
void remove_feature(string title)

{
   mapping  feature = _features[title];
   mixed    items;
   
   if (!feature)
      return;
   
   map_delete(_features, title);
   items = feature["items"];
   if (stringp(items))
      remove_item(items);
   else
      remove_item(items[0]);
}


/**
 * This figures out the range to the specified feature.
 * @param title the name of the feature
 */
int query_feature_range(string title)

{
   mapping   feature = _features[title];
   
   if (!feature)
      return -1;
   
   return feature["range"];
}


/**
 * This method returns the item description for the feature.
 * @param title the feature to look up
 * @return the description of the feature
 */
string query_feature_item_desc(string title)

{
   return query_map_handler()->query_feature_item_desc(title);
}


/**
 * This method returns all of our features.
 */
mapping query_features() { return _features; }

// When someone logs into the room, see if they were previously in a
// virtual. If they were, put them back in the same location.
// coords are stored as a property, so remove it when done for neatness' sake.
/** @ignore yes */
void login_restore( string name, string l_event)

{
   object player;
   string path = explode(file_name(this_object()), "#")[0];
   int    *coords, x, y;
   
   if (l_event != LOGIN)
      return;
   
   player = find_player(name);
   if (!player)
      return;

   coords = player->query_property("area_map_coords");
   player->remove_property("area_map_coords");
   if (!coords)
      return;
   
   x = coords[0];
   y = coords[1];
   
   LOGIN_HANDLER->remove_static_login_call(name, "login_restore", path);
   player->move(query_map_handler()->load_room_at(x, y));
}

// If someone quits here, and this is a virtual, store their coords in a
// property, and flag the login handler so it knows to talk to us when
// they return.
/** @ignore yes */
void event_quit(object player)

{
   string name;
   string path = explode(file_name(this_object()), "#")[0];
   
   if (!player)
      return;
      
   if (!interactive(player))
      return;
   
   if ((_x_coord < 0) || (_y_coord < 0))
      return;
      
   name = player->query_name();
   player->add_property("area_map_coords", query_coords());
   LOGIN_HANDLER->add_static_login_call(name, "login_restore", path);
}

int query_installed() { return _installed; }
void set_installed() { _installed = 1; }

// --- END [/mnt/home2/grok/lib/std/room/inherit/terrain_map_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/room_save.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/room_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629427   Available: 13576781
Inodes: Total: 5242880    Free: 4960136
11282 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/room_save.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629427   Available: 13576781
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A saving room inheritable.  This handles rooms which save their inventory,
 * or more specifically part of their inventory.
 *
 * Which objects should be saved or not saved can be controlled by overriding
 * test_save.
 *
 * Containers in this room that need to cause it to save its inventory should
 * generate a save event.
 *
 * @see test_save
 * @see event_save
 *
 * @author ceres
 */
#include <move_failures.h>
#include <player.h>

inherit "/global/auto_load";

//#define DEBUG_SAVE

// This is the minimum time between saves.
#define SAVE_TIME 10

#if 0
#undef AUTO_LOAD_OB
#define AUTO_LOAD_OB "/global/auto_load_debug"
#endif

varargs void set_save_file( string file, object thing );
varargs void do_load(object thing);
mapping query_dynamic_auto_load();
void init_dynamic_arg(mapping bing);

private mapping details;
private nosave string _save_file, _ram_file;
private nosave object _effects;
private nosave int _inventory_loaded;
private nosave int _last_saved;
private nosave int _door_opened, _door_unlocked;

#ifdef DEBUG_SAVE
void debug_log(string fmt, mixed args ...) {
    debug_printf(fmt + "\n", args ...);
#ifdef DISABLED
  if(base_name(this_object()) == "/d/cwc/Bes_Pelargic/Shoo_Li/roads/pang_ho_street/housing/03flat") {
    log_file("HOUSING_DEBUG", "%s (%s): " + fmt + "\n", 
             ctime(time())[4..18], base_name(this_object()), args ...);
  }
#endif
}
#endif

/** @ignore yes */
void create() {
   _save_file = "";
   details = ([ ]);
   _last_saved = time();
} /* create() */

/**
 * Set the filename that this object should use to save its inventory to.
 * @param file The file.
 */
void set_save_file( string file) {
#ifdef USE_RAMDISK
  string *bits, fname;
  int i;
#endif

  _save_file = file;

#ifdef USE_RAMDISK
  if(strsrch(_save_file, "/save/player_housing") != -1) {
    _ram_file = replace_string(_save_file, "/save/player_housing",
                               "/save/ramdisk/player_housing");
    fname = "";
    bits = explode(_ram_file, "/");
    for(i=0; i<sizeof(bits)-1; i++) {
      fname += "/" + bits[i];
      if(file_size(fname) == -1) {
        debug_printf("Creating %s", fname);
        mkdir(fname);
      }
    }
  }
#endif
  
  do_load();
} /* set_save_file() */

/**
 * This method determines if a given object should be saved or not.  When
 * inheriting this room you should define your own test_save function and use
 * it to decide which parts of the inventory are saved and which are not.
 *
 * @param ob The object to be tested.
 * @return 1 for yes 0 for no.
 */
int test_save(object ob) { return 1; }

/**
 * This method returns the current save file for the object.
 * @return the current save file
 */
string query_save_file() {
   return _save_file;
} /* query_save_file() */

/**
 * Objects that need to make this room save such as containers in the room
 * should generate a save event to make the room save its inventory.
 * eg. event(environment(this_object()), "save");
 */
void event_save(object thing) {
  // Certain conditions must be met in order to generate a save callout.
  if(!thing || !_inventory_loaded || !_save_file || _save_file == "") {
    if(find_call_out("do_save") != -1)
      remove_call_out("do_save");
    return;
  }
  
  // If thing is empty or this object then save. Alternatively, if
  // it's something this room should save then do a save.
  if(thing == this_object() || base_name(thing) == "/std/room/basic/door" ||
     test_save(thing)) {
    // Figure out when to schedule the callout for if necessary.
    if (find_call_out("do_save") == -1)
      call_out("do_save", SAVE_TIME);
  }
}

/** @ignore yes */
/* The following functions attempt to prevent saving when someone opens
 * and then closes a door.
 */
void door_action() {
  if(_door_opened || _door_unlocked) {
    event_save(this_object());
#ifdef DEBUG_SAVE
    debug_log("saving opened %d unlocked %d", _door_opened, 
        _door_unlocked);
  } else {
    debug_log("not saving %s door has returned "
        "to original state.\n", base_name(this_object()));
#endif
  }
  _door_opened = 0;
  _door_unlocked = 0;
}

/** @ignore yes */
void event_open(object door, object opener) {
  _door_opened++;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}

/** @ignore yes */
void event_close(object door, object closer) {
  _door_opened--;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}

/** @ignore yes */
void event_unlock(object door, object unlocker) {
  debug_printf("Event unlock called %O", door);
  _door_unlocked++;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}

/** @ignore yes */
void event_lock(object door, object locker) {
  debug_printf("Event lock called %O", door);
  _door_unlocked--;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}

/** @ignore yes */
void do_save() {
  int saved;
  
#ifdef DEBUG_SAVE  
  object ob;
#endif
  
  remove_call_out("do_save");

  // No save file, no save.
  if(!_save_file || _save_file == "") {
#ifdef DEBUG_SAVE
    log_file("ROOM_SAVE", "%s no save file for %s\n", ctime(time())[4..18],
             base_name(this_object()));
#endif
    return;
  }
  
  details = ([ ]);
  details = query_dynamic_auto_load();

#ifdef USE_RAMDISK
  if(_ram_file)
    saved = unguarded((: save_object, _ram_file, 3 :));
  else
#endif
    saved = unguarded((: save_object, _save_file, 3 :));
  
#ifdef DEBUG_SAVE
  if (saved) {
    log_file("HOUSING_DEBUG",
             "%s %s saved.\n", ctime(time())[4..18],
             base_name(this_object()));
  } else {
    log_file("HOUSING_DEBUG",
             "%s %s failed to save.\n", ctime(time())[4..18],
             base_name(this_object()));
  }
#endif
  
#ifdef DEBUG_INVENTORY
  foreach(ob in all_inventory(this_object())) {
    if(test_save(ob))
      log_file(base_name(this_object()) + ".log",
               "%s %s contained %d items.\n", ctime(time())[4..18],
               ob->query_short(), sizeof(deep_inventory(ob)));
  }
#endif  
  _last_saved = time();
}

/**
 * @ignore yes
 * This causes the inventory to be loaded
 */
void do_load( object thing ) {
  mapping tmp;
  string fname;
  
  if(_save_file) {
    if(_ram_file &&
       (file_size(_ram_file + ".o.gz") > 0 || file_size(_ram_file + ".o") > 0))
      fname = _ram_file;
    else
      fname = _save_file;
    
    if(file_size(fname + ".o.gz") > 0 || file_size(fname + ".o") > 0) {
      tmp = this_object()->query_properties();
      unguarded((: restore_object, fname :));
      this_object()->set_properties(tmp);
      
      if ( sizeof( details ) ) {
        init_dynamic_arg( details );
      } else {
        // If there is no save file then set out inventory as loaded.
        _inventory_loaded = 1;
      }
    } else {
      // If there is no save file then set out inventory as loaded.
      _inventory_loaded = 1;
    }
  }
  // prevent us doing a save.
  _last_saved = time();
  remove_call_out("do_save");
  remove_call_out("door_action");
  _door_opened = 0;
  _door_unlocked = 0;
}

/**
 * @ignore yes
 * Makes sure furniture is removed from the save file
 * when its removed from this room.
 */
int test_remove(object thing, int flag, mixed dest) {
  if(test_save(thing))
    event(this_object(), "save", thing);
  return 1;
}

/**
 * @ignore yes
 * Makes sure furniture is saved when its put in this room.
 */
int test_add( object ob, int flag) {
  if(!query_auto_loading() && test_save(ob))
    event(this_object(), "save", ob);
  return 1;
}

/** @ignore yes
 * This container cannot be added into other containers.
 */
int query_prevent_insert() { return 1; }

/** @ignore yes */
mapping query_dynamic_auto_load() {
  mapping map;
  string *obs;

  map = ([ ]);

#ifdef DISABLED
  if ( _effects ) {
    if ( sizeof( (mixed *)_effects->query_effs() ) ) {
      _effects->effect_freeze();
      _effects->effects_saving();
      map += ([
               "effects" : ({
                 (mixed *)_effects->query_effs(),
                 (int *)_effects->query_eeq()
               })
      ]);
      _effects->effect_unfreeze();
    }
  }
#endif
  
  obs = filter(all_inventory(this_object()), "test_save");
  
  // Try the autoload object.
  catch(obs = AUTO_LOAD_OB->create_auto_load( obs, 0 ) );
  map["inv"] = obs;
  
  return map;
} /* query_dynamic_auto_load() */

/**
 * We make sure that receipts are set to 'no get' when moved into the room.
 */
private int move_to_dest(object ob) {
   if (base_name(ob) == PLAYER_RECEIPT) {
      ob->reset_get();
   }
   return ob->move(this_object());
}

/** @ignore yes */
void init_dynamic_arg( mapping bing ) {
#ifdef DEBUG_INVENTORY
  object ob;

  log_file(base_name(this_object()) + ".log",
           "%s Loading.\n", ctime(time())[4..18]);
#endif  
  if ( !mapp( bing ) ) {
#ifdef DEBUG_INVENTORY  
  log_file(base_name(this_object()) + ".log",
           "%s no mapping to load.\n", ctime(time())[4..18]);
#endif  
    return;
  }
  
  if ( bing[ "effects" ] ) {
    _effects->set_effs( bing[ "effects" ][ 0 ] );
    _effects->set_eeq( bing[ "effects" ][ 1 ] );
    if ( environment() && shadow( this_object(), 0 ) )
       move_object( environment() );
    _effects->init_after_save();
  }
  
#ifdef DEBUG_INVENTORY  
  log_file(base_name(this_object()) + ".log",
           "%s done effects.\n", ctime(time())[4..18]);
#endif  

  /*
   * Potential order of inventory generation problem here...  Where the
   * upper parts of the container don't initialise until after we
   * return...
   */
  if ( bing[ "inv" ] && !_inventory_loaded) {
#ifdef DEBUG_INVENTORY  
  log_file(base_name(this_object()) + ".log",
           "%s starting inventory.\n", ctime(time())[4..18]);
#endif  
    AUTO_LOAD_OB->load_auto_load_to_inventory( bing["inv"], this_object(),
                                               this_player(),
                                               (: move_to_dest($1) :) );
    _inventory_loaded = 1;
  } else {
#ifdef DEBUG_INVENTORY  
  log_file(base_name(this_object()) + ".log",
           "%s inventory_loaded already set.\n", ctime(time())[4..18]);
#endif  
  }
#ifdef DEBUG_INVENTORY
  log_file(base_name(this_object()) + ".log",
           "%s done inventory.\n", ctime(time())[4..18]);
  foreach(ob in all_inventory(this_object())) {
    if(test_save(ob))
      log_file(base_name(this_object()) + ".log",
               "%s %s contains %d items.\n", ctime(time())[4..18],
               ob->query_short(), sizeof(deep_inventory(ob)));
  }
  if(!sizeof(all_inventory(this_object())))
    log_file(base_name(this_object()) + ".log",
             "%s room has no inventory.\n", ctime(time())[4..18]);
    
#endif
} /* init_dynamic_arg() */


/** @ignore yes */
void check_euid() {   
  if ( previous_object() ) {
    seteuid( geteuid( previous_object() ) );
  }
} /* check_euid() */

/** @ignore yes
 * Cleanup could screw us up so we stay loaded.
 */
int query_keep_room_loaded() { return 1; }

/** @ignore yes
 * Do any outstanding saves.
 */
void dest_me() {
  if(find_call_out("do_save") != -1)
    do_save();
}

/** @ignore yes */
int query_inventory_loaded() { return _inventory_loaded; }
// --- END [/mnt/home2/grok/lib/std/room/inherit/room_save.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/p_library.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/p_library.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629424   Available: 13576778
Inodes: Total: 5242880    Free: 4960136
39846 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/p_library.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629424   Available: 13576778
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Library inherit. Allows players to take out books on loan. If
 * set to be player contributable, then books (most likely player 
 * written, but any kind) can be added/removed by designated 
 * librarian players.
 *
 * @author Aquilo
 */

// ToDo 
// Functions to be called when a damaged/lost book is reported for a player
// Prevent returning of books w/ pages ripped out.
// Gving status of a book, who has it on loan, ue back etc...

#include <book_handler.h>
#include <money.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#include <am_time.h>

#define BASE_PATHS ({ "/std/book", "/std/book_dir", "/std/leaflet", \
                      "/obj/misc/paper", "/obj/misc/nroff_paper" })

#define TITLE_PROP          "title"
#define AUTHOR_PROP         "author"
#define FROM_LIBRARY_PROP   "from library"
#define BORROWED_BY_PROP    "borrowed by"
#define DUE_BACK_PROP       "due back"
#define REFERENCE_ONLY_PROP "reference only"

#define USER_ACCESS      1
#define LIBRARIAN_ACCESS 2

inherit "/std/room/basic_room";

nosave int       _player_contributable;
nosave string    _library_name;
nosave string    _save_file;
nosave function  _borrow_func;
nosave function  _test_allowed;

int       _loan_length;
int       _fine_per_day;
int       _lost_damaged_fine;
int       _max_loans;

mapping _catalog;    // ([ librarybook id : class _book ])
mapping _accounts;   // ([ playername     : class _account ])
mapping _fines;      // ([ playername     : int fine ])
mapping _access;     // ([ playername     : int access ])

nosave mapping _catalog_by_title;    // ([ "title" : ({ library id }) ])
nosave mapping _catalog_by_author;   // ([ "author" : ({ library id }) ])

/**
 * This is all the info on one of our stored books.
 * @element path the path to the item, if applicable
 * @element auto_load if no path, we store the object whole in this string
 * @element cap_title the capitalized title of the book
 * @element cap_author the capitalized author of the book
 * @element borrowable 1 if this book can be borrowed, 0 if not
 * @element copies Total number of copies owned by library
 * @element loaned An array of due back dates for loaned out copies
 * @element total_borrowed total no of times this book has been borrowed
 */
class _book { 
    string     path;     
    string     auto_load;
    string     cap_title;
    string     cap_author;
    mapping    loaned;
    int        borrowable;
    int        copies;
    int        total_borrowed;
}

/**
 * This holds info on a book a player has borrowed
 * @element id the librarybook id num
 * @element due_back the rl time due back, in secs from 1970
 */
class _loan {
    int       id;
    int       due_back;
}

/**
 * Holds info on a player.
 * @element total_fines_paid how much this blokie has paid in fines in total
 * @element damaged_books total number of books he has damaged
 * @element lost_books total number of books he has lost
 * @element loans info on what  books he currently has out
 */ 
class _account {
    int           total_fines_paid;
    int           lost_damaged;
    class _loan   *loans;
}

int do_add( object *obs, string title, string author );
int do_remove_book( int id );
int do_borrow( mixed arg );
int do_return( object *obs );
int do_list( string arg, string to, string from, string specific );
int do_status( string player );
int do_book_status( int id );
int do_set( string player, string type );
int do_mark( int id, int flag );
int do_set_fine( int i );
int do_set_loan_length( int days );
int do_set_max_loans( int i );
int do_lost_damaged_fine( int i );
int do_report( int id, string arg, string player );

mapping query_loans( string name );
mapping query_borrowed_by( int id );
int query_fine( string name );

void clear_loan( mixed player, int id, int calc_fines );
varargs int add_book_to_library( mixed thing, int copies, string cap_title, 
                                 string cap_author, int borrowable );
void set_access( string player, int access );
int query_access( mixed player );
int do_set( string player, string type );
void save_me();

protected string make_pretty_catalog( string arg, string from, string to, string specific );
protected int compare_widgets( object new_ob, int existing_id );

/** @ignore yes */
protected void build_catalogs(){
  int id;
  class _book book;

  foreach( id, book in _catalog ){
    if( _catalog_by_author[ lower_case(book->cap_author) ] )
      _catalog_by_author[ lower_case(book->cap_author) ] += ({ id });
    else
      _catalog_by_author[ lower_case(book->cap_author) ] = ({ id });

    if( _catalog_by_title[ lower_case(book->cap_title) ] )
      _catalog_by_title[ lower_case(book->cap_title) ] += ({ id });
    else
      _catalog_by_title[ lower_case(book->cap_title) ] = ({ id });
  }

}


/** @ignore yes */
void create(){
  object sign;
  ::create();

  _catalog_by_author = ([ ]);
  _catalog_by_title = ([ ]);

  /* Some default settings */
  _player_contributable = 1;
  _library_name = "The illustrious library of fluff";
  _save_file = base_name( this_object() ) + ".o";

  if( master()->file_exists(_save_file) ){
    unguarded( (: restore_object, _save_file :) );
  } else {
    _catalog = ([ ]);
    _accounts = ([ ]);
    _fines = ([ ]);
    _access = ([ ]);
    _loan_length = 3 * 24 * 60 * 60;
    _fine_per_day = 400;
    _lost_damaged_fine = 1050;
    _max_loans = 5;
  }

  build_catalogs();

  add_help_file("p_library_user");
  add_help_file("p_library_librarian");

  sign = add_sign( 
      "The plaque is a traditional brass plate, set on top a piece "
      "of cherry oak. It looks very formal.\n",
      "For some reason, reading this sign doesn't give you as much "
      "information as looking at it would.\n",
      "brass plaque", "plaque", "common" );
  sign->add_extra_look( this_object() );
  sign->set_read_mess( 0, 0, 0 );

/*
  if ( !do_setup ) { 
    this_object()->setup();
  }
*/

}


/*
void setup(){
  set_short("small library");
  set_long("A library. Lots of books everywhere.\n");
  set_light(70);
}
*/

/** @ignore yes */
int query_library(){  return 1;  }

/** @ignore yes */
void init(){
  if( _player_contributable ){
    add_command( "add", "<indirect:object:me'book'> with "
        "title <string'title'> by author <word'author'>",
        (: do_add( $1, $4[1], $4[2] ) :) );
    add_command( "remove", "<number'book id'>", 
        (: do_remove_book( $4[0] ) :));
  }

  add_command( "borrow", "<number'book id'>", (: do_borrow( $4[0] ) :) );
  add_command( "return", "<indirect:object:me-here>" );
  add_command( "pay", "[fine]"  );

  add_command( "view", "catalogue by {author|title}", (: do_list( $4[0], "a", "z", 0 ) :) );
  add_command( "view", "catalogue by {author|title} from "
      "<word'letter'> to <word'letter'>", (: do_list( $4[0], $4[1], $4[2], 0 ) :) );

  add_command( "view", "works by <string'author'>", 
      (: do_list( "author", 0, 0, $4[0] ) :) );
  add_command( "view", "works titled <string'title'>",
      (: do_list( "title", 0, 0, $4[0] ) :) );

  add_command( "status", "", (: do_status(0) :) );

  add_command( "status", "book <number'book id'>", 
               (: do_book_status( $4[0] ) :) );  

  add_command( "report", "<number'book id'> as {damaged|lost}",
               (: do_report( $4[0], $4[1], 0 ) :) );

  /* Librarian only commands */

  add_command( "set", "access for <word'player'> to {allowed|disallowed}", 
               (: do_set( $4[0], $4[1] ) :) );

  add_command( "set", "fine per day to <number'amount'>", 
               (: do_set_fine( $4[0] ) :) );

  add_command( "set", "loan length to <number'number of days'>", 
               (: do_set_loan_length( $4[0] ) :) );

  add_command( "set", "maximum number of loans to <number'number'>", 
               (: do_set_max_loans( $4[0] ) :) );

  add_command( "set", "lost or damaged fine to <number'amount'>", 
               (: do_lost_damaged_fine( $4[0] ) :) );

  add_command( "mark", "<number'book id'> as reference only",
    (: do_mark( $4[0], 1) :) );

  add_command( "mark", "<number'book id'> as not reference only", 
    (: do_mark( $4[0], 0) :) );

  add_command( "status", "<word'player'>", (: do_status($4[0]) :) );

  add_command( "report", "<number'book id'> as {damaged|lost} for <word'player'>",
               (: do_report( $4[0], $4[1], $4[2] ) :) );



}

/** @ignore yes */
protected string id_to_name( int id ){
  if( !_catalog[id] )
    return 0;
  return "'" +_catalog[id]->cap_title+ "' by " + _catalog[id]->cap_author;
}

/** @ignore yes */
protected int valid_media( object ob ){
  if( ob->query_book() || ob->query_paper() || ob->query_leaflet() )
    return 1;
}

/** @ignore yes */
int do_add( object *obs, string title, string author ){
  object t_p, t_o;
  int num, id, *ids;

  t_p = this_player();
  t_o = this_object();

  debug_printf( "Obs: %O\n", obs );

  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("Only librians can do this.\n");
    return 0;
  }

  if( strlen(author) > 14 ){
    add_failed_mess("The author's name is too long. It has to be less than 13 characters.\n");
    return 0;
  }

  if( strlen(title) > 26 ){
    add_failed_mess("The title is too long. It can only use less than 27 characters.\n");
    return 0;
  }

  if( sizeof(obs) > 1 ){
    add_failed_mess("You can only add one item at a time.\n");
    return 0;
  }

  if( !t_o->valid_media(obs[0]) ){
    add_failed_mess( "The library does not lend items like $I.\n", obs);
    return 0;
  }

  if( obs[0]->query_magic_scroll() || obs[0]->query_spell_book() ){
    add_failed_mess( "This library does not deal in magical works.\n" );
    return 0;
  }

  if( obs[0]->query_property(FROM_LIBRARY_PROP) ){
    add_failed_mess( "This item belongs to a library and cannot be added.\n" );
    return 0;
  }


  if( (num = obs[0]->query_book_num()) ){   // then its a player written book
    if( lower_case(author) != BOOK_HANDLER->query_book_owner(num) ){
      add_failed_mess( "The book has been authored by " + 
        capitalize(BOOK_HANDLER->query_book_owner(num)) + " and not " + 
        author + ".\n");
      return 0;
    }
  }



  if( (ids = _catalog_by_title[ lower_case(title) ]) ){
    foreach( id in ids ){
      if( lower_case(_catalog[id]->cap_author) == lower_case(author) ){
        // Then we already have a book of the same title by the same author
        // Make sure that they are infact the same...
        if( compare_widgets( obs[0], id ) ){
          add_book_to_library( id, 1 );
          add_succeeded_mess( "$N add$s another copy of "
              +id_to_name(id)+ " to the library.\n" );
          obs[0]->move( "/room/rubbish" );
          return 1;
        } else {
          add_failed_mess("$I doesn't seem to be the same as the copy held "
            "in the library. Catalogue it under a different title or author.\n", obs );
          return 0;
        }
      }
    }
  }
        
  if( member_array(base_name(obs[0]), BASE_PATHS) == -1 )
    add_book_to_library( base_name(obs[0]), 1, title, author, 1 );
  else
    add_book_to_library( obs[0], 1, title, author, 1 );    

  add_succeeded_mess( "$N $V an item to the library.\n" );
  obs[0]->move( "/room/rubbish" );
  return 1;
}

/** @ignore yes */
void remove_book( int id ){
  object ob;
  class _book book;
  int i;

  if( !_catalog[id] )
    return;

  book = _catalog[id];

  for( i = 0; i < (book->copies - sizeof(book->loaned)); i++ ){
    if( book->path )
      ob = clone_object( book->path );
    if( book->auto_load )
      ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];

    ob->move( this_object() );
  }

  _catalog_by_title[lower_case(book->cap_title)] -= ({ id });
  _catalog_by_author[lower_case(book->cap_author)] -= ({ id });

  if( !sizeof( _catalog_by_title[lower_case(book->cap_title)] ) )
    map_delete( _catalog_by_title, lower_case(book->cap_title) );
  if( !sizeof( _catalog_by_author[lower_case(book->cap_author)] ) )
    map_delete( _catalog_by_author, lower_case(book->cap_author) );

  map_delete( _catalog, id );
  save_me();
}

/** @ignore yes */
int do_remove_book( int id ){
  int out;
  string player, bit;
  class _account account;
  class _loan loan;

  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("Only librians can do this.\n");
    return 0;
  }

  id = to_int(id);
  if( !_catalog[id] ){
    add_failed_mess("There is no item with that id.\n");
    return 0;
  }

  foreach( player, account in _accounts ){
    foreach( loan in account->loans ){
      if( loan->id == id )
        out++;
    }
  }

  if( out ){
    if( out > 1 ) 
      bit = "are " +query_num(out)+ " ";
    else 
      bit = "is one"+" ";
    add_failed_mess( "There " +bit+ id_to_name(id) + 
        ", out on loan already. You can only remove a book if all "
        "copies are in the library.\n" );
    return 0;
  } else {
    add_succeeded_mess("$N $V " +id_to_name(id) + " from the library.\n" );
    remove_book(id);
    tell_object( this_player(), "Any remaining copies will be placed on the floor.\n");
    return 1;
  } 

}

/** @ignore yes */
int do_borrow( mixed arg ){
  int id, ret, t;
  object ob;
  class _book book;
  class _loan loan;
  string name;
  
  name = this_player()->query_name();
  id = to_int(arg);

  if( query_access(this_player()) < USER_ACCESS ){
    add_failed_mess("You do not have access to this library.\n");
    return 0;
  }

  if( _borrow_func ){
    ret = evaluate( _borrow_func, this_player(), id );
    if( ret != 1 )
      return ret;
  }

  if( _fines[name] ){
    add_failed_mess("You can't borrow a book whilst having outstanding fines.\n" );
    return 0;
  }

  if( !_catalog[id] ){
    add_failed_mess("There is no book with an id of " +id+ ".\n" );
    return 0;
  } else {
    book = _catalog[id];
  }

  if( _accounts[name] && sizeof(_accounts[name]->loans) >= _max_loans ){
    add_failed_mess("You have already borrowed the maximum number of books.\n");
    return 0;
  }

  if( (book->copies - sizeof(book->loaned)) < 1 ){
    add_failed_mess("Unfortunately, all copies of " +
        id_to_name(id) + " are out on loan.\n");
    return 0;
  }

  if( _accounts[name] && sizeof( _accounts[name]->loans ) ){
    foreach( loan in _accounts[name]->loans ){
      if( loan->id == id ){
        add_failed_mess("You have already borrowed a copy of " + 
            id_to_name(id) + ".\n");
        return 0;
      }
    }
  }

  if( book->path )
    ob = clone_object( book->path );
  if( book->auto_load )
    ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];

  if( !ob ){
    add_failed_mess("Uh oh, something buggered with book id: " + id + 
      ". Please tell a creator.\n" );
    return 0;
  } 

  t = time() + _loan_length;

  ob->add_property( TITLE_PROP, book->cap_title );
  ob->add_property( AUTHOR_PROP, book->cap_author );
  ob->add_property( FROM_LIBRARY_PROP, _library_name );
  ob->add_property( BORROWED_BY_PROP, name );
  ob->add_property( DUE_BACK_PROP, t );

  book->loaned[name] = t;
  book->total_borrowed++;
  _catalog[id] = book;

  loan = new( class _loan, id : id, due_back : t );

  if( _accounts[name] )
    _accounts[name]->loans += ({ loan });
  else {
    // Start them up an account
    _accounts[name] = new( class _account, total_fines_paid : 0,
                           lost_damaged : 0,
                           loans : ({ loan }) );
  }


  if( !book->borrowable ){
    tell_object( this_player(), id_to_name(id)+ " is a reference only book. "
      "It will be placed on "
      "a lecturn for you to read and cannot be removed from the library. Please return it "
      "in the normal way after use.\n");
    ob->move( this_object() );
    ob->reset_get();
    ob->add_property( "there", "sitting on a lecturn" );
    ob->add_property( REFERENCE_ONLY_PROP, 1 );
  } else {
    tell_object( this_player(), "You have until "+ am_time(t) + 
        " to return it.\n");
    ob->move( this_player() );
  }  
  save_me();
  add_succeeded_mess( "$N $V " +id_to_name(id)+ ".\n");
  return 1;
}

/** @ignore yes */
int do_return( object *obs ){
  string name, bit;
  int id, *owed, i, *ours, due;
  class _loan loan;
  class _book book;
  object ob, *not_ours, *wrong_player, *returned;

  name = this_player()->query_name();
  owed = ({ }); 
  ours = not_ours = wrong_player = returned = ({ });


  if( !sizeof(_accounts[name]->loans) ){
    add_failed_mess( "You don't have any books out on loan.\n" );
    return 0;
  }

  foreach( loan in _accounts[name]->loans ){
    owed += ({ loan->id });
  }

  foreach( ob in obs ){
    if( ob->query_property( FROM_LIBRARY_PROP ) == _library_name ){
      if( ob->query_property( BORROWED_BY_PROP ) == name ){     
        foreach( id in owed ){
          if( (book = _catalog[id]) ){
            if( ob->query_property( TITLE_PROP ) == book->cap_title && 
                ob->query_property( AUTHOR_PROP ) == book->cap_author ){

              /* Make sure it has same pages in here... */

              map_delete( _catalog[id]->loaned, name );
              ob->move("/room/rubbish");
              returned += ({ ob });
              ours += ({ id });
            }  
          } else {
            // Book no longer matches id....What to do?
            // Take book from player, clear loan then dest?
            ob->move("/room/rubbish");
            returned += ({ ob });
          }
        }
      } else {
        wrong_player += ({ ob });
      }
    } else {
      not_ours += ({ ob });
    }
  }

  if( sizeof(returned) ){
    foreach( i in ours )
      clear_loan( this_player(), i, 1 );
    if( _fines[name] )
      tell_object(this_player(), "Note: You have fines that are due.\n");
    add_succeeded_mess( "$N $V $I.\n", returned );
    return 1;
  }

  if( (i=sizeof(not_ours)) ){
    if( i > 1 ) bit = "do not"; else bit = "does not";
    add_failed_mess( "$I " +bit+ " belong to this library.\n", not_ours );
    return 0;
  }
 
  if( (i=sizeof(wrong_player)) ){
    if( i > 1 ) bit = "were not"; else bit = "was not";
    add_failed_mess( "$I " +bit+ " were not loaned to you. Only the borrower may "
        "return items.\n", wrong_player );
    return 0;
  }

}

/** @ignore yes */
int do_list( string arg, string from, string to, string specific ){

  if( (to && !stringp(to)) || (from && !stringp(from)) ){
    add_failed_mess( "The ranges must be letters.\n");
    return 0;
  }

  if( specific ){
    tell_object( this_player(), make_pretty_catalog( arg, 0, 0, lower_case(specific) ) );
    return 1;
  } else {
    tell_object( this_player(), make_pretty_catalog( arg, from, to, 0 ) );
    return 1;
  }

}

/** @ignore yes */
int do_pay(){
  int cash, fine;
  string place, str;

  place = query_property( "place" );
  if ( !place || ( place == "" ) )
    place = "default";

  cash = this_player()->query_value_in( place );
  if ( place != "default" )
    cash += this_player()->query_value_in( "default" );

  if( !cash ){
    add_failed_mess("You have money!.\n");
    return 0;
  }

  fine = _fines[this_player()->query_name()];
  if( fine <= 0 ){
    add_failed_mess("You have no outstanding fines to pay.\n");
    return 0;
  }

  if( cash >= fine )
    cash = fine;
  
  this_player()->pay_money( MONEY_HAND->create_money_array(cash, place), place );
  _fines[this_player()->query_name()] -= cash;
  _accounts[this_player()->query_name()]->total_fines_paid += cash;

  if( _fines[this_player()->query_name()] <= 0 ){
    str = MONEY_HAND->money_value_string( cash, place );
    add_succeeded_mess("$N pay$s all $p fines ("+str+").\n");
    map_delete( _fines, this_player()->query_name() );
    save_me();
    return 1;
  } else {
    str = MONEY_HAND->money_value_string( fine - cash, place );
    add_succeeded_mess("$N pay$s some of $p fine, but sill owe$s ("+str+").\n");
    save_me();
    return 1;
  }

}

/** @ignore yes */
int do_status( string player ){
  int fine;
  string place, str, bit;
  class _loan loan;

  if( !player )
    player = this_player()->query_name();

  player = lower_case(player);

  if( player != this_player()->query_name() &&
      query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have access to see other accounts.\n");
    return 0;
  }

  str = "Account status for " + PLAYER_HANDLER->query_cap_name(player) +".\n";

  if( _accounts[player] && sizeof(_accounts[player]->loans)  ){
    str += "Loaned items:\n";
    str += sprintf( "%|4s%|=30s%|=20s%|9s\n", "Id", "Item", "Due back", "Overdue" );
    foreach( loan in _accounts[player]->loans ){
      if( loan->due_back - time() > 0 )
        bit = "";
      else 
        bit = "*Yes*";
      str += sprintf( "%|4d%|=30s%|=20s%|9s\n", loan->id,
          id_to_name(loan->id), am_time( loan->due_back ), bit );
    }
  } else {
    str += "No items currently on loan.\n";
  }
  

  place = query_property( "place" );
  if ( !place || ( place == "" ) )
    place = "default";

  fine = _fines[player];
  if( fine >= 0 ){
    str += sprintf( "%-15s%-6s\n", "Fines Due:", 
           MONEY_HAND->money_value_string( fine, place ) );
  } else {
    str += "No fines due.\n";
  }
  if( _accounts[player] ){
    str += "Total previously paid fines: " +
      MONEY_HAND->money_value_string( _accounts[player]->total_fines_paid, place );
    str += ".\nBooks lost or damaged: " + _accounts[player]->lost_damaged + ".\n";
  }


  tell_object( this_player(), str );
  add_succeeded_mess("");
  return 1;
}


/** @ignore yes */
int do_book_status( int id ){
  string str, name, date;
  class _book book;

  id = to_int(id);

  if( !_catalog[id] ){
    add_failed_mess("The id " +id+ ", does not point to an item.\n");
    return 0;
  }
  book = _catalog[id];
  str = "Status for id: " +id+ " - " + id_to_name(id) + ".\n";
 
  if( sizeof(book->loaned) ){
    str += sprintf( "%|=14s%|=30s\n", "On loan to", "Date Due Back " );
    foreach( name, date in book->loaned ){
      str += sprintf( "%|=12s%|=30s\n", 
             PLAYER_HANDLER->query_cap_name(name), am_time(date) );
    }
  } else {
    str += "Currently, no copies of the item are on loan.";
  }

  str += "The library holds " + (string)book->copies; 
  if( book->copies == 1 ) str += " copy "; else str += " copies ";
  str += "in total, " + (string)( book->copies - sizeof(book->loaned) ) +
         " of which are available.\n";

  str += "It has been borrowed a total of " + book->total_borrowed;
  if( book->total_borrowed == 1 ) str += " time.\n"; else str += " times.\n";
 
  if( !book->borrowable )
    str += "It is a reference only item.\n";
  tell_object( this_player(), str);
  add_succeeded_mess("$N look$s at the status of a library item.\n");
  return 1;
}


/** @ignore yes */
int do_set( string player, string type ){

  player = lower_case(player);

  if( query_access(this_object()) <= query_access(player) ){
    add_failed_mess( "You do not have permission to do this.\n");
    return -1;
  }

  if( type == "allowed" ){
    if( query_access(player) < USER_ACCESS ){
      set_access( player, USER_ACCESS );
      add_succeeded_mess("$N allow$s " + PLAYER_HANDLER->query_cap_name(player) + 
        " to use the library.\n");
      save_me();
      return 1;
    }
  }

  if( type == "disallowed" ){
    if( query_access(player) == USER_ACCESS ){
      set_access( player, 0 );
      add_succeeded_mess("$N disallow$s " + PLAYER_HANDLER->query_cap_name(player) + 
        " from using the library.\n");
      save_me();
      return 1;
    }
  }
}


int do_mark( int id, int flag ){

  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }

  if( !_catalog[id] ){
    add_failed_mess("There is no item with that id.\n");
    return 0;
  }

  if( flag ){
    add_succeeded_mess("$N $V " + id_to_name(id) + " to reference only.\n");
    _catalog[id]->borrowable = 0;
    return 1;
  } else {
    add_succeeded_mess("$N $V " + id_to_name(id) + " to not reference only.\n");
    _catalog[id]->borrowable = 1;
    return 1;
  }
  save_me();
}

int do_set_fine( int i ){
  string place;

  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }

  place = query_property( "place" );
  if( !place || ( place == "" ) )
    place = "default";
   
  i = to_int(i);

  if( i < 0 ){
    add_failed_mess("Don't be silly, thats a negative value!\n");
    return 0;
  }

  if( i > 4000 ){
    add_failed_mess("The maximum fine you can set per day is 4000 units (" +
        MONEY_HAND->money_value_string( 4000, place ) + ").\n" );
    return 0;
  }

  add_succeeded_mess("$N set$s the fine per day to " + i +
    " ("+ MONEY_HAND->money_value_string( i, place ) + ").\n" );
  _fine_per_day = i;
  save_me();
  return 1;
}


int do_set_loan_length( int days ){
  string str;

  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  days = to_int(days);

  if( days > 10 ){
    add_failed_mess("The maximum loan length is 10 days.\n");
    return 0;
  }

  if( days < 1 ){
    add_failed_mess("The minimum loan length is 1 day.\n");
    return 0;
  }
  if( days == 1 )  str = " day"; else str = " days";

  add_succeeded_mess("$N set$s the loan length to " 
     + query_num(days) + str + ".\n" );
  _loan_length = days * AM_SECONDS_PER_DAY;
  save_me();
  return 1;
}

/** @ignore yes */
int do_set_max_loans( int i ){

  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  i = to_int(i);

  if( i < 1 ){
    add_failed_mess("The minimum amount of loans is one.\n");
    return 0;
  }

  if( i > 10 ){
    add_failed_mess("The maximum amount of loans a player can have is ten.\n");
    return 0;
  }

  add_succeeded_mess("$N set$s the maximum number of loans to " 
     + query_num(i) + " items.\n" );
  _max_loans = i;
  save_me();
  return 1;

}

int do_lost_damaged_fine( int i ){
  string place;
 
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  i = to_int(i);
  place = query_property( "place" );
  if( !place || ( place == "" ) )
    place = "default";
   
  if( i < 0 ){
    add_failed_mess("Don't be silly, thats a negative value!\n");
    return 0;
  }

  if( i > 20000 ){
    add_failed_mess("The maximum fine you can set per day is 20000 units (" +
        MONEY_HAND->money_value_string( 20000, place ) + ").\n" );
    return 0;
  }

  add_succeeded_mess("$N set$s the lost or damaged fine to " + i +
    " ("+ MONEY_HAND->money_value_string( i, place ) + ").\n" );
  _lost_damaged_fine = i;
  save_me();
  return 1;


}

int do_report( int id, string arg, string player ){
  string str;
  class _loan loan, match;

  if( player && query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You can only report your damaged or lost books.\n");
    return 0;
  }
 
  if( player ){
    str = PLAYER_HANDLER->query_cap_name(player)+ " does";
    player = lower_case(player);
  } else {
    str = "You do";
    player = this_player()->query_name();
  }

  if( !_accounts[player] ){
    add_failed_mess(str + " not have any items on loan.\n");
    return 0;
  }

  if( !_catalog[id] ){
    add_failed_mess("The id " + id + " does not exist.\n");
    return 0;
  }


  foreach( loan in _accounts[player]->loans ){
    if( loan->id == id ){
      match = loan;
    }
  }
  if( !match ){
    add_failed_mess(str + " not have " + id_to_name(id) + " out on loan.\n");
    return 0;
  }

  _accounts[player]->loans -= ({ match });
  map_delete( _catalog[id]->loaned, player );
  _catalog[id]->copies--;
  
  if( player == this_player()->query_name() ) 
    str = "";
  else 
    str = " for " + PLAYER_HANDLER->query_cap_name(player);

  if( _fines[player] )
    _fines[player] += _lost_damaged_fine;
  else
    _fines[player] = _lost_damaged_fine;

  if( arg == "lost" ){
    add_succeeded_mess("You report the loss of " + id_to_name(id) + str + ".\n");
    _accounts[player]->lost_damaged++;
    save_me();
    return 1;
  } 
  if( arg == "damaged" ){
    add_succeeded_mess("You report the damaging of " +id_to_name(id) + str + ".\n");
    _accounts[player]->lost_damaged++;
    save_me();
    return 1;
  }

}


/** @ignore yes */
protected string make_pretty_catalog( string arg, string from, string to, string specific ){
  string widget, c_widget, str, *list;
  int id, *ids;

  if( !from )
    from = "a";
  else
    from = lower_case(from);

  if( !to )
    to = "z";
  else 
    to = lower_case(to);

  if( from > to ){ 
    /* Then they have said between z and a, rather than a to z,
       silly buggers */
    widget = to;
    to = from;
    from = widget;
  }

  if( specific ){
    if( _catalog_by_title[specific] || _catalog_by_author[specific] )
      list = ({ specific });
    else
      list = ({ });
  }

  if( arg == "title" ){

    str = sprintf( "%|=4s%|=26s%|=12s%|=9s%|=8s\n", 
            "Id", "Title", "Author", "Copies", "On Loan" );

    if( !list )
      list = sort_array( keys(_catalog_by_title), 0 );

    foreach( widget in list ){
      ids = _catalog_by_title[ widget ];
      if( widget && sizeof(ids) && (widget[0..0] >= from) && (widget[0..0] <= to) ){
        foreach( id in ids ){
          c_widget = _catalog[ id ]->cap_title;
          str += sprintf( "%|=4d%|=26s%|=12s%|=9d%|=8d\n", 
                   id, c_widget, _catalog[id]->cap_author, 
                   _catalog[id]->copies, sizeof(_catalog[id]->loaned) );
        }
      }
    }
    return str;
  } 


  if( arg == "author" ){

    str = sprintf( "%|=4s%|=12s%|=26s%|=9s%|=8s\n", 
            "Id", "Author", "Title", "Copies", "On Loan" );

    if( !list )
      list = sort_array( keys(_catalog_by_author), 0 );

    foreach( widget in list ){
      ids = _catalog_by_author[ widget ];
      if( widget && sizeof(ids) && (widget[0..0] >= from) && (widget[0..0] <= to) ){
        foreach( id in ids ){
          c_widget = _catalog[ id ]->cap_title;
          str += sprintf( "%|=4d%|=12s%|=26s%|=9d%|=8d\n", 
                   id, _catalog[id]->cap_author, c_widget,
                   _catalog[id]->copies, sizeof(_catalog[id]->loaned) );
        }
      }
    }
    return str;
  }


}

/**
 * This clears the loan of library book id the specified player.
 * If its overdue it sorts out adding a fine to his name.
 * @param player Either the player name or object
 * @param id the library book id
 * @param calc_fines if this is 1, then we add fines onto the player
 * if appropriate, if 0 then we ignore fines and just clear the loan
 */
void clear_loan( mixed player, int id, int calc_fines ){
  int fine;
  class _loan loan;

  if( objectp(player) && userp(player) )
    player = player->query_name();

  if( !stringp(player) )  return;
  if( !_accounts[player] || !sizeof(_accounts[player]->loans) )  return;

  foreach( loan in _accounts[player]->loans ){
    if( loan->id == id ){
      if( calc_fines && (loan->due_back - time() < 0) ){   // Naughty!
        fine = (((time() - loan->due_back) / AM_SECONDS_PER_DAY) + 1) * _fine_per_day;
        if( _fines[player] )
          _fines[player] += fine;
        else
          _fines[player] = fine;
      }
      _accounts[player]->loans -= ({ loan });
    }
  }  
  save_me();
}


/** @ignore yes */
protected int find_blank_id(){
  int *ids;
  int unused_id, i;

  ids = sort_array( keys(_catalog), -1 );
  if( !sizeof(ids) ){
    unused_id = 1;
  } else {
    if( ids[0] > sizeof(ids) ){
      for( i = 0; i < sizeof(ids); i++ ){
        if( undefinedp(_catalog[i]) ){
          unused_id = i;
          break;
        }
      }
    } else {
      unused_id = sizeof(ids) + 1;
    }
  }
  if( unused_id == 0 )
    unused_id = 1;

  return unused_id;
}

/** @ignore yes */
protected void add_book_to_catalogs( class _book new_book, int id ){

  _catalog[id] = new_book;
  save_me();

  if( _catalog_by_author[lower_case(new_book->cap_author)] )
    _catalog_by_author[lower_case(new_book->cap_author)] += ({ id });
  else
    _catalog_by_author[lower_case(new_book->cap_author)] = ({ id });

  if( _catalog_by_title[lower_case(new_book->cap_title)] )
    _catalog_by_title[lower_case(new_book->cap_title)] += ({ id });
  else
    _catalog_by_title[lower_case(new_book->cap_title)] = ({ id });

}


/**
 * This function adds the specified object to the library 
 * @param thing Either a filename, or object. If its an object we record its autoload info
 * @param copies how many copies to add
 * @param cap_title The capitalized title its cataloged under
 * @param cap_author The capitalized author of the work
 * @param borrowable 1 if it can be borrowed, 0 if its reference only
 */
varargs int add_book_to_library( mixed thing, int copies, string cap_title, 
                                 string cap_author, int borrowable ){
  class _book book;
  int id, *ids;

  if( intp(thing) ){
    if( _catalog[thing] ){
      _catalog[thing]->copies += copies;
      return 1;
    } else {
      return 0;
    }
  }

  if( !cap_title || !cap_author || cap_title == "" || cap_author == "" )
    return 0;

  if( (ids = _catalog_by_title[ lower_case(cap_title) ]) ){
    foreach( id in ids ){
      if( lower_case(_catalog[id]->cap_author) == lower_case(cap_author) )
          /*= Then we already have a book of the same title by the same author =*/
          return add_book_to_library( id, 1 );
    }
  }

  if( stringp(thing) ){    
    book = new( class _book );
    book->path = thing;
    book->cap_author = cap_author;
    book->cap_title = cap_title;
    book->borrowable = 1;
    book->copies = copies;
    book->loaned = ([ ]);
    book->total_borrowed = 0;

    id = find_blank_id();
    add_book_to_catalogs( book, id );
    return 1;
  }
  
  if( objectp(thing) ){
    book = new( class _book );
    book->auto_load = AUTO_LOAD_OB->create_auto_load( ({ thing }) );
    book->cap_author = cap_author;
    book->cap_title = cap_title;
    book->borrowable = 1;
    book->copies = copies;
    book->loaned = ([ ]);
    book->total_borrowed = 0;

    id = find_blank_id();
    add_book_to_catalogs( book, id );
    return 1;
  }

}


/**
 * Returns 1, if we think that the new object is the same as the existing one we
 * have in stock.
 * @ignore yes
 */
protected int compare_widgets( object new_ob, int existing_id ){
  class _book book;
  object ob;
  mixed info;
  int perc;

  book = _catalog[existing_id];
  if( !book )  return 0;

  if( book->path )
    ob = clone_object( book->path );
  if( book->auto_load )
    ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];

  if( !ob ){
    // Shouldn't happen...
    return 0;
  }

  if( base_name(ob) != base_name(new_ob) )
    return 0; // Then they can't be the same surely...

  if( inherits("/std/book.c", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
             BOOK_HANDLER->query_pages( new_ob ),
             BOOK_HANDLER->query_pages( ob )
           );
  }

  if( inherits("/std/leaflet.c", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
             map( new_ob->query_pages(), (: $1[0][0] :) ),
             map( ob->query_pages(), (: $1[0][0] :) )
           );
  }

  if( inherits("/obj/misc/paper", new_ob) ||
      inherits("/obj/misc/nroff_paper", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
      map( new_ob->query_read_mess(), (: $1[0] :) ),
      map( ob->query_read_mess(), (: $1[0] :) )
    );
  }
  ob->move( "/room/rubbish" );

  if( perc > 97 )
    return 1;
  else
    return 0;
}



/**
 * This is used to sort out the look msg of the sign.
 * @ignore yes
 */
string extra_look( object ob ){
  string *libs, str, place;

  str = "Welcome to " + _library_name + ".\n";

  libs = filter( keys(_access), (: _access[$1] == LIBRARIAN_ACCESS :) );
  if( !sizeof(libs) )
    str += "Currently there are no caretakers of the books.\n";
  if( sizeof(libs) == 1 )
    str += PLAYER_HANDLER->query_cap_name(libs[0]) + " is the sole caretaker "
          " of the books.\n";
  if( sizeof(libs) > 1 ){
    libs = map( libs, (: PLAYER_HANDLER->query_cap_name($1) :) );
    str += query_multiple_short(libs) + " are caretakers of the books.\n";
  }

  place = query_property("place");
  if( !place || place == "" )
    place = "default";
  
  str += "Books may be borrowed for a maximum of " +
         (_loan_length / AM_SECONDS_PER_DAY) +
         " Disc days, before fines are levied.\n";
  str += "Fines currently stand at " +
         MONEY_HAND->money_value_string( _fine_per_day, place ) + 
         " per day the book is overdue.\n";
  str += "A charge of " + MONEY_HAND->money_value_string( _lost_damaged_fine, place ) +
         " will be incurred if you lose or damage a book.\n";
  str += "The maximum number of items you can borrow at one time currently stands at "+
         query_num(_max_loans) + ".\n";

  return str;
}

/** @ignore yes */
protected void save_it(){
  unguarded( (: save_object, _save_file :) );
}

/** @ignore yes */
void save_me(){
  if( find_call_out("save_it") == -1 )
    call_out( "save_it", 2 );
}

/*
void dest_me(){
  object ob, *ref;

  ref = filter( all_inventory(), (: $1->query_property(REFERENCE_ONLY_PROP) :) ) );
  foreach( ob in ref ){

  }
}
*/

/**
 * Returns a mapping of book ids to due back dates for the given player.
 * @param name the player
 * @return a mapping in the form ([ book id : due back ])
 */
mapping query_loans( string name ){
  class _loan loan;
  mapping m = ([ ]);

  if( !_accounts[name] )
    return ([ ]);

  foreach( loan in _accounts[name]->loans ){
    m[ loan->id ] = loan->due_back;
  }  

  return m;

}

/**
 * Returns a mapping of players who borrowed the given book id, mapped to their 
 * due back dates.
 * @param id valid book id
 */
mapping query_borrowed_by( int id ){
  if( _catalog[id] )
    return _catalog[id]->loaned;
  else
    return ([ ]);
}

/**
 * @param name the string name of the person to check
 * @return How much of a fine this person has
 */
int query_fine( string name ){  return _fines[name];  }

/**
 * Debug only
 * @ignore yes
 */
mapping query_catalog(){
  return _catalog;
}

/** @ignore yes */
mapping query_catalog_by_title(){
  return _catalog_by_title;
}

/** @ignore yes */
mapping query_catalog_by_author(){
  return _catalog_by_author;
}

/** @ignore yes */
mapping query_all_accounts(){
  return _accounts;
}


/***** ******/

void set_library_name( string str ){  _library_name = str;  }

string query_library_name(){  return _library_name;  }

void set_player_contributable( int i ){  _player_contributable = i;  }

int query_player_contributable(){  return _player_contributable;  }

void set_max_loans( int i ){  _max_loans = i;  }

int query_max_loans(){  return _max_loans;  }

void set_loan_length( int i ){  _loan_length = i;  }

int query_loan_length(){  return _loan_length;  }

void set_fine_per_day( int i ){  _fine_per_day = i;  }

int query_fine_per_day(){  return _fine_per_day;  }

void set_lost_damaged_fine( int i ){ _lost_damaged_fine = i;  }

int query_lost_damaged_fine(){ return _lost_damaged_fine;  }

void set_save_file( string s ){  _save_file = s;  }

string query_save_file(){  return _save_file;  }

void set_borrow_func( function f ){  _borrow_func = f;  }

function query_borrow_func(){  return _borrow_func;  }


void set_access( string player, int access ){ 
  if( !access ){
    map_delete( _access, player );
  } else {
    _access[player] = access;
  }
  save_me();
}

int query_access( mixed player ){
/*
  if( userp(player) )
    player = player->query_name();
 
  if( stringp(player) )
    player = lower_case(player);
  else 
    return 0;

  return _access[player];
*/
  return LIBRARIAN_ACCESS;
}


// --- END [/mnt/home2/grok/lib/std/room/inherit/p_library.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/room_rental.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/room_rental.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629414   Available: 13576768
Inodes: Total: 5242880    Free: 4960136
1532 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/room_rental.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629414   Available: 13576768
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A Room Rental room inheritable
 *
 * @author goldenthread
 * @started 1 Oct y2k1
 *
 */

#include <room/room_rental.h>

string *query_exits();

/** @ignore yes */
int check_entry( object player_ob, object room_ob ) {
  return ROOM_RENTAL_HANDLER->check_tenant( player_ob, room_ob );
}

/**
 * Returns the message given to the player when a costume item is
 * confiscated
 * @param costume the costume object
 * @returns the message
 */
string query_costume_mess( object costume ) {
  return "The imp takes the " + costume->query_short() + ".\n";
}

/**
 * This sends a message to the tenant and moves them from the room.
 * @param tenant the person being evicted
 */
void evict_tenant( object* tenants ) {
  string exit = query_exits()[0];

  foreach (object person in tenants) {
     tell_object( person, "You hear the soft tinkling of a bell.  As the "
               "sound resounds throughout the room it shatters your "
               "illusions.  A small imp hurries into the room and gently but "
               "firmly propels you outside the door.\n" );
  }
  tenants->move_with_look( exit, "$N appears from $F as though he's been "
                                "pushed in rather abruptly.\n" );
}

/** @ignore yes */
void event_exit( object ob, string message, object to ) {
  object *costumes;

  costumes = filter( deep_inventory( ob ),
                     (: $1->query_property( "costume" ) :) );
  foreach( object costume in costumes )
    costume->move( "/room/rubbish", query_costume_mess( costume ) );
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/room_rental.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/meeting.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/meeting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629413   Available: 13576767
Inodes: Total: 5242880    Free: 4960136
4951 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/meeting.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629413   Available: 13576767
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file is the inheritable for a meeting room.  It handles the floor
 * and a few other things neatly.
 * @author Pinkfish 
 * @started 25th of June
 */

private object _floor;
private string _leader;

int do_bang();
int do_recover();
int do_start();
int do_finish();
object create_floor();
void add_property(string name, mixed data);

/** @ignore yes */
void create() {
   _floor = create_floor();
   _floor->move(this_object());
} /* create() */

/** @ignore yes */
void init() {
   add_command("bang", "gavel", (: do_bang() :));
   add_command("recover", "floor", (: do_recover() :));
   add_command("start", "meeting", (: do_start() :));
   add_command("finish", "meeting", (: do_finish() :));
} /* init() */

/**
 * This method creates the floor for the room.
 * @return the floor for the room
 */
object create_floor() {
   object floor;
   
   floor = clone_object("/std/object");
   floor->set_name("floor");
   floor->set_short( "floor" );
   floor->add_property( "determinate", "the " );
   floor->add_property( "no burial", 1);
   floor->set_long("This is the floor of the meeting.  It gives you the "
                   "right to speak during the meeting.  Please give this "
                   "to the next person to speak after you have finished.\n");
   return floor;
} /* create_floor() */

/**
 * Called to start a meeting.
 * @return 1 on success, 0 on failure
 */
int do_start() {
   if (_leader &&
       find_player(_leader) &&
       environment(find_player(_leader)) == this_object()) {
      add_failed_mess("There is already a meeting started with " + 
                      find_player(_leader)->the_short() +
                      " as the leader.\n");
      return 0;
   }

   _leader = this_player()->query_name();
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
} /* do_start() */

/**
 * This method is called when the gavel is going to banged.
 * @return 1 on success, 0 on failure
 */
int do_bang() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can bang the gavel!\n");
      return 0;
   }

   add_succeeded_mess("$N $V the gavel.\n\nSTOP STOP!\n\n");
   return 1;
} /* do_bang() */

/**
 * This method is called when the floor is recovered by the leader.
 * @return 1 on success, 0 on failure
 */
int do_recover() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can recover the floor.\n");
      return 0;
   }

   _floor->move(this_player());
   add_succeeded_mess("$N recovers the floor.\n");
   return 1;
} /* do_recover() */

/**
 * This method is called to finish the meeting.
 * @return 1 on success, 0 on failure
 */
int do_finish() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can stop the meeting!\n");
      return 0;
   }

   _leader = 0;
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
} /* do_finish() */

/** @ignore yes */
void event_exit(object ob,
                string mess,
                object to) {
   object *inv;

   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      "'s hands and flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
} /* event_exit() */

/** @ignore yes */
void event_dest_me(object ob) {
   object *inv;

   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
} /* event_dest_me() */

/** @ignore yes */
void event_quit(object ob) {
   object *inv;

   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
} /* event_quit() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/meeting.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/newspaper_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/newspaper_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629412   Available: 13576766
Inodes: Total: 5242880    Free: 4960136
88230 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/newspaper_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629412   Available: 13576766
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/*  -*- LPC -*-  */
/*
 * $Locker: pinkfish $
 * $Id: newspaper_office.c,v 1.52 2003/05/23 22:26:02 wirble Exp pinkfish $
 *
 *
 */
/**
 * An office from which a player run newspaper can be run.
 * @author Obilix
 * @changed Pinkfish Fri Apr 27 12:08:29 PDT 2001
 * Turned into an inherit and made to use a newspaper handler for
 * distributing the actual text.
 */

#include <mail.h>
#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
#include <room/newspaper.h>
#include <nroff.h>
#include <board.h>
#include <housing.h>

#define NEWSPAPER_POSTPONE_FLAG 1
#define NEWSPAPER_LOCK_FLAG 2

class our_article {
   class article art;
   int flags;
   int length;
   int suggested_payment;
}

class reporter {
   int date_added;
   int num_articles;
   int total_payed;
}

class category_data {
   int cost_per_add;
   int cost_per_ten_chars;
   int open;
}

class payee_data {
   int paid;
   string message;
}

private mapping _reporters;
private string* _editors;
private string* _setters;
private string* _sponsors;
private string _owner;
private mapping _payees;
private int _published_time;
private class our_article* _articles;
private class advert* _adverts;
private int _next_article_num;
private int _edition_number;
private int _locked;
private int _owner_extra_cash;
private mapping _category;
private nosave string _save_dir;
private nosave string _paper_name;
private string _bank_branch;
private nosave string _proxy;

int show_article(class our_article art, int source);
string* query_all_reporters();
string* query_all_setters();
string* query_all_editors();
string* query_all_sponsors();
mapping query_all_payees();
int is_reporter(string word);
int is_setter(string word);
int is_editor(string word);
int is_sponsor(string word);
void add_reporter(string word);
void add_setter(string word);
void add_editor(string word);
void add_sponsor(string word);
void remove_reporter(string word);
void remove_setter(string word);
void remove_editor(string word);
void remove_sponsor(string word);
void update_commands(string word);
string query_log_file_name();
string query_article_log_file_name();
int query_current_edition();
string query_paper_name();
string query_next_article_file_name();
string query_bank_branch();
mixed query_property(string);
string query_owner();
int is_owner(string word);

void create()
{
   _reporters = ([ ]);
   _editors = ({ });
   _payees = ([ ]);
   _articles = ({ });
   _category = ([ ]);
   _adverts = ({ });
   _setters = ({ });
   _sponsors = ({ });
   _next_article_num = 2;
}                               /* setup() */

/**
 * Saves the data in the file.
 */
protected void save_me()
{
   if (_save_dir && !_proxy) {
      unguarded( (: save_object(_save_dir + "main") :) );
   }
}                               /* save_me() */

/**
 * Loads the data in the file.
 */
protected void load_me()
{
   class article fluff;
   int i;

printf("%O %O\n", _save_dir, _proxy);
   if (_save_dir && !_proxy) {
      unguarded( (: restore_object(_save_dir + "main", 1) :) );
printf("%O %O\n", _save_dir, _proxy);
      if (!_articles) {
         _articles = ({ });
      }
      if (!_setters) {
         _setters = ({ });
      }
      if (!_sponsors) {
         _sponsors = ({ });
      }
      if (!_adverts) {
         _adverts = ({ });
      }
      for (i = 0; i < sizeof(_articles); i++) {
         if (sizeof(_articles[i]->art) == 6) {
            fluff = new(class article);
            fluff->file_name = _articles[i]->art->file_name;
            fluff->title = _articles[i]->art->title;
            fluff->author = _articles[i]->art->author;
            fluff->date_written = _articles[i]->art->date_written;
            fluff->type = _articles[i]->art->type;
            fluff->shown_name = _articles[i]->art->shown_name;
            fluff->colour = 0;
            _articles[i]->art = fluff;
         }
      }
   }
}                               /* save_me() */

private int a_type(int data) {
   return data & NEWSPAPER_ARTICLE_TYPE_MASK;
}
private int a_flags(int data) {
   return data & ~NEWSPAPER_ARTICLE_TYPE_MASK;
}

/**
 * This method sets the directory we are to use for all the
 * temporary files and data.  The actual pubished data will be stored
 * by the newspaper handler.
 * @param dir the directory to put stuff in
 */
void set_save_directory(string dir) {
   if (dir[<1] != '/') {
      dir += "/";
   }
   _save_dir = dir;
   load_me();
} /* set_save_directory() */

/**
 * This method saves an article.
 */
void save_article_text(class our_article art, string text) {
   if (a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_HTML &&
       a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_PLAIN) {
      return ;
   }
   unguarded( (:
       write_file(_save_dir + $(art->art->file_name), save_variable(({ $(art), $(text) })), 1) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".nroff.o" ) :) );
} /* save_article_text() */

/**
 * THis method updates any information about the article if needed.
 */
private void update_article_info(class our_article art, string text) {
   int fsize;

   fsize = strlen(text);
   art->length = fsize;
   if (fsize < 0) {
      fsize = 0;
   }
   if (fsize > 4000) {
      fsize = 4000;
   }
   fsize = fsize / 100;
   art->suggested_payment = fsize;
} /* update_article_info() */

/**
 * This method loads the text of an article.
 */
string load_article_text(class our_article art) {
   mixed* bits;
   string str;


   str = unguarded( (: read_file(_save_dir + $(art->art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      return bits[1];
   }
   return "Error loading the article.";
} /* load_article_text() */

/**
 * This method is used by the web, it loads the article by the file name.
 */
string load_article_text_by_file(string fname) {
   int i;

   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         return load_article_text(_articles[i]);
      }
   }
   return "Lost the article.\n";
} /* load_article_text_by_file() */

/**
 * This method is used by the web, it loads the article by the file name.
 */
void save_article_text_by_file(string fname, string text) {
   int i;

   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         //_articles[i]->art->length = strlen(text);
         update_article_info(_articles[i], text);
         return save_article_text(_articles[i], text);
      }
   }
    return ;
} /* load_article_text_by_file() */

/**
 * This method is used by the web, it loads the article by the file name.
 */
void set_article_title_by_file(string fname, string title) {
   int i;

   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         _articles[i]->art->title = title;
         save_me();
         return ;
      }
   }
    return ;
} /* load_article_text_by_file() */

/**
 * This method deletes any bitsof the article off the disk.
 * @param article the article to delete
 */
void delete_article(class our_article article) {
   unguarded( (: rm(_save_dir + $(article->art->file_name)) :) );
   unguarded( (: rm(_save_dir + $(article->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(article->art->file_name) + ".nroff.o" ) :) );
} /* delete_article() */

/**
 * This method returns the index of the article in the article array.
 * @return the article index
 */
int query_article_index(string match) {
   int index;

   match = lower_case(match);
   if (strlen(match) && (match[0] >= '0' && match[0] <= '9')) {
      sscanf(match, "%d", index);
      index--;
      if (index < 0 || index >= sizeof(_articles)) {
         return -1;
      }
      return index;
   }
   if (strlen(match) == 1) {
      index = match[0] - 'a';
      if (index < 0 || index >= sizeof(_articles)) {
         return -1;
      }
      return index;
   }
   return -1;
} /* query_article_index() */

class our_article* query_articles() {
   return _articles;
}

/**
 * This method finds an article based on a string.
 * @return the article
 */
class our_article query_article(string match) {
   int index;

   index = query_article_index(match);
   if (index == -1) {
      return 0;
   }
   return _articles[index];
} /* query_article() */

/**
 * This method tries to find a category based on some fuzzy matching.
 * @param category the category to lookup
 * @return the fixed up category name
 */
string query_category(string category) {
   string name;

   category = lower_case(category);
   foreach (name in keys(_category)) {
      if (lower_case(name) == category ||
          lower_case(name)[0..strlen(category) - 1] == category) {
         return name;
      }
   }
   return 0;
} /* query_category() */

/**
 * The file name of the log file for events.
 * @return the log file name
 */
string query_log_file_name() {
   return _save_dir + "event.log";
} /* query_log_file_name() */

/**
 * The file name of the log file for article events.
 * @return the article log file name
 */
string query_article_log_file_name() {
   return _save_dir + "aritcle.log";
} /* query_article_log_file_name() */

/**
 * This method returns the current edition of the newspaper./
 * @return the current edition of the newspaper
 */
int query_current_edition()
{
   return NEWSPAPER_HANDLER->query_current_edition_num(query_paper_name());
}

/**
 * This method returns the name of the paper.
 * @return the name of the paper
 */
string query_paper_name()
{
   return _paper_name;
}

/**
 * This method returns the name of the paper with a 'the' in front.
 * @return the name of the paper
 */
string query_the_paper_name()
{
   if (lower_case(_paper_name[0..3]) == "the") {
      return _paper_name;
   }
   return "the " + _paper_name;
}

/**
 * This method sets the name of the paper.
 * @param name the new name of the paper
 */
string set_paper_name(string name)
{
   _paper_name = name;
}

/**
 * This returns the next number to use for an article.
 * @return the next article number
 */
string query_next_article_file_name()
{
   while (file_size(_save_dir + _next_article_num + ".txt") != -1) {
      _next_article_num++;
   }
   return (_next_article_num++) + ".txt";
}

/**
 * This method returns the bank branch to use for depositing money for
 * editions.
 * @return the bank branch to use
 */
string query_bank_branch()
{
   return _bank_branch;
}

/**
 * This method sets the bank branch to use for depositing money when
 * editions are made.
 * @param bank the bank branch to use
 */
void set_bank_branch(string bank) {
   _bank_branch = bank;
} /* set_bank_branch() */

/** @ignore yes */
int do_apply()
{
   if (_proxy) {
      return _proxy->do_apply();
   }
   tell_object(this_player(), "To apply for a job at " + query_the_paper_name() + ", please write "
               "us a letter outlining your areas of interest and what you think you "
               "would be able to contribute to the newspaper.  It will be sent to the "
               "editors of " + query_the_paper_name() +
               ", who will get back to you with an answer "
               "within a few days.\n");
   this_player()->do_edit(0, "mail_application");
   add_succeeded_mess(({ "", "$N start$s writing an application.\n" }));
   return 1;
}                               /* do_apply */

/** @ignore yes */
int mail_application(string text)
{
   string word;
   string *eds;

   if (!text) {
      tell_object(this_player(), "You decide not to apply just yet.\n");
      return 0;
   }
   eds = ({ });
   foreach(word in query_all_editors()) {
      if (PLAYER_HANDLER->test_user(word)) {
         eds += ({ word });
      }
   }
   if (!sizeof(eds)) {
      eds = ({ "pinkfish" });
   }
   AUTO_MAILER->auto_mail(implode(eds, ","), this_player()->query_name(),
                          "" + query_paper_name() + " application", "", text, 0, 0);
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " applied for a job at " + query_the_paper_name() + ".\n");
   tell_object(this_player(), "Your application has been submitted.  Thanks!\n");
   tell_room(this_object(),
             this_player()->the_short() + " finishes " + this_player()->query_possessive() +
             " application for a job at " + query_the_paper_name() + ".\n", this_player());
   return 1;
}                               /* mail_application */

/** @ignore yes */
int part_two(string str, string author, int html)
{
   if (!sizeof(str)) {
      tell_object(this_player(), "The article must have a name!\n");
      tell_room(this_object(), this_player()->the_short() +
                " stops writing to think of a name.\n",
                this_player());
      return 0;
   }
   if (!html) {
      tell_object(this_player(), "Please enter the text of your story.  It will make "
               "everyone's life much easier if it is less than 75 characters per "
               "line!\n\n"
               "%^BOLD%^<--------+10-------+20-------+30-------+40-------+50-------+60-"
               "------+70-->%^RESET%^\n");
   }
   this_player()->do_edit(0, "write_it", this_object(), 0, ({ str, author, html }));
   return 1;
}                               /* part_two() */

/** @ignore yes */
int do_submit(string str, string author, int html)
{
   if (_proxy) {
      return _proxy->do_submit(str, author, html);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked for "
                      "submissions.\n");
      return 0;
   }

   if (!str) {
      add_failed_mess("Please enter the name of the article you wish "
                       "to submit.  A short but descriptive name would be good, and it will "
                       "automagically have your name appended to the end of it.\n");
      return 0;
   }
   if (!author) {
      author = this_player()->query_cap_name();
   }
   add_succeeded_mess(({ "", "$N start$s writing an article.\n" }));
   part_two(str, author, html);
   return 1;
}                               /* do_submit */

/** @ignore yes */
varargs int write_it(string article,
                     mixed *stuff,
                     class our_article cur_art)
{
   int fsize;
   string person;
   string title;
   string author;
   int html;

   title = stuff[0];
   author = stuff[1];
   html = stuff[2];

   if (!article) {
      tell_object(this_player(), "You decide not to submit your story after all.\n");
      tell_room(this_object(), this_player()->the_short() +
                    " stops writing the article.\n", this_player());
      return 0;
   }
   person = this_player()->query_cap_name();
   if (!cur_art) {
      cur_art = new(class our_article);
      cur_art->art = new(class article);
      cur_art->art->title = title;
      cur_art->art->shown_name = author;
      cur_art->art->file_name = query_next_article_file_name();
      cur_art->art->author = person;
      cur_art->art->date_written = time();
      if (html) {
         cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_HTML;
      } else {
         cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_PLAIN;
      }
      update_article_info(cur_art, article);
      cur_art->flags = 0;
   }

   _articles += ({ cur_art });
   save_article_text(cur_art, article);
   save_me();
   log_file(query_article_log_file_name(),
                 "On " + ctime(time()) + " " + person +
                 " submitted the story " + title + ".\n");
   log_file(query_article_log_file_name(), "Recommended payment for above "
                           "article: $" + fsize + ".\n");
   tell_object(this_player(), "Article submitted!\n");
   tell_room(this_object(), this_player()->the_short() +
              " submits an article to the newspaper.\n",
             this_player());
}                               /* write_it() */

/** @ignore yes */
int do_retrieve(string edn, int source)
{
   class our_article article;

   if (_proxy) {
      return _proxy->do_retrieve(edn, source);
   }
   add_succeeded_mess("");
   if (!sizeof(_articles)) {
      add_failed_mess("There do not seem to have be any articles "
                      "submitted for this edition yet.\n");
      return 0;
   }
   article = query_article(edn);
   if (!article) {
      add_failed_mess("Sorry, " + edn + " is an incorrect article "
                      "reference.\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(article->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only read your own articles.\n");
      return 0;
   }
   show_article(article, source);
   return 1;
}                               /* do_retrieve */

/** @ignore yes */
int show_article(class our_article article, int source)
{
   string text;
   mixed* bits;
   int i;
   mixed* stuff;
   class advert data;

   switch (a_type(article->art->type)) {
   case NEWSPAPER_ARTICLE_TYPE_SECTION :
      text = "%^BOLD%^" + article->art->title + "%^RESET%^\n\n";
      for (i = 0; i < sizeof(_articles); i++) {
         if (_articles[i] == article) {
            i++;
            break;
         }
      }
      for (; i < sizeof(_articles); i++) {
         if (a_type(_articles[i]->art->type) != NEWSPAPER_ARTICLE_TYPE_SECTION) {
            text += sprintf("%2d .... %70-=s\n", i + 1,
                            _articles[i]->art->title);
         }
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
      text = "%^BOLD%^" + article->art->title + "%^RESET%^\n";
      stuff = unique_array(_adverts, (: $1->category :));
      foreach (bits in stuff) {
         text += "\n$I$0=" + bits[0]->category + "\n$I$3=   ";
         foreach (data in bits) {
            text += data->text + "\n-- " + data->author + "\n\n";
         }
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_HTML :
      if (!source) {
         // Do evil banana things.
         text = unguarded( (: NROFF_HAND->cat_file(_save_dir +
                              $(article->art->file_name) + ".nroff", 1) :) );
         if (!text) {
            // Make the html output.
            text = unguarded( (: read_file(_save_dir +
                                           $(article->art->file_name)) :) );
            if (text) {
               bits = restore_variable(text);
               bits[1] = NEWSPAPER_HANDLER->convert_html(bits[1]);
               unguarded( (: write_file(_save_dir + $(article->art->file_name) +
                              ".proc", $(bits[1]), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff(_save_dir +
                               $(article->art->file_name) + ".proc",
                           _save_dir + $(article->art->file_name) + ".nroff") :) )) {
                  text = unguarded( (: NROFF_HAND->cat_file(_save_dir +
                                   $(article->art->file_name) + ".nroff") :) );
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the article.  Opps.\n";
            }
         }
         break;
      }
   case NEWSPAPER_ARTICLE_TYPE_PLAIN :
      text = load_article_text(article);
      break;
   }
   this_player()->more_string("The article you requested reads as follows:\n" +
                   text + "\n");
   return 1;
}                               /* show_article */

/** @ignore yes */
int do_logs(int article_log)
{
   string logfile;

   if (_proxy) {
      return _proxy->do_logs(article_log);
   }
   if (article_log) {
      logfile = read_file(query_article_log_file_name());
   } else {
      logfile = read_file(query_log_file_name());
   }
   if (!logfile) {
      add_failed_mess("There don't appear to be any logs.\n");
      return 0;
   }
   this_player()->more_string("The log contains:\n" + logfile + "\n");
   add_succeeded_mess("");
   return 1;
}                               /* do_logs() */

/** @ignore yes */
int do_articles(int scroll)
{
   string str;
   class our_article article;
   int pos;
   int editor;

   if (_proxy) {
      return _proxy->do_articles(scroll);
   }
   str = "";
   editor = is_editor(this_player()->query_name());
   if (sizeof(_articles)) {
      str = "The articles for edition " + query_current_edition() + " are:\n";
      pos = 1;
      foreach(article in _articles) {
         if (article->art->colour) {
            str += "%^" + article->art->colour + "%^";
         }
         switch (a_type(article->art->type)) {
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            str += sprintf("$I$5=Page %2d) %s by %s (shown author %s) submitted at %s; length %d%s%s%s\n",
               pos, article->art->title,
               (editor || article->art->author == this_player()->query_name()?article->art->author:article->art->shown_name),
               article->art->shown_name,
               ctime(article->art->date_written),
               article->length,
               (editor?" suggested payment $" + article->suggested_payment:""),
               (article->flags & NEWSPAPER_POSTPONE_FLAG?" (postponed)":""),
               (article->flags & NEWSPAPER_LOCK_FLAG?" (locked)":""),
               (a_flags(article->art->type) & NEWSPAPER_ARTICLE_NO_XP_FLAG?" (no xp)":"") );
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            str += sprintf("$I$5=Page %2d) Section Header '%s'\n",
                           pos,
                           article->art->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            str += sprintf("$I$5=Page %2d) Adverts\n", pos);
            break;
         }
         if (article->art->colour) {
            str += "%^RESET%^";
         }
         pos++;
      }
   } else {
      str = "There are no articles in this edition yet.\n";
   }
   if (!scroll) {
      write("$P$Articles$P$" + str);
   } else {
      write(str);
   }
   return 1;
}                               /* do_logs() */

/** @ignore yes */
int do_resign()
{
   object *inv;
   object ob;
   string person;

   if (_proxy) {
      return _proxy->do_resign();
   }
   person = this_player()->query_name();
   remove_reporter(person);
   if (is_editor(person)) {
      remove_editor(person);
   }
   if (is_setter(person)) {
      remove_setter(person);
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " resigned from " + query_the_paper_name() + ".\n");
   inv = match_objects_for_existence("press credentials", ({ this_player() }),
                                     this_player());
   foreach (ob in inv) {
      if (ob->query_paper_name() == query_paper_name()) {
         ob->dest_me();
      }
   }
   add_succeeded_mess(({ "You hand in your badge, and tender your "
                         "resignation from " + query_the_paper_name() +
                         ".  You can't help but feel a little "
                         "saddened as a result.\n",
                         "$N $V from " + query_the_paper_name() + ".\n" }));
   return 1;
}                               /* do_resign() */

/** @ignore yes */
int do_delete(string str)
{
   class our_article article;
   int i;

   if (_proxy) {
      return _proxy->do_delete(str);
   }
   article = query_article(str);
   if (!article) {
      add_failed_mess("There is no article referenced by " + str + ".\n");
      return 0;
   }

   if (!is_editor(this_player()->query_name()) &&
       this_player()->query_name() != lower_case(article->art->author)) {
      add_failed_mess("You cannot delete this article.\n");
      return 0;
   }

   delete_article(article);
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i] == article) {
         _articles = _articles[0..i - 1] + _articles[i+1..];
      }
   }
   save_me();

   log_file(query_article_log_file_name(),
                    "On " + ctime(time()) + " " + this_player()->query_short() +
                    " deleted the article " + article->art->title + ".\n");
   add_succeeded_mess(({ "Article deleted!\n",
                         "$N $V an article from "
                         "the current edition.\n" }));
   return 1;
}                               /* do_delete */

/** @ignore yes */
int do_hire(string person, int setter)
{
   string bing;
   object thatguy;

   if (_proxy) {
      return _proxy->do_hire(person, setter);
   }
   person = lower_case(person);
   if (setter) {
      if (is_setter(person)) {
         add_failed_mess("That person is already employed as a setter by " +
                         query_the_paper_name() + "!\n");
         return 0;
      }
      bing = "setter";
   } else {
      if (is_reporter(person)) {
         add_failed_mess("That person is already employed by " +
                         query_the_paper_name() + "!\n");
         return 0;
      }
      bing = "reporter";
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("There is nobody called " + capitalize(person) + "!\n");
      return 0;
   }
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "just been hired by " + this_player()->the_short() +
                  " as a " + bing + " for " +
                  query_the_paper_name() + ".\n");
   }
   if (setter) {
      add_setter(person);
   } else {
      add_reporter(person);
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " employed " + capitalize(person) + " as a " + bing + ".\n");
   add_succeeded_mess(capitalize(person) +
                      " is now employed by " +
                      query_the_paper_name() + " as a " + bing + ".\n");
   return 1;
}                               /* do_hire() */

/** @ignore yes */
int do_dismiss(string person)
{
   object thatguy;

   if (_proxy) {
      return _proxy->do_dismiss(person);
   }
   if (!is_reporter(person)) {
      add_failed_mess("That person is not employed by " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   remove_reporter(person);
   remove_editor(person);
   remove_setter(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "been fired from " + query_the_paper_name() + " by " + this_player()->the_short() +
                  "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " fired " + capitalize(person) + ".\n");
   add_succeeded_mess(capitalize(person) +
                      " is no longer employed by " +
                      query_the_paper_name() + ".\n");
   return 1;
}                               /* do_dismiss() */

/** @ignore yes */
int do_sponsor_add(string person)
{
   if (_proxy) {
      return _proxy->do_sponsor_add(person);
   }
   person = lower_case(person);
   if (is_sponsor(person)) {
      add_failed_mess(person + " is already a sponsor of " +
                      query_the_paper_name() + "!\n");
      return 0;
   }

   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("I am sorry, but " + person + " does not exist.\n");
      return 0;
   }

   add_sponsor(person);
   add_succeeded_mess(capitalize(person) +
                      " is now a sponsor of " + query_the_paper_name() + ".\n");
   return 1;
}                               /* do_sponsor_add() */

/** @ignore yes */
int do_sponsor_remove(string person)
{
   if (_proxy) {
      return _proxy->do_sponsor_remove(person);
   }
   person = lower_case(person);
   if (!is_sponsor(person)) {
      add_failed_mess(person + " is not a sponsor of " +
                      query_the_paper_name() + "!\n");
      return 0;
   }

   remove_sponsor(person);
   add_succeeded_mess(capitalize(person) +
                      " is not a sponsor of " +
                      query_the_paper_name() + " anymore.\n");
   return 1;
}                               /* do_sponsor_remove() */

/** @ignore yes */
int do_promote(string person)
{
   object thatguy;

   if (_proxy) {
      return _proxy->do_promote(person);
   }
   person = lower_case(person);
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   if (is_editor(person)) {
      add_failed_mess(capitalize(person) + " is already an editor!\n");
      return 0;
   }
   add_editor(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "been promoted to editor of " + query_the_paper_name() + " by " +
                  this_player()->the_short() + "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " promoted " + capitalize(person) + " to " +
                 "editor.\n");
   add_succeeded_mess(capitalize(person) +
                      " is now an editor of " + query_the_paper_name() + ".\n");
   return 1;
}                               /* do_promote() */

/** @ignore yes */
int do_demote(string person, int editor)
{
   object thatguy;

   if (_proxy) {
      return _proxy->do_demote(person, editor);
   }
   person = lower_case(person);
   if (editor) {
      if (!is_editor(person)) {
         add_failed_mess
            ("There is nobody by that name currently employed as an "
             "editor at " + query_the_paper_name() + "!\n");
         return 0;
      }
      remove_editor(person);
   } else {
      if (!is_setter(person)) {
         add_failed_mess
            ("There is nobody by that name currently employed as a "
             "setter at " + query_the_paper_name() + "!\n");
         return 0;
      }
      remove_setter(person);
   }
   add_reporter(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy,
                  this_player()->the_short() +
                  " just demoted you as an editor of " + query_the_paper_name() + "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " demoted " + capitalize(person) +
                 " to reporter.\n");
   add_succeeded_mess(capitalize(person) +
                      " is no longer an editor of " + query_the_paper_name() + ".\n");
   return 1;
}                               /* do_demote */

/**
 * This is the status that everyone can see, not just the employees.
 */
int do_everyone_status() {
   string ret;

   if (_proxy) {
      return _proxy->do_everyone_status();
   }
   ret = query_the_paper_name() + " has the following employees:\n";
   ret += "$I$3=Owner: " +
          query_owner() +
          "\n";
   ret += "$I$3=Reporters: " +
          query_multiple_short(sort_array(query_all_reporters(), 0)) +
          "\n";
   ret += "$I$3=Setters  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_setters(), 0)):"no one") +
          "\n";
   ret += "$I$3=Editors  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_editors() - ({ query_owner() }), 0)):"no one") +
          "\n";

   write("$P$Status$P$" + ret);
   return 1;
} /* do_everyone_status() */

/** @ignore yes */
int do_status()
{
   string ret;
   int i;
   int last_num;

   if (_proxy) {
      return _proxy->do_status();
   }
   ret = query_the_paper_name() + " has the following employees:\n";
   ret += "$I$3=Owner: " +
          query_owner() +
          "\n";
   ret += "$I$3=Reporters: " +
          query_multiple_short(sort_array(query_all_reporters(), 0)) +
          "\n";
   ret += "$I$3=Setters  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_setters(), 0)):"no one") +
          "\n";
   ret += "$I$3=Editors  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_editors() - ({ query_owner() }), 0)):"no one") +
          "\n";
   ret += "$I$3=Sponsors : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_sponsors(), 0)):"no one") +
          "\n";

   ret += "\n$I$0=Sale Statistics:\n";
   // Show the sale stats.
   last_num = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   for (i = last_num - 5; i <= last_num; i++) {
      if (i >= 1) {
         ret += "Edition " + i + " sold to " +
             NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, i) +
             " people.\n";
      }
   }
   ret += "\n";

   ret += "Using Bank  : " + _bank_branch + "\n";

   write("$P$Status$P$" + ret);
   return 1;
}                               /* do_reporters() */

/** @ignore yes */
int do_claim()
{
   object badge;
   object *deepinv;
   object *inv;

   if (_proxy) {
      return _proxy->do_claim();
   }
   deepinv = deep_inventory(this_player()) + ({ this_player() });
   inv = filter(deepinv, (: $1->query_paper_name() == query_paper_name() :));
   if (sizeof(inv)) {
      add_failed_mess
         ("You already have a set of credentials!  Why would you "
          "want another?\n");
      return 0;
   }
   badge = clone_object(NEWSPAPER_PRESS_CREDITIALS);
   badge->set_drop();
   badge->set_paper_name(query_paper_name());
   if (badge->move(this_player()) != MOVE_OK) {
      badge->move(this_object());
      tell_object(this_player(),
                  "The credentials are too heavy for you, so they fall "
                  "to the floor.\n");
   }
   badge->reset_drop();
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " claimed some new credentials.\n");
   add_succeeded_mess(({ "A new set of credentials appear from thin air, as "
                         "if by magic!\n",
                         "$N $V a set of credentials.\n" }));
   return 1;
}

/** @ignore yes */
int do_publish(string headline)
{
   class our_article* bing;

   if (_proxy) {
      return _proxy->do_publish(headline);
   }
   bing = filter(_articles, (: !$1->flags & NEWSPAPER_POSTPONE_FLAG :));
   if (!sizeof(bing)) {
      add_failed_mess("You cannot publish with no articles!\n");
      return 0;
   }
   write("Do you wish to publish this edition with a headline of:\n" +
          headline + "\nResponse [y/n]? ");
   add_succeeded_mess("");
   input_to("really_publish", 0, headline);
   return 1;
}                               /* do_publish() */

/**
 * This method figures out the total profit from the paper.
 */
int query_total_profit(int num_articles) {
   int last_pub;
   int amount;
   int edition;
   int adds;
   class advert data;
   class our_article bing;
   string text;

   if (num_articles == -1) {
      num_articles = 0;
      foreach (bing in _articles) {
         if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
            text = load_article_text(bing);
            if (strlen(text) > 500) {
               num_articles++;
            }
         }
      }
   }

   foreach (data in _adverts) {
      adds += data->value;
   }

   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   last_pub = NEWSPAPER_HANDLER->query_edition_date(_paper_name, edition);
   // Work out the amount based on how many much money they were sold for.
   amount = NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, edition) * 100;
   // First we scale it based on the number of articles.  Ignore number of
   // articles.
   //amount = (amount * num_articles * 400) / 14;
   amount = amount * 400 + adds;
   // Next we decrease it based on the time since the last edition.
   if ((time() - last_pub) < 42 * 24 * 60 * 60) {
      return amount;
   }
   last_pub = (time() - last_pub) - 42 * 24 * 60 * 60;
   last_pub = last_pub / (24 * 60 * 60);
   amount = ( amount / 150 ) * (150 - last_pub);
   return amount + _owner_extra_cash;
} /* query_total_profit() */

/** @ignore yes */
void really_publish(string char, string headline)
{
   int article_count;
   int amount;
   int total;
   string *things;
   string temp;
   class article* to_publish;
   string* text;
   class our_article bing;
   class payee_data data;
   string stuff;
   string place;
   int i;
   int editor_bonus;
   int num_editors;

   place = query_property("place");
   char = lower_case(char);
   things = ({ });
   if (strlen(char) && char[0] == 'y') {
      tell_object(this_player(),
                  "Okay, warm up the frogs, let's see if everything is "
                  "sorted out.\n");
   } else {
      tell_object(this_player(), "Okay, publishing aborted.\n");
      return 0;
   }

   to_publish = ({ });
   text = ({ });
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         to_publish += ({ copy(bing->art) });
         text += ({ load_article_text(bing) });
         if (strlen(text[<1]) > 500) {
            article_count++;
         }
      }
   }

   amount = query_total_profit(article_count);
   foreach (temp, data in _payees) {
      total += data->paid;
   }
   num_editors = sizeof(query_all_editors() - ({ query_owner() }));
   editor_bonus = (amount * 5 / 100) / num_editors;
   total += (amount * 5 / 100) * num_editors;
   //total += sizeof(query_all_editors() - ({ query_owner() })) *
   //          amount * 5 / 100;

   if (amount < total) {
      add_failed_mess("You have allocated paying your reporters " + total +
                      " when you only have " + amount + " total profit.\n");
      return 0;
   }

   if (!NEWSPAPER_HANDLER->publish_paper(query_paper_name(),
                                         headline,
                                         to_publish,
                                         text,
                                         _adverts,
                                         query_all_editors())) {
      tell_object(this_player(), "There was an error making the new issue!\n");
      return ;
   }
   _adverts = ({ });
   _owner_extra_cash = 0;
   stuff = "Edition summary.\nArticles posted:\n";
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         stuff += bing->art->title + " by " + bing->art->shown_name + "\n";
         // Delete it!
         delete_article(bing);
      }
   }
   _articles = filter(_articles, (: $1->flags & NEWSPAPER_POSTPONE_FLAG :));

   stuff += "\nTotal profit " +
            MONEY_HAND->money_value_string(amount, place) +
            ".\n";
   // Split it up.
   BANK_HANDLER->adjust_account(query_owner(), query_bank_branch(),
                                (amount - total));
   amount = editor_bonus;
   if (sizeof(query_all_editors() - ({ query_owner() })) > 0) {
      stuff += "\nEditors bonus " +
               query_multiple_short(query_all_editors() - ({ query_owner() })) +
               " paid " +
               MONEY_HAND->money_value_string(amount, place) + "each.\n";
      foreach (temp in query_all_editors()) {
         if (temp != query_owner()) {
            BANK_HANDLER->adjust_account(temp, query_bank_branch(),
                                         (amount));
            _reporters[temp]->total_payed += amount;
         }
      }
   }

   stuff += "\nReporters paid:\n";
   foreach (temp, data in _payees) {
      BANK_HANDLER->adjust_account(temp, query_bank_branch(), data->paid);
      if (is_reporter(temp)) {
         _reporters[temp]->total_payed += data->paid;
         stuff += temp + " " +
               MONEY_HAND->money_value_string(data->paid, place) + ".\n";
         i++;
         call_out((: AUTO_MAILER->auto_mail($1, $2, $3, $4, $5) :), i * 4,
                   temp,
                                this_object()->query_short(),
                                "Payment for new edition.",
                                "",
                                "A new edition has been released and "
                                "you have been paid!\n\n"
                                "For your work on the newspaper you "
                                "have been paid " +
                                MONEY_HAND->money_value_string(data->paid, place) +
                                ".\n\n" +
                                (data->message?data->message:"") );
      }
   }

   // Send this mail to the editors and the owner.
   call_out((: AUTO_MAILER->auto_mail($1, $2, $3, $4, $5) :), i * 4,
                          implode(query_all_editors(), ","),
                          this_object()->query_short(),
                          "Published new edition.",
                          implode(query_all_editors(), ","),
                          stuff);

   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " published an edition of " + query_the_paper_name() + ".\n");
   _published_time = time();
   _payees = ([ ]);
   rename(query_article_log_file_name(),
             _save_dir + "article" + query_current_edition() + ".log");
   save_me();
   write("$P$Summary$P$" +
               "The pages have been sent to the printery, and another "
               "edition of " + query_the_paper_name() +
               " is about to hit the streets!  You feel rather "
               "impressed with your efforts.\n\n" + stuff);
   return;
}                               /* really_publish() */

/** @ignore yes */
int do_summary() {
   int amount;
   int adds;
   string person;
   int total;
   class our_article bing;
   class payee_data payee_data;
   string text;
   string ret;
   int article_count;
   string place;
   class advert data;
   int i;
   int last_num;
   int num_editors;
   int editor_bonus;

   if (_proxy) {
      return _proxy->do_summary();
   }
   ret = "";
   // Show the sale stats.
   last_num = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   for (i = last_num - 5; i <= last_num; i++) {
      if (i >= 1) {
         ret += "Edition " + i + " sold to " +
             NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, i) +
             " people.\n";
      }
   }
   ret += "\n";

   place = query_property("place");
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         text = load_article_text(bing);
         if (strlen(text) > 500) {
            article_count++;
         }
      }
   }

   ret += "Article count of " + article_count + "\n";

   if (!_adverts) {
      _adverts = ({ });
   }

   foreach (data in _adverts) {
      adds += data->value;
   }

   amount = query_total_profit(article_count);
   foreach (person, payee_data in _payees) {
      total += payee_data->paid;
   }
   num_editors = sizeof(query_all_editors() - ({ query_owner() }));
   editor_bonus = (amount * 5 / 100) / num_editors;
   total += editor_bonus * num_editors;

   ret += "Using Bank  : " + _bank_branch + "\n";
   ret += "Total Profit: " +
         MONEY_HAND->money_value_string(amount, place) +
         ", total editor bonus " +
         MONEY_HAND->money_value_string(editor_bonus * num_editors, place) +
         ", total paid to reporters " +
         MONEY_HAND->money_value_string(total, place) +
         ", profit from adverts " +
         MONEY_HAND->money_value_string(adds, place) +
         (_owner_extra_cash > 0 ?
         ", " + MONEY_HAND->money_value_string(_owner_extra_cash, place) +
            " extra added by the owner":"") +
         ".\n\n";

   ret += "Owner/Editors:\n";
   ret += "   " + query_owner() + " " +
          MONEY_HAND->money_value_string((amount - total), place) +
          " (owner)\n";
   ret += "Reporters:\n";
   foreach (person, payee_data in _payees) {
      if (!is_editor(person)) {
         ret += "$I$6=   " + person + " " +
                MONEY_HAND->money_value_string(payee_data->paid, place) +
                (payee_data->message?" " + payee_data->message:"") + ".\n";
      }
   }
   ret += "$I$0=Editor Bonuses:\n";
   foreach (person in query_all_editors()) {
      if (person != query_owner()) {
         if (!_payees[person]) {
            _payees[person] = new(class payee_data);
         }
         ret += "   " + person  + " " +
                MONEY_HAND->money_value_string(editor_bonus, place) +
                " Total " +
                MONEY_HAND->money_value_string((editor_bonus + _payees[person]->paid), place) +
                "\n";
      }
   }
   write("$P$Profits$P$" + ret);
   return 1;
} /* do_summary() */

/** @ignore yes */
int do_deposit(string amt) {
   int amt_int;
   string place;

   if (_proxy) {
      return _proxy->do_deposit(amt);
   }

   if (this_player()->query_name() != query_owner()) {
      add_failed_mess("Only the owner can do this.\n");
      return 0;
   }

   place = query_property("place");
   amt_int = MONEY_HAND->value_from_string(amt, place);
   if (amt_int <= 0) {
      add_failed_mess("The amount " + amt + " is invalid.\n");
      return 0;
   }

   // See if the owner has the right amount in the bank.
   if (BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       amt_int) {
      add_failed_mess("You do not have " +
                      MONEY_HAND->money_value_string(amt_int, place) +
                      " in " + query_bank_branch() + ".\n");
      return 0;
   }

   _owner_extra_cash += amt_int;
   save_me();
   BANK_HANDLER->adjust_account(this_player()->query_name(), _bank_branch, -amt_int);

   add_succeeded_mess(({ "$N deposit " +
                      MONEY_HAND->money_value_string(amt_int, place) +
                      " for extra cash to pay reporters.\n",
                      "$N deposits some extra cash for reporters.\n" }));
   return 1;
} /* do_deposit() */

/** @ignore yes */
int do_set_bank_branch(string branch)
{
   string* accounts;

   if (_proxy) {
      return _proxy->do_set_bank_branch(branch);
   }
   accounts = BANK_HANDLER->query_accounts(this_player()->query_name());
   if (member_array(branch, accounts) == -1) {
      add_failed_mess("You need to specify a bank you have an account "
                      "with: " + query_multiple_short(accounts) +
                      ".\n");
      return 0;
   }
   _bank_branch = branch;

   save_me();
   add_succeeded_mess("$N set$s the bank branch to " + branch + ".\n");
   return 1;
} /* do_set_bank_branch() */

/** @ignore yes */
int do_pay(string person,
           string amt)
{
   string place;
   string fluff;
   int amount;
   int profit;
   int total;
   class payee_data data;

   if (_proxy) {
      return _proxy->do_pay(person, amt);
   }
   place = query_property("place");
   if (amt == "none" || amt == "0") {
      amount = 0;
   } else {
      amount = MONEY_HAND->value_from_string(amt, place);
      if (amount <= 0) {
         add_failed_mess("Sorry, you must pay reporters a "
                         "positive amount.\n");
         return 0;
      }
   }
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                       query_the_paper_name() + "!\n");
      return 0;
   }

   if (person == query_owner()) {
      add_failed_mess("The owner gets paid anyway.\n");
      return 0;
   }

   profit = query_total_profit(-1);
   profit = profit * 95 / 100;
   foreach (fluff, data in _payees) {
      total += data->paid;
   }

   if (profit - total - amount < 0) {
      add_failed_mess("You are not making enough money to pay " +
                      person + " " +
                      MONEY_HAND->money_value_string(amount, place) +
                      ".\n");
      return 0;
   }

   if (!_payees[person]) {
      _payees[person] = new(class payee_data);
   }
   _payees[person]->paid = amount;

   if (_payees[person]->paid < 0) {
      add_succeeded_mess(({ "You can't pay anybody less than nothing!  "
                            "Amount owing reset to nothing.\n", "" }));
      map_delete(_payees, person);
      save_me();
      return 1;
   }
   if (!_payees[person]->paid) {
      add_succeeded_mess(({ "Ok, amount owing set to nothing.\n", "" }));
      map_delete(_payees, person);
      save_me();
      return 1;
   }
   add_succeeded_mess(({ "Ok, " + capitalize(person) + " will be paid a "
                         "total of " +
                     MONEY_HAND->money_value_string(_payees[person]->paid, place) +
                         " for this edition.\n", "" }));
   // Do the payment when the issue is done.
   save_me();
   return 1;
}                               /* do_pay() */

/** @ignore yes */
int do_pay_tag(string person,
               string tag)
{
   if (_proxy) {
      return _proxy->do_pay_tag(person, tag);
   }
   if (tag == "none") {
      tag = 0;
   }

   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                       query_the_paper_name() + "!\n");
      return 0;
   }

   if (person == query_owner()) {
      add_failed_mess("The owner gets paid anyway.\n");
      return 0;
   }

   if (!_payees[person]) {
      add_failed_mess("You can only set a reason for someone who is "
                      "being paid.\n");
      return 0;
   }

   _payees[person]->message = tag;

   if (!tag) {
      add_succeeded_mess(({ "You remove the message from " +
                            capitalize(person) + ".\n", "" }));
   } else {
      add_succeeded_mess(({ "You set a message to " + capitalize(person) +
                            " of " + tag + ".\n", "" }));
   }
   // Do the payment when the issue is done.
   save_me();
   return 1;
}                               /* do_pay() */

/** @ignore yes */
int do_title(string id, string title)
{
   class our_article art;

   if (_proxy) {
      return _proxy->do_title(id, title);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }

   art->art->title = title;
   save_me();
   add_succeeded_mess(({ "You set the title to " + title + ".\n",
                         "$N sets the title of an article.\n" }));
   return 1;
}                               /* do_title() */

/** @ignore yes */
int do_author(string id, string author)
{
   class our_article art;

   if (_proxy) {
      return _proxy->do_author(id, author);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }

   art->art->shown_name = author;
   save_me();
   add_succeeded_mess(({ "You set the author to " + author + ".\n",
                         "$N sets the author of an article.\n" }));
   return 1;
}                               /* do_author() */

/** @ignore yes */
int do_change(string id, string type)
{
   class our_article art;

   if (_proxy) {
      return _proxy->do_change(id, type);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }

   if (type == "html") {
      art->art->type = NEWSPAPER_ARTICLE_TYPE_HTML | a_flags(art->art->type);
   } else {
      art->art->type = NEWSPAPER_ARTICLE_TYPE_PLAIN | a_flags(art->art->type);
   }
   save_me();
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".nroff.o" ) :) );
   add_succeeded_mess(({ "You set the article type to " + type + ".\n",
                         "$N sets the type of an article.\n" }));
   return 1;
}                               /* do_author() */

/** @ignore yes */
int do_change_xp(string id, string type)
{
   class our_article art;

   if (_proxy) {
      return _proxy->do_change_xp(id, type);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name())) {
      add_failed_mess("Only the editors can do this.\n");
      return 0;
   }

   if (type == "none") {
      art->art->type |= NEWSPAPER_ARTICLE_NO_XP_FLAG;
   } else {
      art->art->type &= ~NEWSPAPER_ARTICLE_NO_XP_FLAG;
   }
   save_me();
   add_succeeded_mess(({ "You set the article xp return to " + type + ".\n",
                         "$N sets the xp return of an article.\n" }));
   return 1;
}                               /* do_author() */

/** @ignore yes */
int do_change_colour(string id, string colour)
{
   class our_article art;

   if (_proxy) {
      return _proxy->do_change_colour(id, colour);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }

   if (colour != "none") {
      art->art->colour = upper_case(colour);
   } else {
      art->art->colour = 0;
   }
   save_me();
   add_succeeded_mess(({ "You set the article colour to " + colour + ".\n",
                         "$N sets the colour of an article.\n" }));
   return 1;
}                               /* do_author() */

/** @ignore yes */
int do_editing(string id)
{
   class our_article art;
   string contents;

   if (_proxy) {
      return _proxy->do_editing(id);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked for "
                      "submissions.\n");
      return 0;
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }

   if (art->flags & NEWSPAPER_LOCK_FLAG) {
      add_failed_mess("This article is locked.\n");
      return 0;
   }

   contents = load_article_text(art);
   add_succeeded_mess("");
   this_player()->do_edit(contents, "finish_editing", this_object(), 0, art);
   return 1;
}                               /* do_editing() */

/**
 * This method moves an article up or down in the current article list.
 * @param index the index of the article to move
 * @param up_down move it up or down
 */
int move_article(int index, string up_down) {
   class our_article womble;

   if (index == -1) {
      return 0;
   }

   womble = _articles[index];
   if (up_down == "up") {
      if (index > 0) {
         _articles = _articles[0..index - 1] + _articles[index+1..];
         _articles = _articles[0..index - 2] + ({ womble }) +
                     _articles[index - 1..];
         save_me();
      } else {
         return 0;
      }
   } else {
      if (index < sizeof(_articles) - 1) {
         _articles = _articles[0..index - 1] + _articles[index+1..];
         _articles = _articles[0..index] + ({ womble }) +
                     _articles[index + 1..];
         save_me();
      } else {
         return 0;
      }
   }
   return 1;
}

/** @ignore yes */
int do_move(string article, string up_down) {
   int index;
   class our_article womble;

   if (_proxy) {
      return _proxy->do_move(article, up_down);
   }
   index = query_article_index(article);
   if (index == -1) {
      add_failed_mess("Article reference " + index + " is out of bounds.\n");
      return 0;
   }

   womble = _articles[index];
   if (!move_article(index, up_down)) {
      add_failed_mess("Unable to move the article.\n");
      return 0;
   }
   add_succeeded_mess(({ "You moved the article " + womble->art->title + " " +
                         up_down + ".\n", "" }));

   return 1;
}

/** @ignore yes */
int do_move_pos(string article, string pos) {
   int index;
   int to_index;
   class our_article womble;

   if (_proxy) {
      return _proxy->do_move_pos(article, pos);
   }
   index = query_article_index(article);
   if (index == -1) {
      add_failed_mess("Article reference " + index + " is out of bounds.\n");
      return 0;
   }
   to_index = query_article_index(pos);
   if (to_index == -1) {
      add_failed_mess("Article reference " + pos + " is out of bounds.\n");
      return 0;
   }

   if (to_index == index) {
      add_failed_mess("You cannot move the article there, it is already "
                      "there.\n");
      return 0;
   }

   womble = _articles[index];
   if (index < to_index) {
      _articles = _articles[0..index - 1] + _articles[index + 1..to_index] +
                  ({ _articles[index] }) + _articles[to_index+1..];
   } else {
      _articles = _articles[0..to_index - 1] +
                  ({ _articles[index] }) +
                  _articles[to_index..index - 1] +
                  _articles[index+1..];
   }
   save_me();
   add_succeeded_mess(({ "You moved the article " + womble->art->title +
                         " to " + pos + ".\n", "" }));

   return 1;
}

/** @ignore yes */
int do_postpone(string id, string on_off) {
   class our_article art;

   if (_proxy) {
      return _proxy->do_postpone(id, on_off);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article reference " + id + " does not exist.\n");
      return 0;
   }

   if (on_off == "on") {
      art->flags |= NEWSPAPER_POSTPONE_FLAG;
      add_succeeded_mess(({ "You postpone the article " + art->art->title +
                            " to a later issue.\n",
                            "" }));
   } else {
      art->flags &= ~NEWSPAPER_POSTPONE_FLAG;
      add_succeeded_mess(({ "You unpostpone the article " + art->art->title +
                            " so it will be in this issue.\n",
                            "" }));
   }
   save_me();
   return 1;
} /* do_postpone() */

/** @ignore yes */
int do_lock_article(string id, string on_off) {
   class our_article art;

   if (_proxy) {
      return _proxy->do_lock_article(id, on_off);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article reference " + id + " does not exist.\n");
      return 0;
   }

   if (on_off == "on") {
      art->flags |= NEWSPAPER_LOCK_FLAG;
      add_succeeded_mess(({ "You lock the article " + art->art->title +
                            ".\n",
                            "" }));
   } else {
      art->flags &= ~NEWSPAPER_LOCK_FLAG;
      add_succeeded_mess(({ "You unlock the article " + art->art->title +
                            ".\n",
                            "" }));
   }
   save_me();
   return 1;
} /* do_lock() */

/** @Ignore yes */
int do_category_list() {
   string ret;
   string place;
   string name;
   class category_data data;

   if (_proxy) {
      return _proxy->do_category_list();
   }
   if (!sizeof(_category)) {
      add_failed_mess("There are no categories.\n");
      return 0;
   }

   ret = "";
   place = query_property("place");
   foreach (name, data in _category) {
      ret += "$I$5=" + name + " costs ";
      if (data->cost_per_add) {
         ret += MONEY_HAND->money_value_string(data->cost_per_add, place);
      } else {
         ret += "nothing";
      }
      ret += " per add and ";
      if (data->cost_per_ten_chars) {
         ret += MONEY_HAND->money_value_string(data->cost_per_ten_chars,
                                               place);
      } else {
         ret += "nothing";
      }
      ret += " for every ten characters.";
      if (!data->open) {
         ret += "  The category is currently closed.\n";
      } else {
         ret += "\n";
      }
   }
   write("$P$Category$P$" + ret);
   return 1;
} /* do_category_list() */

/** @Ignore yes */
int do_advert_list() {
   string ret;
   string place;
   class advert data;
   int editor;
   int found;
   int pos;

   if (_proxy) {
      return _proxy->do_advert_list();
   }
   if (!sizeof(_adverts)) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }

   ret = "";
   place = query_property("place");
   editor = is_editor(this_player()->query_name());
   pos = 1;
   foreach (data in _adverts) {
      if (editor ||
          lower_case(data->author) == this_player()->query_name()) {
         if (editor) {
            ret += "$I$5=" + pos + ") ";
         } else {
            ret += "$I$5=";
         }
         ret += data->author + " cost " +
                MONEY_HAND->money_value_string(data->value, place) +
                " written at " + ctime(data->date_written) + ":\n" +
                data->text + "\n";
         found = 1;
      }
      pos++;
   }
   if (!found) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }
   write("$P$Category$P$" + ret);
   return 1;
} /* do_advert_list() */

/** @ignore yes */
int do_advert_remove(int id) {
   class advert fluff;

   if (_proxy) {
      return _proxy->do_advert_remove(id);
   }
   if (!sizeof(_adverts)) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }

   if (!is_editor(this_player()->query_name())) {
      add_failed_mess("You must be an editor to remove adverts.\n");
      return 0;
   }

   if (id < 1 || id > sizeof(_adverts)) {
      add_failed_mess("The id " + id + " is invalid.\n");
      return 0;
   }

   fluff = _adverts[id - 1];
   _adverts = _adverts[0..id-2] + _adverts[id..];
   add_succeeded_mess("$N remove$s an advert by " + fluff->author + ".\n");
   return 1;
} /* do_advert_remove() */

/** @Ignore yes */
int do_category_remove(string category) {
   if (_proxy) {
      return _proxy->do_category_remove(category);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }

   if (sizeof(filter(_adverts, (: $1->category == $2 :), category))) {
      add_failed_mess("You have adverts in that category, you cannot "
                      "remove it.\n");
      return 0;
   }

   map_delete(_category, category);
   save_me();
   add_succeeded_mess(({ "You delete the category " + category + ".\n",
                          "" }));
   return 1;
} /* do_category_remove() */

/** @Ignore yes */
int do_category_add(string category) {
   string new_category;

   if (_proxy) {
      return _proxy->do_category_add(category);
   }
   new_category = query_category(category);
   if (new_category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }

   _category[category] = new(class category_data,
                             open : 0,
                             cost_per_add : 40,
                             cost_per_ten_chars : 40);
   save_me();
   add_succeeded_mess(({ "You add the category " + category + ".\n",
                          "" }));
   return 1;
} /* do_category_add() */

/** @Ignore yes */
int do_category_open(string category, string open) {
   if (_proxy) {
      return _proxy->do_category_open(category, open);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }

   _category[category]->open = open == "open";
   save_me();
   add_succeeded_mess(({ "You " + open + " the category " + category + ".\n",
                          "" }));
   return 1;
} /* do_category_open() */

/** @Ignore yes */
int do_category_cost(string category, string cost) {
   int value;
   string place;

   if (_proxy) {
      return _proxy->do_category_cost(category, cost);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must change a cost for a category.\n");
      return 0;
   }

   place = query_property("place");
   if (lower_case(cost) == "none") {
      value = 0;
   } else {
      value = MONEY_HAND->value_from_string(cost, place);
      if (!value) {
         add_failed_mess("The value " + cost + " is not a valid money "
                         "value.\n");
         return 0;
      }
   }

   _category[category]->cost_per_add = value;
   save_me();
   add_succeeded_mess(({ "You set the cost per add in category " +
                         category + " to " +
                         MONEY_HAND->money_value_string(value, place) +
                         ".\n",
                          "" }));
   return 1;
} /* do_category_cost() */

/** @Ignore yes */
int do_category_cost_per_ten_chars(string category, string cost) {
   int value;
   string place;

   if (_proxy) {
      return _proxy->do_category_cost_per_ten_chars(category, cost);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must change a cost for a category.\n");
      return 0;
   }

   place = query_property("place");
   if (lower_case(cost) == "none") {
      value = 0;
   } else {
      value = MONEY_HAND->value_from_string(cost, place);
      if (!value) {
         add_failed_mess("The value " + cost + " is not a valid money "
                         "value.\n");
         return 0;
      }
   }

   _category[category]->cost_per_ten_chars = value;
   save_me();
   add_succeeded_mess(({ "You set the cost per ten characters in category " +
                         category + " to " +
                         MONEY_HAND->money_value_string(value, place) +
                         ".\n",
                          "" }));
   return 1;
} /* do_category_cost_per_ten_chars() */

/** @ignore yes */
int do_submit_section(string name) {
   class our_article cur_art;

   if (_proxy) {
      return _proxy->do_submit_section(name);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked.\n");
      return 0;
   }
   cur_art = new(class our_article);
   cur_art->art = new(class article);
   cur_art->art->title = name;
   cur_art->art->shown_name = this_player()->query_name();
   cur_art->art->author = this_player()->query_name();
   cur_art->art->date_written = time();
   cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_SECTION;

   _articles += ({ cur_art });
   save_me();
   add_succeeded_mess("$N $V a section.\n");
   return 1;
} /* do_submit_section() */

/** @Ignore yes */
int do_submit_add(string category) {
   if (_proxy) {
      return _proxy->do_submit_add(category);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked.\n");
      return 0;
   }

   category = query_category(category);
   if (!category) {
      add_failed_mess("You must specify an existing category to "
                      "submit an add in.\n");
      return 0;
   }

   if (!_category[category]->open) {
      add_failed_mess("The category must be open to submit an add "
                      "for it.\n");
      return 0;
   }

   add_succeeded_mess(({ "", "$N starts submiting an add to " +
                 this_object()->the_short() +
                      ".\n" }));
   write("Please submit the text of your add:\n");
   this_player()->do_edit(0, "finish_add", this_object(), 0, category);
   //input_to("finish_add", 0, category)category;
   return 1;
} /* do_submit_add() */

/** @Ignore yes */
int do_lock(int locked) {

   if (_proxy) {
      return _proxy->do_lock(locked);
   }
   _locked = locked;
   if (_locked) {
      add_succeeded_mess("$N lock$s " + this_object()->the_short() + ".\n");
   } else {
      add_succeeded_mess("$N unlock$s " + this_object()->the_short() + ".\n");
   }
   return 1;
} /* do_lock() */

/** @ignore yes */
void finish_add(string str, string category) {
   int value;
   string place;

   if (!str || !strlen(str)) {
      write("Ok, Aborted writing an add.\n");
      return ;
   }

   if (is_sponsor(this_player()->query_name())) {
      write("You add in the category " + category + " with a text of:\n" +
             str + "\n\nThis will cost you nothing since you are a sponsor.\n"
               ", do you want to do this? ");
      input_to("confirm_add", 0, str, category, 0);
   } else {
      place = query_property("place");
      value = _category[category]->cost_per_add +
              _category[category]->cost_per_ten_chars * strlen(str) / 10;
      if (this_player()->query_value_in(place) < value) {
         write("You add in the category " + category + " with a text of:\n" +
               str + "\n\nThis will cost you " +
               MONEY_HAND->money_value_string(value, place) +
               ", but you do not have enough money!  Sorry.\n");
      } else {
         write("You add in the category " + category + " with a text of:\n" +
               str + "\n\nThis will cost you " +
               MONEY_HAND->money_value_string(value, place) +
               ", do you want to do this? ");
         input_to("confirm_add", 0, str, category, value);
      }
   }
} /* finish_add() */

/** @ignore yes */
void confirm_add(string str, string text, string category, int value) {
   class advert add;
   string place;
   int found;
   class our_article bing;

   if (!str || !strlen(str)) {
      return 0;
   }

   if (lower_case(str)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }

   if (!is_sponsor(this_player()->query_name())) {
      place = query_property("place");
      if (this_player()->query_value_in(place) < value) {
         add_failed_mess("You do not have " +
            MONEY_HAND->money_value_string(value, place) +
            " to pay for the add.\n");
         return ;
      }

      this_player()->pay_money(MONEY_HAND->create_money_array(value, place),
                               place);
   }

   add = new(class advert);
   add->author = this_player()->query_cap_name();
   add->text = text;
   add->category = category;
   add->value = value;
   add->date_written = time();
   _adverts += ({ add });
   foreach (bing in _articles) {
      if (a_type(bing->art->type) == NEWSPAPER_ARTICLE_TYPE_ADVERTS) {
         found = 1;
         break;
      }
   }
   if (!found) {
      _articles += ({ new(class our_article,
                          art : new(class article,
                                    title : "Adverts",
                                    author : query_owner(),
                                    shown_name : query_owner(),
                                    date_written : time(),
                                    type : NEWSPAPER_ARTICLE_TYPE_ADVERTS
                                   )
                          ) });
   }
   save_me();
   write("Ok, your advertisement is added.\n");
} /* confirm_add() */

/** @ignore yes */
int finish_editing(string story, class our_article art)
{
   if (!story) {
      tell_object(this_player(), "Ok, no editing saved.\n");
      return 0;
   }
   save_article_text(art, story);
   log_file(query_article_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " edited the story " + art->art->title + ".\n");
}                               /* finish_editing() */


/** @ignore yes */
int do_transfer_ownership(string new_owner) {
   int value;
   string place;

   if (!is_owner(this_player()->query_name())) {
      add_failed_mess("You must be the owner to transfer the ownership.\n");
      return 0;
   }

   if (_proxy) {
      add_failed_mess("You must be in the main office to transfer ownership.\n");
      return 0;
   }

   if (!PLAYER_HANDLER->test_user(new_owner)) {
      add_failed_mess("You must transfer ownership to someone that exists.\n");
      return 0;
   }

   //
   // Find out how much the paper cost inthe first place to demand that as
   // a fee.
   //
   place = query_property("place");
   value = HOUSING->query_value(base_name(this_object()));
   if (this_player()->query_value_in(place) < value &&
       BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       value) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(value, place)  +
                      " to transfer the ownership, in hand or in the bank.\n");
      return 0;
   }


   write("It will cost you " + MONEY_HAND->money_value_string(value, place)  +
         " in fees to transfer ownership to " +
         new_owner + ".\nDo you want to do this? ");
   input_to("check_transfer", 0, new_owner, value);
   add_succeeded_mess("");
   return 1;
}

/** @ignore yes */
void check_transfer(string test, string new_owner, int value) {
   string place;

   test = lower_case(test);
   if (!strlen(test) || test[0] != 'y') {
      write("Aborted.\n");
      return 0;
   }

   // Check the money again.
   place = query_property("place");
   if (this_player()->query_value_in(place) < value  &&
       BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       value) {
      write("You need at least " +
                      MONEY_HAND->money_value_string(value, place)  +
                      " to transfer the ownership.\n");
      return 0;
   }

   // Do it.
   if (this_player()->query_value_in(place) >= value ) {
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place), place);
   } else {
       BANK_HANDLER->adjust_account(this_player()->query_name(), query_bank_branch(), -value);
   }
   write("Transfering the ownership from " +
         query_owner() + " to " + new_owner + ".\n");
   HOUSING->set_owner(base_name(this_object()), new_owner);
}

/**
 * This method returns all the current reporters of the magazine.
 * @return all the current reporters
 */
string* query_all_reporters()
{
   return keys(_reporters);
}

/**
 * This method returns all the current setters of the magazine.
 * @return all the current setters
 */
string* query_all_setters()
{
   return copy(_setters);
}

/**
 * This method returns all the current sponsors of the magazine.
 * @return all the current sponsors
 */
string* query_all_sponsors()
{
   return copy(_sponsors);
}

/**
 * This method returns all the current editors of the magazine.
 * @return all the current editors
 */
string* query_all_editors()
{
   return _editors + ({ query_owner() });
}

/**
 * This method returns all the current payees of the magazine.
 * @return who is to be payed and how much
 */
mapping query_all_payees()
{
   return copy(_payees);
}

/**
 * This method returns the 'article' class bits of the articles.
 * @return all the articles.\
 */
class article* query_all_articles() {
   return map(_articles, (: copy($1->art) :) );
} /* query_all_articles() */

/**
 * This method checks to see if the specified article is postponed
 * or not.
 * @param art the article to check
 * @return 1 if it is postponed, 0 if not
 */
int is_postponed(class article art) {
   class our_article rabbit;

   foreach (rabbit in _articles) {
      if (rabbit->art->file_name == art->file_name) {
         return rabbit->flags & NEWSPAPER_POSTPONE_FLAG;
      }
   }
   return 0;
} /* is_postponned() */

/**
 * This method checks to see if the specified article is locked
 * or not.
 * @param art the article to check
 * @return 1 if it is locked, 0 if not
 */
int is_locked(class article art) {
   class our_article rabbit;

   foreach (rabbit in _articles) {
      if (rabbit->art->file_name == art->file_name) {
         return rabbit->flags & NEWSPAPER_LOCK_FLAG;
      }
   }
   return 0;
} /* is_locked() */

/**
 * This method checks to see if the specified person is an reporter for
 * the paper or not.
 * @param word the person to check
 * @return 1 if they are a reporter
 */
int is_reporter(string word)
{
   if (_proxy) {
      return _proxy->is_reporter(word);
   }
   return classp(_reporters[word]);
}

/**
 * This method checks to see if the specified person is an setter for
 * the paper or not.
 * @param word the person to check
 * @return 1 if they are a setter
 */
int is_setter(string word)
{
   if (_proxy) {
      return _proxy->is_setter(word);
   }
   return member_array(word, _setters) != -1;
}

/**
 * This method checks to see if the specified person is a sponsor for
 * the paper or not.
 * @param word the person to check
 * @return 1 if they are a sponsor
 */
int is_sponsor(string word)
{
   if (_proxy) {
      return _proxy->is_sponsor(word);
   }
   return member_array(word, _sponsors) != -1;
}

/**
 * This method checks to see if the specified person is an editor for
 * the paper or not.
 * @param word the person to check
 * @return 1 if they are a editor
 */
int is_editor(string word)
{
   if (_proxy) {
      return _proxy->is_editor(word);
   }
   if (master()->query_administrator(word)) {
      return 1;
   }
   if (word == query_owner()) {
      return 1;
   }
   return member_array(word, _editors) != -1;
}

/**
 * This method checks to see if the specified person is an owner of
 * the paper or not.
 * @param word the person to check
 * @return 1 if they are a owner
 */
int is_owner(string word)
{
   if (_proxy) {
      return _proxy->is_owner(word);
   }
   if (master()->query_administrator(word)) {
      return 1;
   }
   if (word == query_owner()) {
      return 1;
   }
   return 0;
}

/**
 * This method adds a new reporter to the paper.
 * @param word the new reporter to add
 */
void add_reporter(string word)
{
   if (!_reporters[word]) {
      _reporters[word] = new(class reporter);
      _reporters[word]->date_added = time();
      update_commands(word);
      save_me();
   }
}                               /* add_reporter() */

/**
 * This method adds a new sponsor to the paper.
 * @param word the new sponsor to add
 */
void add_sponsor(string word)
{
   if (!is_sponsor(word)) {
      _sponsors += ({ word });
      update_commands(word);
      save_me();
   }
}                               /* add_sponsor() */

/**
 * This method adds a new setter to the paper.
 * @param word the new setter to add
 */
void add_setter(string word)
{
   if (!is_setter(word)) {
      if (!is_reporter(word)) {
         add_reporter(word);
      }
      _setters += ({ word });
      update_commands(word);
      save_me();
   }
}                               /* add_setter() */

/**
 * This method adds a new editor to the paper.
 * @param word the new editor to add
 */
void add_editor(string word)
{
   if (!is_editor(word)) {
      if (!is_reporter(word)) {
         add_reporter(word);
      }
      _editors += ({ word });
      update_commands(word);
      save_me();
   }
}                               /* add_editor() */

/**
 * This method removes a reporter from the paper.
 * @param word the reporter to remove
 */
void remove_reporter(string word)
{
   if (!is_reporter(word)) {
      return;
   }
   map_delete(_reporters, word);
   update_commands(word);
   save_me();
}                               /* remove_reporter() */

/**
 * This method removes a editor from the paper.
 * @param word the editor to remove
 */
void remove_editor(string word)
{
   if (!is_editor(word)) {
      return;
   }
   _editors -= ({ word });
   update_commands(word);
   save_me();
}                               /* remove_editor() */

/**
 * This method removes a setter from the paper.
 * @param word the setter to remove
 */
void remove_setter(string word)
{
   if (!is_setter(word)) {
      return;
   }
   _setters -= ({ word });
   update_commands(word);
   save_me();
}                               /* remove_setter() */

/*
 * This method removes a sponsor from the paper.
 * @param word the sponsor to remove
 */
void remove_sponsor(string word)
{
   if (!is_sponsor(word)) {
      return;
   }
   _sponsors -= ({ word });
   save_me();
}                               /* remove_editor() */

/**
 * This method moves the player in and out of the room to fix up their
 * commands.
 * @param word the player to move
 */
void update_commands(string word)
{
   object player;

   player = find_player(word);
   if (player && environment(player) == this_object()) {
      player->move("/room/void");
      player->move(file_name(this_object()));
   }
}                               /* update_commands() */

/**
 * This method returns the current owner of the paper.
 * @return the owner of the paper
 */
string query_owner() {
   if (_proxy) {
      return _proxy->query_owner();
   }
   return _owner;
} /* query_owner() */

/**
 * This method sets the current owner of the paper.
 * @param person the new owner
 */
void set_owner(string person) {
   _owner = person;
   save_me();
} /* set_owner() */

/**
 * This method is called by the housing system when the ownership changes.
 * @param old_owner the old owner
 * @param new_owner the newowner
 */
void ownership_change(string old_owner, string new_owner) {
   set_owner(new_owner);
}

/**
 * This method sets up a proxy for the room.  A proxy means all the commands
 * are mirrored to the real location, so save files do not get messed up.
 * You set this if you have any extra rooms you want to be able to control
 * the paper.
 * @param proxy the proxy to set
 */
void set_proxy(string proxy) {
   _proxy = proxy;
} /* set_proxy() */

/**
 * This method returns the proxy for this room.
 * @return the proxy for the room
 */
string query_proxy() {
   return _proxy;
} /* query_proxy() */

/**
 * This method is here to control access to a board if one is requested.
 * It allows only reporters to be able to see or write to it and it
 * allows editors to be able to eat messages from it.
 */
int board_access_check(int type, string board, object previous, string name) {
   switch (type) {
   case B_ACCESS_READ :
      return is_reporter(lower_case(name));
   case B_ACCESS_WRITE :
      return is_reporter(lower_case(name));
   case B_ACCESS_DELETE :
      // Players can always delete their own notes, do not need to code
      // for that.
      return is_editor(name);
   }
} /* board_access_check() */

void init()
{
   string person;

   person = this_player()->query_name();
   add_command("advert", "categories", (: do_category_list() :));
   add_command("advert", "list", (: do_advert_list() :));
   add_command("category", "list", (: do_category_list() :));
   add_command("submit", "advert {in|to|into} <string'category'>",
               (: do_submit_add($4[1]) :));
   add_command("submit", "advert <string'category'>",
               (: do_submit_add($4[0]) :));
   if (!is_editor(person) && !is_reporter(person) && !is_setter(person)) {
      add_command("apply", "", (: do_apply() :));
      add_command("status", "", (: do_everyone_status() :));
      return;
   }
   add_command("submit", "text <string:quoted'article name'> as <string'author'>",
               (: do_submit($4[0], $4[1], 0) :));
   add_command("submit", "html <string:quoted'article name'> as <string'author'>",
               (: do_submit($4[0], $4[1], 1) :));
   add_command("submit", "text <string'article name'>",
               (: do_submit($4[0], 0, 0) :));
   add_command("submit", "html <string'article name'>",
               (: do_submit($4[0], 0, 1) :));
   add_command("retrieve", "<string'article'>", (: do_retrieve($4[0], 0) :));
   add_command("retrieve", "source <string'article'>",
               (: do_retrieve($4[0], 1) :));
   add_command("resign", "", (: do_resign() :));
   add_command("status", "", (: do_status() :));
   add_command("status", "room", (: do_status() :));
   add_command("claim", "", (: do_claim() :));
   add_command("articles", "", (: do_articles(0) :));
   add_command("articles", "scroll", (: do_articles(1) :));
   add_command("edit", "<string'article'>", (: do_editing($4[0]) :));
   add_command("delete", "<string'article'>", (: do_delete($4[0]) :));
   add_command("title", "<string'article'> <string'new title'>",
               (: do_title($4[0], $4[1]) :));
   add_command("author", "<string'article'> <string'new author name'>",
               (: do_author($4[0], $4[1]) :));
   add_command("change", "type of <string'article'> to {html|plain}",
               (: do_change($4[0], $4[1]) :));
   if (!is_setter(person) && !is_editor(person)) {
      return;
   }
   add_command("change", "colour of <string'article'> to {red|blue|green|cyan|magenta|yellow|brown|none}",
               (: do_change_colour($4[0], $4[1]) :));
   add_command("move", "<string'article'> {up|down}",
               (: do_move($4[0], $4[1]) :));
   add_command("move", "<string'article'> to <string'position'>",
               (: do_move_pos($4[0], $4[1]) :));
   if (!is_editor(person)) {
      return;
   }
   add_command("change", "xp [return] of <string'article'> to {none|normal}",
               (: do_change_xp($4[0], $4[1]) :));
   add_command("submit", "section <string'section name'>",
               (: do_submit_section($4[0]) :));
   add_command("add", "reporter <string'person'>", (: do_hire($4[0], 0) :));
   add_command("add", "setter <string'person'>", (: do_hire($4[0], 1) :));
   add_command("add", "editor <string'person'>", (: do_promote($4[0]) :));
   add_command("add", "sponsor <string'person'>", (: do_sponsor_add($4[0]) :));
   //add_command("promote", "<string'person'>", (: do_promote($4[0]) :));
   add_command("remove", "editor <string'person'>", (: do_demote($4[0], 1) :));
   add_command("remove", "setter <string'person'>", (: do_demote($4[0], 0) :));
   add_command("remove", "reporter <string'person'>", (: do_dismiss($4[0]) :));
   add_command("remove", "sponsor <string'person'>", (: do_sponsor_remove($4[0]) :));
   add_command("log", "", (: do_logs(0) :));
   add_command("log", "article", (: do_logs(1) :));
   //add_command("unmark", "<string'article'>", (: do_unmark($4[0]) :));
   add_command("pay", "bank branch <string'bank name'>",
               (: do_set_bank_branch($4[0]) :));
   add_command("pay", "<word'person'> <string'amount|none'>",
               (: do_pay($4[0], $4[1]) :));
   add_command("pay", "<word'person'> message <string'message|none'>",
               (: do_pay_tag($4[0], $4[1]) :));
   add_command("profit", "", (: do_summary() :));
   add_command("profit", "deposit extra <string'cash'>",
               (: do_deposit($4[0]) :));
   add_command("postpone", "<string'article'> {on|off}",
               (: do_postpone($4[0], $4[1]) :));
   add_command("lock", "articles {on|off}", (: do_lock($4[0] == "on") :));
   add_command("lock", "article <string'article'> {on|off}",
               (: do_lock_article($4[0], $4[1]) :));
   add_command("publish", "with headline <string'headline'>",
               (: do_publish($4[0]) :));
   add_command("category", "{open|close} <string'catgory'>",
               (: do_category_open($4[1], $4[0]) :));
   add_command("category", "add <string'catgory'>",
               (: do_category_add($4[0]) :));
   add_command("category", "remove <string'catgory'>",
               (: do_category_remove($4[0]) :));
   add_command("category", "cost <string'category'> per add <string'cost|none'>",
               (: do_category_cost($4[0], $4[1]) :));
   add_command("category", "cost <string'category'> per ten characters <string'cost|none'>",
               (: do_category_cost_per_ten_chars($4[0], $4[1]) :));
   add_command("advert", "remove <number'id'>", (: do_advert_remove($4[0]) :));

   if (!is_owner(this_player()->query_name())) {
      return ;
   }
   add_command("transfer", "paper ownership to <string'name'>",
               (: do_transfer_ownership($4[0]) :));
}                               /* init() */

class advert* query_ads() { return _adverts; }


// --- END [/mnt/home2/grok/lib/std/room/inherit/newspaper_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/complaints_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/complaints_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629390   Available: 13576744
Inodes: Total: 5242880    Free: 4960136
3512 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/complaints_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629390   Available: 13576744
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming

/**
 * This inherit allows people to complain in unhappy times.  It does the
 * interfacing with the complaints handler and all the other gubbins.
 *
 * @see /std/room/inherit/complaints_room.c
 * @see /obj/handlers/complaints_handlers.c
 * @author Arienne
 * @started Wed Apr  4 14:11:50 BST 2001
**/

#include <complaints_handler.h>
#include <board.h>

/**
 * @ignore
**/
void init() {
    add_command( "complain", "" );
} /* init() */

/**
 * This prints a set message to the player who wants to complain.  It also
 * enforces who cannot complain (eg. guest characters cannot complain).
 *
 * @return Should always return 1.
**/
int do_complain() {
    // guest characters cannot complain
    if ( this_player()->query_property( "guest" ) )
        return add_failed_mess( "Guest characters cannot lodge "
                                "complaints.\n" );

    // A simple message about nature of complaints before you begin
    tell_object( this_player(), "You are lodging an official complaint about "
                 "something or someone.\n"
                 
                 "Do not take this action lightly.\n"
                 
                 "Complaints should be about serious Disc-related matters.  "
                 "Please note that this complaint is submitted anonymously.  "
                 "If you wish to receive a reply, make sure you place your "
                 "character name in the complaint so we know who to respond "
                 "to.\n"
                 
                 "Feedback for the general populous also often appears on "
                 "various bulletin boards.\n" );
    
    this_player()->do_edit( 0, "finish_complaint", this_object() );
    return 1;
} /* do_complain() */

/**
 * Check to see whether the complaint was cancelled.  If not, submit it to the
 * complaints handler.  Print a message on success or failure.
**/
void finish_complaint( string str ) {
    if ( !str ) {
        tell_object( this_player(), "Complaint aborted.\n" );
    } else {
        // you have finished a complaint, so submit it to the handler

        if ( COMPLAINTS_HANDLER->do_submit_complaint( str ) ) {
            tell_object( this_player(), "Complaint posted.  Thank you for "
                         "your complaint.  If you submitted your name in "
                         "your complaint, you should receive a response in "
                         "the near future.  Please be patient, as there may "
                         "be in-depth discussions as a result of your "
                         "complaint.\n" );
        } else {
            tell_object( this_player(), "There has been a problem posting "
                         "your complaint.  As a result it has NOT been "
                         "submitted.  You should contact a liaison or other "
                         "creator to get this rectified immediately.\n" );
        }
    }
} /* finish_complaint() */

/**
 * @ignore
**/
int board_access_check( int type, string, object previous, string name ) {
    tell_creator("arienne",file_name(previous)+"\n");
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
        
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
        
    case B_ACCESS_DELETE :
        // Players can always delete their own notes, do not need to code
        // for that.
        return 0;
    }
} /* board_access_check() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/complaints_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/room_rental_office.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/room_rental_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629389   Available: 13576743
Inodes: Total: 5242880    Free: 4960136
6179 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/room_rental_office.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629389   Available: 13576743
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * A Room Rental Office inheritable
 *
 * by goldenthread started 24 Sep y2k1
 *
 */

#include <money.h>
#include <room/room_rental.h>

private string _location;
private string _domain;

int do_rental( string room );
int add_room( string room, int cost );
int delete_room( string room );
int clear_rooms();

/**
 * Sets the domain of the current office.
 *
 * @param dom the domain
 */
void set_domain( string dom ) {
  _domain = dom;
} /* set_domain */


/**
 * Queries the domain of the current office.
 *
 * @return the domain of the office.
 */
string query_domain() {
  return _domain;
} /* query_domain */


/**
 * Sets the location of the current office.
 * This is a name to identify the "hotel" or
 * local group of rooms.
 *
 * @param loc the location
 */
void set_location( string loc ) {
  _location = loc;
} /* set_location */


/**
 * Queries the location of the current office.
 *
 * @return the location of the office.
 */
string query_location() {
  return _location;
} /* query_location */


void create() {
  /* these will be overloaded by anything inheriting this */
  set_location( "default" );
  set_domain( "default" );
} /* setup() */

void init() {
  add_command( "list", "[rooms]" );
  add_command( "rent", "<string'room'>",
               (: do_rental( $4[0] ) :) );
  if ( this_player()->query_creator() ) {
    add_command( "add", "<string> for <number>",
                 (: add_room( $4[0], $4[1] ) :) );
    add_command( "remove", "<string>", (: delete_room( $4[0] ) :) );
    // Don't make it too easy to delete all the rooms.
    //add_command( "clear", "[list]", (: clear_rooms() :) );
  }
} /* init() */

/**
 * This method returns the list of all the rooms available from this
 * office.
 * @return the string list of rooms
 */
string query_list() {
   string room;
   string list = "";
   string tenant;
   object room_ob;
   object office_ob = this_object();

   tell_creator( "goldenthread", "getting list for %s ( %O )\n",
                 office_ob->short(), office_ob );
   foreach( room in ROOM_RENTAL_HANDLER->query_rooms_to_rent( office_ob ) ) {
      tenant = ROOM_RENTAL_HANDLER->query_who_rents( room, office_ob );

      tell_creator( "goldenthread", "found %s\n", room );
      
      if ( room_ob = load_object( room ) ) {
         list += room_ob->query_short();
         if ( tenant != "nobody" )
            list += " (rented by " + tenant + ")\n";
         else
            list += " (available for " + MONEY_HAND->money_value_string(
               to_int( ROOM_RENTAL_HANDLER->query_rental_value( room ) ),
               _domain ) + ")\n";
      }
   }

   if ( list != "")
      list = "/global/events"->convert_message(list) + "\n";
   else
      list = "There are no rooms available here.\n";

   return list;
} /* query_list */


/**
 * The command to print the list of rooms available to rent.
 */
int do_list() {
  string list = "Here are the rooms available to rent in " + _location
                + ":\n\n";

  this_player()->add_succeeded_mess( this_object(), "$N ask$s for a list "
                                     "of available rooms.\n", ({ }) );

  list += query_list();

  tell_object( this_player(), list );

  return 1;
} /* do_list */

/**
 * This method adds a room into the offices list of rooms to rent.
 * @param room the room to add
 * @param cost how much the room costs to rent
 * @return 1 on success, 0 on failure
 */
int add_room( string room, int cost ) {
  if ( ROOM_RENTAL_HANDLER->add_room( room, cost, this_object() ) ) {
    this_player()->add_succeeded_mess( this_object(),
                   ({ "$N $V a room.\n", "" }), ({ }) );
    return 1;
  }
  this_player()->add_failed_mess( this_object(),
                                  "That room cannot be added.\n", ({ }) );
  return 0;
}

/**
 * This method deletes a room from the offices list of rooms to rent.
 * @param room the room to delete
 * @return 1 on success, 0 on failure
 */
int delete_room( string room ) {
  if( ROOM_RENTAL_HANDLER->delete_room( room, this_object() ) ) {
    this_player()->add_succeeded_mess( this_object(),
                   ({ "$N $V a room.\n", "" }), ({ }) );
    return 1;
  }

  return 0;
}

/**
 * This method removes all the rooms from the offices list of rooms to rent.
 * Use this function with caution.
 * @return 1 on success, 0 on failure
 */
int clear_rooms() {
  if( ROOM_RENTAL_HANDLER->clear_rooms( this_object() ) ) {
    this_player()->add_succeeded_mess( this_object(),
                   ({ "$N $V the list of rooms.\n", "" }), ({ }) );
    return 1;
  }
  return 0;
}


/**
 * This method attempts to rent a room.  It checks the return from the
 * handler and prints the appropriate message.
 * @param room the room to try and rent
 * @return 1 on success, 0 on failure
 */
int do_rental( string room ) {
  object ob = this_player();
  int ret = ROOM_RENTAL_HANDLER->do_rental( ob, room, this_object() );

  switch( ret ) {
    case RENTAL_SUCCESS:
      ob->pay_money( MONEY_HAND->create_money_array(
          ROOM_RENTAL_HANDLER->query_rental_value( room ), query_domain() ),
          query_domain() );
      ob->add_succeeded_mess( this_object(), ({ "$N $V a room.\n", "" }),
                              ({ }) );
      return 1;
    case RENTAL_NO_SUCH_ROOM:
      ob->add_failed_mess( this_object(), "There is no such room here.\n",
                           ({ }) );
      return 0;
    case RENTAL_ALREADY_RENTED:
      ob->add_failed_mess( this_object(), "The room has already been rented.\n",
                           ({ }) );
      return 0;
    case RENTAL_NO_MONEY:
      ob->add_failed_mess( this_object(), "You don't have enough money for "
                           "that.\n", ({ }) );
      return 0;
    default:
      ob->add_failed_mess( this_object(), "Something has gone wrong.  Please "
                           "contact a creator.\n", ({ }) );
      return 0;
  }
}


/** @ignore yes */
void init_dynamic_arg( mapping map, object ob ) {
   _domain = map[ "domain" ];
   _location = map[ "location" ];
}

/** @ignore yes */
mapping query_dynamic_auto_load( void ) {
   return ([ "domain" : _domain,
           "location" : _location, ]);
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/room_rental_office.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/placement.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/placement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629387   Available: 13576741
Inodes: Total: 5242880    Free: 4960136
47398 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/placement.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629387   Available: 13576741
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
// Gototh, 10/07/99
/**
 * This inherit handles all the placement code and description stuff for
 * player housing.
 * @author Gototh
 * @started 10/07/99
 */

/*
 * Todo:
 *
 *  - Convert from properties to functions.
 *  - Document fully.
 */

#include <obj_parser.h>
#include <dirs.h>
#include <room/placement.h>

#define PLAYTESTING
//#define DEBUG

#define MAX_PLACED 10

/*
#define PLACEMENT_CURRENT_ROOM_VERB "current room verb"
#define CURRENT_ROOM_OTHER "current room other"
#define CURRENT_ROOM_POSITION "current room position"
#define CURRENT_ROOM_RELATIVE "current room relative"
#define IMMOVABLE "immovable"
 */
#define PLACEMENT_CURRENT_ROOM_HIDDEN "current room hidden"

#define OPPOSITE 0
#define ABOVE    1
#define BELOW    2
#define RIGHT    3
#define LEFT     4

#define OPPOSITE_DESCS ({ \
  "opposite which", \
  "facing which", \
})

#define ABOVE_DESCS ({ \
  "above which", \
  "over which", \
})

#define BELOW_DESCS ({ \
  "under which", \
  "below which", \
})

#define RIGHT_DESCS ({ \
  "to the right of which", \
})

#define LEFT_DESCS ({ \
  "to the left of which", \
})

#define HANGING_VERBS ({ \
  "hanging", \
  "suspended", \
  "dangling", \
})

#define HANGING_PREPOSITIONS ({ \
  "from", \
  "on", \
})

#define WALL_PREPOSITIONS ({ \
  "beside", \
  "against", \
})

#define CORNER_PREPOSITIONS ({ \
  "in", \
})

#define ABOUT_PREPOSITIONS ({ \
  "near", \
  "at", \
})
//  "in front of", \

string get_pos_desc(int pos_int);
int do_place(object *obs, string, string, mixed *args, string);
int do_help(object *);
int get_pos_int(string str);
string extra_look(object);
string object_position_desc(object thing);
string object_desc(object thing);
string object_desc2(object thing);
object *build_structure();
int find_opposite(int pos, object *structure);
int find_above(int pos, object *structure);
int find_below(int pos, object *structure);
int find_left(int pos, object *structure);
int find_right(int pos, object *structure);
int get_structure_index(object ob);
varargs int is_beside_wall(int pos, int flag);
varargs int is_in_corner(int pos, int flag);

nosave object *needs_described;
nosave object *have_described;
nosave int orientation;
nosave mapping _wall_names;
nosave string furniture_long = "";

void init() {
 if(!this_player() || !interactive(this_player()))
     return;
     
  this_player()->add_command("place", this_object(),
    "<indirect:object'furniture'> so it is <word'verb'> "
    "{"+implode(ABOUT_PREPOSITIONS+HANGING_PREPOSITIONS+WALL_PREPOSITIONS+CORNER_PREPOSITIONS, "|")+"} "
    "the <string:'location'> [wall|corner]");
  
  // Without a verb.
  this_player()->add_command("place", this_object(),
    "<indirect:object'furniture'> "
    "{"+implode(ABOUT_PREPOSITIONS+HANGING_PREPOSITIONS+WALL_PREPOSITIONS+CORNER_PREPOSITIONS, "|")+"} the <string'location'> [wall|corner]");

  this_player()->add_command("displace", this_object(),
    "<indirect:object'furniture'>");

  this_player()->add_command("place", this_object(),
                             "help", (: do_help(0) :));
  this_player()->add_command("place", this_object(),
                             "help <indirect:object'furniture'>",
                             (: do_help($1[0]) :));
}

/**
 * This method sets a special description for a wall.  For example making
 * it a fence or something.
 * @param direction the direction to do a thing for
 * @param name the nice name
 */
void set_wall_name(string direction, string name) {
   int pos;

   if (!_wall_names) {
      _wall_names = ([ ]);
   }
   pos = get_pos_int(direction);
   _wall_names[pos] = name;
} /* set_wall_name() */

/**
 * This method gets the wall name from the integer position.
 * @param pos the integer position
 * @return the wall name
 */
string query_wall_name_pos(int pos) {
   if (!_wall_names) {
      _wall_names = ([ ]);
   }
   if (_wall_names[pos]) {
      return _wall_names[pos];
   }
   if(!orientation)
   {
      if(pos % 2)
      {
         return "corner";
      }
      return "wall";
   }
   if(pos % 2)
   {
      return "wall";
   }
   return "corner";
} /* query_wall_name_pos() */

/** 
 * This method returns the special description for the wall in that
 * direction.
 * @param direction
 * @return the special description, or wall if none
 */
string query_wall_name(string direction) {
   int pos;

   pos = get_pos_int(direction);
   return query_wall_name_pos(pos);
} /* query_wall_name() */

string query_another(object ob)
{
  object *obs;
  string another;

  obs = filter(have_described, 
    (: $1->query_plural() == $(ob->query_plural()) :));

  switch(sizeof(obs))
  {
    case 0 :
      another = " a";
      break;
    case 1 :
      another = " another";
      break;
    default :
      another = " yet another";
      break;
  }
  return another;
} /* query_another() */

string query_more(object ob)
{
  object *obs;
  string more;

  obs = filter(have_described, 
    (: $1->query_plural() == $(ob->query_plural()) :));

  switch(sizeof(obs))
  {
    case 0 :
      more = "";
      break;
    default :
      more = " more";
      break;
  }
  return more;
} /* query_more() */

string clutter_string(object ob) {
  mixed *things;
  string cluttered = "";
  
  if(ob->query_has_surface()) {
    things = ob->find_inv_match("all", ob);
    things = unique_array(things, (: $1->query_plural() :));

    switch(sizeof(things)) {
      case 1 :
        if(sizeof(things[0]) == 1)
          cluttered = " is";
        else
          cluttered = " are";

        cluttered += " " + query_multiple_short(things[0]); 
        break;
      default :
        break;
    }
  }
  
  return cluttered;
} /* clutter_string() */

string query_multiple_furniture_short(object *obs) {
  object *group;
  mixed *things;
  string str;
  string *strs;
  strs = ({ });
  things = unique_array(obs, (: $1->query_plural() :));
  foreach(group in things)
  {
    switch(sizeof(group))
    {
      case 0 :
        break;
      case 1 :
        str = query_another(group[0])[1..];
        str += " " + group[0]->query_short();
        break;
      default :
        str = query_num(sizeof(group));
        str += query_more(group[0]);
        str += " " + group[0]->query_plural();
        break;
    }
    strs += ({ str });
  }
  return query_multiple_short(strs);
} /* query_multiple_furniture_short() */

/*
 * This function returns true if the object has been placed in 
 * the corner.
 */
varargs int is_in_corner(int pos, int flag)
{
  if(orientation && !flag)
    return is_beside_wall(pos, 1);
  
  if(member_array(pos, ({ 3, 5, 7, 9 })) != -1)
    return 1;

  return 0;
} /* is_in_corner() */

/*
 * This function returns true if the object has been placed 
 * beside a wall.
 */
varargs int is_beside_wall(int pos, int flag)
{
  if(orientation && !flag)
  {
    return is_in_corner(pos, 1);
  }
  if(member_array(pos, ({ 2, 4, 6, 8 })) != -1)
  {
    return 1;
  }
  return 0;
} /* is_beside_wall() */

/*
 * This function returns true if the object is hanging from a
 * wall.
 */
int is_wall_hanging(int pos)
{
  if(orientation)
  {
    if(member_array(pos, ({ 13, 15, 17, 19 })) != -1)
    {
      return 1;
    }
    return 0;
  }
  if(member_array(pos, ({ 12, 14, 16, 18 })) != -1)
  {
    return 1;
  }
  return 0;
} /* is_hanging() */

int is_in_centre(int pos)
{
  if(pos == 1)
  {
    return 1;
  }
  return 0;
} /* is_hanging() */

int query_max_space_around(int pos)
{
  if(is_in_corner(pos))
  {
    return 2;
  }
  if(is_beside_wall(pos))
  {
    return 3;
  }
  if(is_in_centre(pos))
  {
    return 4;
  }
  return 0;
} /* query_max_space_around() */

int do_help(object ob) {
  string str;
  string *bits;

  if(ob && !ob->query_furniture())
    return this_player()->add_failed_mess(this_object(),
                                          "$I is not a piece of furniture.\n",
                                          ({ ob }));
  
  
  str = "The place command requires a furniture object, an optional verb, "
    "a preposition and a location.  ";
  
  if(!ob) {
    str += "Which verbs are available depends on the furniture.  Hanging "
      "furniture can use " + query_multiple_short(HANGING_VERBS) + ".  ";
  } else {
    if(ob->query_allowed_room_verbs())
      bits = filter(keys(ob->query_allowed_room_verbs()), (: $1 != "" :));

    switch(sizeof(bits)) {
    case 0:
      str += "The " + ob->the_short() + " has no verbs.\n";
      break;
    case 1:
      str += "The verb for " + ob->the_short() + " is " +
        query_multiple_short(bits) + ".\n";
      break;
    default:
      str += "The verbs available for " + ob->the_short() + " are " +
        query_multiple_short(bits) + ".\n";
    }
  }

  str += "The prepositions for hanging things are " +
    query_multiple_short(HANGING_PREPOSITIONS) + ", while items may be "
    "placed " + query_multiple_short(WALL_PREPOSITIONS) + " walls, " +
    query_multiple_short(CORNER_PREPOSITIONS) + " corners, or " +
    query_multiple_short(ABOUT_PREPOSITIONS) + " other objects.  " 
    "The " + query_multiple_short(({"ceiling", "floor", "centre", "north",
                                      "south", "east", "west", "northeast",
                                      "southeast", "northwest", "southwest"}))+
    " may be used as locations.\n";
  write(str);
  return 1;
}

int do_place(object *obs, string, string, mixed *args, string)
{
  int pos, allowed;
  string k, v;
  mapping allowed_verbs;
  object *things;
  object *placed;
  object* already_around;
  class obj_match result;

#ifdef DEBUG
  debug_printf("Obs: %O, args: %O", obs, args);
#endif
  
  if(this_player() &&
     !this_object()->test_occupier(this_player()->query_name()) &&
     !this_player()->query_creator()) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  if(sizeof(obs) > 1) {
    this_player()->add_failed_mess(this_object(),
      "You may only place one object at a time.\n", ({ }));
    return 0;
  }
  if(!obs[0]->query_furniture()) {
    this_player()->add_failed_mess(this_object(),
      "$I is not suitable furniture.\n", ({ obs[0] }));
    return 0;
  }

  placed = filter(all_inventory(this_object()), 
    (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));

  if(!obs[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION))
  {
    if(sizeof(placed) >= MAX_PLACED)
    {
      if(this_player())
         this_player()->add_failed_mess(this_object(),
                                        "$C$"+this_object()->the_short() +
                                        " is too cluttered to place anything "
                                        "else.\n", ({ }));
      return 0;
    }
  }

  if(obs[0]->query_property(PLACEMENT_IMMOVABLE)) {
    this_player()->add_failed_mess(this_object(),
                                   "Try as you might you cannot move $I.\n",
                                   ({ obs[0] }));
    return 0;
  }
  
  /*
   * Wrestle with the args to see if they're not using a verb.  If
   * they're not, reposition the args array so it still works.
   */
  if(member_array(args[1], HANGING_PREPOSITIONS + WALL_PREPOSITIONS
    + CORNER_PREPOSITIONS + ABOUT_PREPOSITIONS) != -1)
  {
    // allow "north wall" or "northern wall"
    args[2] = replace_string(args[2], "ern ", " ");
    
    if((member_array(EXPAND_EXIT(args[2]), ({"north", "south", "east", 
      "west", "northeast", "southeast", "southwest", "northwest",    
      "centre"})) != -1) || sizeof(match_objects_for_existence(args[2], 
      ({ this_object() }) )))
    {
      int i;
      string *new_args;
      
      new_args = ({ });
      new_args += ({ args[0] });
      new_args += ({ "" });
      for(i = 1; i < sizeof(args); i++)
      {
        new_args += ({ args[i] });
      }
      args = new_args;
    }
  }

  allowed_verbs = obs[0]->query_allowed_room_verbs();

  if(allowed_verbs)
  {
    allowed_verbs += ([ "" : "" ]);
    foreach(k, v in allowed_verbs)
    {
      if(k == args[1] || v == args[1])
      {
        allowed = 1;
        break;
      }
    }
  }
  if(!allowed)
  {
    string *verb_keys;
    string extra = "";
    
    // Tell them the verbs they're allowed to use.
    if(allowed_verbs)
    {
      verb_keys = keys(allowed_verbs);
      verb_keys -= ({ "" });
      verb_keys = map(verb_keys, (: ("\"" + $1 + "\"") :));
      extra = "  You may only place $I " + 
        query_multiple_short(verb_keys) + ".";
    }

    if(this_player())
      this_player()->add_failed_mess(this_object(),
      "You can't place $I with that verb." 
      + extra + "\n", ({ obs[0] }));
    return 0;
  }

  /*
   * Needed for compatability with two command syntaxes.
   */
  if(sizeof(args) == 3)
  {
    string *shrapnel;
    shrapnel = explode(args[2], " ");
    args -= ({ args[2] });
    args += shrapnel;
  }

  /*
   * Makes handling messages easier later on.
   */
  if(args[1] != "")
  {
    args[1] = " " + args[1];
  }

  pos = get_pos_int(args[3]);

  // Prevent "on the centre" by turning "on the floor" into "in the centre"
  if(args[3] == "floor" && args[2] == "on")
    args[2] = "in";
  
   
  if(member_array(args[2], ABOUT_PREPOSITIONS) != -1)
  {
    /*
     * Check to see if they're trying to position the object relative
     * to another object.
     */
    if(!pos)
    {
      result = (class obj_match)match_objects_in_environments(args[3], ({ this_object() }));

      if (result->result != OBJ_PARSER_SUCCESS) {
         if(this_player()) {
            add_failed_mess( match_objects_failed_mess( result ));
         }
         return 0;
      }

      things = result->objects;

      pos = things[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
      
      if(pos < -1)
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "$I is placed around another piece of "
          "furniture.\n", ({ things[0]->the_short() }));
        return 0;
      }
      
      if(pos == get_structure_index(obs[0]))
      {
        if(this_player()) {
          if(sizeof(args) >= 4)
            this_player()->add_failed_mess(this_object(),
                   "You can't place $I " + args[2] + " the " + args[3] + ".\n",
                                           ({ obs[0] }));
          else
            this_player()->add_failed_mess(this_object(),
                   "You can't place $I " + args[2] + " itself.\n", ({ obs[0] }));
        }
        return 0;
      }
      
      if(pos > 9)
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "You can't place $I " + args[2] + " " +
          things[0]->the_short() + ".\n", ({ obs[0] }));
        return 0;
      }
      
      if(pos == -1)
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "$I isn't placed.\n", ({ things[0] }));
        return 0;
      }
    }
    /*
     * Okay, change the sign on pos.  This'll mark it as one of the
     * object positioned around the object in pos.
     */
    already_around = filter(all_inventory(this_object()), 
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) == -($(pos)) :));
    if(sizeof(already_around) > query_max_space_around(pos))
    {
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "There isn't enough room to place " + obs[0]->the_short()
        + " there.\n", ({ }));
      return 0;
    }
    pos = -(pos);
  }

  if(pos > 0)
  {
    object *already_there;
    if(member_array(args[1][1..], HANGING_VERBS) != -1)
    {
      /*
       * Make sure they're not trying to 'hang' it in a corner.
       */
      if(is_in_corner(pos))
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "You may not place $I" + args[1] + " in a "
          "corner.\n", ({ obs[0] }));
        return 0;
      }
      pos += 10;
    }
    already_there = filter(all_inventory(this_object()),
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) == $(pos) :));
    if((sizeof(already_there)) && (already_there[0] != obs[0]))
    {
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "$I is already"
        + already_there[0]->query_property(PLACEMENT_CURRENT_ROOM_VERB) + " "
        + already_there[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) + " "
        + get_pos_desc(pos) + ".\n", ({ already_there[0] }));
      return 0;
    }
  }
  
  if(is_wall_hanging(pos))
  {
    if(member_array(args[2], HANGING_PREPOSITIONS) == -1)
    {
      string *preps;
      string extra = "";

      preps = HANGING_PREPOSITIONS;
      preps = map(preps, (: ("\"" + $1 + "\"") :));
      
      extra = "  You may only use " + query_multiple_short(preps) + 
        " as prepositions."; 
        
#ifdef PLAYTESTING

      extra += "  Mail suggestions for more to Gototh.";
      
#endif

      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "You may not place $I"+ args[1] + " \"" + args[2] + "\" "
        + get_pos_desc(pos) + "." + extra + "\n", ({ obs[0] }));
      return 0;
    }
  }
  if(is_beside_wall(pos))
  {  
    if(member_array(args[2], WALL_PREPOSITIONS) == -1)
    {
      string *preps;
      string extra = "";

      preps = WALL_PREPOSITIONS;
      preps = map(preps, (: ("\"" + $1 + "\"") :));
      
      extra = "  You may only use " + query_multiple_short(preps) + 
        " as prepositions.";
        
#ifdef PLAYTESTING

      extra += "  Mail suggestions for more to Gototh.";
      
#endif

      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "You may not place $I"+ args[1] + " \"" + args[2] + "\" "
        + get_pos_desc(pos) + "." + extra + "\n", ({ obs[0] }));
      return 0;
    }
  }
  if(is_in_corner(pos))
  {
    if(member_array(args[2], CORNER_PREPOSITIONS) == -1)
    {
      string *preps;
      string extra = "";    

      preps = CORNER_PREPOSITIONS;
      preps = map(preps, (: ("\"" + $1 + "\"") :));
      
      extra = "  You may only use " + query_multiple_short(preps) + 
        " as a preposition.";

#ifdef PLAYTESTING

      extra += "  Mail suggestions for more to Gototh.";
      
#endif
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "You may not place $I"+ args[1] + " \"" + args[2] + "\" "
        + get_pos_desc(pos) + "." + extra + "\n", ({ obs[0] }));
      return 0;
    }
  }

  if(!pos)
  {
    if(this_player())
       this_player()->add_failed_mess(this_object(),
      "You may not place $I"+ args[1] + " " + args[2] + " the \""
      + args[3] + "\".\n", ({ obs[0] }));
    return 0;
  }

  obs[0]->add_property(PLACEMENT_CURRENT_ROOM_VERB, args[1]);
  obs[0]->add_property(PLACEMENT_CURRENT_ROOM_OTHER, args[2]);
  obs[0]->add_property(PLACEMENT_CURRENT_ROOM_POSITION, pos);

  if(environment(obs[0]) != this_object())
  {
    obs[0]->move(this_object());
  }
  if(pos > 0)
  {
    if(this_player())
      this_player()->add_succeeded_mess(this_object(),
      "$N $V $I so that it is" + args[1] + " " + args[2]
      + " " + get_pos_desc(pos) + ".\n", ({ obs[0] }));
  }
  else
  {
    if(sizeof(things))
    {
      if(this_player())
        this_player()->add_succeeded_mess(this_object(),
        "$N $V $I so that it is" + args[1] + " " + args[2] +
        " " + things[0]->the_short() + ".\n", ({ obs[0] }));
    }
    else
    {
      pos = -(pos);
      if(this_player())
      this_player()->add_succeeded_mess(this_object(),
        "$N $V $I so that it is" + args[1] + " " + args[2] +
        " " + get_pos_desc(pos) + ".\n", ({ obs[0] }));
    }
  }
  event(this_object(), "save", this_object());
  furniture_long = "";
  return 1;  
} /* do_place() */

int get_pos_int(string str)
{
  string dir;
  int pos_int;

  dir = explode(str, " ")[0];
  dir = EXPAND_EXIT(dir);    

  switch(dir)
  {
    case "ceiling" :
    case "floor" :
    case "centre" :
      pos_int = 1;
      break;
    case "north" :
      pos_int = 2;
      break;
    case "south" :
      pos_int = 6;
      break;
    case "east" :
      pos_int = 4;
      break;
    case "west" :
      pos_int = 8;
      break;
    case "northeast" :
      pos_int = 3;
      break;
    case "southeast" :
      pos_int = 5;
      break;
    case "southwest" :
      pos_int = 7;
      break;
    case "northwest" :
      pos_int = 9;
      break;
  }
  return pos_int;
} /* get_pos_int() */

/*
 * The following functions are all geared towards returning
 * the index of where an object sits in relation to the object
 * in index position 'pos' in the structure array.
 */
int find_opposite(int pos, object *structure)
{
  int opp;
  if(pos == 1 || pos == 11)
  {
    return 0;
  }
  if((pos > 5 && pos < 10) || (pos > 11 && pos > 15))
  {
    opp = pos - 4;
  }
  else
  {
    opp = pos + 4;
  }
  return opp;
} /* find_opposite() */

int find_above(int pos, object *structure)
{
  int above;
  if(pos < 10)
  {
    above = pos + 10;
  }
  return above;
} /* find_above() */

int find_below(int pos, object *structure)
{
  int below;
  if(pos > 10)
  {
    below = pos - 10;
  }
  return below;
} /* find_below() */

int find_left(int pos, object *structure)
{
  int left;

  if(pos == 1 || pos == 11)
  {
    return 0;
  }
  left = pos - 1;
  if(left == 1)
  {
    left = 9;
  }
  if(left == 11)
  {
    left = 19;
  }
  return left;
} /* find_left() */

int find_right(int pos, object *structure)
{
  int right;

  if(pos == 1 || pos == 11)
  {
    return 0;
  }
  right = pos + 1;
  if(right == 10)
  {
    right = 2;
  }
  if(right == 20)
  {
    right = 12;
  }
  return right;
} /* find_right() */

string query_furniture_ordinal(object ob)
{
  int index;
  string str_num;
  object *obs;

  str_num = "";

  obs = match_objects_for_existence(ob->query_plural(), ({ this_object() }));

  index = member_array(ob, obs);

  if((index != -1) && (sizeof(obs) != 1))
  {
    // Cheers to Presto for word_ordinal. :)
    str_num = " " + word_ordinal(index + 1);
  }

  if((index != -1) && (sizeof(obs) != 1))
  {
    // Cheers to Presto for word_ordinal. :)
    str_num = " " + word_ordinal(index + 1);
  }
  
  return str_num;
} /* query_furniture_ordinal() */

/*
 * Should produce "squatting against the eastern wall"
 */
string object_position_desc(object thing)
{
  string verb;
  string other;
  string position;
  string str;
  
  verb = thing->query_property(PLACEMENT_CURRENT_ROOM_VERB);
  other = thing->query_property(PLACEMENT_CURRENT_ROOM_OTHER);
  position = get_pos_desc(thing->query_property(PLACEMENT_CURRENT_ROOM_POSITION));

  if(verb == "")
  {
    str = other + " " + position;
  }
  else
  {
    str = verb[1..] + " " + other + " " + position;
  }  
  return str;
} /* object_position_desc() */

/*
 * Returns a description of how two objects are in relation to
 * each other.
 */
string describe_relative_position(int index)
{
  string relative_desc;
  switch(index)
  {
    case OPPOSITE :
      relative_desc = OPPOSITE_DESCS[random(sizeof(OPPOSITE_DESCS))];
      break;
    case ABOVE :
      relative_desc = ABOVE_DESCS[random(sizeof(ABOVE_DESCS))];
      break;
    case BELOW :
      relative_desc = BELOW_DESCS[random(sizeof(BELOW_DESCS))];
      break;
    case RIGHT :
      relative_desc = RIGHT_DESCS[random(sizeof(RIGHT_DESCS))];
      break;
    case LEFT :
      relative_desc = LEFT_DESCS[random(sizeof(LEFT_DESCS))];
      break;
  }
  return relative_desc;
} /* describe_relative_position() */

/*
 * Should produce "squats a stove" or "is a stove"
 */
string object_desc2(object thing)
{
  string verb;
  string other;
  string position;
  string str;
  mapping allowed_verbs;
  
  verb = thing->query_property(PLACEMENT_CURRENT_ROOM_VERB);
  allowed_verbs = thing->query_allowed_room_verbs();
  if (!allowed_verbs) {
     allowed_verbs = ([ ]);
  }
  verb = allowed_verbs[verb[1..]];
  if(!verb || verb == "")
  {
    verb = "is";
  }
  other = thing->query_property(PLACEMENT_CURRENT_ROOM_OTHER);
  position = get_pos_desc(thing->query_property(PLACEMENT_CURRENT_ROOM_POSITION));
  str = verb + " " + thing->a_short();
  return str;
} /* object_desc2() */

/*
 * Should produce "squatting against the eastern wall is a stove"
 * or "a stove is squatting against the eastern wall".
 */
string object_desc(object thing)
{
  string str;
  /*
   * There may be more ingenious ways of phrasing this.
   */
  switch(random(2))
  {
    case 0 :
      str = object_position_desc(thing) + " is " + thing->a_short();
      break;
    default :
      str = object_position_desc(thing) + " is " + thing->a_short();
      break;
  }  
  return str;
} /* object_desc() */

/**
 * @ignore yes
 *
 * This function returns an array of the indexes which are
 * opposite, above, below, right, and left of the object
 * with the index 'index' in the array 'structure'.  If
 * no object exists in that position a 0 will be inserted.
 */
int *find_relative_indexes(int index, mixed structure)
{
  int *relatives;
  relatives = allocate(5);
  relatives[OPPOSITE] = find_opposite(index, structure);
  relatives[ABOVE] = find_above(index, structure);
  relatives[BELOW] = find_below(index, structure);
  relatives[RIGHT] = find_right(index, structure);
  relatives[LEFT] = find_left(index, structure);
  return relatives;
} /* find_relative_indexes() */

/**
 * @ignore yes
 *
 * This function generates strings like... "Lying in the centre of 
 * the room is a Klatchian rug near which is an armchair.", "Lying 
 * in the centre of the room is a Klatchian rug around which are 
 * three armchairs.", and "Lying in the centre of the room is a 
 * Klatchian rug around which are two armchairs, a sofa, and a 
 * foot stool."
 */
string desc_around_with(object ob, object *around)
{
  // don't list items already described.
  around -= have_described;
  
  if(sizeof(around) == 1)
  {
    return "$C$" + object_desc(ob) + " " +
      around[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) +
      " which is " + query_multiple_furniture_short(around) + ".  ";
  }
  return "$C$" + object_desc(ob) + " around which are " + 
    query_multiple_furniture_short(around) + ".  ";
} /* desc_around_with() */

/**
 * @ignore yes
 *
 * This function generates strings like... "Near the Klatchian rug 
 * is an armchair.", "Around the Klatchian rug are three armchairs."
 * and "Around the Klatchian rug are two armchairs, a sofa, and a 
 * foot stool."
 */
string desc_around_without(object *around, object *structure,
  int location)
{
  if(location < 0)
  {
    location = -(location);
  }
  if(!structure[location])
  {
    if(sizeof(around) == 1)
    {
      return "$C$" + around[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) 
        + " " + get_pos_desc(location) + " is" +
        query_another(around[0]) + " " + around[0]->query_short() +
        ".  ";
    }
    else
    {
      return "Around " + get_pos_desc(location) + 
        " are " + query_multiple_furniture_short(around) + ".  ";
    }
  }
  else
  {

    if(sizeof(around) == 1)
    {
      return "$C$" + around[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) +
        " the" + query_furniture_ordinal(structure[location]) + " " +
        structure[location]->query_short() + " is" +
        query_another(around[0]) + " " +
        around[0]->query_short() + ".  ";
    }
    else
    {
      return "Around " + structure[location]->the_short() + 
        " are " + query_multiple_furniture_short(around) + ".  ";
    }
  }
} /* desc_around_without() */

/**
 * @ignore yes
 *
 * This function removes spaces off the end of a string.
 */
string trim_trailing_spaces(string str)
{
  int i;
  if(!sizeof(str))
  {
    return str;
  }
  for(i = (sizeof(str)) - 1; str[i] == ' '; i--);
  return str[0..i];
} /* trim_trailing_spaces() */

/**
 * @ignore yes
 *
 * This function chooses an object from an array of indexes.  It
 * it doesn't find one it returns zero.
 */
int choose_relative(int *relatives, object *structure) {
  int num, found;
  int *rands;
  
  rands = ({ 0, 1, 2, 3, 4 });
  while(sizeof(rands)) {
    num = rands[random(sizeof(rands))];
    if(objectp(structure[relatives[num]])) {
      if(member_array(structure[relatives[num]], needs_described) != -1) {
        found = 1;
        break;
      }
    }
    rands -= ({ num });
  }
  if(found)
    return num;
  return -1;
} /* choose_relative() */

/**
 * @ignore yes
 *
 * This function returns the objects placed around the specified
 * object.
 */
object *get_around(object ob) {
  object *around;
  around = filter(all_inventory(this_object()), 
    (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) &&
       $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) == 
       -($(ob->query_property(PLACEMENT_CURRENT_ROOM_POSITION))) :));
  return around;
} /* get_around() */

void set_orientation(int num)
{
  orientation = num;
} /* set_orientation() */

int query_orientation()
{
  return orientation;
} /* set_orientation() */

string wall_or_corner(int pos)
{
   return query_wall_name_pos(pos);
} /* wall_or_corner() */

/**
 * @ignore yes
 *
 * This function returns a string describing objects in relation
 * to each other and the objects placed around them.
 */
string desc_obs_relatively(int *indexes, object *structure)
{
  int i;
  int *relatives;
  string desc;
  object *around;
  int rel_num;
  object rel_ob;

  desc = "";
  while(sizeof(indexes)) {
    i = indexes[random(sizeof(indexes))];

    // Remove object object's index from the indexes array.
    indexes -= ({ i });

    // Make absolutely sure the object hasn't been described before.
    if(member_array(structure[i], needs_described) == -1) {
      continue;
    }

    // Remove the object from the needs described array.
    needs_described -= ({ structure[i] });
    have_described += ({ structure[i] });

    // Find out what we've got relative to us.
    relatives = find_relative_indexes(i, structure);
    
    // Pick one of the things we've got relative to us.
    rel_num = choose_relative(relatives, structure);
    if(rel_num == -1)
      rel_ob = 0;
    else
      rel_ob = structure[relatives[rel_num]];
    
    // Find out what we've got around us.
    around = get_around(structure[i]);

    // Check if we have an object relative to this object.
    if(!rel_ob) {
      // Check if we've got anything placed around this object.
      if(sizeof(around)) {
        // Generate a string describing the location of this object
        // and what has been placed around it.
        desc += desc_around_with(structure[i], around);
        
        // Remove the around objects from the needs described array.
        needs_described -= around;
        have_described += around;
        continue;
      } else {
        if(clutter_string(structure[i]) == "") {
          // Nothing to work with so just describe the object.
          desc += "$C$" + object_desc(structure[i]) + ".  ";
        } else {
          desc += "$C$" + object_desc(structure[i]) + 
            " upon which" + clutter_string(structure[i]) + ".  ";
        }
        continue;
      }
    }

    // Remove the relative object from the needs described array.
    needs_described -= ({ rel_ob });
    have_described += ({ rel_ob });

    // Remove the relative object's index from the indexes array.
    indexes -= ({ relatives[rel_num] });
    
    // Build the sentence described the two objects relations to
    // each other.
    desc += "$C$" + object_desc(structure[i]) + " " + 
      describe_relative_position(rel_num) + " " + 
      object_desc2(rel_ob) + ".  ";

    // Check for objects on the first object.
    
    if(clutter_string(structure[i]) != "") {
      desc += "On " + structure[i]->the_short() + 
        clutter_string(structure[i]);
      if(clutter_string(rel_ob) != "") {
        // It was here that Gototh realised he was totally pissed,
        // but carried on regardless.
        desc += " while on " + rel_ob->the_short() + 
          clutter_string(rel_ob) + ".  ";
      } else {
        desc += ".  ";
      }
    } else if(clutter_string(rel_ob) != "") {
      desc += "On " + rel_ob->the_short() + 
        clutter_string(rel_ob) + ".  ";
    }

    // Check for objects placed around the first object.
    if(sizeof(around)) {
      // Describe objects around the first object.
      desc += desc_around_without(around, structure, i);
      needs_described -= around;
      have_described += around;
      continue;
    }
    
    // Find out what objects are around the second object.
    around = get_around(rel_ob);

    // Check for objects placed around the second object.
    if(sizeof(around)) {
      // Describe objects around the second object.
      desc += desc_around_without(around, structure, relatives[rel_num]);
      needs_described -= around;
      have_described += around;
      continue;
    }
  }
  return desc;
} /* desc_objects_relatively() */

int room_order(object *obs1, object *obs2, object *structure)
{
  int pos1, pos2;
  object ob1, ob2;
  int order1, order2;

  pos1 = -(obs1[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION));
  pos2 = -(obs2[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION));

  if (pos1 < 0) {
     ob1 = 0;
  } else {
     ob1 = structure[pos1];
  }
  if (pos2 < 0) {
     ob2 = 0;
  } else {
     ob2 = structure[pos2];
  }

  if(!ob1 || !ob2)
  {
    return 0;
  }

  if(ob1->query_plural() != ob2->query_plural())
  {
    return 0;
  }

  order1 = member_array(ob1, match_objects_for_existence(ob1->query_plural(), 
    ({ this_object() })));
  order2 = member_array(ob2, match_objects_for_existence(ob2->query_plural(), 
    ({ this_object() })));

  if(order1 > order2)
  {
    return 1;
  }
  return -1;
} /* room_order() */

/**
 * @ignore yes
 *
 * This function describes objects which have been placed around
 * room locations or objects which are no longer there.
 */
string describe_remaining_objects(object *structure)
{
  int pos;
  string desc;
  object *group;
  mixed *orphans;
  desc = "";

  if(sizeof(needs_described))
  {
    // Group them into arrays depending on where they're positioned.
    orphans = unique_array(needs_described, 
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));

    if(sizeof(orphans))
    {
      orphans = sort_array(orphans, (: room_order($1, $2, $(structure)) :));

      foreach(group in orphans)
      {
        // Find out where they're positioned.
        pos = group[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
        
        // Described where they're positioned.
        desc += desc_around_without(group, structure, pos);
        
        // Remove them from the need described array.
        needs_described -= group;
        have_described += group;
      }
    }
  }
  return desc;
} /* describe_remaining_objects() */

string get_group_verb(object *obs)
{
  mixed *verbs;
  
  verbs = map(obs, (: $1->query_property(PLACEMENT_CURRENT_ROOM_VERB) :));
  verbs = unique_array(verbs, (: $1 :));
  
  if(sizeof(verbs) == 1)
  {
    return verbs[0][0];
  }
  return "";  
} /* query_same_verb() */

string get_group_other(object *obs)
{
  mixed *others;
  
  others = map(obs, (: $1->query_property(PLACEMENT_CURRENT_ROOM_OTHER) :));
  others = unique_array(others, (: $1 :));
  
  if(sizeof(others) == 1)
  {
    return others[0][0];
  }
  // Can't think of a good way to do this.
  return others[random(sizeof(others))][0];
} /* query_same_other() */

string describe_plural_objects(int *indexes, object *structure)
{
  int i, j;
  int flag;
  int rel_num;
  int used_pos;
  mixed *things;
  string desc = "";
  string *strs;
  
  strs = ({ });
  things = ({ });
  // Check for multiple objects with the same plural.
  for(i = 0; i < sizeof(indexes); i++) {
    things += ({ structure[indexes[i]] });
  }
  things = unique_array(things, (: $1->query_plural() :));
  things = filter(things, (: sizeof($1) > 1 :) );

  if(sizeof(things) > 0) {
    // Deal with these and remove them from the list.
    for(i = 0; i < sizeof(things); i++) {

      needs_described -= things[i];
      have_described += things[i];

      // Find out if there's four of them.
      if(sizeof(things[i]) == 4) {
        int they_are = 1;
        int *rel_nums;
        int num;

        rel_nums = map(things[i],
          (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));
#ifdef DEBUG
        debug_printf("rel_nums: %O", rel_nums);
#endif        
        // Find out if they're in each corner.
        foreach(num in rel_nums)
          if(is_in_corner(num))
            they_are = 0;

        if(they_are) {        
          desc += "$C$" + things[i][0]->query_plural() + " are" +
            get_group_verb(things[i]) + " " + 
            get_group_other(things[i]) + " each " + 
            wall_or_corner(rel_nums[0]) + ".  ";
#ifdef DEBUG
          debug_printf("4 corner: %s\n", desc);
#endif
          continue;
        }

        they_are = 1;

        // Find out if they're at each wall.
        foreach(num in rel_nums)
        {
          if(is_beside_wall(num))
          {
            they_are = 0;
          }
        }
        if(they_are)
        {
          desc += "$C$" + things[i][0]->query_plural() + " are" +
            get_group_verb(things[i]) + " " + 
            get_group_other(things[i]) + " each " + 
            wall_or_corner(3) + ".  ";
          continue;
        }
      }

      if(sizeof(things[i]) == 3)
      {
        int *rel_nums;

        rel_nums = map(things[i], 
          (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));
        rel_nums = sort_array(rel_nums, 1);

        if(rel_nums[2] == 9)
        {
          rel_nums -= ({ 9 });
          rel_nums = ({ 1 }) + rel_nums;
        }
        
        if(is_beside_wall(rel_nums[1]) && 
          rel_nums[0] == rel_nums[1] - 1 &&
          rel_nums[2] == rel_nums[1] + 1)
        {
          desc += "$C$" + query_multiple_short(things[i]) +
            " are" + get_group_verb(things[i]) + " beside each other " +
            structure[rel_nums[1]]->query_property(PLACEMENT_CURRENT_ROOM_OTHER)
            + " the " + get_pos_desc(rel_nums[1]) + ".  ";
          continue;
        }
      }

      // Find out if there's two of them.
      if(sizeof(things[i]) == 2)
      {
        // Find out if they're positioned relative to each other.
        rel_num = member_array(get_structure_index(things[i][1]), 
          find_relative_indexes(get_structure_index(things[i][0]), 
          structure));
        if(rel_num != -1)
        {
          desc += "$C$" + query_multiple_short(things[i]);
          switch(rel_num)
          {
            case OPPOSITE :
              desc += " face each other across the room.  ";
              continue;
              break;
            case RIGHT :
            case LEFT :
              desc += " are" + get_group_verb(things[i]) + 
                " beside each other ";
              break;
            default :
              break;
          }
          if(!orientation)
          {
            // Check if it's odd.
            if(get_structure_index(things[i][0]) & 1)
            {
              used_pos = 
                things[i][1]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
            else
            {
              used_pos = 
                things[i][0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
          }
          else
          {
            // Check if it's odd.
            if(get_structure_index(things[i][0]) & 1)
            {
              used_pos = 
                things[i][0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
            else
            {
              used_pos = 
                things[i][1]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
          }
          desc += 
            structure[used_pos]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) +
            " the " + get_pos_desc(used_pos) + ".  ";
          continue;
        }
      }

      desc += "$C$" + query_num(sizeof(things[i]), 4) + " "
        + things[i][0]->query_plural() + " are positioned "
        "around the room.  ";
#ifdef DEBUG
      debug_printf("2 items: %s\n", desc);
#endif

      // If there's more than four say no more about them.
      if(sizeof(things[i]) > 4)
      {
        flag = 1;
      }
      else
      {
        desc += "They are ";
      }

      for(j = 0; j < sizeof(things[i]); j++)
      {
        if(!flag)
        {
          strs += ({ object_position_desc(things[i][j]) });
        }
        indexes -= 
          ({ things[i][j]->query_property(PLACEMENT_CURRENT_ROOM_POSITION) });
      }
      
      if(!flag)
      {
        desc += query_multiple_short(strs)+".  ";
#ifdef DEBUG
        debug_printf("position: %s [%s]\n",
                     query_multiple_short(strs), desc);
#endif
        strs = ({ });
      }
      
    }
  }
  return desc;
} /* describe_plural_objects() */

string furniture_long()
{
  string desc, d1, d2, d3;
  object *structure;
  int i, *indexes;

  if(furniture_long != "") {
    return furniture_long;
  }
  
  structure = build_structure();
  indexes = ({ });

  // Build an array of indexes where objects are stored.
  for(i = 0; i < sizeof(structure); i++)
  {
    if(objectp(structure[i]))
    {
      indexes += ({ i });
    }
  }

  needs_described = filter(all_inventory(this_object()), 
    (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));

  have_described = ({ });

  d1 = describe_plural_objects(indexes, structure);
  d2 = desc_obs_relatively(indexes, structure);
  d3 = describe_remaining_objects(structure);
#ifdef DEBUG
  debug_printf("1: %s\n2:%s\n3:%s\n",d1, d2, d3);
#endif
  desc = d1 + d2 + d3;

  if(desc == "")
    desc = "$C$" + this_object()->the_short() + "$C$" + " is completely empty.";
  furniture_long = trim_trailing_spaces(desc);
  return furniture_long;
} /* furniture_long() */

/**
 * @ignore yes
 *
 * This function returns a string describing the location of
 * the index in the structure array.
 */
string get_pos_desc(int pos_int)
{
  string str;
  switch(pos_int)
  {
    case 1 :
      str = "the centre of " + this_object()->the_short();
      break;
    case 2 :
    case 12 :
      str = "the north " + wall_or_corner(pos_int);
      break;
    case 3 :
    case 13 :
      str = "the northeast " + wall_or_corner(pos_int);
      break;
    case 4 :
    case 14 :
      str = "the east " + wall_or_corner(pos_int);
      break;
    case 5 :
    case 15 :
      str = "the southeast " + wall_or_corner(pos_int);
      break;
    case 6 :
    case 16 :
      str = "the south " + wall_or_corner(pos_int);
      break;
    case 7 :
    case 17 :
      str = "the southwest " + wall_or_corner(pos_int);
      break;
    case 8 :
    case 18 :
      str = "the west " + wall_or_corner(pos_int);
      break;
    case 9 :
    case 19 :
      str = "the northwest " + wall_or_corner(pos_int);
      break;
    case 11 :
      str = "the centre of the ceiling";
      break;
  }
  return str;
} /* get_pos_desc() */

/**
 * @ignore yes
 *
 * This builds a structure based on what things are in the room so
 * that it can be determined where the objects are in relation to
 * one another.
 *
 *   19---12---13
 *    |\        \
 *    | 18  11   14
 *    |  \        \
 *    |  17---16---15
 *    |
 *    9----2----3
 *     \         \
 *      8    1    4
 *       \         \
 *        7----6----5
 */
object *build_structure()
{
  int i;
  object *positions, *obs, *dummies;

  positions = allocate(20);
  obs = all_inventory(this_object());
  for(i = 1; i < sizeof(positions); i++)
  {
    dummies = filter(obs, 
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) == $(i) :));
    if(sizeof(dummies))
    {
      positions[i] = dummies[0];
    }
  }
  return positions;
} /* build_structure() */

/**
 * @ignore yes
 *
 * This function returns the position of the object in the
 * structure array.
 */
int get_structure_index(object ob)
{
  return member_array(ob, build_structure());
} /* get_structure_index() */

/**
 * @ignore yes
 *
 * This function is used from describing the individual walls,
 * corners, floor and ceiling for use in add_item()s.
 */
string desc_surface(string dir)
{
  int i;
  int pos;
  int *indexes;
  int current_pos;
  string desc;
  object *structure;
  object *around;
  
  structure = build_structure();
  needs_described = ({ });
  have_described = ({ });
  
  if(dir == "ceiling")
  {
    pos = 11;
  }
  else
  {
    pos = get_pos_int(dir);
  }
  desc = "";
  indexes = ({ });
  
  for(i = 1; i < sizeof(structure); i++)
  {
    if(!objectp(structure[i]))
    {
      continue;
    }
    current_pos = structure[i]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
    if(current_pos != pos)
    {
      if(pos != 1 && pos != 11)
      {
        if((current_pos != pos + 10) && (current_pos != pos - 10))
        {
          structure[i] = 0;
        }
        else
        {
          needs_described += ({ structure[i] });
          indexes += ({ i });
        }
      }
    }
    else
    {
      needs_described += ({ structure[i] });
      around = get_around(structure[i]);
      if(around)
      {
        needs_described += around;
      }
      indexes += ({ i });
    }
  }

  desc += desc_obs_relatively(indexes, structure);

  return desc;
} /* desc_surface() */

void displace_object(object ob)
{
  // Make sure it is in the room first.
  if (ob->query_property(PLACEMENT_CURRENT_ROOM_POSITION)) {
    ob->remove_property(PLACEMENT_CURRENT_ROOM_VERB);
    ob->remove_property(PLACEMENT_CURRENT_ROOM_OTHER);
    ob->remove_property(PLACEMENT_CURRENT_ROOM_POSITION);
    // Make sure the long is fixed up.
    furniture_long = "";
  }
} /* displace_object() */

int do_displace(object *obs)
{
  if(this_player() &&
     !this_object()->test_occupier(this_player()->query_name()) &&
     !this_player()->query_creator()) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n");
    return 0;
  }

  if(sizeof(obs) > 1)
  {
    this_player()->add_succeeded_mess(this_object(),
      "You may only displace one thing at a time.\n", ({ }));
    return 1;
  }

  if(!obs[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION))
  {
    this_player()->add_failed_mess(this_object(),
      "$C$" + obs[0]->the_short() + " is not placed.\n", ({ }));
    return 0;
  }

  if(obs[0]->query_property(PLACEMENT_IMMOVABLE)) {
    this_player()->add_failed_mess(this_object(),
                                   "Try as you might you cannot move $I.\n",
                                   ({ obs[0] }));
    return 0;
  }
  
  displace_object(obs[0]);
  this_player()->add_succeeded_mess(this_object(),
    "$N drag$s " + obs[0]->a_short() + " out of position.\n", ({ }));
  furniture_long = "";
  return 1;
} /* do_displace() */

/**
 * @ignore yes
 *
 * This removes the placement properties from an object when it is
 * removed from the room.
 */
void event_exit(object ob, string, object) 
{
  displace_object(ob);
} /* event_exit() */

int test_remove(object thing, int flag, mixed dest) {
  if(thing->query_property(PLACEMENT_IMMOVABLE))
    return 0;

  // Let stuff that's kind of placed (eg. curtains) be notified when they
  // are removed.
  if(thing->query_property(PLACEMENT_CURRENT_ROOM_HIDDEN))
    thing->removed();
  return 1;
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/placement.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/club_control_room.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/club_control_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629375   Available: 13576729
Inodes: Total: 5242880    Free: 4960136
68041 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/club_control_room.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629375   Available: 13576729
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/* -*- LPC -*- */
/**
 * This room allows people to create clubs and do fluffy club stuff if
 * they need to.
 * @author Pinkfish
 * @started Sun Oct  4 02:24:46 EDT 1998
 */
#include <clubs.h>
#include <money.h>
#include <move_failures.h>
#include <player_handler.h>

inherit "/std/basic/club_listing";
inherit "/std/room/inherit/club_discuss";

private int _percentage_cut;
private int _room_type;
private string _region;

protected int do_create(string name);
protected int do_create_family(string name);
protected int do_replace(string name);
protected int do_vote(string name, string position, string club);
protected int do_nominate(string name, string position, string club);
protected int do_balance(string name);
protected int do_deposit(string mon, string name, string account, string reason);
protected int do_change(string name, string type);
protected int do_change_option(string name, string type);
protected int do_disband(string name);
protected int do_insignia(string number, int num);
protected int do_recruiter_add(string name, string recruit);
protected int do_recruiter_remove(string name, string recruit);
protected int do_financials(string name, string account);
protected int do_describe(string name);
protected int do_club_list_member(string name);
protected int do_withdrawl(string money, string club, string account, string reason);
protected int do_transfer(string money, string club, string from_account,
                          string to_account, string reason);
protected int do_force_election(string name);
protected void finish_description(string describe, string name);
protected int do_announcement(string name);
private int check_member_func(string club, string person, string mem);

// External defintions.
mixed query_property(string name);
void add_help_file(string name);

void create() {
   _percentage_cut = 5;
   _room_type = CLUB_ROOM_CLUB_OR_FAMILY;
} /* create() */

private int club_commands_allowed() {
   return _room_type != CLUB_ROOM_FAMILY_ONLY;
} /* club_commands_allowed() */

private int family_commands_allowed() {
   return _room_type != CLUB_ROOM_CLUB_ONLY;
} /* club_commands_allowed() */

/** @ignore yes */
void init() {
   string bit;

   if (club_commands_allowed()) {
      add_help_file("club_control_room");
      bit = "club name";
      add_command("create", "club called <string'club name'>",
                  (: do_create($4[0]) :));
      add_command("list", "clubs",
                  (: club_list(this_player()->query_name(), 0, 0) :) );
      add_command("list", "clubs [with member] <string'member name'>",
                  (: do_club_list_member($4[0]) :));
      add_command("list", "club <string'club name'>",
                  (: club_info($4[0], 1, this_player()->query_name()) :) );
      add_command("vote",
                  "<word'person'> for <string:small'position'> in <string'club name'>",
                  (: do_vote($4[0], $4[1], $4[2]) :));
      add_command("nominate",
                  "<word'person'> for <string:small'position'> in <string'club name'>",
                  (: do_nominate($4[0], $4[1], $4[2]) :));
      add_command("disband", "<string'club name'>", (: do_disband($4[0]) :));
      add_command("change", "<string'club name'> to {elected}",
                   (: do_change($4[0], "elected") :) );
      add_command("change", "<string'club name'> option {secret|open}",
                      (: do_change_option($4[0], $4[1]) :) );
      add_command("replace", "<number> insignia for <string'club name'>",
                      (: do_insignia($4[1], $4[0]) :));
      add_command("replace", "insignia for <string'club name'>",
                      (: do_insignia($4[0], 1) :));
      add_command("recruiter", "add <string'member'> for <string'club'>",
                      (: do_recruiter_add($4[1], $4[0]) :));
      add_command("recruiter", "remove <string'member'> for <string'club'>",
                      (: do_recruiter_remove($4[1], $4[0]) :));
      add_command("financials", "<string'club'>",
                      (: do_financials($4[0], CLUB_DEFAULT_ACCOUNT_NAME) :));
      add_command("financials", "<string'club'> account <string'account name'>",
                      (: do_financials($4[0], $4[1]) :));
      add_command("description", "of club <string'club name'>",
                   (: do_describe($4[0]) :));
      add_command("announce", "for club <string'club name'>",
                  (: do_announcement($4[0]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> for <string:small'reason'>",
                  (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> for <string:quoted'reason'>",
                  (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:small'reason'>",
                  (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:quoted'reason'>",
                  (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :));
      add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:small'reason'>",
                  (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :));
      add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:quoted'reason'>",
                  (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :));
      add_command("election", "force in <string'club'>",
                  (: do_force_election($4[0]) :));
      club_discuss::init();
   }

   if (family_commands_allowed()) {
      add_help_file("family_control_room");
      if (bit) {
         bit += "|family name";
      } else {
         bit = "family name";
      }
      add_command("create", "family called <string'family name'>",
                  (: do_create_family($4[0]) :));
      add_command("list", "families",
                  (: club_list(this_player()->query_name(), 1, 0) :) );
      add_command("list", "family <string'family name'>",
                  (: family_info($4[0], this_player()->query_name()) :) );
   }
   add_command("description", "of <string'" + bit + "'>",
                (: do_describe($4[0]) :));
   add_command("balance", "[of] <string'" + bit  +"'>",
               (: do_balance($4[0]) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'>",
               (: do_deposit($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, 0) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> for <string:small'reason'>",
               (: do_deposit($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> account <string'account name'>",
               (: do_deposit($4[0], $4[1], $4[2], 0) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> account <string'account name'> for <string:small'reason'>",
               (: do_deposit($4[0], $4[1], $4[2], $4[3]) :));
} /* init() */

int is_valid_club_name(string name) {
   int i;

   if (strlen(name) > CLUB_MAX_NAME_LEN) {
      return 0;
   }

   for (i = 0; i < strlen(name); i++) {
      if (!((name[i] >= 'a' && name[i] <= 'z') ||
            (name[i] >= 'A' && name[i] <= 'Z') ||
            name[i] == '\'' ||
            name[i] == ' ' ||
            name[i] == '_')) {
          return 0;
       }
   }
   return 1;
} /* is_valid_club_name() */

/**
 * This method sets the type of the room.  This controls if the room is to 
 * be used for clubs, families or both.
 * @param type the type of the club
 * @see query_club_control_type()
 * @example
 * // Make the room only handle clubs.
 * set_club_control_type(CLUB_ROOM_CLUB_ONLY);
 */
void set_club_control_type(int room_type) {
   _room_type = room_type;
} /* set_club_control_type() */

/**
 * This method queries the type of the room.  This controls if the room is to 
 * be used for clubs, families or both.
 * @return the control type of the room
 * @see set_club_control_type()
 */
int query_club_control_type() {
   return _room_type;
} /* set_club_control_type() */

/**
 * This method sets the region for the club control room.
 * @param region the region for the clubs created here
 */
void set_club_region(string region) {
   _region = region;
} /* set_club_region() */

/**
 * This method returns the region for the club control room.
 * @return the region the clubs are created in
 */
string query_club_region() {
   return _region;
}

/**
 * This method is called to try and create a club of the specified name.
 * All clubs when they first start are personal clubs.  Once they have
 * a certain number of members, they can convert to being an elected
 * type of club if they wish.
 * @param name the name of the club to create
 * @return 1 on success, 0 on failure
 */
protected int do_create(string name) {
   string place;

   /* First check to see if the club already exists. */
   if (CLUB_HANDLER->is_club(name)) {
      add_failed_mess("Cannot create '" + name + "' as the name already "
                      "exists.\n");
      return 0;
   }

   if (!is_valid_club_name(name)) {
      add_failed_mess("The club name '" + name + "' has invalid characters in "
                      "it.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   /* Check to make sure they have enough money. */
   if (this_player()->query_value_in(place) < CLUB_STARTUP_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
                      " to start a club.\n");
      return 0;
   }
   write("It will cost you " + 
         MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
         " to create a club.  Double check the capitalization of " +
         name + ", you cannot change it after it is created.  "
         "Do you wish to continue? ");
   input_to("confirm_create", 0, name);
   return 1;
} /* do_create() */

/**
 * This method will confirm the creation of a club.
 * @param str the yes or no string
 * @param name the name of the club to create
 */
protected void confirm_create(string str, string name) {
   object badge;
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   str = lower_case(str);
   if (strlen(str) < 1 ||
       (str[0] != 'n' && str[0] != 'y' && str[0] != 'q')) {
      write("Please answer yes or no.\nDo you wish to continue creating "
            "the club " + name + " for " +
            MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
            "? ");
      input_to("confirm_create", 0, name);
      return ;
   }

   if (str[0] == 'n' || str[0] == 'q') {
      write("Aborted.\n");
      return ;
   }

   /* Ok, confirmed... */
   if (this_player()->query_value_in(place) < CLUB_STARTUP_COST) {
      write("Your money appears to have evaporated.  You need " +
                      MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
                      " to start a club.\nAborting club creation.\n");
      return 0;
   }

   /* Create the club. */
   if (CLUB_HANDLER->create_club(name,
                                 this_player()->query_name(),
                                 CLUB_PERSONAL,
                                 query_club_region())) {
      /* Make them pay! */
      this_player()->pay_money(MONEY_HAND->create_money_array(CLUB_STARTUP_COST,
                                                           place), place);
      write("Created the club called '" + name + "'.\n");
      /* Give them a badge... */
      badge = clone_object(CLUB_BADGE);
      badge->set_club(name);
      if (badge->move(this_player()) == MOVE_OK) {
         if (!this_player()->wear_armour(badge)) {
            write("You notice a badge turn up and wear itself, this is your "
                  "membership badge.\n");
         } else {
            write("You notice a badge turn up and attempt to wear itself, "
                  "this is your membership badge.\n");
         }
      } else {
         badge->move(environment(this_player()));
         badge->set_worn_by(this_player());
         write("You notice a badge turn up and wear itself, this is your "
               "membership badge.\n");
      }
      event(users(), "inform", this_player()->query_cap_name() + 
                     " created the club " + name, "club");
   }
} /* confirm_create() */

/**
 * This method is called to check the validity of a family name.
 * @param name the name of the family.
 * @return 1 if valid, 0 if invalid.
 */
int is_valid_family_name(string name) {
  
  if (PLAYER_HANDLER->test_user(lower_case(name))) {
    add_failed_mess("Cannot use the family name '" + name + "' since "
        "a player is already using it.\n");
    return 0;
  }
  
  if(!PLAYER_HANDLER->test_valid(name)) {
    add_failed_mess("The family name '" + name + "' is invalid.\n");
    return 0;
  }

  if (!is_valid_club_name(name)) {
    if (this_player()->query_creator()) {
      add_failed_mess("invalid.\n");
    }
    add_failed_mess("The family name '" + name + "' has invalid characters "
                    "in it.\n");
    return 0;
  }
  
  if (strlen(name) > MAX_FAMILY_NAME_LEN) {
    if (this_player()->query_creator()) {
      add_failed_mess("too long!\n");
    }
    add_failed_mess("The maximum length of a family name is " +
                    MAX_FAMILY_NAME_LEN + ".\n");
    return 0;
  }

  return 1;
}

/**
 * This method is called to try and create a family of the specified name.
 * @param name the name of the family to create
 * @return 1 on success, 0 on failure
 */
protected int do_create_family(string name) {
   string place;
   
   /* First check to see if the club already exists. */
   if (CLUB_HANDLER->is_club(name)) {
      if (this_player()->query_creator()) {
         write("exist\n");
      }
      add_failed_mess("Cannot create '" + name + "' as the name already "
                      "exists.\n");
      return 0;
   }

   if(!is_valid_family_name(name))
     return 0;
   
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   /* Check to make sure they have enough money. */
   if (this_player()->query_value_in(place) < FAMILY_STARTUP_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(FAMILY_STARTUP_COST,
                                                     place) +
                      " to start a family.\n");
      return 0;
   }
   write("It will cost you " + 
         MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
         " to create a family.  Do you wish to continue? ");
   input_to("confirm_create_family", 0, name);
   return 1;
} /* do_create_family() */

/**
 * This method will confirm the creation of a family.
 * @param str the yes or no string
 * @param name the name of the family to create
 */
protected void confirm_create_family(string str, string name) {
   string place;

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   str = lower_case(str);
   if (strlen(str) < 1 ||
       (str[0] != 'n' && str[0] != 'y' && str[0] != 'q')) {
      write("Please answer yes or no.\nDo you wish to continue creating "
            "the family " + name + " for " +
            MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
            "? ");
      input_to("confirm_create_family", 0, name);
      return ;
   }

   if (str[0] == 'n' || str[0] == 'q') {
      write("Aborted.\n");
      return ;
   }

   /* Ok, confirmed... */
   if (this_player()->query_value_in(place) < FAMILY_STARTUP_COST) {
      write("Your money appears to have evaporated.  You need " +
            MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
            " to start a family.\nAborting family creation.\n");
      return 0;
   }

   /* Create the family. */
   if (CLUB_HANDLER->create_club(name,
                                 this_player()->query_name(),
                                 CLUB_FAMILY,
                                 query_club_region())) {
      if (this_player()->query_family_name()) {
         CLUB_HANDLER->move_family_member(this_player()->query_family_name(),
                                          this_player()->query_name(),
                                          name);
      } else {
         CLUB_HANDLER->add_member(name, this_player()->query_name());
      }
      /* Make them pay! */
      this_player()->pay_money(MONEY_HAND->create_money_array(FAMILY_STARTUP_COST,
                                                              place), place);
      write("Created the family called '" + name + "'.\n");
      this_player()->set_family_name(name);
      event(users(), "inform", this_player()->query_cap_name() + 
                     " created the family " + name, "club");
   }
} /* confirm_create_family() */

/**
 * This method nominates a person into a position in a club.
 * @param person the person to nominate
 * @param position the position to nominate them too
 * @param club_name the name of the club
 * @return 1 on success, 0 on failure
 * @see /obj/handlers/club_handler.c
 * @see do_vote()
 */
protected int do_nominate(string person, string position, string club_name) {
   string our_name;

   our_name = this_player()->query_name();
   if (!CLUB_HANDLER->is_member_of(club_name, our_name)) {
      add_failed_mess("You can only nominate people in a club your a "
                      "member of.\n");
      return 0;
   }

   person = lower_case(person);     

   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      person = this_player()->expand_nickname(person);
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      add_failed_mess("You can only nominate people in the club.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_election_in_progress(club_name)) {
      add_failed_mess("This club is not having an election right now.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_voting_in_progress(club_name)) {
      add_failed_mess("This club is not accepting nominations right now, "
                      "it is past the nomination phase.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club not in the nomination phase of "
                      "voting.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_valid_position(club_name, position)) {
      add_failed_mess("You must nominate them in a valid position.\n"
                      "Valid positions are " +
                      sort_and_capitalise(CLUB_HANDLER->query_valid_positions(club_name)) +
                      ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club is not accepting nominations for positions "
                      "right now.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_creator_club(club_name) &&
       PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You cannot nominate a creator to a position in a "
                      "non-creator club.\n");
      return 0;
   }

   if (CLUB_HANDLER->has_nominated_person(club_name,
                                           position,
                                           person,
                                           our_name)) {
      add_failed_mess("You have already nominated " + capitalize(person) +
                      " for the position " + capitalize(position) + " in '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
      return 0;
   }

   /* Everything seems in order, try and nominate someone. */
   if (CLUB_HANDLER->nominate_person(club_name,
                                     position,
                                     person,
                                     our_name)) {
      add_succeeded_mess( ({
                      "$N nominated " + capitalize(person) + " to " +
            capitalize(position) + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n",
                      "$N nominated " + capitalize(person) + " to " +
            capitalize(position) + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n" }) );
      if (find_player(lower_case(person)) &&
          environment(find_player(lower_case(person))) != this_object()) {
         tell_object(find_player(lower_case(person)),
                     "You have a weird feeling that " +
                     this_player()->the_short() +
                     " just nominated you for " + capitalize(position) +
                     ".\n");
      }
      return 1;
   }
   add_failed_mess("Unable to nominate " + person + " to " +
                   position + " in '" + 
                   CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   return 0;
} /* do_nominate() */

/**
 * This method attempts to vote for someone in a club.
 * @param person the person to vote for
 * @param position the position to vote for them in
 * @param club_name the name of the club to vote for them in
 * @return 1 on success, 0 on failure
 * @see do_nominate()
 * @see /obj/handlers/club_handler.c
 */
protected int do_vote(string person, string position, string club_name) {
   string our_name;
   string *stuff;

   our_name = this_player()->query_name();
   if (!CLUB_HANDLER->is_member_of(club_name, our_name)) {
      add_failed_mess("You can only vote for people in a club you're a "
                      "member of.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      person = this_player()->expand_nickname(person);
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      add_failed_mess("You can only vote for people in the club.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_election_in_progress(club_name)) {
      add_failed_mess("This club is not having an election at the moment.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club is accepting nominations right now, "
                      "it is not ready for votes.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_voting_in_progress(club_name)) {
      add_failed_mess("This club is not accepting votes right now.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_valid_position(club_name, position)) {
      add_failed_mess("You must vote for them in a valid position.\n"
                      "Valid positions are " +
                      sort_and_capitalise(CLUB_HANDLER->query_valid_positions(club_name)) +
                      ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_nominated_for(club_name, position, person)) {
      stuff =  CLUB_HANDLER->query_nominated_for(club_name, position);
      if (sizeof(stuff)) {
         add_failed_mess("You must vote for a person that has been "
                         "nominated for the position.\n" +
                         sort_and_capitalise(stuff) +
                         " have been nominated for " + position + " in " +
                         club_name + ".\n");
      } else {
         add_failed_mess("No one has been nominated for the position "
                         + position + " in " + club_name + ".\n");
      }
      return 0;
   }

   if (CLUB_HANDLER->has_person_voted(club_name, position, our_name)) {
      add_failed_mess("You can only vote for each position once.\n");
      return 0;
   }

   /* Everything seems in order, try and nominate someone. */
   if (CLUB_HANDLER->vote_for_person(club_name,
                                     position,
                                     person,
                                     our_name)) {
      add_succeeded_mess(({
                      "$N vote for $C$" + person + " to " + position + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n",
                      "$N voted for " + position + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n" }));
      return 1;
   }
   add_failed_mess("Unable vote for " + person + " to " +
                   position + " in " + club_name +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
   return 0;
} /* do_vote() */

/**
 * This method prints the balance of this club.
 * @param name the name of the club to get the balance of
 * @return 1 on success, 0 on failure
 * @see do_deposit()
 */
protected int do_balance(string name) {
   string place;
   int amount;
   string bit;
   string *accounts;
   string account;
   string account_name;
   string ret;

   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must get a balance of an existing " + bit + ".\n");
      return 0;
   }

   if (CLUB_HANDLER->is_family(name)) {
      bit = "family";
   } else {
      bit = "club";
   }

   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to get the balance.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   accounts = CLUB_HANDLER->query_account_names(name);
   ret = "";
   foreach (account in accounts) {
      if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
         account_name = "main " + bit + " account";
      } else {
         account_name = "special " + bit + " account " + account;
      }
      amount = CLUB_HANDLER->query_balance(name, account);
      if (amount < 0) {
         ret += "The balance of the " + account_name + " in '" +
                CLUB_HANDLER->query_club_name(name) +
                "' is in remission by " +
                MONEY_HAND->money_value_string(-amount, place) + ".\n";
      } else {
         ret += "The balance of the " + account_name + " in '" +
                CLUB_HANDLER->query_club_name(name) + "' is " +
                MONEY_HAND->money_value_string(amount, place) + ".\n";
      }
   }
   ret += "The next pay period ends at " +
          ctime(CLUB_HANDLER->query_time_fees_due(name)) +
          ", which will cost " +
          MONEY_HAND->money_value_string(CLUB_HANDLER->query_club_cost_per_period(name), place) + " from the main " + bit + " account.\n",
   add_succeeded_mess(({ ret,
                      "$N checks the balance of '" +
                      CLUB_HANDLER->query_club_name(name) + "'.\n" }));
   return 1;
} /* do_balance() */

/**
 * This method allows to you deposit money into the club.
 * @param obs the money objects to deposit
 * @param name the name of the club to deposit them to
 * @param reason the reason of the deposit
 * @return 1 on success, 0 on failure
 * @see do_balance()
 * @see query_percentage_cut()
 * @see set_percentage_cut()
 */
protected int do_deposit(string mon, string name, string account, string reason) {
   int amt;
   int after;
   int total;
   string place;
   mixed money;
   string bit;
   string account_name;

   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must deposit into an existing " + bit + ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to deposit into the clubs coffers.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_creator_club(name) &&
       this_player()->query_creator()) {
      add_failed_mess("Creators can only deposit to creator " + bit + "s.\n");
      return 0;
   }

   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main " + bit + " account";
   } else {
      account_name = "special " + bit + " account " + account;
   }

   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }

   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   money = MONEY_HAND->parse_money(mon, this_player(), place);
   if (intp(money)) {
      switch (money) {
         case NO_MATCH :
            add_failed_mess("You do not have '" + mon + "'.\n");
            return 0;
         case NO_MONEY :
            add_failed_mess("You can only deposit money.\n");
            return 0;
         default :
            add_failed_mess("You can only deposit legal tender.\n");
            return 0;
      }
   }

   amt = money->query_value_in(place);
   if (place != "default") {
      amt += money->query_value_in("default");
   }
   after = amt - ((amt * _percentage_cut) / 100);
   CLUB_HANDLER->add_money(name,
                           after,
                           CLUB_TRANSACTION_DEPOSIT,
                           this_player()->query_name(),
                           account,
                           reason);
   total = CLUB_HANDLER->query_balance(name, account);
   money->move("/room/rubbish");
   add_succeeded_mess(({ "$N deposit " +
                         MONEY_HAND->money_value_string(amt, place) +
                         ", which after expenses is " +
                         MONEY_HAND->money_value_string(after, place) +
                         ", to the " +
                         (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                         " '" +
                         CLUB_HANDLER->query_club_name(name) +
                         "' for a total of " +
                         MONEY_HAND->money_value_string(total, place) + ".\n",
                         "$N deposits some money to the " +
                         (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                         " '" +
                         CLUB_HANDLER->query_club_name(name) +
                         "'.\n" }));

   return 1;
} /* do_deposit() */

/**
 * This method is used when someone wishes to withdraw some money from the
 * club account.
 * @param money the amount of money to withdraw
 * @param club the club to withdraw the money from
 * @param account the account to withdraw money from
 * @param reason the reason to withdraw money from the account
 * @return 1 if suecceded, 0 if failed.
 */
protected int do_withdrawl(string money,
                           string name,
                           string account,
                           string reason) {
   string place;
   int value;
   string bit;
   object obj;
   string account_name;
   string* stuff;
   string ret;

   if (club_commands_allowed()) {
      bit = "club";
   }

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must withdraw from an existing " + bit + ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to withdraw money from the club.\n");
      return 0;
   }

   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main " + bit + " account";
   } else {
      account_name = "special " + bit + " account " + account;
   }

   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }

   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }

    if(!CLUB_HANDLER->is_elected_club(name)) {
        add_failed_mess("You may only withdraw funds from an elected "
            "club.\n");   
        return 0;
    }

   if (!CLUB_HANDLER->is_allowed_to_modify_account(name,
                                                   account,
                                                   this_player()->query_name())) {
      stuff = CLUB_HANDLER->query_account_allowed_positions(name, account);
      ret = "Only the positions " + query_multiple_short(stuff);
      stuff = CLUB_HANDLER->query_account_allowed_people(name, account);
      if (sizeof(stuff)) {
         ret += " and the people " + query_multiple_short(stuff);
      }
      
      add_failed_mess(ret + " can withdraw from this account.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = MONEY_HAND->value_from_string(money, place);
   if (value > CLUB_HANDLER->query_balance(name, account)) {
      add_failed_mess("The " + account_name +
                      " does not have that much money!\n");
      return 0;
   }
   obj = MONEY_HAND->make_new_amount(value, place);
   if (!obj) {
      add_failed_mess("Unable to create the money object.\n");
      return 0;
   }
 
   if (CLUB_HANDLER->remove_money(name,
                              value,
                              CLUB_TRANSACTION_WITHDRAWL,
                              this_player()->query_name(),
                              account,
                              reason)) {
      obj->move(this_player());
      add_succeeded_mess(({ "$N withdraw " +
                            MONEY_HAND->money_value_string(value, place) +
                            " from the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n",
                            "$N withdraws some money from the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n" }));

      return 1;   
   } else {
      obj->dest_me();
      add_failed_mess("Unable to remove the money from the account.\n");
      return 0;
   }
} /* do_withdrawl() */

/**
 * This method is used when someone wishes to withdraw some money from the
 * club account.
 * @param money the amount of money to withdraw
 * @param club the club to withdraw the money from
 * @param from_account the account to withdraw money from
 * @param to_account the account to deposit the money to
 * @param reason the reason to withdraw money from the account
 * @return 1 if suecceded, 0 if failed.
 */
protected int do_transfer(string money,
                           string name,
                           string from_account,
                           string to_account,
                           string reason) {
   string place;
   int value;
   string bit;
   object obj;
   string from_account_name;
   string to_account_name;
   string* stuff;
   string ret;

   if (club_commands_allowed()) {
      bit = "club";
   }

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must transfer money in an existing " + bit + ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to transfer money.\n");
      return 0;
   }

   if (from_account == CLUB_DEFAULT_ACCOUNT_NAME) {
      from_account_name = "main " + bit + " account";
   } else {
      from_account_name = "special " + bit + " account " + from_account;
   }

   if (to_account == CLUB_DEFAULT_ACCOUNT_NAME) {
      to_account_name = "main " + bit + " account";
   } else {
      to_account_name = "special " + bit + " account " + to_account;
   }

   if (!CLUB_HANDLER->is_account_of(name, from_account)) {
      add_failed_mess("The account " + from_account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_account_of(name, to_account)) {
      add_failed_mess("The account " + to_account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }

   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_allowed_to_modify_account(name,
                                                   from_account,
                                                   this_player()->query_name())) {
      stuff = CLUB_HANDLER->query_account_allowed_positions(name, from_account);
      ret = "Only the positions " + query_multiple_short(stuff);
      stuff = CLUB_HANDLER->query_account_allowed_people(name, from_account);
      if (sizeof(stuff)) {
         ret += " and the people " + query_multiple_short(stuff);
      }
      
      add_failed_mess(ret + " can withdraw from this account.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   value = MONEY_HAND->value_from_string(money, place);
   if (value > CLUB_HANDLER->query_balance(name, from_account)) {
      add_failed_mess("The " + from_account_name +
                      " does not have that much money!\n");
      return 0;
   }
 
   if (CLUB_HANDLER->remove_money(name,
                              value,
                              CLUB_TRANSACTION_TRANSFER,
                              this_player()->query_name(),
                              from_account,
                              "to " + to_account_name + ": " + reason)) {
      CLUB_HANDLER->add_money(name,
                              value,
                              CLUB_TRANSACTION_TRANSFER,
                              this_player()->query_name(),
                              to_account,
                              "from " + from_account_name + ": " + reason);
      add_succeeded_mess(({ "$N transfer " +
                            MONEY_HAND->money_value_string(value, place) +
                            " between the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "' accounts " + from_account_name + " and " +
                            to_account_name + ".\n",
                            "$N transfers some money between accounts in the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n" }));

      return 1;   
   } else {
      obj->dest_me();
      add_failed_mess("Unable to remove the money from the account.\n");
      return 0;
   }
} /* do_withdrawl() */

private void do_change_inform(string club_name) {
   object *people;
   object person;

   people = map(CLUB_HANDLER->query_members(club_name), (: find_player :));
   people -= ({ 0 });
   foreach (person in people) {
      all_inventory(person)->event_club_change(this_player(), club_name);
   }
} /* do_change_inform() */

/**
 * This allows the club to change into a new type.
 * @param name the name of the club to change
 * @param type the type to change the club into
 * @see do_create()
 * @see do_disband()
 */
protected int do_change(string name, string type) {
   int ret;

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must change a club that exists.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a founder type before you can change "
                      "it to another type.\n");
      return 0;
   }

   switch (type) {
      case "elected" :
         if (CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
            if (sizeof(CLUB_HANDLER->query_members(name)) < 
                CLUB_MINIMUM_ELECTED_MEMBERS) {
               add_failed_mess("You must have at least " +
                               query_num(CLUB_MINIMUM_ELECTED_MEMBERS) +
                               " members to change to an elected club.\n");
            } else if (CLUB_HANDLER->change_club_type(name, CLUB_ELECTED)) {
               ret = 1;
               add_succeeded_mess("$N change$s the type of '" +
                                  CLUB_HANDLER->query_club_name(name) +
                                  "' to elected.\n");
               // Inform all the people who were in the club's badges...
               call_out((: do_change_inform :), 0, name);
            } else {
               add_failed_mess("You are unable to change the club type.\n");
            }
         } else {
            add_failed_mess("You must be the founder to change the "
                            "club type.\n");
         }
         break;
   }
   return ret;
} /* do_change() */

/**
 * This allows the club to change its options.
 * @param name the name of the club to change
 * @param option the option to change on the club
 * @see do_create()
 * @see do_disband()
 * @see do_change()
 */
protected int do_change_option(string name, string option) {
   int ret;

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must change a club that exists.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You must change options through discussion items.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to change the "
                      "options of the club.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a personal club before the options "
                      "can be changed in this way.\n");
      return 0;
   }

   switch (option) {
      case "secret" :
         if (CLUB_HANDLER->set_club_secret(name)) {
            add_succeeded_mess("$N wipe$s the records on the club '" +
                            CLUB_HANDLER->query_club_name(name) + "'.\n");
            ret = 1;
         } else {
            add_failed_mess("Unable to change the club to a secret type.\n");
         }
         break;
      case "open" :
         if (CLUB_HANDLER->reset_club_secret(name)) {
            add_succeeded_mess("$N replace$s the records of the club '" +
                            CLUB_HANDLER->query_club_name(name) + "'.\n");
            ret = 1;
         } else {
            add_failed_mess("Unable to change the club to an open type.\n");
         }
         break;
   }
   return ret;
} /* do_change() */

/**
 * This method will forcibly disband the club.  This can only be done
 * for founder type clubs.
 * @param name the name of the club to disband
 * @see do_change()
 * @see do_create()
 * @see disband_confirm()
 */
protected int do_disband(string name) {
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must disband a club that exists.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You cannot disband an elected club.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a personal club type for you to "
                      "be able to disband it.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to disband it.\n");
      return 0;
   }

   write("Are you sure you wish to disband the club '" +
         CLUB_HANDLER->query_club_name(name) +
         "'? ");
   input_to("disband_confirm", 0, name);
   add_succeeded_mess("");
   return 1;
} /* do_disband() */

/**
 * This method is called to confirm the disbanding of the club.
 * @param str the response the user type
 * @param name the name of the club to disband
 * @see do_disband()
 * @see do_create()
 * @see create_confirm()
 */
protected void disband_confirm(string str, string name) {
   string club_name;

   str = lower_case(str);
   if (str == "" ||
       str[0] == 'n' ||
       str[0] == 'q') {
      write("Canceling disbanding of the club '" + name + "'.\n");
      return ;
   }
   if (str[0] == 'y') {
      if (!CLUB_HANDLER->is_club(name)) {
         write("The club appears to have been disbanded already.\n");
         return 0;
      }
   
      if (CLUB_HANDLER->is_elected_club(name)) {
         write("The club has changed to an elected club and you cannot "
               "disband it.\n");
         return 0;
      }
   
      if (!CLUB_HANDLER->is_personal_club(name)) {
         write("The club must be a personal club for you to be able to "
                         "disband it.\n");
         return 0;
      }

      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         write("You must be the founder of the club to disband it.\n");
         return 0;
      }

      club_name = CLUB_HANDLER->query_club_name(name);
      CLUB_HANDLER->disband_club(name);
      write("You disband the club '" + club_name + "'.\n");
      say(this_player()->the_short() + " disbands the club '" +
                      club_name + "'.\n");
   } else {
      write("You must answer yes or no.\n");
      write("Are you sure you wish to disband the club '" +
            CLUB_HANDLER->query_club_name(name) +
            "'? ");
      input_to("disband_confirm", 0, name);
   }
} /* disband_confirm() */

/**
 * This method will create a bunch of insignia for the club.
 * @param number the number of insignia to create
 * @param name the name of the club to create insignia for
 */
protected int do_insignia(string name, int num) {
   int i;
   object *insignias;
   object ob;
   string place;

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must create the insignia for a club that exists.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_family(name)) {
      add_failed_mess("You cannot create insignia for a family.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the club to create the "
                      "insignia for it.\n");
      return 0;
   }

   if (num > 1 &&
       !CLUB_HANDLER->is_recruiter_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a recruiter to ask for more than one "
                      "insignia.\n");
      return 0;
   }

   if (num > 20) {
      add_failed_mess("You cannot ask for more than 20 insignia.\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }
   /* Check to make sure they have enough money. */
   if (this_player()->query_value_in(place) < (num * CLUB_COST_INSIGNIA)) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(CLUB_COST_INSIGNIA * num, place) +
                      " to pay for " +
                      query_num(num) + " insignia.\n");
      return 0;
   }

   insignias = ({ });
   for (i = 0; i < num; i++) {
      ob = clone_object(CLUB_HANDLER->query_insignia_path(name));
      ob->set_cond(ob->query_max_cond());
      ob->set_club(name);
      if (ob->move(this_player()) == MOVE_OK) {
         insignias += ({ ob });
         this_player()->pay_money(MONEY_HAND->create_money_array(CLUB_COST_INSIGNIA,
                                                           place), place);
      } else {
         ob->dest_me();
      }
   }

   if (!sizeof(insignias)) {
      add_failed_mess("Unable to move the insignia into your inventory, "
                      "insignia not created.\n");
      return 0;
   } else {
      add_succeeded_mess("$N create$s " + query_num(sizeof(insignias)) +
                         " club '" + CLUB_HANDLER->query_club_name(name) +
                         "' insignia.\n");
      return 1;
   }
} /* do_insignia() */

/**
 * This method attempts to add a recruiter to the club.
 * @param name the name of the club
 * @param recruit the person to add as a recruiter
 */
protected int do_recruiter_remove(string name, 
                                  string recruit) {
   string *all_names;
   string one_name;

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must remove a recruiter to a club that exists.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_personal_club(name)) {
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         add_failed_mess("Only the founder can remove recruiters.\n");
         return 0;
      }
   } else if (CLUB_HANDLER->is_elected_club(name)) {
      if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(name, this_player()->query_name())) {
         add_failed_mess("Only the president and vice president can remove " 
                         "recruiters.\n");
         return 0;
      }
   } else {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }

   all_names = map(explode(recruit, ","),
                   (: this_player()->expand_nickname($1) :));
   if (recruit == "all") {
      all_names = CLUB_HANDLER->query_recruiters(name);
   }

   foreach (one_name in all_names) {
      if (!CLUB_HANDLER->is_recruiter_of(name, one_name)) {
         add_failed_mess("The person(s) you are removeing must be a recruiter "
                         " of the club.\n");
         all_names -= ({ name });
         continue;
      }
      CLUB_HANDLER->remove_recruiter(name, one_name);
      one_name = lower_case(one_name);
      if (find_player(one_name) &&
          environment(find_player(one_name)) != this_object()) {
         tell_object(find_player(one_name), "You feel suddenly feel like "
                     "you are unable to "
                     "recruit people into the club '" +
                     CLUB_HANDLER->query_club_name(name) +
                     "'.\n");
      }
   }

   if (!sizeof(all_names)) {
      return 0;
   }

   add_succeeded_mess("$N remove$s " + query_multiple_short(all_names) + 
                      " as " +
                      (sizeof(all_names) > 1 ? "recruiters " : "a recruiter ") +
                      "to the club '" + CLUB_HANDLER->query_club_name(name) +
                      "'.\n");
   return 1;
} /* do_recruiter_remove() */

/**
 * This method attempts to add a recruiter to the club.
 * @param name the name of the club
 * @param recruit the person to add as a recruiter
 */
protected int do_recruiter_add(string name, string recruit) {
   string *all_names;
   string one_name;

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must add a recruiter to a club that exists.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_personal_club(name)) {
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         add_failed_mess("Only the founder can add recruiters.\n");
         return 0;
      }
   } else if (CLUB_HANDLER->is_elected_club(name)) {
      if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(name, this_player()->query_name())) {
         add_failed_mess("Only the president and vice president can add "
                         "recruiters.\n");
         return 0;
      }
   } else {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }

   all_names = map(explode(recruit, ","),
                   (: this_player()->expand_nickname($1) :));
   if (recruit == "all") {
      all_names = CLUB_HANDLER->query_members(name);
   }
   
   foreach (one_name in all_names) {
      if (!CLUB_HANDLER->is_member_of(name, one_name)) {
         add_failed_mess("The person you are making a recruiter must be a "
                         "member of the club.\n");
         all_names -= ({ one_name });
         continue;
      }

      if (CLUB_HANDLER->is_recruiter_of(name, one_name)) {
         add_failed_mess("The person you are making a recruiter is already a "
                         "recruiter of the club.\n");
         all_names -= ({ one_name });
         continue;
      }


      CLUB_HANDLER->add_recruiter(name, one_name);
      one_name = lower_case(one_name);
      if (find_player(one_name) &&
          environment(find_player(one_name)) != this_object()) {
         tell_object(find_player(one_name), "You feel suddenly empowered to "
                     "recruit people into the club '" +
                     CLUB_HANDLER->query_club_name(name) +
                     "'.\n");
      }
   }

   if (!sizeof(all_names)) {
      return 0;
   }

   add_succeeded_mess("$N add$s " + query_multiple_short(all_names) + 
                      (sizeof(all_names) == 1? " as a recruiter " : " as recruiters ") +
                      "to the club '" + CLUB_HANDLER->query_club_name(name) +
                      "'.\n");
   return 1;
} /* do_recruiter_add() */

/**
 * This method prints out financial reports for the club.
 * @param club_name the name of the club to get financials on
 * @return 1 on success, 0 on failure
 * @see do_deposit()
 * @see do_balance()
 */
protected int do_financials(string name, string account) {
   string place;
   class club_transaction* transactions;
   int i;
   int deposit_total;
   int withdrawl_total;
   string ret;
   string account_name;

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("The club '" + name + "' does not exist.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of a club to see its "
                      "financials.\n");
      return 0;
   }

   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main club account";
   } else {
      account_name = "special club account " + account;
   }

   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the "
                      "club '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "The club '" + CLUB_HANDLER->query_club_name(name) +
         "' " + account_name + " has a current balance of " +
         MONEY_HAND->money_value_string(CLUB_HANDLER->query_balance(name, account), place) +
         " and the next pay period ends at " +
         ctime(CLUB_HANDLER->query_time_fees_due(name)) +
         ", which will cost " +
         MONEY_HAND->money_value_string(CLUB_HANDLER->query_club_cost_per_period(name), place) +
         ".\n";

   // Let all players know about the transaction history of the club.
   transactions =  CLUB_HANDLER->query_transactions(name, account);
   for (i = 0; i < sizeof(transactions); i++) {
      if (transactions[i]->amount > 0) {
         ret += i + ": DEPOSIT " +
               MONEY_HAND->money_value_string(transactions[i]->amount, place) +
               " from " + transactions[i]->who +
               " at " + ctime(transactions[i]->date) + " (" +
               CLUB_HANDLER->query_transaction_type_name(transactions[i]->transaction_type) +
               ")\n";
         if (transactions[i]->information) {
            ret += "   - " + transactions[i]->information + "\n";
         }
         deposit_total += transactions[i]->amount;
      } else {
         ret += i + ": WITHDRAWL " +
               MONEY_HAND->money_value_string(-transactions[i]->amount, place) +
               " from " + transactions[i]->who +
               " at " + ctime(transactions[i]->date) + " (" +
               CLUB_HANDLER->query_transaction_type_name(transactions[i]->transaction_type) +
               ")\n";
         if (transactions[i]->information) {
            ret += "   - " + transactions[i]->information + "\n";
         }
         withdrawl_total += -transactions[i]->amount;
      }
   }

   ret += "\nTotal withdrawals: " + 
         MONEY_HAND->money_value_string(withdrawl_total, place) + "\n";
   ret += "Total deposits  : " + 
         MONEY_HAND->money_value_string(deposit_total, place) + "\n";

   write("$P$Club Financials$P$" + ret);
   return 1;
} /* do_financials() */

/**
 * This method sets the club description.
 * @param name the name of the club to describe
 * @see finish_description()
 */
protected int do_describe(string name) {
   string bit;

   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }

   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("The " + bit + " '" + name +
                      "' must exist for you to describe it.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You cannot change the description of an elected club, "
                      "it must be done as a discussion item.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of a personal club to "
                      "change the description.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_family(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("Only the founder of the family can set the "
                      "description of the family.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_family(name)) {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }

   write("What do you wish to change the description of '" +
         CLUB_HANDLER->query_club_name(name) + "' to?\n");
   this_player()->do_edit("", (: finish_description($1, $(name)) :));
   add_succeeded_mess("");
   return 1;
} /* do_describe() */

/**
 * This is the method that is called when the club description has been
 * finished edited.  It will set the description on the club handler.
 * @param describe the new description
 * @param name the name of the club to describe
 * @see do_describe()
 */
protected void finish_description(string describe, string name) {
   if (!describe ||
       describe == "") {
      write("Aborting setting the description.\n");
      return ;
   }

   CLUB_HANDLER->set_club_description(name, describe);
   if (CLUB_HANDLER->is_family(name)) {
      write("Set the description of the family '" +
             CLUB_HANDLER->query_club_name(name) + "' to:\n" +
             CLUB_HANDLER->query_club_description(name) + "\n");
   } else {
      write("Set the description of the club '" +
             CLUB_HANDLER->query_club_name(name) + "' to:\n" +
             CLUB_HANDLER->query_club_description(name) + "\n");
   }
} /* finish_description() */

/**
 * This method sets the percentage cut the room takes for deposits to the
 * club account.
 * @param cut the nice new percentage cut
 * @see query_percentage_cut()
 * @see do_deposit()
 */
void set_percentage_cut(int value) {
   _percentage_cut = value;
} /* set_percentage_cut() */

/**
 * This method returns the percentage cut the room takes for deposits
 * to the club account.
 * @return the current percentage cut
 * @see set_percentage_cut()
 * @see do_deposit()
 */
int query_percentage_cut() {
   return _percentage_cut;
} /* query_percentage_cut() */

/**
 * This method creates the warning message for the club, saying how much
 * it costs per year and how everything works.  This should probably
 * be used in a sign or something in the main room.
 * @return the warning message
 */
string query_club_warning_message() {
   string place;
   string ret;

   place = query_property("place");
   if (!place) {
      place = "default";
   }

   ret = "";

   if (club_commands_allowed()) {
      ret += "Clubs have a few rules and regulations associated with "
         "them.  They cost " +
         MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) + 
         " to start.  Every quarter of a " + mud_name() + " year the club "
         "costs " + 
         MONEY_HAND->money_value_string(CLUB_COST_PER_YEAR, place) +
         " plus " +
         MONEY_HAND->
            money_value_string(CLUB_COST_PER_MEMBER_PER_YEAR, place) +
         " per member.  Each insignia will cost " +
         MONEY_HAND->money_value_string(CLUB_COST_INSIGNIA, place) +
         " to be made, and the cost an insignia is taken from the "
         "person requesting the insignia, not the club.\n\n"
         "If the club goes into remission for 2 pay periods then the "
         "club will be disbanded.  If the club is not touched for 8 "
         "real weeks then the club will be disbanded.  A club is "
         "considered touched if a member is added or removed, if an "
         "election is held or nominations are added or if money is " 
         "deposited into the account.\n\n" 
         "Clubs default to being founder controlled clubs, meaning "
         "that the founder has all the control of the club.  Once a "
         "club gets over " + 
         CLUB_MINIMUM_ELECTED_MEMBERS +
         " members it can change to an elected club.  In this mode "
         "the committee members of the club are elected to their "
         "positions.  Once a club gets over " + 
         CLUB_MAXIMUM_ELECTED_MEMBERS + " it must become an elected "
         "club.  A new election is held every " + mud_name() + " year for all "
         "the positions.  If the founder of a founder base club leaves "
         "the mud or is idle is for 8 real weeks then the club will be "
         "disbanded.\n\n" 
         "In this room, clubs can be created and disbanded.  Money can "
         "be deposited into a club, or withdrawn from a club.  It is "
         "possible to see the balance of a given club, and also to see "
         "various lists of clubs.  It is also possible to nominate "
         "someone for position, vote for someone and to force an "  
         "election in a particular club.  Furthermore, announcements "
         "and discussion items for clubs can be added here.  Club "
         "insignias can be replaced, and types and options of a club "
         "can be changed.  Finding out more about a club's financials "
         "is also possible, as well as changing the description of a "
         "club.  Last, but not least, a recruiter can be added to a "
         "club.\n";
   }
   if (family_commands_allowed()) {
      ret += "Families have a few rules and regulations associated "
        "with them.  They cost " + 
       MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
       " to start and cost " +
       MONEY_HAND->money_value_string(FAMILY_COST_PER_YEAR, place) +
       " in upkeep every quarter of a " + mud_name() + " year, plus " +
       MONEY_HAND->
         money_value_string(FAMILY_COST_PER_MEMBER_PER_YEAR, place) +
       " per member.\n\n"
       "You can create relationships between people, and also create "
       "families.  It is possible to list families, or details about "
       "any particular " 
       "family.  On a family of yours, you can set the description, " 
       "see its bank balance and deposit more money into its account.  "
       "If your family balance is less than the required amount when "
       "it is time for your family to pay for its fees, the family "
       "will be disbanded.\n\n" 
       "You cannot choose a family name from the books for "
       "your families.\n";
   }
   return ret;
} /* query_club_warning_message() */

/**
 * This method does a listing of all the clubs that a certain person is
 * in.
 * @param name the person whose name to check
 * @return 1 on success, 0 on failure
 * @see /std/basic/club_listing.c
 */
protected int do_club_list_member(string name) {
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess(name + " does not play " + mud_name() + ".\n");
      return 0;
   }

   if (club_list(this_player()->query_name(),
                 0,
                 (: check_member_func($1, $2, $(name)) :))) {
      return 1;
   }
   add_failed_mess("Could not find any clubs with " + name +
                   " as a member.\n");
   return 0;
} /* do_club_list_member() */

/** @ignore yes */
private void finish_announcement(string str, string name) {
   if (!str) {
      write("Aborting.\n");
      return ;
   }

   if (CLUB_HANDLER->set_announcement(name,
                                      str)) {
      write("Added the announcement to the club " +
            CLUB_HANDLER->query_club_name(name) +
            ".\n");
   } else {
      write("Unable to add the announcement to the club " +
            CLUB_HANDLER->query_club_name(name) +
            " for some reason.\n");
   }
} /* finish_announcement() */

/**
 * This method sets an announcement for the club.
 * @return 1 on success, 0 on failure
 */
protected int do_announcement(string name) {
   if (!CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("The club must be an elected club for an announcement "
                      "to be set.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
       !CLUB_HANDLER->is_secretary_of(name, this_player()->query_name())) {
      add_failed_mess("Only the president and secretary can set an "
                      "announcement.\n");
      return 0;
   }

   write("What announcement do you wish to set?\n");
   this_player()->do_edit(0,
                          (: finish_announcement :),
                          0,
                          0,
                          name);
   return 1;
} /* do_announcement() */

private int check_member_func(string club,
                              string person,
                              string mem) {
   if (!CLUB_HANDLER->is_member_of(club, mem)) {
      return 0;
   }

   if (CLUB_HANDLER->query_club_secret(club) &&
       !CLUB_HANDLER->is_member_of(club, person)) {
      return 0;
   }

   return 1;
} /* check_member_func() */

protected int do_force_election(string name) {
   if (!CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("The club must be elected for you to force an "
                      "election in it.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the president of the club to force an "
                      "election.\n");
      return 0;
   }

   if (CLUB_HANDLER->is_election_in_progress(name) > time()) {
      add_failed_mess("There is already an election in progress, you cannot "
                      "start another one!\n");
      return 0;
   }

   if (CLUB_HANDLER->query_minimum_next_election(name) > time()) {
      add_failed_mess("It is too soon to force an election, that cannot "
                      "be done until " +
                       ctime(CLUB_HANDLER->query_minimum_next_election(name)) +
                       ".\n");
      return 0;
   }

   if (!CLUB_HANDLER->start_election(name)) {
      add_failed_mess("Could not start the election for some reason.\n");
      return 0;
   }

   add_succeeded_mess("$N start$s an election in " +
                      CLUB_HANDLER->query_club_name(name) + ".\n");
   return 1;
} /* do_force_election() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/club_control_room.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/guild.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/guild.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629359   Available: 13576713
Inodes: Total: 5242880    Free: 4960136
26256 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/guild.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629359   Available: 13576713
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
#include <money.h>
#include <skills.h>
#include <tune.h>
#include <config.h>

private int cost_div;
private int cost_mult;
private string our_guild;
private string start_pos;
private mapping spells;
private mapping commands;
private object teaching_person;

void check_spells_commands(string *sk, int lvl);
int do_cost_primaries();
int do_cost_all(int brief);
int do_cost_to(string skill, int level);
int do_cost_by(string skill, int level);
int do_cost(string skill);

int do_advance(string skill);
int do_advance_to(string skill, int num);
int do_advance_by(string skill, int num);

void create()
{
   cost_div = COST_DIV;
   cost_mult = 100;
   spells = ([ ]);
   commands = ([ ]);
   this_object()->add_help_file("guild");
} /* create() */


void init()
{
   this_player()->add_command("advance", this_object(),
                              "<string>", (: do_advance($4[0]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> to <number>",
                              (: do_advance_to($4[0], $4[1]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> by <number>",
                              (: do_advance_by($4[0], $4[1]) :));
   this_player()->add_command("join", this_object(), "");
   this_player()->add_command("info", this_object(), "");
   this_player()->add_command("cost", this_object(),
                              "primaries", (: do_cost_primaries() :));
   this_player()->add_command("cost", this_object(),
                              "all", (: do_cost_all(0) :));
   this_player()->add_command("cost", this_object(),
                              "all brief", (: do_cost_all(1) :));
   this_player()->add_command("cost", this_object(),
                              "<string>", (: do_cost($4[0]) :));
   this_player()->add_command("cost", this_object(),
                              "<string> to <number>",
                              (: do_cost_to($4[0], $4[1]) :));
   this_player()->add_command("cost", this_object(), "<string> by <number>",
                              (: do_cost_by($4[0], $4[1]) :));
   if ((string) this_player()->query_guild_ob() == our_guild) {
      if (stringp(start_pos) && !clonep(this_object())) {
         this_player()->add_start(file_name(this_object()), start_pos);
      }
   }
} /* init() */


varargs void set_guild(string word1, string word2)
{
   our_guild = word1;
   start_pos = word2;
} /* set_guild() */


void set_cost_div(int number)
{
   cost_div = number;
/*
 * Points of interest:
 *    cost_div -> zero      gives cost_mult = 10
 *    cost_div = COST_DIV   gives cost_mult = 100
 *    cost_div -> infinity  gives cost_mult = 1000
 */
   if (!cost_div)               /* stands in for infinity */
      cost_mult = 1000;
   else
      cost_mult = 10 + (990 * cost_div) / (10 * COST_DIV + cost_div);
} /* set_cost_div() */


int query_skill_cost(string skill, int offset)
{
   int i;
   int total;
   string *next;

   next = (string *) SKILL_OB->query_immediate_children(skill);
   if (!sizeof(next)) {
      if (!this_player()->query_guild_ob())
         total = DEFAULT_COST;
      else
         total = (int) our_guild->query_skill_cost(skill);
      total *= (STD_COST * cost_mult) / 500;
      total *= ((int) this_player()->query_skill(skill) + offset) /
         LEVEL_DIV + 1;
      // this is the new, increased skill cost.
      total = to_int(total * exp((this_player()->query_skill(skill) +
                                  offset) / 150.0));

      return total;
   }
   for (i = 0; i < sizeof(next); i++)
      total += query_skill_cost(next[i], offset);
   return total;

} /* query_skill_cost() */


int do_advance_internal(string skill, int to, int by)
{
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   int lvl;
   int max_lvl;
   int tmp;
   int total_xp;
   int total_cost;
   int tmp_cost;
   int p_val;
   int i, j;
   int round_value;

   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You cannot advance here!  Go to your own guild.\n");
      return 0;
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("The skill " + skill + " does not exist.\n");
      return 0;
   }

   bits = SKILL_OB->query_inactive_skills();
   for(j=0; j<sizeof(bits); j++)
     if(strsrch(skill, bits[j]) != -1)
       return add_failed_mess("The skill " + skill + " is inactive at "
                              "present and cannot be taught.\n");

   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by <= 0) {
      if (by == 0) {
         add_failed_mess("You are already at level " + lvl + " at " +
                         skill_name + ".\n");
      } else {
         add_failed_mess("You cannot regress below your current "
                         "skill level!\n");
      }
      return 0;
   }
   if (SKILL_OB->query_only_leaf(skill_name)) {
      if (sizeof((mixed *)SKILL_OB->query_immediate_children(skill_name))) {
         add_failed_mess("You can only advance the outer skills "
                         "(eg: other.movement.riding.horse), "
                         "not the internal "
                         "skills (eg: other.movement.riding, or other).\n");
         return 0;
      }
   } else {
      bits = explode(skill_name, ".");
      if (sizeof(bits) > 1) {
         outer_name = implode(bits[0..<2], ".");
         if (!SKILL_OB->is_skill_ignored(outer_name) &&
             ((sizeof(bits) - 1) * 5) >
             (int) this_player()->query_skill(outer_name)) {
            add_failed_mess("You are not at a high enough level in " +
                            outer_name +
                            " to advance " + skill_name + " yet.\n");
            return 0;
         }
      }
   }

   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }

   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("You cannot advance in " + skill_name +
                      " any further here.\n");
      return 0;
   }

   p_val = (int) this_player()->query_value_in(place);
   if (place != "default") {
      p_val += (int) this_player()->query_value_in("default");
   }

   round_value = MONEY_HAND->query_smallest_value_in(place);
   total_cost = 0;

   for (i = 0; i < by; i++) {
      tmp = query_skill_cost(skill_name, i);

      if ((int) this_player()->query_xp() < tmp + total_xp) {
         if (!i) {
            add_failed_mess("Your lack of experience prevents you improving "
                            + skill_name + ".\n");
            return 0;
         } else {
            write("Your lack of experience prevents you taking all the "
                  "advancement you requested in " + skill_name + ".  You are "
                  "only trained up to level " + (i + lvl) + ".\n");
         }
         break;
      }
      if ((lvl + i) >= max_lvl) {
         write("Your guild hasn't the resources to train you as far as " +
               "you requested in " + skill_name +
               ".  It trains you to level " + max_lvl + ".\n");
         break;
      }
      if (cost_div) {
         tmp_cost = ( total_xp + tmp ) / cost_div;
         tmp_cost -= (tmp_cost % round_value);
         if ( tmp_cost > p_val ) {
            if (!i) {
               add_failed_mess
                  ("Due to your lack of money, the guild cannot train " +
                   "you in " + skill_name + ": it would have cost you " +
                   MONEY_HAND->money_value_string( tmp_cost, place ) + ".\n" );
               return 0;
            } else {
               write("Due to your sad lack of money the guild cannot train " +
                     "you in " + skill_name + " to level " + (by + lvl) +
                     ".  It trains you to level " + (i + lvl) + " instead.\n");
            }
            break;
         }
      }
      total_xp += tmp;
      total_cost = tmp_cost;
   }

   if (!total_xp) {
      return add_failed_mess("Oops, something has gone wrong.\n");
   }

   this_player()->adjust_xp(-total_xp);
   if (total_cost) {
      this_player()->pay_money((mixed *) MONEY_HAND->
                               create_money_array(total_cost, place), place);
   }
   this_player()->add_skill_level(skill_name, i, total_xp);
   this_player()->reset_all();
   this_player()->dest_hide_shadow();
   event(this_object(), "guild_advance", bits, lvl, lvl + i);
   check_spells_commands(bits, lvl + i);
   write("You advance your skill in " + skill_name + " from " + lvl + " to " +
         (lvl + i) + " for " + total_xp + " xp" + (total_cost ? " and " +
                                                   (string) MONEY_HAND->
                                                   money_value_string
                                                   (total_cost,
                                                    place) : "") + ".\n");
   say((string) this_player()->one_short() + " $V$0=advances,advance$V$ " +
       "$V$0=" + this_player()->query_possessive() + ",their$V$ skills.\n");
   return 1;
} /* do_advance_internal() */

int do_advance(string skill)
{
   return do_advance_internal(skill, 0, 1);
} /* do_advance() */

int do_advance_by(string skill,
                  int num)
{
   return do_advance_internal(skill, 0, num);
} /* do_advance_by() */

int do_advance_to(string skill,
                  int num)
{
   return do_advance_internal(skill, num, 0);
} /* do_advance_to() */


int do_join(string str)
{
   if ((string) this_player()->query_guild_ob() == our_guild) {
      add_failed_mess("You're already in this guild.\n");
      return 0;
   }
   if (this_player()->query_guild_ob()) {
      add_failed_mess("You cannot join a guild while a member of another.\n");
      return 0;
   }
   write("You will only ever get to join one guild.  Are you sure? ");
   input_to("join2");
   return 1;
} /* do_join() */


int join2(string str)
{

   str = lower_case(str);

   if (str[0] != 'n' && str[0] != 'y') {
      write("I do not understand.  Yes or no? ");
      input_to("join2");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not joining the " + our_guild->query_name() + " guild.\n");
      return 1;
   }
   this_player()->set_guild_ob(our_guild);
   if (stringp(start_pos) && !clonep(environment(this_player())))
      this_player()->add_start(file_name(environment(this_player())),
                               start_pos);
   this_player()->race_guild_commands();
   write("You are now a member of the " + our_guild->query_name() +
         " guild.\n");
   say(this_player()->one_short() + " joins the " + our_guild->query_name() +
       " guild.\n");
   event(this_object(), "guild_join");
   event(users(), "inform",
         this_player()->query_cap_name() + " is now a member " + "of " +
         our_guild->query_name(), "guild");
   return 1;
} /* join2() */


int do_leave(string str)
{
   if (str != "guild") {
      add_failed_mess("Syntax : leave guild\n");
      return 0;
   }
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("How can you leave a guild if you aren't in it.\n");
      return 0;
   }
   if ((int) this_player()->query_level() > 5) {
      add_failed_mess("You are too high a level to leave this guild.\n");
      return 0;
   }
   write("Are you sure you want to leave the guild (Y/N) : ");
   input_to("confirm_leave");
   return 1;
} /* do_leave() */


void confirm_leave(string str)
{
   str = lower_case(str);
   if (str != "y") {
      write("You are still in the guild.\n");
      return;
   }
   write("Goodbye.\n");
   call_other(our_guild, "leaving_guild");
   this_player()->set_start_pos(CONFIG_START_LOCATION);
   this_player()->set_guild_ob(0);
   this_player()->set_guild_data(0);
   this_player()->guild_commands();
   this_player()->save_me();
} /* confirm_leave() */


int check_primaries(string lpath, string g_o)
{
   int i;
   string dummy,
    *primaries;

   primaries = (string *) g_o->query_skills();
   if (member_array(lpath, primaries) != -1)
      return 1;
   for (i = 0; i < sizeof(primaries); i++)
      if (sscanf(primaries[i], lpath + ".%s", dummy))
         return 1;
   return 0;
} /* check_primaries() */


/*
 * The purpose of this function is to build an array in the same
 * format as what you get from SKILL_OB->query_skills, but only
 * containing the data for the primaries in this guild.
 */
mixed *filter_primaries(mixed *tmp_skills, string skill_path,
                        string *primaries)
{
   int i;
   string test_skill;

   for (i = 0; i < sizeof(tmp_skills); i += SKILL_ARR_SIZE)  {
      test_skill = skill_path + tmp_skills[i];
      if (sizeof(tmp_skills[i + SKILL_BIT]) != 0) /* not a leaf skill */
         tmp_skills[i + SKILL_BIT] =
            filter_primaries(tmp_skills[i + SKILL_BIT], test_skill + ".",
                             primaries);
      if (member_array(test_skill, primaries) == -1  &&
          sizeof(tmp_skills[i + SKILL_BIT]) == 0)
      {
         tmp_skills = tmp_skills[0 .. (i - 1)] +
                      tmp_skills[(i + SKILL_ARR_SIZE) .. ];
         i -= SKILL_ARR_SIZE;
      }
   }
   return tmp_skills;

} /* filter_primaries() */


private string rec_cost(mixed *arr, string path, int depth, string guild,
                        int brief)
{
   /* use lots of variables...so we only work things out minimum times */
   int i;
   int depth_gap;
   int ndots;
   int lvl;
   int max_lvl;
   int only_leaf;
   int tmp;
   string str;
   string sub_str;
   string lpath;

   str = "";
   depth_gap = (depth - 1) * 2;
   ndots = 19 - depth_gap;

   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      lpath = path + arr[i];
      lvl = this_player()->query_skill(lpath);
      if (!guild) {
         max_lvl = 5;
      } else {
         max_lvl = guild->query_skill_max_level(lpath);
      }

      only_leaf = SKILL_OB->query_only_leaf(lpath);

      /* If this is a "leaf-only" skill and it's not bottom level... */
      if (only_leaf  &&  sizeof(arr[i + SKILL_BIT]) > 0)  {
         sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                            guild, brief);
         /* And if there are subskills to print under this skill... */
         if (sub_str != "")  {
            /*
             * Print a row of dots for this skill, then print the
             * subskill info and skip to the next skill
             */
            str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                           ndots + 18, arr[i]) + sub_str;
            continue;
         }
      }
      /* If we can actually learn this skill from the guild... */
      else if (SKILL_OB->query_allowed_to_teach(lpath))  {
         /* If we're over the guild max in this skill... */
         if (lvl >= max_lvl)  {
            /* And we're in brief mode... */
            if (brief)  {
               sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                                  guild, brief);
               /* And if there are subskills to print under this skill... */
               if (sub_str != "")  {
                  /*
                   * Print a row of dots for this skill, then print the
                   * subskill info and skip to the next skill
                   */
                  str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                                 ndots + 18, arr[i]) + sub_str;
                  continue;
               }
            }
            /* But if we're not in brief mode, print the 'mastered' thingy */
            else str += sprintf("%*'| 's%-*'.'s%4d/%3d  mastered\n", depth_gap,
                                "", ndots, arr[i], lvl, max_lvl);
         }
         /* Otherwise, we're not over the max level, so print the cost info */
         else if (SKILL_OB->query_allowed_to_teach(lpath))  {
            tmp = query_skill_cost(lpath, 0);
            str += sprintf("%*'| 's%-*'.'s%4d/%3d %6d xp\n", depth_gap, "",
                           ndots, arr[i], lvl, max_lvl, tmp);
         }
      }

      /*
       *If we're capable of learning subskills for this skill, or if this
       * is a leaf-only skill, then go down one more level
       */
      if (lvl >= depth * 5  ||  only_leaf) {
         reset_eval_cost();
         str += rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1, guild,
                         brief);
      }
   }
   return str;

} /* rec_cost() */


int do_cost_all(int brief)
{
   mixed *arr;
   string list;

   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols(),
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols() + 1,
                   rec_cost(arr, "", 1, our_guild, brief));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols(),
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "All", 1);
   return 1;

} /* do_cost_all() */


int do_cost_primaries()
{
   mixed *arr;
   string list;
   string *primaries;

   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }

   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);

   list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols(),
                   rec_cost(arr, "", 1, our_guild, 0));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "Primaries", 1);
   return 1;

} /* do_cost_primaries() */


int do_cost_internal(string skill, int to, int by)  {
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   string cost_str;
   int lvl;
   int max_lvl;
   int i;
   int tmp;
   int cost;

   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }

   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }

   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by == 0) {
      add_failed_mess
         ("It won't cost you anything to stay at the same level!\n");
      return 0;
   }
   if (by < 0) {
      add_failed_mess("We can't give refund xp for regressing skills!\n");
      return 0;
   }

   bits = explode(skill_name, ".");
   if (sizeof(bits) > 1  &&  !SKILL_OB->query_only_leaf(skill_name)) {
      outer_name = implode(bits[0 .. <2], ".");
      if (!SKILL_OB->is_skill_ignored(outer_name) &&
          ((sizeof(bits) - 1) * 5) > this_player()->query_skill(outer_name))
      {
         add_failed_mess("You are not at a high enough level in " +
                         outer_name + " to advance " + skill_name +
                         " yet.\n");
         return 0;
      }
   }

   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }

   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("Your guild prevents you even considering advancing " +
                      skill_name + " above level " + max_lvl + ".\n");
      return 0;
   }

   for (i = 0; i < by; i++) {
      if ((lvl + i) >= max_lvl) {
         write("Your guild prevents you considering all the advancement you "
               + "requested.  You can only advance up to level " + max_lvl +
               " in " + skill_name + " here.\n");
         break;
      }
      tmp += query_skill_cost(skill_name, i);

   }

   // Now work out the monetary cost if any.
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   cost_str = "";
   if (cost_div) {
      cost = tmp / cost_div;
      cost += cost % MONEY_HAND->query_smallest_value_in(place);
      if (cost)
         cost_str = " and " + MONEY_HAND->money_value_string(cost, place);
   }

   printf("It would cost you %d xp%s to raise %s from level %d to %d.\n",
          tmp, cost_str, skill_name, lvl, (lvl + i));
   return 1;

} /* do_cost_internal() */


int do_cost(string skill)
{
   mixed *arr;
   int i;
   int depth;
   string list;
   string exp_skill;
   string *sub_skills;
   int only_leaf;

   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }

   exp_skill =
      SKILL_OB->query_skill(explode(implode(explode(skill, " "), "."), "."));
   if (!exp_skill)  {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }

   if (SKILL_OB->query_allowed_to_teach(exp_skill))  {
      i = member_array(exp_skill, arr);
      only_leaf = SKILL_OB->query_only_leaf(exp_skill);
      if (only_leaf)  {
         sub_skills = explode(exp_skill, ".");
         foreach (skill in sub_skills[0 .. < 2])  {
            i = member_array(skill, arr);
            arr = arr[i + 3];
         }
         i = member_array(sub_skills[<1], arr);
         depth = sizeof(sub_skills) + 1;
      }
      else depth = 2;
      if (sizeof(arr[i + 3]) > 0)  {
         list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                        "======SKILLS=======Cur/Max==For Next") +
                sprintf("%#*-s\n", (int) this_player()->query_cols(),
                         rec_cost(arr[i + SKILL_BIT], exp_skill + ".", depth,
                         our_guild, 0)) +
                sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                         "> You have " + (int) this_player()->query_xp() +
                         " points to spend <");
         this_player()->more_string(list, capitalize(exp_skill), 1);
         return 1;
      }
   }
   return do_cost_internal(exp_skill, 0, 1);

} /* do_cost() */


int do_cost_to(string skill, int num)
{
   return do_cost_internal(skill, num, 0);
} /* do_cost_to() */

int do_cost_by(string skill, int num)
{
   return do_cost_internal(skill, 0, num);
} /* do_cost_to() */


int do_info()
{
   mixed *arr;
   string *primaries;

   write(our_guild->long() +
         "\nThis guild's primary skills and costs are:\n");
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   printf("%-*'='s\n", this_player()->query_cols() - 1,
          "======SKILLS=======Cur/Max==For Next");
   printf("%#*-s\n", this_player()->query_cols(),
          rec_cost(arr, "", 1, our_guild, 0));
   printf("%*'='|s\n", this_player()->query_cols() - 1, "> You have " +
          this_player()->query_xp() + " points to spend <");
   return 1;

} /* do_info() */


void set_teaching_person(object ob)
{
   teaching_person = ob;
}

object query_teaching_person()
{
   return teaching_person;
}


void add_spell(string name, string *blue, int lvl)
{
   string path;

   path = implode(blue, ".");
   if (!spells[path])
      spells[path] = ({ name, lvl });
   else
      spells[path] += ({ name, lvl });
} /* add_spell() */


void add_command(string name, string *blue, int lvl)
{
   string path;

   path = implode(blue, ".");

   if (!commands)
      commands = ([ ]);
   if (!commands[path])
      commands[path] = ({ name, lvl });
   else
      commands[path] += ({ name, lvl });

} /* add_command() */


void check_spells_commands(string *sk, int lvl)
{
   string *bits;
   int val;

   int i;
   int j;

   if (!teaching_person)
      return;
   bits = keys(spells);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(spells[bits[i]]); j += 2)
         if ((spells[bits[i]][j + 1] < val) &&
             !(this_player()->query_spell(spells[bits[i]][j])))
            teaching_person->init_command("teach " + spells[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
   bits = keys(commands);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(commands[bits[i]]); j += 2)
         if ((commands[bits[i]][j + 1] < val) &&
             !(this_player()->query_known_command(commands[bits[i]][j])))
            teaching_person->init_command("teach " + commands[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
} /* check_spell_commands() */


mapping query_spells()
{
   return spells + ([ ]);
}

mapping query_commands()
{
   return commands + ([ ]);
}

string query_start_pos()
{
   return start_pos;
}

string query_our_guild()
{
   return our_guild;
}
// --- END [/mnt/home2/grok/lib/std/room/inherit/guild.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/council_base.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/council_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629352   Available: 13576706
Inodes: Total: 5242880    Free: 4960136
1099 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/council_base.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629352   Available: 13576706
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This inherit has all the basic things that all the council rooms
 * of various sorts share.
 * @author Pinkfish
 * @started Wed Oct 25 21:44:37 PDT 2000
 */
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
private nosave string _council_area;

/**
 * This method returns the current area this council chambers deals with.
 * @return the area the council chambers deal with
 */
string query_council_area() {
   return _council_area;
} /* query_council_area() */

/**
 * This method sets the current area the council chambers deal with.
 * @param area the new council area
 */
void set_council_area(string area) {
   _council_area = area;
} /* set_council_area() */

/**
 * This method broadcasts a message to the citizens or magistrates of
 * the area.
 * @param magistrate_only 1 if only for magistrates, 0 for citizens
 * @param message the message to send
 */
void send_council_inform(int magistrate_only, string message) {
   NOMIC_HANDLER->send_council_inform(query_council_area(),
                                       magistrate_only, message);
} /* send_council_message() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/council_base.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/inherit/club_discuss.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/inherit/club_discuss.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629352   Available: 13576706
Inodes: Total: 5242880    Free: 4960136
33838 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/inherit/club_discuss.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629352   Available: 13576706
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This file is for adding discussion items to clubs.  It should be included
 * into the main club control room.
 * @author Pinkfish
 * @started April 21st 1999
 * @see /obj/handlers/club_handler.c
 */
#include <clubs.h>

#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 30
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"

private void discuss_finish_description(string str, int open);
protected int do_discuss(int open, string type, string club_name);

/**
 * This class is used by the memo discussion item addition code.
 * @element subject the subject of the discussion item
 * @element description the description of the discussion item
 * @element choices the choices for the discussion item
 * @element timeout the length of time the item runs for
 * @element open if the discussion item is open or not
 */
class memo_item {
   string club_name;
   string subject;
   string description;
   string *choices;
   int timeout;
   int open;
}

/** @ignore yes */
void init() {
   add_command("discuss",
               "[open] {description|add position|"
               "change position name|memo|secret|"
               "remove member|no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                (: do_discuss(1, $4[0], $4[1]) :));
   add_command("discuss",
               "committee {description|add position|"
               "change position name|memo|secret|remove member|"
               "no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                     (: do_discuss(0, $4[0], $4[1]) :));
} /* init() */

/**
 * This method is the return from the editing for the information
 * bit and will now try and confirm this.
 * @param str the confirmation string
 * @param data the passed in data
 * @see discussion_add_name()
 * @see do_discuss_add_position()
 */
protected void discussion_finish_information(string info,
                                             mixed *data) {
   int type;
   string short;
   string name;
   string optional;
   string club_name;

   club_name = data[0];
   short = data[1];
   type = data[2];
   name = data[3];
   optional = data[4];

   write("Discussion item: " + short + ".\n");
   if (!info) {
      write("No description used.\n");
   } else {
      write(info);
   }

   write("\nDo you wish to add this? ");
   input_to("discussion_finish_confirm", 
            0, 
            club_name,
            short, 
            type, 
            name, 
            info, 
            optional);
} /* discussion_finish_information() */

/**
 * @ignore yes
 */
protected void discussion_finish_confirm(string str,
                                         string club_name,
                                         string short,
                                         int type,
                                         string name,
                                         string info,
                                         string optional) {
   str = lower_case(str);
   if (!strlen(str) ||
       str[0] != 'y') {
      write("Aborting.\n");
      return ;
   }

   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         type,
                                         this_player()->query_cap_name(),
                                         name,
                                         info,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         optional)) {
      write("Added in the discussion item: " + short + ".\n");
   } else {
      write("Unable to add in the discussion item: " + short + ".\n");
   }
} /* discussion_add_name_confirm() */

/**
 * This is the entry point for setting up a discussion on changing
 * the description of the club.
 * @see description_confirm()
 */
protected int do_discuss_description(int open,
                                     string club_name) {
   // Must be a member of the committee to discuss it.
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_DESCRIPTION,
                                                   0)) {
      add_failed_mess("A description is already being discussed, you can only "
                      "discuss one description at a time.\n");
      return 0;
   }

   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Please enter the description you wish to have discussed as the "
         "new description of the club '" + 
         CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discuss_finish_description :),
                          0,
                          0,
                          ({ open,
                             club_name }));
   return 1;
} /* do_discuss_description() */

private void discuss_finish_description(string str, mixed *junk) {
   int open;
   string club_name;

   if (!str) {
      write("Description aborted.\n");
      return ;
   }

   open = junk[0];
   club_name = junk[1];

   write("Adding the description:\n" + str +
         "\nIs this the correct description (yes/no/edit)? ");
   input_to("description_confirm", 0, str, open, club_name);
} /* discuss_finish_description() */

/**
 * This method confirms the description typed in is correct.
 * @param confirm the string the used typed to confirm the description
 * @param str the description
 * @see do_discuss_description()
 */
protected void description_confirm(string confirm, string str, int open, string club_name) {
   confirm = lower_case(confirm);
   if (strlen(confirm) &&
       confirm[0] == 'e') {
      this_player()->do_edit(str,
                             (: discuss_finish_description :),
                             0,
                             0,
                             ({ open, club_name }));
      return ;
   }

   if (!strlen(confirm) ||
       confirm[0] != 'y') {
      write("Aborting.\n");
      return ;
   }

   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         CLUB_DISCUSS_DESCRIPTION | open,
                                         this_player()->query_name(),
                                         "Change club description",
                                         str,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         0)) {
      write("Successfuly added the item for discussion.\n");
   } else {
      write("Unable to add the item for discussion.\n");
   }
} /* description_confirm() */

/**
 * This is the method used to start the discussion of an add position
 * discussion item.
 * @return 1 on success, 0 on failure
 * @see do_discuss()
 * @see discussion_add_name()
 * @see discussion_add_name_confirm()
 */
protected int do_discuss_add_position(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What committee position do you wish to add to the club '" + 
         club_name + "'? ");
   input_to("discussion_add_name", 0, open, club_name);
   return 1;
} /* do_discuss_add_position() */

/**
 * This method checks to make sure that the entered position name is
 * valid.
 * @param str the position to check
 * @see do_discuss_add_position()
 * @see discussion_add_name_confirm()
 */
protected void discussion_add_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }

   str = strip_colours(str);
   
   // Check to see if this position is already in the club.
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The position '" + str + "' already exists in the club.  You "
            "cannot add it.\nAborting.\n");
      return ;
   }
   
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, it can be a "
            "maximum length of " + CLUB_MAX_POSITION_NAME +
            ".\nAborting.\n");
      return ;
   }

   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }

   write("What message do you wish display as to why you wish this position "
         "added?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Adding the position " + str,
                                CLUB_DISCUSS_NEW_POSITION | open,
                                str,
                                0 }) );
} /* discussion_add_name() */

/**
 * This is the main entry point for the function to setup a discussion item
 * to remove a member from the club.
 * @param open the open flag
 */
protected int do_discuss_remove_member(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which member to do you wish to try and remove? ");
   input_to("discussion_remove_member_name", 0, open, club_name);
   return 1;
} /* do_discuss_remove_member() */

/**
 * @ignore yes
 */
protected void discussion_remove_member_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   
   // Check to see if this position is already in the club.
   if (!CLUB_HANDLER->is_member_of(club_name,
                                   str)) {
      write("The person " + str + " is not a member of the club " +
            CLUB_HANDLER->query_club_name(club_name) +
            " and therefor you cannot remove them.\nAborting.\n");
      return ;
   }

   write("What do you want to say about removing " + str + "?\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Removing the member " + str,
                                CLUB_DISCUSS_MEMBER_REMOVE | open,
                                str,
                                0 }) );
} /* discussion_remove_member_confirm() */

/**
 * This method is the main entry point to adding a discussion type to make
 * the club secret.
 * @param open if the item is being added as an open item
 */
protected int do_discuss_secret(int open, string club_name) {
   string short;

   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_SECRET_TYPE)) {
      notify_fail("There is already a discussion item to change this club's "
                  "secret status.\n");
      return 0;
   }

   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   if (CLUB_HANDLER->query_club_secret(club_name)) {
      write("What description to wish to use to make the club open?\n");
      short = "make the club open";
   } else {
      write("What description to wish to use to make the club secret?\n");
      short = "make the club secret";
   }

   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                short,
                                CLUB_DISCUSS_SECRET_TYPE | open,
                                "Change to be secret",
                                0 }) );
   return 1;
} /* do_discuess_secret() */

/**
 * This is the main entry point for setting up a discussion item to 
 * remove a position from the club.
 * @return 1 on success, 0 on failure
 * @see do_discuss()
 */
protected int do_discuss_remove_position(int open, string club_name) {
   string *choices;
   string *ok;
   string bing;

   choices = CLUB_HANDLER->query_valid_positions(club_name);
   ok = filter(choices, (: !CLUB_HANDLER->is_basic_position($(club_name),
                                                            $1) :));
   if (!sizeof(ok)) {
      add_failed_mess("You cannot remove the basic positions of " + 
                      query_multiple_short(choices) + ".\n");
      return 0;
   }

   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to remove?\n");
   foreach (bing in ok) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("remove_position", 0, open, club_name, ok);
   return 1;
} /* do_discuss_remove_position() */

/**
 * @ignore yes
 */
protected void remove_position(string str, int open, string club_name) {
   str = lower_case(str);

   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }

   if (CLUB_HANDLER->is_basic_position(club_name,
                                       str)) {
      write("Unable to remove the basic positions from the club.\n");
      return ;
   }

   write("What description do you wish to associate with removing the "
         "position " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Remove the positon " + str,
                                CLUB_DISCUSS_POSITION_REMOVE | open,
                                str,
                                0 }) );
} /* remove_position() */

/**
 * This is the main entry point for setting up a discussion item to 
 * change a position name in the club.
 * @return 1 on success, 0 on failure
 * @see change_position()
 * @see change_position_new_name()
 * @see change_position_new_name_confirm()
 * @see do_discuss()
 */
protected int do_discuss_change_position_name(int open, string club_name) {
   string *choices;
   string bing;

   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to change?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("change_position", 0, open, club_name);
   return 1;
} /* do_discuss_change_position_name() */

/**
 * Figure out which of the choices the player wishes to change.
 * @param str the name of the position to be changed
 * @see do_discuss_change_position_name()
 * @see change_position_new_name()
 * @see change_position_new_name_confirm()
 */
protected void change_position(string str, int open, string club_name) {
   str = lower_case(str);

   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }

   write("What name do you wish to change '" + str + "' to? ");
   input_to("change_position_new_name", 0, str, open, club_name);
} /* change_position() */

/**
 * This method checks to make sure that the entered name to change the
 * position to is valid.
 * @param str the new name for the position
 * @param position the position to change
 * @see change_position()
 * @see do_discuss_change_position_name()
 * @see change_position_new_name_confirm()
 */
protected void change_position_new_name(string str,
                                        string position,
                                        int open, string club_name) {
   str = strip_colours(str);

   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The name '" + str + "' already exists in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }

   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, the maximum is " +
            CLUB_MAX_POSITION_NAME + ".\n");
      return ;
   }

   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }

   write("What description to you wish to give for changing the position " +
         position + " to " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "change the position " + position + " to " + str,
                                CLUB_DISCUSS_POSITION_NAME | open,
                                position,
                                str }) );
} /* change_position_new_name() */

/**
 * This is the main entry point for the no confidence discussion votes.
 * @param open the open flag
 * @return 1 on success, 0 on failure
 * @see do_discuss()
 */
protected int do_discuss_no_confidence(int open, string club_name) {
   string *choices;
   string bing;

   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to add a no confidence "
         "vote in?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("   " + CLUB_ALL_POSITIONS + "\n");
   write("Choice? ");
   input_to("no_confidence", 0, open, club_name);
   return 1;
} /* do_discuss_no_confidence() */

/** @ignore yes */
protected void no_confidence(string str,
                             int open, string club_name) {
   string bing;

   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name, str) &&
       str != CLUB_ALL_POSITIONS) {
      write("Sorry, '" + str + "' is not a valid position in " +
            CLUB_HANDLER->query_club_name(club_name) +
            ".\n");
      return ;
   }

   if (str == CLUB_ALL_POSITIONS) {
      bing = 0;
   } else {
      bing = str;
   }
   write("What description do you wish to give for a vote of no confidence "
         "in " + str + "?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "no confidence in " + str,
                                CLUB_DISCUSS_NO_CONFIDENCE | open,
                                bing,
                                0 }) );
} /* no_confidence() */

/**
 * This is the main entry point for setting up a discussion item to 
 * remove an account from the club.
 * @return 1 on success, 0 on failure
 * @see do_discuss()
 */
protected int do_discuss_remove_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }

   write("What is the name of the special account you wish to close? ");
   input_to("remove_account", 0, open, club_name);
   return 1;
} /* do_discuss_create_account() */

/**
 * @ignore yes
 */
protected void remove_account(string str, int open, string club_name) {
   str = lower_case(str);

   if (!CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot remove an account that doesn't exist.\n");
      return ;
   }

   if (str == CLUB_DEFAULT_ACCOUNT_NAME) {
      write("You cannot remove the default account name.\n");
      return ;
   }

   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_REMOVE_ACCOUNT | open,
                                str,
                                0 }) );
} /* remove_account() */

/**
 * This is the main entry point for setting up a discussion item to 
 * remove a position from the club.
 * @return 1 on success, 0 on failure
 * @see do_discuss()
 */
protected int do_discuss_create_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }

   write("What is the name of the special account you wish to open? ");
   input_to("create_account", 0, open, club_name);
   return 1;
} /* do_discuss_create_account() */

/**
 * @ignore yes
 */
protected void create_account(string str, int open, string club_name) {
   str = lower_case(str);

   if (CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot create an account that already exists.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_CREATE_ACCOUNT | open,
                                str,
                                0 }) );
} /* create_account() */

/** @ignore yes */
protected void discuss_memo_show(class memo_item memo) {
   write("The memo in club " +
         CLUB_HANDLER->query_club_name(memo->club_name) +
         " will complete in " + memo->timeout + " days.\n");
   if (memo->subject) {
      write("Subject: " + memo->subject + "\n");
   } else {
      write("No subject set.\n");
   }
   if (sizeof(memo->choices)) {
      write("Choices: " + query_multiple_short(memo->choices) + "\n");
   } else {
      write("No choices set.\n");
   }
   if (memo->description) {
      write("Description:\n" + memo->description + "\n");
   } else {
      write("No description set.\n");
   }
} /* discuss_memo_show() */

/**
 * This method runs the menu for the memo discussion item.
 * @param memo the memo item to be used in the menu
 */
protected void discuss_memo_menu(class memo_item memo) {
   discuss_memo_show(memo);
   write("\n");
   write("a) Set subject\n");
   write("b) Make a yes/no memo item\n");
   write("c) Add new choice\n");
   write("d) Remove choice\n");
   write("e) Set completion time\n");
   if (memo->description) {
      write("f) Change description\n");
      write("g) Zap description\n");
   } else {
      write("f) Add description\n");
   }
   write("m) Redisplay this menu\n");
   write("s) Save and Quit\n");
   write("q) Quit\n\n");
   write("Choice: ");
   input_to("discuss_memo_menu_choice", 0, memo);
} /* discuss_memo_menu() */

/** @ignore yes */
protected void discuss_memo_subject(class memo_item memo) {
   write("What do you wish the new subject to be? ");
   input_to("discuss_memo_subject_name", 0, memo);
} /* discuss_memo_subject() */

/** @ignore yes */
protected void discuss_memo_subject_name(string name,
                                         class memo_item memo) {
   if (!strlen(name)) {
      write("Not changing the subject.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(name) > MAX_SUBJECT_LEN) {
      write("The subject name is too long, the maximum "
            "length is " + MAX_SUBJECT_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }

   memo->subject = name;
   discuss_memo_menu(memo);
} /* discuss_memo_subject_name() */

/** @ignore yes */
protected void discuss_memo_add_choice(class memo_item memo) {
   write("What is the name of the choice you wish to add? ");
   input_to("discuss_memo_add_choice_response", 0, memo);
} /* discuss_memo_add_choice() */

/** @ignore yes */
protected void discuss_memo_add_choice_response(string response,
                                                class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   response = strip_colours(response);
   if (!strlen(response)) {
      write("Not adding any choices.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(response) > MAX_CHOICE_LEN) {
      write("The choice name " + response + " is too long, maximum "
            "length is " + MAX_CHOICE_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (member_array(response, memo->choices) != -1) {
      write("The choice name " + response + " is already in the list of "
            "choices.  Current choices are " +
            query_multiple_short(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices += ({ response });
   discuss_memo_menu(memo);
} /* discuss_memo_add_choice_response() */

/** @ignore yes */
protected void discuss_memo_remove_choice(class memo_item memo) {
   write("What is the name of the choice you wish to remove? ");
   input_to("discuss_memo_remove_choice_response", 0, memo);
} /* discuss_memo_remove_choice() */

/** @ignore yes */
protected void discuss_memo_remove_choice_response(string response,
                                                   class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   if (member_array(response, memo->choices) == -1) {
      write("The choice '" + response + "' is not in current memo.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices -= ({ response });
   discuss_memo_menu(memo);
} /* discuss_memo_remove_choice_response() */

/** @ignore yes */
protected void discuss_memo_timeout(class memo_item memo) {
   write("What do you wish to change the length of the item to (in days)? ");
   input_to("discuss_memo_timeout_response", 0, memo);
} /* discuss_memo_timeout() */

/** @ignore yes */
protected void discuss_memo_timeout_response(string str,
                                             class memo_item memo) {
   int tim;

   if (sscanf(str, "%d", tim) != 1) {
      write("Must specify a number.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim < MIN_TIMEOUT) {
      write("The timeout " + tim + " is lower than the minimum allowed "
            "length of " + MIN_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim > MAX_TIMEOUT) {
      write("The timeout " + tim + " is higher than the maximum allowed "
            "length of " + MAX_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->timeout = tim;
   discuss_memo_menu(memo);
} /* discuss_memo_timeout_response() */

/** @ignore yes */
protected void discuss_memo_finish_description(string desc,
                                               class memo_item memo) {
   if (!desc) {
      write("Not changing the description.\n");
   } else {
      memo->description = desc;
   }
   discuss_memo_menu(memo);
} /* discuss_memo_finish_description() */

/** @ignore yes */
protected void discuss_memo_description(class memo_item memo) {
   if (memo->description) {
      write("Edit your description.\n");
   } else {
      write("Add your description.\n");
   }
   this_player()->do_edit(memo->description,
                          (: discuss_memo_finish_description :),
                          0,
                          0,
                          memo);
} /* discuss_memo_description() */

/** @ignore yes */
protected void discuss_memo_save(class memo_item memo) {
   if (!memo->subject) {
      write("The memo must have a subject to save it!\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (sizeof(memo->choices) < 2) {
      write("The memo must have at least two choices!  Currently you have " +
            sizeof(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }

   if (CLUB_HANDLER->add_discussion_item(memo->club_name,
                                         CLUB_DISCUSS_MEMO | memo->open,
                                         this_player()->query_name(),
                                         memo->subject,
                                         memo->description,
                                         memo->choices,
                                         memo->timeout * 24 * 60 * 60,
                                         0)) {
      write("Successfuly added the memo item.\n");
   } else {
      write("Unable to add the memo item for some reason.\n");
   }
} /* discuss_memo_save() */

/** @ignore yes */
protected void discuss_memo_menu_choice(string str, class memo_item memo) {
   str = lower_case(str);
   if (!strlen(str)) {
      write("Invalid choice\nChoice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }

   switch (str[0]) {
      case 'a' :
         discuss_memo_subject(memo);
         break;
      case 'b' :
         memo->choices = ({ "yes", "no", "abstain" });
         discuss_memo_menu(memo);
         break;
      case 'c' :
         discuss_memo_add_choice(memo);
         break;
      case 'd' :
         discuss_memo_remove_choice(memo);
         break;
      case 'e' :
         discuss_memo_timeout(memo);
         break;
      case 'f' :
         discuss_memo_description(memo);
         break;
      case 'g' :
         memo->description = 0;
         write("Description zapped.\n");
         discuss_memo_menu(memo);
         break;
      case 'q' :
         write("Quiting memo addition!\n");
         break;
      case 's' :
         discuss_memo_save(memo);
         break;
      case 'm' :
         discuss_memo_menu(memo);
         break;
      default :
         write("Invalid choice\nChoice: ");
         input_to("discuss_memo_menu_choice", 0, memo);
         break;
   }
} /* discuss_meno_menu_choice() */

/**
 * This is the main entry point for setting up a memo discussion type.
 * A memo is a user run discussion item which has no effect on any
 * real game mechanics.
 * @see do_discuss()
 */
protected int do_discuss_memo(int op, string club_name) {
   discuss_memo_menu(new(class memo_item, choices : ({ }),
                                          timeout : 14,
                                          club_name : club_name,
                                          open : op));
   return 1;
} /* do_discuss_memo() */

/**
 * The main entry point for all the discussion item types.  Figures out
 * which discussion item it is and calls the correct method to start the
 * ball rolling.
 * @param type the type of the discussion item
 * @return 1 on success, 0 on failure
 * @see /obj/handlers/club_handler.c
 * @see do_discuss_description()
 * @see do_discuss_add_position()
 * @see do_discuss_change_position_name()
 * @see do_discuss_memo()
 */
int do_discuss(int open, string type, string club_name) {
   if (open) {
      open = CLUB_DISCUSS_OPEN;
   }

   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("No such club '" + club_name + "'.\n");
      return 0;
   }

   if (!CLUB_HANDLER->is_elected_club(club_name)) {
      add_failed_mess("The club " + CLUB_HANDLER->query_club_name(club_name) +
                      " is not an elected club.\n");
      return 0;
   }

   if (!CLUB_HANDLER->holds_any_position_of(club_name, this_player()->query_name())) {
      if (type != "no confidence" &&
          type != "remove member") {
         add_failed_mess("Non elected officals can only add discussion items "
                         "of 'no confidence' and 'remove member'.\n");
         return 0;
      }
   }

   switch (type) {
      case "description" :
         return do_discuss_description(open, club_name);
      case "add position" :
         return do_discuss_add_position(open, club_name);
      case "change position name" :
         return do_discuss_change_position_name(open, club_name);
      case "memo" :
         return do_discuss_memo(open, club_name);
      case "remove member" :
         return do_discuss_remove_member(open, club_name);
      case "secret" :
         return do_discuss_secret(open, club_name);
      case "remove position" :
         return do_discuss_remove_position(open, club_name);
      case "no confidence" :
         return do_discuss_no_confidence(open, club_name);
      case "create account" :
         return do_discuss_create_account(open, club_name);
      case "remove account" :
         return do_discuss_remove_account(open, club_name);
      default :
         add_failed_mess("Horrible, horrible error.  The worms!  "
                         "The worms!\n");
         return 0;
   }
} /* do_discuss() */
// --- END [/mnt/home2/grok/lib/std/room/inherit/club_discuss.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_fine.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_fine.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629343   Available: 13576697
Inodes: Total: 5242880    Free: 4960136
4491 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_fine.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629343   Available: 13576697
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the room to handle paying for fines.
 * @author Pinkfish
 * @started Thu Sep 21 15:58:48 PDT 2000
 */
#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";

private string _fine_handler;

void create() {
   ::create();
   add_help_file("fines");
} /* create() */

/**
 * This method sets the current fine handler for this council.
 * @param fine the fine handler
 */
void set_fine_handler(string fine) {
   _fine_handler = fine;
} /* set_fine_handler() */

/**
 * This method returns the current fine handler for this counci;.
 * @return the fine handler for the council
 */
string query_fine_handler() {
   return _fine_handler;
} /* query_fine_handler() */

/**
 * This method handles a person trying to pay their fine.
 * @return 1 on success, 0 on failure
 */
int do_pay() {
   string place;
   mixed* m_array;
   int fine;
   int value;

   //
   // Check to see if they have a fine.
   //
   fine = _fine_handler->query_current_fine(this_player()->query_name());
   if (!fine) {
      add_failed_mess("You do not have any fines due here.\n");
      return 0;
   }

   place = query_property("place");
   value = this_player()->query_value_in(place);
   if (value >= fine) {
      m_array = MONEY_HAND->create_money_array(fine, place);
      this_player()->pay_money(m_array, place);
      _fine_handler->pay_fine(this_player()->query_name(), fine);
      write("You pay off all of your fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n");
   } else {
      m_array = MONEY_HAND->create_money_array(value, place);
      this_player()->pay_money(m_array, place);
      _fine_handler->pay_fine(this_player()->query_name(), value);
      write("You pay off " +
            MONEY_HAND->money_value_string(value, place) +
            " of your fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n");
   }
   add_succeeded_mess(({ "", "$N $V $p fine.\n" }));
   return 1;
} /* do_pay() */

/**
 * This method returns a string detailing information about their fines.
 * @return information about the fines
 */
string query_fine_information(string person) {
   string ret;
   int fine;
   string place;

   place = query_property("place");
   ret = "";
   fine = _fine_handler->query_current_fine(person);
   if (!fine) {
      ret += "No current fine.\n";
   } else {
      ret += "Current fine of " + 
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }

   fine = _fine_handler->query_total_fine(person);
   if (!fine) {
      ret += "No fines ever.\n";
   } else {
      ret += "Total fines of " + 
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }

   fine = _fine_handler->query_total_payments(person);
   if (!fine) {
   } else {
      ret += "Total fine payments of " + 
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }

   return ret;
} /* query_fine_information() */


/**
 * This method tells them some information about their current and previous
 * fines.
 */
int do_fine() {
   write(query_fine_information(this_player()->query_name()));
   add_succeeded_mess(({ "", "$N look$s up a fine.\n" }));
   return 1;
} /* do_fine() */

/** 
 * This method shows fines about someone else.
 * @param person to show the fines about
 */
int do_show_fine(string person) {
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("You must find a fine for an existing person.\n");
      return 0;
   }

   write(person + ":\n" + query_fine_information(person));
   add_succeeded_mess(({ "", "$N look$s up a fine.\n" }));
   return 1;
} /* do_show_fine() */

int do_show_all_fines() {
   string ret;
   int fine;

   ret = "";
   foreach (string person in _fine_handler->query_people_with_fines()) {
      fine = _fine_handler->query_current_fine(person);
      if (fine) {
         ret += person + " " + query_fine_information(person) + "\n";
      }
   }
   write("$P$Fines$P$" + ret);
} /* do_show_all_fines() */

void init() {
   add_command("pay", "fine", (: do_pay() :));
   add_command("fine", "", (: do_fine() :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      add_command("fine", "<string'player'>", (: do_show_fine($4[0]) :));
      add_command("fine", "all", (: do_show_all_fines :));
      add_command("list", "fines", (: do_show_all_fines :));
   }
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/council_fine.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_cases.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_cases.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629342   Available: 13576696
Inodes: Total: 5242880    Free: 4960136
35719 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_cases.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629342   Available: 13576696
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This room is for handling control of cases.  It allows people to
 * add notes, open cases and general have a wild time in case land.
 * @param Pinkfish
 * @started Fri Jul 21 18:57:34 PDT 2000
 */
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>

void add_punishment_type(string name, string file);
string query_punishment_type(string name);

private mapping _types;

void create() {
   _types = ([ ]);
   ::create();
   if (!query_punishment_type("not guilty")) {
      add_punishment_type("not guilty", NOMIC_PUNISHMENT_DIR + "not_guilty");
   }
   if (!query_punishment_type("dismissed")) {
      add_punishment_type("dismissed", NOMIC_PUNISHMENT_DIR + "dismissed");
   }
   if (!query_punishment_type("lose citizenship")) {
      add_punishment_type("lose citizenship",
                          NOMIC_PUNISHMENT_DIR + "lose_citizenship");
   }
   add_help_file("cases");
} /* create() */

/**
 * This method adds a type to the room.  A type is a type of
 * punishment that can be applied to the person when the case is close.
 * The different functions have the following arguments:<br>
 * start_punishment(the_case, type, finish_func)<br>
 * query_short(the_case, type, data)<br>
 * complete_punishment(the_case, type, data)<br>
 * finish_func(the_case, type, data) (from start())<br>
 * suspend_punishment(the_case, type, data)<br>
 * <P>
 * The functions are all called on a inheritable file.
 * @param name the name of the type
 * @param short the function to make the short description
 * @param start the function to call at the start
 * @param complete the function to call at the completion
 * @param suspend suspend the punishment
 */
void add_punishment_type(string name, string file) {
   _types[name] = file;
} /* add_punishment_type() */

/**
 * This method returns the file associated with the type.
 * @param name the nam eof the class to lookup
 * @return the file of the type
 */
string query_punishment_type(string name) {
   return _types[name];
} /* query_punishment_type() */

/**
 * This method starts the punishment check thingy to get any extra
 * arguements.
 * @param name the name of the punishment to check
 * @param the_case th case we are messing with
 * @param finish the finish function to call
 */
void start_punishment(string name, class nomic_case the_case, function finish) {
   string bing;


   bing = query_punishment_type(name);
   if (bing) {
      call_other(bing, "start_punishment", query_council_area(),
                 the_case, name, finish);
   } else {
      write("Big hairy error.\n");
   }
} /* start_punishment() */

/**
 * This method starts the punishment check thingy to get any extra
 * arguements.
 * @param name the name of the punishment to check
 * @param the_case th case we are messing with
 * @param finish the finish function to call
 */
void complete_punishment(string name, class nomic_case the_case, mixed data) {
   string bing;

   bing = query_punishment_type(name);
   if (bing) {
      call_other(bing, "complete_punishment", query_council_area(),
                 the_case, name, data);
   } else {
      write("Big hairy error.\n");
   }
} /* complete_punishment() */

/**
 * This method suspends the punishment after it is started.  Used in the
 * appeals process.
 * @param the_case th case we are messing with
 */
void suspend_punishment(class nomic_case the_case) {
   string bing;
   class nomic_case_event event;
   string type;
   mixed data;

   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_CLOSE) {
         type = event->data[0];
         data = event->data[1];
      }
   }
   bing = query_punishment_type(type);
   if (bing) {
      call_other(bing, "suspend_punishment", query_council_area(),
                 the_case, type, data);
   } else {
      write("Big hairy error.\n");
   }
} /* start_punishment() */

/**
 * This method returns the short of the punishment.
 * @param name the name of the punishment type
 * @param the_case the caseof the thingy
 * @param data the extra punishment type data
 * @return the short of the type
 */
string query_punishment_short(string name, class nomic_case the_case,
                              mixed data) {
   string bing;

   bing = query_punishment_type(name);
   if (bing) {
      return call_other(bing, "query_short", query_council_area(), the_case, name, data);
   } else {
      return "Big hairy error.\n";
   }
} /* query_punishment_short() */

/**
 * This method returns the mail information of the punishment.
 * @param name the name of the punishment type
 * @param the_case the caseof the thingy
 * @param data the extra punishment type data
 * @return the short of the type
 */
string query_punishment_mail_info(string name, class nomic_case the_case,
                              mixed data) {
   string bing;

   bing = query_punishment_type(name);
   if (bing) {
      return call_other(bing, "query_mail_information", query_council_area(), the_case,
                        name, data);
   } else {
      return "Big hairy error.\n";
   }
} /* query_punishment_mail_info() */

/**
 * This method returns the name of all the allowed punishment types.
 */
string* query_all_punishment_types() {
   return keys(_types);
} /* query_all_punishment_types() */

/**
 * This method returns any extra information to print about a player in
 * the status information.
 * @param player the player we are checking
 * @return any extra information
 */
string query_extra_player_status(string player) {
   return 0;
} /* query_extra_player_status() */

/**
 * This method finds the last person to appeal the case.
 * @param person the person to check
 */
string query_last_appealer(class nomic_case the_case) {
   class nomic_case_event event;
   string ret;

   ret = 0;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_APPEAL) {
         ret = event->person;
      }
   }
   return ret;
} /* query_last_appealer() */

/**
 * This method checks and sees if the person is the last person to appeal
 * the case.
 * @param person the person to check
 */
int is_last_appealer(class nomic_case the_case, string person) {
   return query_last_appealer(the_case) == person;
} /* is_last_appealer() */

/**
 * This method checks and sees if the person is the last person to close
 * the case.
 * @param person the person to check
 */
string query_last_closer(class nomic_case the_case) {
   class nomic_case_event event;
   string ret;

   ret = 0;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_CLOSE) {
         ret = event->person;
      }
   }
   return ret;
} /* is_last_closer() */

/**
 * This method checks and sees if the person is the last person to close
 * the case.
 * @param person the person to check
 */
int is_last_closer(class nomic_case the_case, string person) {
   return query_last_closer(the_case) == person;
} /* is_last_closer() */

/**
 * This method lists the current set of punishments known by this
 * area.
 */
int do_list_punishments() {
   string punish;
   string file;

   write("Punishments:\n");
   foreach (punish, file in _types) {
      write("   " + punish + "\n");
   }
   return 1;
} /* do_list_punishments() */

/**
 * This method lists the current set of punishments known by this
 * area.
 */
int do_list_punishments_desc(string type) {
   string file;

   write("Punishments:\n");
   file = _types[type];
   if (!file) {
      add_failed_mess("No punishment of type " + type + ".\n");
      return 0;
   }

   this_player()->more_string(file->query_description(), "punishment");
   return 1;
} /* do_list_punishments() */

/**
 * Opening a case.
 * @param people the people the case ie against
 * @param short the short description of the case
 * @return 1 on success, 0 on failure
 */
int do_open_case(string people, string short) {
   string* bits;
   string* bad;
   string person;

/*
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                      this_player()->query_name())) {
      add_failed_mess("You need to be a citizen to open a case.\n");
      return 0;
   }
 */

   people = replace_string(people, " and ", ",");
   people = replace_string(people, " ", "");
   bits = explode(lower_case(people), ",");
   bad = ({ });
   foreach (person in bits) {
      if (!PLAYER_HANDLER->test_user(person)) {
         bad += ({ person });
      }
   }

   if (member_array(this_player()->query_name(), bits) != -1) {
      bits = bits - ({ this_player()->query_name() });
   }

   if (sizeof(bad) == 1) {
      add_failed_mess("The player " + query_multiple_short(bad) +
                      " does not exist.\n", bad);
      return 0;
   } else if (sizeof(bad)) {
      add_failed_mess("The players " + query_multiple_short(bad) +
                      " do not exist.\n", bad);
      return 0;
   }

   if (!sizeof(bits)) {
      add_failed_mess("There have to be some people involved in the case.\n");
      return 0;
   }
      

   write("For the case with the people " + query_multiple_short(bits) +
         " and a short of " + short + ", please type in an intial "
         "description of the case.\n");
   this_player()->do_edit("", "open_case_desc", this_object(), 0,
                          ({ bits, short }));
   return 1;
} /* do_open_case() */

/** @ignore yes */
void open_case_desc(string desc, mixed* extra) {
   string* bits;
   string short;

   bits = extra[0];
   short = extra[1];
   if (!desc) {
      write("Aborted.\n");
      return ;
   }

   write("Adding in a case with " + query_multiple_short(bits) +
         " people and a short description of " + short + ".\nYour note is:\n");
   write(desc);
   write("\nAre you sure you wish to add this? ");
   input_to("open_case_desc_confirm", 0, bits, short, desc);
} /* open_case_desc() */

/** @ignore yes */
void open_case_desc_confirm(string response, string* bits,
                            string short, string desc) {
   int id;
   string* magistrates;

   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the addition of the case.\n");
      return ;
   }

   id = NOMIC_HANDLER->add_new_case(query_council_area(),
                                    this_player()->query_name(), short,
                                    bits);
   if (id) {
      NOMIC_HANDLER->add_note_to_case(query_council_area(),
                                      id, this_player()->query_name(),
                                      desc);
      write("Added the case into the system.\n");
      magistrates = NOMIC_HANDLER->query_magistrates(query_council_area());
      MAILER->do_mail_message(implode(magistrates + bits, ","),
                           query_council_area() + " magistrates",
                           "New case against " + implode(bits, ","),
                           "",
                           "A new case is opened against " +
                           implode(bits, ",") +
                           " by " + this_player()->query_cap_name() +
                           "\nwith a reason of:\n" +
                           desc);
      tell_room(this_object(),
           this_player()->the_short() + " opens a case against " +
           query_multiple_short(bits) + ".\n", ({ this_player() }) );
   } else {
      write("Unable to add the case for some reason.\n");
   }
} /* open_case_desc_confirm() */

/**
 * The short description of the case.
 * @param the_case the case to get a short desc
 * @return the short description of the case
 */
string query_case_short(class nomic_case the_case) {
   string ret;

   ret = "Case #" + the_case->id + " \"" +
         the_case->short + "\" opened by " + the_case->opener +
         " against " + query_multiple_short(the_case->people) + " at " +
         ctime(the_case->time_opened);
/*
   if (the_case->magistrate) {
      ret += "; magistrate " + the_case->magistrate;
   }
 */
   return ret;
} /* query_case_short() */

/**
 * This method lists all the currently open cases.
 * @return 1 for success, 0 if failed
 */
int do_list_open_cases() {
   int* cases;
   string ret;
   class nomic_case the_case;
   int id;

   cases = NOMIC_HANDLER->query_open_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   ret = "Currently open cases:\n";
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), id);
      ret += "$I$5=$C$" + query_case_short(the_case);
      ret += "\n";
   }
   this_player()->more_string(ret, "open cases");
   return 1;
} /* do_list_open_cases() */

/**
 * This method lists all the recently closed cases.
 * @return 1 for success, 0 if failed
 */
int do_list_closed_cases() {
   int* cases;
   string ret;
   class nomic_case the_case;
   int id;

   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no recently closed cases.\n");
      return 0;
   }
   ret = "Recently closed cases:\n";
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(), id);
      ret += "$I$5=$C$" + query_case_short(the_case);
      ret += "\n";
   }
   this_player()->more_string(ret, "closed cases");
   return 1;
} /* do_list_closed_cases() */

/**
 * This method lists the specified open case.
 * @param case_id the case to list
 * @return 1 for success, 0 if failed
 */
int do_list_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;

   ret = "";
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " +
                event->mess + "\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "open cases");
   return 1;
} /* do_list_case() */

/**
 * This method lists the specified closed case.
 * @param case_id the case to list
 * @return 1 for success, 0 if failed
 */
int do_list_closed_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;
   int* cases;

   ret = "";
   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   if (member_array(case_id, cases) == -1) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " + event->mess + ".\n";
      }
   }

   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "open cases");
   return 1;
} /* do_list_closed_case() */

/**
 * This method adds a person to an open case.
 * @param case_id the case to add it to
 * @param person the person to add
 * @return 1 on success, 0 on failure
 */
int do_add_person(int case_id, string person) {
   class nomic_case the_case;
   
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to add a person from "
                      "the case.\n");
      return 0;
   }

   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot add a person to a case involving you or "
                      "started by you.\n");
      return 0;
   }

   write("What reason to wish to give for adding this person?\n");
   this_player()->do_edit("", "person_desc", this_object(), 0,
                          ({ case_id, person, "add" }));
   return 1;
} /* do_add_person() */

/** @ignore yes */
void person_desc(string desc, mixed* stuff) {
   int case_id;
   string person;
   string type;
   class nomic_case the_case;

   case_id = stuff[0];
   person = stuff[1];
   type = stuff[2];

   if (!desc) {
      write("Aborted " + type + "ing " + person + ".\n");
      return ;
   }

   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   write("Are you sure you wish to " + type + " " + person + " to the "
        "case " + query_case_short(the_case) + ".\n");
   input_to("person_confirm", 0, case_id, person, type, desc);
} /* person_desc() */

/** @ignore yes */
void person_confirm(
   string response,
   int case_id,
   string person,
   string type,
   string desc
) {
   string* people;
   class nomic_case the_case;

   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborted " + type + "ing " + person + ".\n");
      return ;
   }

   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   people = the_case->people;
   if (type == "add") {
      if (NOMIC_HANDLER->add_person_to_case(query_council_area(), case_id,
                                            this_player()->query_name(), 
                                            person, "\n" + desc)) {
         write("Sucessfully added " + person + " to the case.\n");
         people += ({ person });
      } else {
         write("Unable to add " + person + " to the case.\n");
         return ;
      }
   } else {
      if (NOMIC_HANDLER->remove_person_from_case(query_council_area(), case_id,
                                            this_player()->query_name(), 
                                            person, "\n" + desc)) {
         write("Sucessfully removed " + person + " from the case.\n");
      } else {
         write("Unable to remove " + person + " from the case.\n");
         return ;
      }
   }

   MAILER->do_mail_message(implode(people, ","),
                           query_council_area() + " magistrates",
                           capitalize(type) + " person",
                           "",
                           "From the desk of " +
                           this_player()->query_cap_name() + ":\n"
                           "The " + type + "ing the person " + person +
                           " to the case " +
                           query_case_short(the_case) +
                           "\nwith a reason of:\n" +
                           desc);
   tell_room(this_object(),
           this_player()->the_short() + " " + type + "s " + person +
           " to case #" + the_case->id + ".\n", ({ this_player() }) );
} /* person_confirm() */

/**
 * This method adds a person to an open case.
 * @param case_id the case to add it to
 * @param person the person to add
 * @return 1 on success, 0 on failure
 */
int do_remove_person(int case_id, string person) {
   class nomic_case the_case;
   
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to remove a person "
                      "from the case.\n");
      return 0;
   }

   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot remove a person to a case involving you or "
                      "started by you.\n");
      return 0;
   }

   if (sizeof(the_case->people) == 1) {
      add_failed_mess("You cannot remove everyone from the case.\n");
      return 0;
   }


   write("What reason to wish to give for removeing this person?\n");
   this_player()->do_edit("", "person_desc", this_object(), 0,
                          ({ case_id, person, "remove" }));
   return 1;
} /* do_remove_person() */

/**
 * This method adds a note to an open case.
 * @param case_id the id of the case to add a note to
 * @return 1 for success, 0 if failed
 */
int do_add_note(int case_id) {
   class nomic_case the_case;

   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }

   write(query_case_short(the_case));

   write("\nAdd note:\n");
   this_player()->do_edit("", "note_case_desc", this_object(), 0,
                          the_case);
   return 1;
} /* do_add_note() */

/** @ignore yes */
void note_case_desc(string desc, class nomic_case the_case) {
   if (!desc) {
      write("Aborted.\n");
   }

   write("Do you wish to add the note to the case " +
         query_case_short(the_case) + ".\n");
   write(desc + "\nAre you sure you wish to add this note? ");
   input_to("note_case_desc_confirm", 0, desc, the_case);
} /* note_case_desc() */

/** @ignore yes */
void note_case_desc_confirm(string response, string desc,
                            class nomic_case the_case) {
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the addition of the note.\n");
      return ;
   }

   if (NOMIC_HANDLER->add_note_to_case(query_council_area(), the_case->id,
                                       this_player()->query_name(), desc)) {
      write("Added the note to the case.\n");
      tell_room(this_object(),
           this_player()->the_short() + " adds a note "
           " to case #" + the_case->id + ".\n", ({ this_player() }) );
   } else {
      write("Unable to add the note to the case for some reason.\n");
   }
} /* note_case_desc_confirm() */

/** @ignore yes */
void close_case_bit(class nomic_case the_case, string type, mixed data) {
   write("Please add in your closing summary.\n");
   this_player()->do_edit("", "close_case_desc", this_object(), 0,
                          ({ the_case, type, data }));
} /* close_case_bit() */

/**
 * This method closes the case.
 * @param case_id the id of the case
 * @param type the type of closing
 * @return 1 on success, 0 on failure
 */
int do_close_case(int case_id, string type) {
   class nomic_case the_case;

   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Cannot find the case.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to close the case.\n");
      return 0;
   }

   if (!query_punishment_type(type)) {
      add_failed_mess("This is not an allowed type for closing the case, "+
                      "it must be one of " +
                      query_multiple_short(query_all_punishment_types()) + ".\n");
      return 0;
   }

   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot close a case involving you or started "
                      "by you.\n");
      return 0;
   }

   if (is_last_appealer(the_case, this_player()->query_name())) {
      add_failed_mess("You cannot close a case you appealed.\n");
      return 0;
   }

   start_punishment(type, the_case, (: close_case_bit :));
   return 1;
} /* do_close_case() */

/**
 * This method sets up an exciting set of closing comments for the
 * case.
 * @param desc the closing desc
 * @param extra the extra data
 */
void close_case_desc(string desc, mixed* extra) {
   class nomic_case the_case;
   string type;
   mixed data;

   if (!desc) {
      write("Aborted.\n");
      return ;
   }

   the_case = extra[0];
   type = extra[1];
   data = extra[2];

   write("Closing the case " +
         query_case_short(the_case) +  " with the type of " +
         query_punishment_short(type, the_case, data) + ".\n");
   write("Are sure you wish you wish to close this case? ");
   input_to("close_case_desc_confirm", 0, the_case, type, data, desc);
} /* close_case_desc() */

/** @ignore yes */
void close_case_desc_confirm(string response, class nomic_case the_case,
                             string type, mixed* data, string desc) {
   string* people;

   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the closing of the note.\n");
      return ;
   }

   if (NOMIC_HANDLER->close_case(query_council_area(), the_case->id,
                                this_player()->query_name(),
                                query_punishment_short(type, the_case, data) +
                                "\n" + desc, ({ type, data }))) {
      complete_punishment(type, the_case, data);
      write("Completed closing the case.\n");
      //
      // Send mail to them all.
      //
      people = the_case->people + ({ the_case->opener }) +
               NOMIC_HANDLER->query_magistrates(query_council_area());
      if (query_last_appealer(the_case)) {
         people += ({ query_last_appealer(the_case) });
      }
      MAILER->do_mail_message(implode(people, ","),
                              query_council_area() + " magistrates",
                              "Case closed against " +
                              implode(the_case->people, ","),
                              "",
                              "From the desk of " +
                              this_player()->query_cap_name() + ":\n"
                              "The case " +
                              query_case_short(the_case) +
                              "\nhas been closed with a verdict of " +
                              query_punishment_short(type, the_case, data) +
                              "\nWith a reason of:\n" +
                              desc +
                              query_punishment_mail_info(type, the_case, data));
      tell_room(this_object(),
           this_player()->the_short() + " closes the case #" +
           the_case->id + " against " + query_multiple_short(the_case->people) +
           " with a result of " +
           query_punishment_short(type, the_case, data) +
           ".\n", ({ this_player() }) );
   } else {
      write("Unable to complete closing the case.\n");
   }
} /* close_case_desc_confirm() */

/**
 * This method appeals the case.
 * @param case_id the id of the case
 * @return 1 on success, 0 on failure
 */
int do_appeal_case(int case_id) {
   class nomic_case the_case;

   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (!the_case) {
      add_failed_mess("Cannot find the case.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to appeal the case.\n");
      return 0;
   }

   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot appeal a case involving you or started "
                      "by you.\n");
      return 0;
   }

   if (is_last_closer(the_case, this_player()->query_name())) {
      add_failed_mess("You cannot appeal a case you closed.\n");
      return 0;
   }

   //
   // Included a longer details reason why the case is appealed.
   //
   write("What is the detailed reason for appealing this case?\n");
   this_player()->do_edit("", "appeal_case_desc", this_object(), 0, case_id);
   return 1;
} /* do_appeal_case() */

/** @ignore yes */
void appeal_case_desc(string desc, int case_id) {
   class nomic_case the_case;

   if (!desc) {
      write("Aborted.\n");
      return ;
   }

   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   write("Appealing the case " +
         query_case_short(the_case) +  " because:\n" + desc + "\nAre you sure "
         "you wish to do this? ");
   input_to("appeal_case_desc_confirm", 0, case_id, desc);
} /* appeal_case_desc() */

/** @ignore yes */
void appeal_case_desc_confirm(string response, int case_id, string desc) {
   class nomic_case the_case;
   string* people;

   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the closing of the note.\n");
      return ;
   }

   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   //
   // Add the \n since when it is printed out the first bit is on the same
   // line as the description.
   //
   if (NOMIC_HANDLER->appeal_case(query_council_area(), case_id,
                                  this_player()->query_name(),
                                  "\n" + desc)) {
      write("Appealed the case successfully.\n");
      //
      // Have to suspend the punishment...
      //
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
      suspend_punishment(the_case);
      //
      // Send mail to them all.
      //
      people = the_case->people + ({ the_case->opener });
      MAILER->do_mail_message(implode(people, ","),
                              query_council_area() + " magistrates",
                              "Case appealed",
                              "",
                              "The case " +
                              query_case_short(the_case) +
                              "\nhas been appealed by " +
                              this_player()->query_cap_name() + " because:\n" +
                              desc);
      tell_room(this_object(),
           this_player()->the_short() + " appeals the case #" +
           the_case->id + " against " + query_multiple_short(the_case->people) +
           ".\n", ({ this_player() }) );
   } else {
      write("Error trying to appeal the case!\n");
   }
} /* appeal_case_desc() */

/**
 * This is the command to print the status of the current open and
 * recently closed cases.
 * @param player the player to show
 * @return 1 on success, 0 on failure
 */
int do_player_status(string person) {
   int* cases;
   class nomic_case the_case;
   int id;
   int found;
   int *open_defendant;
   int *open_opener;
   int *open_appealed;
   int *closed_defendant;
   int *closed_opener;
   int *closed_closed;
   string ret;
   string bing;

   person = lower_case(person);
   cases = NOMIC_HANDLER->query_open_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   open_defendant = ({ });
   open_opener = ({ });
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), id);
      if (member_array(person, the_case->people) != -1) {
         found = 1;
         open_defendant += ({ id + "" });
      }
      if (the_case->opener == person) {
         found = 1;
         open_opener += ({ id + "" });
      }
      bing = query_last_appealer(the_case);
      if (bing == person) {
         found = 1;
         open_appealed += ({ id + "" });
      }
   }

   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   closed_defendant = ({ });
   closed_opener = ({ });
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(), id);
      if (member_array(person, the_case->people) != -1) {
         found = 1;
         closed_defendant += ({ id + " (closed)"  });
      }
      if (the_case->opener == person) {
         found = 1;
         closed_opener += ({ id + " (closed)" });
      }
      bing = query_last_closer(the_case);
      if (bing == person) {
         found = 1;
         closed_closed += ({ id + "" });
      }
   }

   //
   // Print the results.
   //
   ret = "Status for " + capitalize(person) + ":\n";
   if (sizeof(open_opener) || sizeof(closed_opener)) {
      ret += "Opened the cases      : " +
             query_multiple_short(open_opener + closed_opener) + "\n";
   }
   if (sizeof(open_defendant) || sizeof(closed_defendant)) {
      ret += "Defendant in the cases: " +
             query_multiple_short(open_defendant + closed_defendant) + "\n";
   }

   bing = query_extra_player_status(person);
   if (bing) {
      ret += bing;
   } else if (!found) {
      add_failed_mess("The player " + person + " has no record.\n");
      return 0;
   }

   write("$P$Status$P$" + ret);
   return 1;
} /* do_player_status() */

void init() {
   add_command("list", "", (: do_list_open_cases() :));
   add_command("list", "[case] <number>", (: do_list_case($4[0]) :));
   add_command("list", "closed", (: do_list_closed_cases() :));
   add_command("list", "{punishments|results}", (: do_list_punishments :));
   add_command("list", "{punishment|punishments|results} <string'type'>", (: do_list_punishments_desc($4[1]) :));
   add_command("list", "closed [case] <number>", (: do_list_closed_case($4[0]) :));
   add_command("case", "add person <string'person'> to <number'case id'>",
               (: do_add_person($4[1], $4[0]) :));
   add_command("case", "remove person <string'person'> from <number'case id'>",
               (: do_remove_person($4[1], $4[0]) :));
   add_command("case", "[add] note <number'case id'>", (: do_add_note($4[0]) :));
   add_command("case", "open [with] <string'people'> about <string'short descripion'>",
                       (: do_open_case($4[0], $4[1]) :));
   add_command("case", "close <number'case id'> result <string'result'>",
                       (: do_close_case($4[0], $4[1]) :));
   add_command("case", "appeal <number'case id'>",
                       (: do_appeal_case($4[0]) :));
   add_command("status", "[of] <string'player'>",
                       (: do_player_status($4[0]) :));
} /* init() */
// --- END [/mnt/home2/grok/lib/std/room/council_cases.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/water_inside.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/water_inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629333   Available: 13576687
Inodes: Total: 5242880    Free: 4960136
1977 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/water_inside.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629333   Available: 13576687
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:03.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * Standard inside water room inheritable.  This is mainly just a mux
 * for the functions that are defined in both /std/room and
 * /std/room/basic/water.
 * @author Presto, Jeremy, Bakhtosh
 * @see /std/room.c
 * @see /std/room/basic/water.c
 */

inherit "/std/room/basic_room";
inherit "/std/room/basic/water";

private int _setting_water_light = 0;

/**
 * @ignore yes
 */
void init() {
  water::init();
  basic_room::init();
}

/**
 * @ignore yes
 */
int is_allowed_position(string poss) {
  return water::is_allowed_position(poss);
}

/**
 * @ignore yes
 */
mixed *query_default_position(object ob) {
  return water::query_default_position(ob);
}

/**
 * @ignore yes
 */
int add_exit(string direc, mixed dest, string type) {
  int retval = basic_room::add_exit(direc, dest, type);
  water::add_exit(direc, dest, type);
  return retval;
}

/**
 * @ignore yes
 */
int query_light() {
  update_water_light();
  if (query_surface()) {
    return ::query_light();
  }
  return ::query_light()*query_clarity()/100;
}

/**
 * This function is used to set the light in a water room without overriding
 * the use of set_use_surface_light(1).  There should be no reason to use it
 * outside of the water inheritable.
 * @param number the new light level
 * @return the new light level
 * @see set_light
 * @see set_use_surface_light
 * @see update_water_light
 */
int set_water_light(int number) {
  _setting_water_light = 1;
  set_light(number);
  _setting_water_light = 0;
}

/**
 * @ignore yes
 */
int adjust_light(int number) {
  if (!_setting_water_light) {
    set_use_surface_light(0);
  }
  return ::adjust_light(number);
}

/**
 * @ignore yes
 */
mixed query_property(string tag) {
  if ("location" == tag && !query_surface()) {
    return "underwater";
  }
  return ::query_property(tag);
}

/**
 * This method sets the default attack speed for the room.
 * This defaults to 5 for water rooms.
 * @return the default attack speed
 */
int attack_speed() { return 5; }
// --- END [/mnt/home2/grok/lib/std/room/water_inside.c] ---
// --- BEGIN [/mnt/home2/grok/lib/std/room/council_citizenship.c] ---
// Size:   File: "/mnt/home2/grok/lib/std/room/council_citizenship.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629332   Available: 13576686
Inodes: Total: 5242880    Free: 4960136
27817 bytes, Last Modified:   File: "/mnt/home2/grok/lib/std/room/council_citizenship.c"
    ID: 110ccfcf38e7e640 Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 20496486   Free: 14629332   Available: 13576686
Inodes: Total: 5242880    Free: 4960136
2006-10-07 21:00:02.000000000 +0000
// Note: To be updated for FluffOS v2019+ with Forgotten Realms theming
/**
 * This is the place you go to try and become a citizen of the council
 * area.
 * @author Pinkfish
 * @started Wed Sep 27 18:19:22 PDT 2000
 */

#define EXPRESSION_NO_CLASSES 1
#include <expressions.h>
inherit "/std/basic/expressions";
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
inherit "/std/room/inherit/honours";

#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>

#define WEEK (7 * (24 * 60 * 60))

class approval_list {
   string* sponsors;
   mapping against;
   int time_added;
}

class approved_person {
   class approval_list info;
   int time_approved;
   string approver;
   int denied;
}

class blacklist {
   string blacklister;
   string reason;
}

class denied {
   string denier;
   string deny_reason;
   int time_denied;
}

private mapping _waiting_approval;
private mapping _blacklist;
private mapping _denied;
private class parse_node* _expression;
private class parse_node* _sponsor_expression;
private mapping _approved;
private int _last_posted;
private nosave string _save_file;

// variables
int variable_age_in_days(object player);
int variable_age_in_hours(object player);
int variable_level(object player);
int variable_denied_in_days(object player);
int function_citizen_of(string area, object player);
int function_magistrate_of(string area, object player);
// do_*
int do_apply();
int do_sponsor(string person);
int do_approve(string person);
int do_deny(string person, string reason);
int do_list();
int do_add_blacklist(string person, string reason);
int do_remove_blacklist(string person);
int do_list_blacklist(int verbose);
int do_list_expression();
int do_set_expression(string expr, int applicant);
int do_list_denied();
void load_me();

void create() {
   _waiting_approval = ([ ]);
   _blacklist = ([ ]);
   _denied = ([ ]);
   _approved = ([ ]);
   _last_posted = time();
   honours::create();
   expressions::create();
   //
   // Add all the functions in here.
   //
   add_allowed_variable("ageindays", EXPRESSION_TYPE_INTEGER,
                        (: variable_age_in_days :));
   add_allowed_variable("ageinhours", EXPRESSION_TYPE_INTEGER,
                        (: variable_age_in_hours :));
   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_level :));
   add_allowed_variable("timesincedeniedindays", EXPRESSION_TYPE_INTEGER,
                        (: variable_denied_in_days :));
   add_allowed_function("citizenof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_citizen_of :));
   add_allowed_function("magistrateof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_citizen_of :));

   add_help_file("citizenship");

   basic_room::create();
} /* create() */

void init() {
   add_command("apply", "[for] [citizenship]", (: do_apply() :));
   add_command("sponsor", "<string'person'> for citizenship",
               (: do_sponsor($4[0]) :));
   add_command("deny", "<string'person'> for citizenship because <string'reason'>",
               (: do_deny($4[0], $4[1]) :));
   add_command("list", "", (: do_list() :));
   add_command("expression", "list",
               (: do_list_expression() :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                      this_player()->query_name()) ||
       master()->query_lord(this_player()->query_name())) {
      add_command("blacklist", "add <string'person'> for <string'reason'>",
                  (: do_add_blacklist($4[0], $4[1]) :));
      add_command("blacklist", "remove <string'person'>",
                  (: do_remove_blacklist($4[0]) :));
      add_command("blacklist", "list {verbose|brief}",
                  (: do_list_blacklist($4[0] == "verbose") :));
      add_command("expression", "citizen <string'citizenship'>",
                   (: do_set_expression($4[0], 0) :));
      add_command("expression", "sponsor <string'citizenship'>",
                   (: do_set_expression($4[0], 1) :));
      add_command("list", "denied", (: do_list_denied :));
      add_command("approve", "<string'person'> for citizenship",
                  (: do_approve($4[0]) :));
   }
   honours::init();
} /* init() */

/**
 * This method sets the save file.
 * @param fname the name of the save file
 */
void set_save_file(string fname) {
   _save_file = fname;
   load_me();
} /* set_save_file() */

/**
 * This method returns the current save file name.
 * @return the current save file name
 */
string query_save_file() {
   return _save_file;
} /* query_save_file() */

/**
 * This loads all the exciting data for the citizenship room.
 */
void load_me() {
   if (!_save_file) {
      return ;
   }
   unguarded( (: restore_object(_save_file, 1) :));
   if (!_expression) {
      _expression = parse_boolean_string("ageindays >= 2 and timesincedeniedindays > 14");
   }
   if (!_sponsor_expression) {
      _sponsor_expression = parse_boolean_string("ageindays >= 10");
   }
   if (!_approved) {
      _approved = ([ ]);
   }

   remove_call_out("post_weekly_results");
   call_out("post_weekly_results", _last_posted + WEEK - time());
} /* load_me() */

/**
 * This method saves everything!
 */
void save_me() {
   if (!_save_file) {
      return ;
   }
   unguarded( (: save_object(_save_file, 1) :));
} /* save_me() */

/**
 * This method posts the weekly results about the citizenship approvals
 * to the council board.
 */
void post_weekly_results() {
   string post;
   string* cit;
   string person;
   string denied;

   cit = sort_array(keys(_approved), 1);
   if (sizeof(cit) > 0) {
      post = "Here are the weekly citizenship application results:\n\n";
      denied = "";
      foreach (person in cit) {
         if (!_approved[person]->denied) {
            if (sizeof(_approved[person]->info->sponsors)) {
               post += "  " + capitalize(person) + " " +
                      ctime(((class approval_list)_approved[person]->info)->time_added)[4..9] +
                      " sponsors " +
                      query_multiple_short(map(_approved[person]->info->sponsors,
                                               (: capitalize($1) :)));
            } else {
               post += "  " + person + " no sponsor";
            }
            post += " approved " +
                    ctime(_approved[person]->time_approved)[4..9] +
                    " by " + capitalize(_approved[person]->approver) + ".\n";
         } else {
            if (sizeof(_approved[person]->info->sponsors)) {
               denied += "  " + capitalize(person) + " " +
                      ctime(((class approval_list)_approved[person]->info)->time_added)[4..9] +
                      " sponsors " +
                      query_multiple_short(map(_approved[person]->info->sponsors,
                                               (: capitalize($1) :)));
            } else {
               denied += "  " + person + " no sponsor";
            }
            denied += " denied " +
                    ctime(_denied[person]->time_denied)[4..9] +
                    " by " + capitalize(_denied[person]->denier) + ".\n";
         }
      }

      if (strlen(denied) > 0) {
         post += "\n\nThese people have been denied citizenship:\n" +
                 denied;
      }

      NOMIC_HANDLER->post_citizen_message(query_council_area(),
                                         "Citizenship results.",
                                         post);
      _approved = ([ ]);
      save_me();
   }
   _last_posted = time();
   remove_call_out("post_weekly_results");
   call_out("post_weekly_results", _last_posted + WEEK - time());
} /* post_weekly_results() */

/**
 * This is the method used for someone to apply for citizenship.
 * @return 1 on success, 0 on failure
 */
int do_apply() {
   class approval_list womble;
   string str;

   //
   // First check everything that could prevent them from applying,
   // citizenship already, blacklisted...
   //
   if (NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("You are already a citizen.\n");
      return 0;
   }

   if (_blacklist[this_player()->query_name()]) {
      add_failed_mess("You are not allowed to become a citizen here.\n");
      return 0;
   }

   if (_waiting_approval[this_player()->query_name()]) {
      add_failed_mess("You are already asking for approval.\n");
      return 0;
   }

   if (!evaluate_expression(_expression, this_player())->value) {
      str = query_expression_string(_expression, 0);
      add_failed_mess("You do not meet the requirements to be a citizen, the "
                      "requirements currently are:\n" + str + "\n");
      return 0;
   }

   if (this_player()->query_creator()) {
      add_failed_mess("Creators cannot be citizens.\n");
      return 0;
   }

   //
   // If in the grace period of the council then it is automatically accepted.
   //
   if (NOMIC_HANDLER->is_grace_phase(query_council_area())) {
      // Check and see if they are a citizen anywhere is.
      str = NOMIC_HANDLER->query_citizen(this_player()->query_name());
      if (str) {
         add_failed_mess("You are already a citizen of " + str +
                         " and cannot join here.\n");
         return 0;
      }
      NOMIC_HANDLER->add_citizen(query_council_area(), this_player()->query_name());
      add_succeeded_mess("$N become$s a citizen of " + query_council_area() +
                          ".\n");
      return 1;
   }

   //
   // Ok, put them into the approval list.
   //
   womble = new(class approval_list);
   womble->sponsors = ({ });
   womble->against = ([ ]);
   womble->time_added = time();
   _waiting_approval[this_player()->query_name()] = womble;
   save_me();

   //
   // Notify the magistrates of the event.
   //
   send_council_inform(1,
              this_player()->query_cap_name() + " applied for citizenship in " +
              query_council_area());

   add_succeeded_mess(({ "You apply for citizenship.\n",
                         "$N applies for citizenship.\n" }));
   return 1;
} /* do_apply() */

/**
 * This allows someone to sponsor someone for citizenship.
 */
int do_sponsor(string person) {
   string str;

   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can sponsor someone.\n");
      return 0;
   }

   if (_blacklist[this_player()->query_name()]) {
      add_failed_mess("You are not allowed to sponsor citizens.\n");
      return 0;
   }

   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }

   if (!evaluate_expression(_sponsor_expression, this_player())->value) {
      str = query_expression_string(_sponsor_expression, 0);
      add_failed_mess("You do not meet the requirements to sponsor citizen, the "
                      "requirements currently are:\n" + str + "\n");
      return 0;
   }

   if (member_array(this_player()->query_name(),
                    _waiting_approval[person]->sponsors) != -1) {
      add_failed_mess("You are already sponsoring " + person + ".\n");
      return 0;
   }

   if (_waiting_approval[person]->against[this_player()->query_name()]) {
      add_failed_mess("You have already put in a reason for deny "
                      "citizenship to " + person + ".\n");
      return 0;
   }

   _waiting_approval[person]->sponsors += ({ this_player()->query_name() });
   save_me();
   add_succeeded_mess("$N $V someone for citizenship.\n");
   return 1;
} /* do_sponsor() */

/**
 * This method makes the citizen approved by a happy little magistrate.
 * @param person the person to approve
 */
int do_approve(string person) {
   person = lower_case( person );
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can sponsor someone.\n");
      return 0;
   }

   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }

   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      //
      // This turns them into a citizen directly.
      //
      NOMIC_HANDLER->add_citizen(query_council_area(), person);
      _approved[person] = new(class approved_person);
      _approved[person]->info = _waiting_approval[person];
      _approved[person]->time_approved = time();
      _approved[person]->approver = this_player()->query_name();
      map_delete(_waiting_approval, person);
      save_me();
      send_council_inform(1, person + " granted citizenship by " +
              this_player()->query_cap_name() + " in " +
              query_council_area());
      add_succeeded_mess("$N add$s " + person + " as a citizen.\n");

      if (find_player(person)) {
         tell_object(find_player(person), "%^RED%^You have been granted "
                     "citizenship of " + query_council_area() +
                     "%^RESET%^.\n");
      } else {
         AUTO_MAILER->auto_mail(person, "Council of " + query_council_area(),
                                "Citizenship of " + query_council_area(),
                                "",
                                "Morning,\n\nYou have been granted "
                                "citizenship in " + query_council_area() +
                                ".\n\n"
                                "Good luck!\nCouncil Administrator.\n");
      }
      return 1;
   }

   add_failed_mess("You are not a magistrate of " + query_council_area() +
                   ".\n");
   return 0;
} /* do_approve() */

/**
 * This allows you to put in a reason for denying someone for citizenship.
 */
int do_deny(string person, string reason) {
   class denied fluff;

   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can deny someone.\n");
      return 0;
   }

   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }

   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      //
      // This denies them directly.
      //
      map_delete(_waiting_approval, person);
      fluff = new(class denied);
      fluff->deny_reason = reason;
      fluff->denier = this_player()->query_name();
      fluff->time_denied = time();
      _denied[person] = fluff;
      save_me();
      if (find_player(person)) {
         tell_object(find_player(person), "%^RED%^You have been denied "
                     "citizenship of " + query_council_area() +
                     "%^RESET%^.\n");
      } else {
         AUTO_MAILER->auto_mail(person, "Council of " + query_council_area(),
                                "Citizenship of " + query_council_area(),
                                "",
                                "Morning,\n\nYou have been denied as a "
                                "citizen of " + query_council_area() + ".\n\n"
                                "Bad luck!\nCouncil Administrator.\n");
      }

      add_succeeded_mess(({ "$N deny " + person + " as a citizen.\n",
                            "$N denies " + person + " as a citizen.\n"
                             }) );
      return 1;
   }

   if (member_array(this_player()->query_name(),
                    _waiting_approval[person]->sponsors) != -1) {
      add_failed_mess("You are already sponsoring " + person + ".\n");
      return 0;
   }

   if (_waiting_approval[person]->against[this_player()->query_name()]) {
      add_failed_mess("You have already put in a reason for deny "
                      "citizenship to " + person + ".\n");
      return 0;
   }

   _waiting_approval[person]->against[this_player()->query_name()] = reason;
   save_me();


   add_succeeded_mess("$N $V someone for citizenship.\n");
   return 1;
} /* do_deny() */

/**
 * This method lists all the current applicants.
 */
int do_list() {
   string ret;
   string ret_tmp;
   string ret_no_sponsor;
   int magistrate;
   string* people;
   string person;
   string denier;
   string reason;
   int index;
   int last;
   int no_sponsor;

   if (!sizeof(_waiting_approval)) {
      add_failed_mess("No one is waiting for citizenship approval.\n");
      return 0;
   }

   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can see who is applying for "
                      "citizenship.\n");
      return 0;
   }

   magistrate = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                                this_player()->query_name());

   people = keys(_waiting_approval);
   people = sort_array(people, (: ((class approval_list)_waiting_approval[$1])->time_added -
                                  ((class approval_list)_waiting_approval[$2])->time_added :));
   ret = ""; // "People currently waiting for sponsorship:\n";
   ret_no_sponsor = "";
   foreach (person in people) {
      if (!PLAYER_HANDLER->test_user(person)) {
         map_delete(_waiting_approval, person);
         continue;
      } 
      if (sizeof(_waiting_approval[person]->sponsors)) {
         ret += "$I$6=   " +
                ctime(((class approval_list)_waiting_approval[person])->time_added)[4..9] + ": " +
                capitalize(person) + " sponsored by " +
                query_multiple_short(map(_waiting_approval[person]->sponsors,
                                         (: capitalize($1) :)));
         no_sponsor = 0;
      } else {
         ret_no_sponsor += "$I$6=   " +
                ctime(((class approval_list)_waiting_approval[person])->time_added)[4..9] + ": " +
                capitalize(person) + " not sponsored by anyone";
         no_sponsor = 1;
      }

      ret_tmp = "";
      if (sizeof(_waiting_approval[person]->against)) {
         if (magistrate) {
             ret_tmp += ";\n";
             index = 1;
             last = sizeof(_waiting_approval[person]->against);
             foreach (denier, reason in _waiting_approval[person]->against) {
                ret_tmp += "- " + denier + " denied '" + reason + "'";
                /* Appends ";\n" for each denier but the last, only "\n" then */
                if( index == last ) {
                   ret_tmp += "\n";
                } else {
                   ret_tmp += ",\n";
                   index++;
                }
             }
         } else {
             ret_tmp += " denied by " +
                    query_num(sizeof(_waiting_approval[person]->against)) +
                    ".\n";
         }
      } else {
         ret_tmp += ".\n";
      }
      if (no_sponsor) {
         ret_no_sponsor += ret_tmp;
      } else {
         ret += ret_tmp;
      }
   }

   if (ret != "") {
      ret = "$I$0=Waiting for approval:\n" + ret;
   }

   if (ret_no_sponsor != "") {
      ret = "$I$0=Waiting for sponsorship:\n" + ret_no_sponsor + "\n" + ret;
   }

   this_player()->more_string(ret, "citizenship");
   return 1;
} /* do_list() */

/**
 * This method lists the current set of denied people.
 */
int do_list_denied() {
   string* people;
   string person;
   string ret;

   if (!sizeof(_denied)) {
      add_failed_mess("No one has been denied yet.\n");
      return 0;
   }


   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only magistrates can see the denied list.\n");
      return 0;
   }

   people = keys(_denied);
   people = sort_array(people, 1);
   ret = "";
   foreach (person in people) {
      ret += "$I$5=" + person + " at " + ctime(_denied[person]->time_denied) +
             " by " + _denied[person]->denier +
             " for " + _denied[person]->deny_reason + ".\n";
   }

   this_player()->more_string(ret, "denied");
   return 1;
} /* do_list_denied() */

/**
 * This method lists the expression used for showing if someone is
 * allowed to be a citizen or not.
 */
int do_list_expression() {
   string str;

   str = query_expression_string(_expression, 0);
   write("The expression to check to make sure someone is allowed to "
         "apply for citizenship is:\n" + str + "\n");
   str = query_expression_string(_sponsor_expression, 0);
   write("The expression to check to make sure someone is allowed to "
         "sponsor an application for citizenship is:\n" + str + "\n");
   return 1;
} /* do_list_expression() */

/**
 * This method sets up the expression to use to check to make sure people
 * are allowed to apply for citizenship.
 * @param expression the expression to set the check to
 * @param sponsor_expr sets the sponsor or the citizen expression
 */
int do_set_expression(string expression, int sponsor_expr) {
   class parse_node* expr;

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can set an expression string.\n");
      return 0;
   }

   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }

   if (!sponsor_expr) {
      _expression = expr;
   } else {
      _sponsor_expression = expr;
   }
   save_me();

   add_succeeded_mess("$N set$s the citizenship requirements.\n");
   return 1;
} /* do_set_expression() */

/**
 * This method adds a person to the blacklist.
 * @param person the person to add
 * @param reason the reason for them to be blacklisted
 */
int do_add_blacklist(string person, string reason) {
   class blacklist bing;

   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can manipulate the blacklist.\n");
      return 0;
   }

/*
   if (NOMIC_HANDLER->is_citizen_of(query_council_area(), person)) {
      add_failed_mess("You cannot blacklist someone who is already a "
                      "citizen.\n");
      return 0;
   }
 */

   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("You cannot blacklist someone that does not exist.\n");
      return 0;
   }

   bing = new(class blacklist);
   bing->blacklister = this_player()->query_name();
   bing->reason = reason;
   _blacklist[person] = bing;
   save_me();

   add_succeeded_mess("$N add$s someone to the blacklist.\n");
   return 1;
} /* do_add_blacklist() */

/**
 * This method removes a person from the blacklist.
 * @param person the person to remove
 */
int do_remove_blacklist(string person) {
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can manipulate the blacklist.\n");
      return 0;
   }

   if (!_blacklist[person]) {
      add_failed_mess("You cannot remove someone from a blacklist that is not "
                      "black listed already!\n");
      return 0;
   }

   map_delete(_blacklist, person);
   save_me();

   add_succeeded_mess("$N remove$s someone from the blacklist.\n");
   return 1;
} /* do_remove_blacklist() */

/**
 * This method lists the current blacklist.
 * @param verbose list in verbose mode or not
 */
int do_list_blacklist(int verbose) {
   string ret;
   string* people;
   string person;

   people = keys(_blacklist);
   people = sort_array(people, 1);
   if (!sizeof(people)) {
      add_failed_mess("There is no one in the blacklist currently.\n");
      return 0;
   }
   ret = "";
   if (!verbose) {
      ret += "$I$5=Blacklist is: " + query_multiple_short(people);
   } else {
      ret += "Blacklist:\n";
      foreach (person in people) {
         ret += "$I$5=" + person + " by " + _blacklist[person]->blacklister +
                " for " + _blacklist[person]->reason + ".\n";
      }
   }
   this_player()->more_string(ret, "blacklist");
   return 1;
} /* do_list_blacklist() */

/** @ignore yes */
int variable_age_in_days(object player) {
   int bing;

   bing = -player->query_time_on();
   return bing / (60 * 60 * 24);
} /* variable_age_in_days() */

/** @ignore yes */
int variable_age_in_hours(object player) {
   int bing;

   bing = -player->query_time_on();
   return bing / (60 * 60);
} /* variable_age_in_hours() */

/** @ignore yes */
int variable_level(object player) {
   return player->query_level();
} /* variable_age_in_days() */

/** @ignore yes */
int variable_denied_in_days(object player) {
   if (_denied[player->query_name()]) {
      return (time() - _denied[player->query_name()]->time_denied) / (60 * 60 * 24);
   }
   return 10000;
} /* variable_age_in_days() */

/** @ignore yes */
int function_citizen_of(string area, object player) {
   return NOMIC_HANDLER->is_citizen_of(area, player->query_name());
} /* function_citizen_of() */

/** @ignore yes */
int function_magistrate_of(string area, object player) {
   return NOMIC_HANDLER->is_magistrate_of(area, player->query_name());
} /* function_magistrate_of() */

/* Support stuff for the honours inherit. */
/** @ignore yes */
int is_allowed_to_change(string person) {
   return NOMIC_HANDLER->is_magistrate_of(query_council_area(), person);
} /* is_allowed_to_change() */

/** @ignore yes */
void inform_of_honour_change(string type, string person,
                             string reason, string changed_by) {
   string subject;
   string mess;

   if (type == "add") {
      subject = PLAYER_HANDLER->query_cap_name(person) +
                " added to the honour roll.";
      mess = PLAYER_HANDLER->query_cap_name(person) + " is added to the "
             "honour roll for this council.\n\nThis means they gain the "
             "honour of using the title(s) " +
             query_multiple_short(map(query_controlled_titles(),
                                      (: capitalize :))) +  ".\n\n" +
             "They were added by " +
             PLAYER_HANDLER->query_cap_name(changed_by) +
             " for:\n" + reason + "\n";
   } else {
      subject = PLAYER_HANDLER->query_cap_name(person) +
                " removed from the honour roll.";
      mess = PLAYER_HANDLER->query_cap_name(person) + " is removed from the "
             "honour roll for this council.\n\nThis means they lose the "
             "privilege of using the title " +
             query_multiple_short(map(query_controlled_titles(),
                                      (: capitalize :))) +  ".\n\n" +
             "They were removed by " +
             PLAYER_HANDLER->query_cap_name(changed_by) +
             " for:\n" + reason + "\n";
   }
   NOMIC_HANDLER->post_citizen_message(query_council_area(),
                                       subject,
                                       mess);
} /* inform_of-honour_change() */

// --- END [/mnt/home2/grok/lib/std/room/council_citizenship.c] ---
